//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Error occurred because of a conflict while performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes {

    /// The configuration of a virtual private cloud (VPC). For more information, see [Protect your data using Amazon Virtual Private Cloud and Amazon Web Services PrivateLink](https://docs.aws.amazon.com/bedrock/latest/userguide/usingVPC.html).
    public struct VpcConfig: Swift.Sendable {
        /// An array of IDs for each security group in the VPC to use.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// An array of IDs for each subnet in the VPC to use.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the configuration for a Amazon SageMaker endpoint.
    public struct SageMakerEndpoint: Swift.Sendable {
        /// The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and docker image for deployment on Amazon EC2 compute instances or for batch transform jobs.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The number of Amazon EC2 compute instances to deploy for initial endpoint creation.
        /// This member is required.
        public var initialInstanceCount: Swift.Int?
        /// The Amazon EC2 compute instance type to deploy for hosting the model.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The Amazon Web Services KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the Amazon EC2 compute instance that hosts the endpoint.
        public var kmsEncryptionKey: Swift.String?
        /// The VPC configuration for the endpoint.
        public var vpc: BedrockClientTypes.VpcConfig?

        public init(
            executionRole: Swift.String? = nil,
            initialInstanceCount: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            kmsEncryptionKey: Swift.String? = nil,
            vpc: BedrockClientTypes.VpcConfig? = nil
        )
        {
            self.executionRole = executionRole
            self.initialInstanceCount = initialInstanceCount
            self.instanceType = instanceType
            self.kmsEncryptionKey = kmsEncryptionKey
            self.vpc = vpc
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the configuration for the endpoint.
    public enum EndpointConfig: Swift.Sendable {
        /// The configuration specific to Amazon SageMaker for the endpoint.
        case sagemaker(BedrockClientTypes.SageMakerEndpoint)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Definition of the key/value pair for a tag.
    public struct Tag: Swift.Sendable {
        /// Key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateMarketplaceModelEndpointInput: Swift.Sendable {
    /// Indicates whether you accept the end-user license agreement (EULA) for the model. Set to true to accept the EULA.
    public var acceptEula: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The configuration for the endpoint, including the number and type of instances to use.
    /// This member is required.
    public var endpointConfig: BedrockClientTypes.EndpointConfig?
    /// The name of the endpoint. This name must be unique within your Amazon Web Services account and region.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The ARN of the model from Amazon Bedrock Marketplace that you want to deploy to the endpoint.
    /// This member is required.
    public var modelSourceIdentifier: Swift.String?
    /// An array of key-value pairs to apply to the underlying Amazon SageMaker endpoint. You can use these tags to organize and identify your Amazon Web Services resources.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        acceptEula: Swift.Bool? = false,
        clientRequestToken: Swift.String? = nil,
        endpointConfig: BedrockClientTypes.EndpointConfig? = nil,
        endpointName: Swift.String? = nil,
        modelSourceIdentifier: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.acceptEula = acceptEula
        self.clientRequestToken = clientRequestToken
        self.endpointConfig = endpointConfig
        self.endpointName = endpointName
        self.modelSourceIdentifier = modelSourceIdentifier
        self.tags = tags
    }
}

extension BedrockClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incompatibleEndpoint
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .incompatibleEndpoint,
                .registered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incompatibleEndpoint: return "INCOMPATIBLE_ENDPOINT"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about an endpoint for a model from Amazon Bedrock Marketplace.
    public struct MarketplaceModelEndpoint: Swift.Sendable {
        /// The timestamp when the endpoint was registered.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the endpoint.
        /// This member is required.
        public var endpointArn: Swift.String?
        /// The configuration of the endpoint, including the number and type of instances used.
        /// This member is required.
        public var endpointConfig: BedrockClientTypes.EndpointConfig?
        /// The current status of the endpoint (e.g., Creating, InService, Updating, Failed).
        /// This member is required.
        public var endpointStatus: Swift.String?
        /// Additional information about the endpoint status, if available.
        public var endpointStatusMessage: Swift.String?
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        /// This member is required.
        public var modelSourceIdentifier: Swift.String?
        /// The overall status of the endpoint in Amazon Bedrock Marketplace (e.g., ACTIVE, INACTIVE).
        public var status: BedrockClientTypes.Status?
        /// Additional information about the overall status, if available.
        public var statusMessage: Swift.String?
        /// The timestamp when the endpoint was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            endpointArn: Swift.String? = nil,
            endpointConfig: BedrockClientTypes.EndpointConfig? = nil,
            endpointStatus: Swift.String? = nil,
            endpointStatusMessage: Swift.String? = nil,
            modelSourceIdentifier: Swift.String? = nil,
            status: BedrockClientTypes.Status? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.endpointConfig = endpointConfig
            self.endpointStatus = endpointStatus
            self.endpointStatusMessage = endpointStatusMessage
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the created endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    )
    {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct DeleteMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to delete.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

public struct DeleteMarketplaceModelEndpointOutput: Swift.Sendable {

    public init() { }
}

/// Returned if the service cannot complete the request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to deregister.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

public struct DeregisterMarketplaceModelEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct GetMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to get information about.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

public struct GetMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the requested endpoint.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    )
    {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct ListMarketplaceModelEndpointsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. If more results are available, the operation returns a NextToken value.
    public var maxResults: Swift.Int?
    /// If specified, only endpoints for the given model source identifier are returned.
    public var modelSourceEquals: Swift.String?
    /// The token for the next set of results. You receive this token from a previous ListMarketplaceModelEndpoints call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelSourceEquals: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelSourceEquals = modelSourceEquals
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// Provides a summary of an endpoint for a model from Amazon Bedrock Marketplace.
    public struct MarketplaceModelEndpointSummary: Swift.Sendable {
        /// The timestamp when the endpoint was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the endpoint.
        /// This member is required.
        public var endpointArn: Swift.String?
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        /// This member is required.
        public var modelSourceIdentifier: Swift.String?
        /// The overall status of the endpoint in Amazon Bedrock Marketplace.
        public var status: BedrockClientTypes.Status?
        /// Additional information about the overall status, if available.
        public var statusMessage: Swift.String?
        /// The timestamp when the endpoint was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            endpointArn: Swift.String? = nil,
            modelSourceIdentifier: Swift.String? = nil,
            status: BedrockClientTypes.Status? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }
}

public struct ListMarketplaceModelEndpointsOutput: Swift.Sendable {
    /// An array of endpoint summaries.
    public var marketplaceModelEndpoints: [BedrockClientTypes.MarketplaceModelEndpointSummary]?
    /// The token for the next set of results. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        marketplaceModelEndpoints: [BedrockClientTypes.MarketplaceModelEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.marketplaceModelEndpoints = marketplaceModelEndpoints
        self.nextToken = nextToken
    }
}

public struct RegisterMarketplaceModelEndpointInput: Swift.Sendable {
    /// The ARN of the Amazon SageMaker endpoint you want to register with Amazon Bedrock Marketplace.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on the endpoint.
    /// This member is required.
    public var modelSourceIdentifier: Swift.String?

    public init(
        endpointIdentifier: Swift.String? = nil,
        modelSourceIdentifier: Swift.String? = nil
    )
    {
        self.endpointIdentifier = endpointIdentifier
        self.modelSourceIdentifier = modelSourceIdentifier
    }
}

public struct RegisterMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the registered endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    )
    {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct UpdateMarketplaceModelEndpointInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the endpoint you want to update.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The new configuration for the endpoint, including the number and type of instances to use.
    /// This member is required.
    public var endpointConfig: BedrockClientTypes.EndpointConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        endpointArn: Swift.String? = nil,
        endpointConfig: BedrockClientTypes.EndpointConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.endpointArn = endpointArn
        self.endpointConfig = endpointConfig
    }
}

public struct UpdateMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the updated endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    )
    {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct BatchDeleteEvaluationJobInput: Swift.Sendable {
    /// A list of one or more evaluation job Amazon Resource Names (ARNs) you want to delete.
    /// This member is required.
    public var jobIdentifiers: [Swift.String]?

    public init(
        jobIdentifiers: [Swift.String]? = nil
    )
    {
        self.jobIdentifiers = jobIdentifiers
    }
}

extension BatchDeleteEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobInput(jobIdentifiers: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A JSON array that provides the status of the evaluation jobs being deleted.
    public struct BatchDeleteEvaluationJobError: Swift.Sendable {
        /// A HTTP status code of the evaluation job being deleted.
        /// This member is required.
        public var code: Swift.String?
        /// The ARN of the evaluation job being deleted.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// A status message about the evaluation job deletion.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            jobIdentifier: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobIdentifier = jobIdentifier
            self.message = message
        }
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// An evaluation job for deletion, and it’s current status.
    public struct BatchDeleteEvaluationJobItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the evaluation job for deletion.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// The status of the evaluation job for deletion.
        /// This member is required.
        public var jobStatus: BedrockClientTypes.EvaluationJobStatus?

        public init(
            jobIdentifier: Swift.String? = nil,
            jobStatus: BedrockClientTypes.EvaluationJobStatus? = nil
        )
        {
            self.jobIdentifier = jobIdentifier
            self.jobStatus = jobStatus
        }
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobItem(jobStatus: \(Swift.String(describing: jobStatus)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteEvaluationJobOutput: Swift.Sendable {
    /// A JSON object containing the HTTP status codes and the ARNs of evaluation jobs that failed to be deleted.
    /// This member is required.
    public var errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]?
    /// The list of evaluation jobs for deletion.
    /// This member is required.
    public var evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]?

    public init(
        errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]? = nil,
        evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]? = nil
    )
    {
        self.errors = errors
        self.evaluationJobs = evaluationJobs
    }
}

extension BedrockClientTypes {

    public enum ApplicationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modelEvaluation
        case ragEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationType] {
            return [
                .modelEvaluation,
                .ragEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modelEvaluation: return "ModelEvaluation"
            case .ragEvaluation: return "RagEvaluation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The location in Amazon S3 where your prompt dataset is stored.
    public enum EvaluationDatasetLocation: Swift.Sendable {
        /// The S3 URI of the S3 bucket specified in the job.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Used to specify the name of a built-in prompt dataset and optionally, the Amazon S3 bucket where a custom prompt dataset is saved.
    public struct EvaluationDataset: Swift.Sendable {
        /// For custom prompt datasets, you must specify the location in Amazon S3 where the prompt dataset is saved.
        public var datasetLocation: BedrockClientTypes.EvaluationDatasetLocation?
        /// Used to specify supported built-in prompt datasets. Valid values are Builtin.Bold, Builtin.BoolQ, Builtin.NaturalQuestions, Builtin.Gigaword, Builtin.RealToxicityPrompts, Builtin.TriviaQA, Builtin.T-Rex, Builtin.WomensEcommerceClothingReviews and Builtin.Wikitext2.
        /// This member is required.
        public var name: Swift.String?

        public init(
            datasetLocation: BedrockClientTypes.EvaluationDatasetLocation? = nil,
            name: Swift.String? = nil
        )
        {
            self.datasetLocation = datasetLocation
            self.name = name
        }
    }
}

extension BedrockClientTypes.EvaluationDataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDataset(datasetLocation: \(Swift.String(describing: datasetLocation)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationTaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classification
        case custom
        case generation
        case questionAndAnswer
        case summarization
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationTaskType] {
            return [
                .classification,
                .custom,
                .generation,
                .questionAndAnswer,
                .summarization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classification: return "Classification"
            case .custom: return "Custom"
            case .generation: return "Generation"
            case .questionAndAnswer: return "QuestionAndAnswer"
            case .summarization: return "Summarization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Defines the prompt datasets, built-in metric names and custom metric names, and the task type.
    public struct EvaluationDatasetMetricConfig: Swift.Sendable {
        /// Specifies the prompt dataset.
        /// This member is required.
        public var dataset: BedrockClientTypes.EvaluationDataset?
        /// The names of the metrics you want to use for your evaluation job. For knowledge base evaluation jobs that evaluate retrieval only, valid values are "Builtin.ContextRelevance", "Builtin.ContextConverage". For knowledge base evaluation jobs that evaluate retrieval with response generation, valid values are "Builtin.Correctness", "Builtin.Completeness", "Builtin.Helpfulness", "Builtin.LogicalCoherence", "Builtin.Faithfulness", "Builtin.Harmfulness", "Builtin.Stereotyping", "Builtin.Refusal". For automated model evaluation jobs, valid values are "Builtin.Accuracy", "Builtin.Robustness", and "Builtin.Toxicity". In model evaluation jobs that use a LLM as judge you can specify "Builtin.Correctness", "Builtin.Completeness", "Builtin.Faithfulness", "Builtin.Helpfulness", "Builtin.Coherence", "Builtin.Relevance", "Builtin.FollowingInstructions", "Builtin.ProfessionalStyleAndTone", You can also specify the following responsible AI related metrics only for model evaluation job that use a LLM as judge "Builtin.Harmfulness", "Builtin.Stereotyping", and "Builtin.Refusal". For human-based model evaluation jobs, the list of strings must match the name parameter specified in HumanEvaluationCustomMetric.
        /// This member is required.
        public var metricNames: [Swift.String]?
        /// The the type of task you want to evaluate for your evaluation job. This applies only to model evaluation jobs and is ignored for knowledge base evaluation jobs.
        /// This member is required.
        public var taskType: BedrockClientTypes.EvaluationTaskType?

        public init(
            dataset: BedrockClientTypes.EvaluationDataset? = nil,
            metricNames: [Swift.String]? = nil,
            taskType: BedrockClientTypes.EvaluationTaskType? = nil
        )
        {
            self.dataset = dataset
            self.metricNames = metricNames
            self.taskType = taskType
        }
    }
}

extension BedrockClientTypes.EvaluationDatasetMetricConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDatasetMetricConfig(dataset: \(Swift.String(describing: dataset)), taskType: \(Swift.String(describing: taskType)), metricNames: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The evaluator model used in knowledge base evaluation job or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
    public struct BedrockEvaluatorModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the evaluator model used used in knowledge base evaluation job or in model evaluation job that use a model as judge.
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            modelIdentifier: Swift.String? = nil
        )
        {
            self.modelIdentifier = modelIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the model configuration for the evaluator model. EvaluatorModelConfig is required for evaluation jobs that use a knowledge base or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
    public enum EvaluatorModelConfig: Swift.Sendable {
        /// The evaluator model used in knowledge base evaluation job or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        case bedrockevaluatormodels([BedrockClientTypes.BedrockEvaluatorModel])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details of an automated evaluation job. The EvaluationDatasetMetricConfig object is used to specify the prompt datasets, task type, and metric names.
    public struct AutomatedEvaluationConfig: Swift.Sendable {
        /// Configuration details of the prompt datasets and metrics you want to use for your evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// Contains the evaluator model configuration details. EvaluatorModelConfig is required for evaluation jobs that use a knowledge base or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        public var evaluatorModelConfig: BedrockClientTypes.EvaluatorModelConfig?

        public init(
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            evaluatorModelConfig: BedrockClientTypes.EvaluatorModelConfig? = nil
        )
        {
            self.datasetMetricConfigs = datasetMetricConfigs
            self.evaluatorModelConfig = evaluatorModelConfig
        }
    }
}

extension BedrockClientTypes {

    /// In a model evaluation job that uses human workers you must define the name of the metric, and how you want that metric rated ratingMethod, and an optional description of the metric.
    public struct HumanEvaluationCustomMetric: Swift.Sendable {
        /// An optional description of the metric. Use this parameter to provide more details about the metric.
        public var description: Swift.String?
        /// The name of the metric. Your human evaluators will see this name in the evaluation UI.
        /// This member is required.
        public var name: Swift.String?
        /// Choose how you want your human workers to evaluation your model. Valid values for rating methods are ThumbsUpDown, IndividualLikertScale,ComparisonLikertScale, ComparisonChoice, and ComparisonRank
        /// This member is required.
        public var ratingMethod: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ratingMethod: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ratingMethod = ratingMethod
        }
    }
}

extension BedrockClientTypes.HumanEvaluationCustomMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanEvaluationCustomMetric(ratingMethod: \(Swift.String(describing: ratingMethod)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains SageMakerFlowDefinition object. The object is used to specify the prompt dataset, task type, rating method and metric names.
    public struct HumanWorkflowConfig: Swift.Sendable {
        /// The Amazon Resource Number (ARN) for the flow definition
        /// This member is required.
        public var flowDefinitionArn: Swift.String?
        /// Instructions for the flow definition
        public var instructions: Swift.String?

        public init(
            flowDefinitionArn: Swift.String? = nil,
            instructions: Swift.String? = nil
        )
        {
            self.flowDefinitionArn = flowDefinitionArn
            self.instructions = instructions
        }
    }
}

extension BedrockClientTypes.HumanWorkflowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanWorkflowConfig(flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), instructions: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Specifies the custom metrics, how tasks will be rated, the flow definition ARN, and your custom prompt datasets. Model evaluation jobs use human workers only support the use of custom prompt datasets. To learn more about custom prompt datasets and the required format, see [Custom prompt datasets](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-prompt-datasets-custom.html). When you create custom metrics in HumanEvaluationCustomMetric you must specify the metric's name. The list of names specified in the HumanEvaluationCustomMetric array, must match the metricNames array of strings specified in EvaluationDatasetMetricConfig. For example, if in the HumanEvaluationCustomMetric array your specified the names "accuracy", "toxicity", "readability" as custom metrics then the metricNames array would need to look like the following ["accuracy", "toxicity", "readability"] in EvaluationDatasetMetricConfig.
    public struct HumanEvaluationConfig: Swift.Sendable {
        /// A HumanEvaluationCustomMetric object. It contains the names the metrics, how the metrics are to be evaluated, an optional description.
        public var customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]?
        /// Use to specify the metrics, task, and prompt dataset to be used in your model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// The parameters of the human workflow.
        public var humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig?

        public init(
            customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]? = nil,
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig? = nil
        )
        {
            self.customMetrics = customMetrics
            self.datasetMetricConfigs = datasetMetricConfigs
            self.humanWorkflowConfig = humanWorkflowConfig
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details of either an automated or human-based evaluation job.
    public enum EvaluationConfig: Swift.Sendable {
        /// Contains the configuration details of an automated evaluation job that computes metrics.
        case automated(BedrockClientTypes.AutomatedEvaluationConfig)
        /// Contains the configuration details of an evaluation job that uses human workers.
        case human(BedrockClientTypes.HumanEvaluationConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Contains the ARN of the Amazon Bedrock model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) specified in your evaluation job. Each Amazon Bedrock model supports different inferenceParams. To learn more about supported inference parameters for Amazon Bedrock models, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). The inferenceParams are specified using JSON. To successfully insert JSON as string make sure that all quotations are properly escaped. For example, "temperature":"0.25" key value pair would need to be formatted as \"temperature\":\"0.25\" to successfully accepted in the request.
    public struct EvaluationBedrockModel: Swift.Sendable {
        /// Each Amazon Bedrock support different inference parameters that change how the model behaves during inference.
        public var inferenceParams: Swift.String?
        /// The ARN of the Amazon Bedrock model or inference profile specified.
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            inferenceParams: Swift.String? = "{}",
            modelIdentifier: Swift.String? = nil
        )
        {
            self.inferenceParams = inferenceParams
            self.modelIdentifier = modelIdentifier
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationBedrockModel(modelIdentifier: \(Swift.String(describing: modelIdentifier)), inferenceParams: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Defines the models used in the model evaluation job.
    public enum EvaluationModelConfig: Swift.Sendable {
        /// Defines the Amazon Bedrock model or inference profile and inference parameters you want used.
        case bedrockmodel(BedrockClientTypes.EvaluationBedrockModel)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details for the guardrail.
    public struct GuardrailConfiguration: Swift.Sendable {
        /// The unique identifier for the guardrail.
        /// This member is required.
        public var guardrailId: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailId: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        )
        {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for text generation using a language model via the RetrieveAndGenerate function.
    public struct TextInferenceConfig: Swift.Sendable {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitrary values, for actual values consult the limits defined by your specific model.
        public var maxTokens: Swift.Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitrary values, for actual values consult the limits defined by your specific model.
        public var stopSequences: [Swift.String]?
        /// Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public var temperature: Swift.Float?
        /// A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details of the inference for knowledge base retrieval and response generation.
    public struct KbInferenceConfig: Swift.Sendable {
        /// Contains configuration details for text generation using a language model via the RetrieveAndGenerate function.
        public var textInferenceConfig: BedrockClientTypes.TextInferenceConfig?

        public init(
            textInferenceConfig: BedrockClientTypes.TextInferenceConfig? = nil
        )
        {
            self.textInferenceConfig = textInferenceConfig
        }
    }
}

extension BedrockClientTypes {

    /// The template for the prompt that's sent to the model for response generation.
    public struct PromptTemplate: Swift.Sendable {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see [Knowledge base prompt template](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html) and [Use XML tags with Anthropic Claude models](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags).
        public var textPromptTemplate: Swift.String?

        public init(
            textPromptTemplate: Swift.String? = nil
        )
        {
            self.textPromptTemplate = textPromptTemplate
        }
    }
}

extension BedrockClientTypes.PromptTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptTemplate(textPromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The response generation configuration of the external source wrapper object.
    public struct ExternalSourcesGenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and their corresponding values not included in the text inference configuration for an external source. Takes in custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// Configuration details for the guardrail.
        public var guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration?
        /// Configuration details for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public var kbInferenceConfig: BedrockClientTypes.KbInferenceConfig?
        /// Contains the template for the prompt for the external source wrapper object.
        public var promptTemplate: BedrockClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration? = nil,
            kbInferenceConfig: BedrockClientTypes.KbInferenceConfig? = nil,
            promptTemplate: BedrockClientTypes.PromptTemplate? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockClientTypes {

    /// Contains the document contained in the wrapper object, along with its attributes/fields.
    public struct ByteContentDoc: Swift.Sendable {
        /// The MIME type of the document contained in the wrapper object.
        /// This member is required.
        public var contentType: Swift.String?
        /// The byte value of the file to upload, encoded as a Base-64 string.
        /// This member is required.
        public var data: Foundation.Data?
        /// The file name of the document contained in the wrapper object.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            data: Foundation.Data? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }
    }
}

extension BedrockClientTypes.ByteContentDoc: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByteContentDoc(contentType: \(Swift.String(describing: contentType)), data: \"CONTENT_REDACTED\", identifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The unique wrapper object of the document from the S3 location.
    public struct S3ObjectDoc: Swift.Sendable {
        /// The S3 URI location for the wrapper object of the document.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }
}

extension BedrockClientTypes {

    public enum ExternalSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byteContent
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSourceType] {
            return [
                .byteContent,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byteContent: return "BYTE_CONTENT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The unique external source of the content contained in the wrapper object.
    public struct ExternalSource: Swift.Sendable {
        /// The identifier, content type, and data of the external source wrapper object.
        public var byteContent: BedrockClientTypes.ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public var s3Location: BedrockClientTypes.S3ObjectDoc?
        /// The source type of the external source wrapper object.
        /// This member is required.
        public var sourceType: BedrockClientTypes.ExternalSourceType?

        public init(
            byteContent: BedrockClientTypes.ByteContentDoc? = nil,
            s3Location: BedrockClientTypes.S3ObjectDoc? = nil,
            sourceType: BedrockClientTypes.ExternalSourceType? = nil
        )
        {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }
    }
}

extension BedrockClientTypes {

    /// The configuration of the external source wrapper object in the retrieveAndGenerate function.
    public struct ExternalSourcesRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public var generationConfiguration: BedrockClientTypes.ExternalSourcesGenerationConfiguration?
        /// The Amazon Resource Name (ARN) of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to generate responses.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The document for the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var sources: [BedrockClientTypes.ExternalSource]?

        public init(
            generationConfiguration: BedrockClientTypes.ExternalSourcesGenerationConfiguration? = nil,
            modelArn: Swift.String? = nil,
            sources: [BedrockClientTypes.ExternalSource]? = nil
        )
        {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for response generation based on retrieved text chunks.
    public struct GenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows you to provide custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// Contains configuration details for the guardrail.
        public var guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration?
        /// Contains configuration details for inference for knowledge base retrieval and response generation.
        public var kbInferenceConfig: BedrockClientTypes.KbInferenceConfig?
        /// Contains the template for the prompt that's sent to the model for response generation.
        public var promptTemplate: BedrockClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration? = nil,
            kbInferenceConfig: BedrockClientTypes.KbInferenceConfig? = nil,
            promptTemplate: BedrockClientTypes.PromptTemplate? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockClientTypes {

    public enum QueryTransformationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queryDecomposition
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransformationType] {
            return [
                .queryDecomposition
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queryDecomposition: return "QUERY_DECOMPOSITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for transforming the prompt.
    public struct QueryTransformationConfiguration: Swift.Sendable {
        /// The type of transformation to apply to the prompt.
        /// This member is required.
        public var type: BedrockClientTypes.QueryTransformationType?

        public init(
            type: BedrockClientTypes.QueryTransformationType? = nil
        )
        {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for the model to process the prompt prior to retrieval and response generation.
    public struct OrchestrationConfiguration: Swift.Sendable {
        /// Contains configuration details for transforming the prompt.
        /// This member is required.
        public var queryTransformationConfiguration: BedrockClientTypes.QueryTransformationConfiguration?

        public init(
            queryTransformationConfiguration: BedrockClientTypes.QueryTransformationConfiguration? = nil
        )
        {
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the name of the metadata attribute/field to apply filters. You must match the name of the attribute/field in your data source/document metadata.
    public struct FilterAttribute: Swift.Sendable {
        /// The name of metadata attribute/field, which must match the name in your data source/document metadata.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the metadata attribute/field.
        /// This member is required.
        public var value: Smithy.Document?

        public init(
            key: Swift.String? = nil,
            value: Smithy.Document? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension BedrockClientTypes {

    public enum SearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .hybrid,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum RetrieveAndGenerateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalSources
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .externalSources,
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalSources: return "EXTERNAL_SOURCES"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The Amazon S3 location where the results of your evaluation job are saved.
    public struct EvaluationOutputDataConfig: Swift.Sendable {
        /// The Amazon S3 URI where the results of the evaluation job are saved.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }
}

public struct CreateEvaluationJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetEvaluationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job you want get information on.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension GetEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automated
        case human
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobType] {
            return [
                .automated,
                .human
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automated: return "Automated"
            case .human: return "Human"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortJobsBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortJobsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEvaluationJobsInput: Swift.Sendable {
    /// A filter to only list evaluation jobs that are either model evaluations or knowledge base evaluations.
    public var applicationTypeEquals: BedrockClientTypes.ApplicationType?
    /// A filter to only list evaluation jobs created after a specified time.
    public var creationTimeAfter: Foundation.Date?
    /// A filter to only list evaluation jobs created before a specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A filter to only list evaluation jobs that contain a specified string in the job name.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies a creation time to sort the list of evaluation jobs by when they were created.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the list of evaluation jobs by either ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter to only list evaluation jobs that are of a certain status.
    public var statusEquals: BedrockClientTypes.EvaluationJobStatus?

    public init(
        applicationTypeEquals: BedrockClientTypes.ApplicationType? = nil,
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.applicationTypeEquals = applicationTypeEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Summary information of an evaluation job.
    public struct EvaluationSummary: Swift.Sendable {
        /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
        public var applicationType: BedrockClientTypes.ApplicationType?
        /// The time the evaluation job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The type of task for model evaluation.
        /// This member is required.
        public var evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]?
        /// The Amazon Resource Names (ARNs) of the models used to compute the metrics for a knowledge base evaluation job.
        public var evaluatorModelIdentifiers: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the evaluation job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name for the evaluation job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Specifies whether the evaluation job is automated or human-based.
        /// This member is required.
        public var jobType: BedrockClientTypes.EvaluationJobType?
        /// The Amazon Resource Names (ARNs) of the model(s) used for the evaluation job.
        public var modelIdentifiers: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the knowledge base resources used for a knowledge base evaluation job.
        public var ragIdentifiers: [Swift.String]?
        /// The current status of the evaluation job.
        /// This member is required.
        public var status: BedrockClientTypes.EvaluationJobStatus?

        public init(
            applicationType: BedrockClientTypes.ApplicationType? = nil,
            creationTime: Foundation.Date? = nil,
            evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]? = nil,
            evaluatorModelIdentifiers: [Swift.String]? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: BedrockClientTypes.EvaluationJobType? = nil,
            modelIdentifiers: [Swift.String]? = [],
            ragIdentifiers: [Swift.String]? = nil,
            status: BedrockClientTypes.EvaluationJobStatus? = nil
        )
        {
            self.applicationType = applicationType
            self.creationTime = creationTime
            self.evaluationTaskTypes = evaluationTaskTypes
            self.evaluatorModelIdentifiers = evaluatorModelIdentifiers
            self.jobArn = jobArn
            self.jobName = jobName
            self.jobType = jobType
            self.modelIdentifiers = modelIdentifiers
            self.ragIdentifiers = ragIdentifiers
            self.status = status
        }
    }
}

public struct ListEvaluationJobsOutput: Swift.Sendable {
    /// A list of summaries of the evaluation jobs.
    public var jobSummaries: [BedrockClientTypes.EvaluationSummary]?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [BedrockClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct StopEvaluationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job you want to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension StopEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct StopEvaluationJobOutput: Swift.Sendable {

    public init() { }
}

/// The request contains more tags than can be associated with a resource (50 tags per resource). The maximum number of tags includes both existing tags and those included in your current request.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension BedrockClientTypes {

    public enum GuardrailModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailModality] {
            return [
                .image,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailFilterStrength: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContentFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate – Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults – Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual – Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence – Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html).
    public struct GuardrailContentFilterConfig: Swift.Sendable {
        /// The input modalities selected for the guardrail content filter configuration.
        public var inputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The output modalities selected for the guardrail content filter configuration.
        public var outputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContentFilterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFilterConfig(inputStrength: \(Swift.String(describing: inputStrength)), outputStrength: \(Swift.String(describing: outputStrength)), type: \(Swift.String(describing: type)), inputModalities: \"CONTENT_REDACTED\", outputModalities: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about how to handle harmful content.
    public struct GuardrailContentPolicyConfig: Swift.Sendable {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]? = nil
        )
        {
            self.filtersConfig = filtersConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContextualGroundingFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grounding
        case relevance
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingFilterType] {
            return [
                .grounding,
                .relevance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grounding: return "GROUNDING"
            case .relevance: return "RELEVANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The filter configuration details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilterConfig: Swift.Sendable {
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        )
        {
            self.threshold = threshold
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The policy configuration details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicyConfig: Swift.Sendable {
        /// The filter configuration details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]? = nil
        )
        {
            self.filtersConfig = filtersConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailSensitiveInformationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymize
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationAction] {
            return [
                .anonymize,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymize: return "ANONYMIZE"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailPiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The PII entity to configure for the guardrail.
    public struct GuardrailPiiEntityConfig: Swift.Sendable {
        /// Configure guardrail action when the PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:
        ///
        /// * General
        ///
        /// * ADDRESS A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        ///
        /// * AGE An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
        ///
        /// * NAME An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        ///
        /// * EMAIL An email address, such as marymajor@email.com.
        ///
        /// * PHONE A phone number. This entity type also includes fax and pager numbers.
        ///
        /// * USERNAME A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        ///
        /// * PASSWORD An alphanumeric string that is used as a password, such as "*very20special#pass*".
        ///
        /// * DRIVER_ID The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        ///
        /// * LICENSE_PLATE A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        ///
        /// * VEHICLE_IDENTIFICATION_NUMBER A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the ISO 3779 specification. Each country has specific codes and formats for VINs.
        ///
        ///
        ///
        ///
        /// * Finance
        ///
        /// * CREDIT_DEBIT_CARD_CVV A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        ///
        /// * CREDIT_DEBIT_CARD_EXPIRY The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as month/year or MM/YY. Guardrails recognizes expiration dates such as 01/21, 01/2021, and Jan 2021.
        ///
        /// * CREDIT_DEBIT_CARD_NUMBER The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        ///
        /// * PIN A four-digit personal identification number (PIN) with which you can access your bank account.
        ///
        /// * INTERNATIONAL_BANK_ACCOUNT_NUMBER An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://www.iban.com/structure).
        ///
        /// * SWIFT_CODE A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        ///
        ///
        ///
        ///
        /// * IT
        ///
        /// * IP_ADDRESS An IPv4 address, such as 198.51.100.0.
        ///
        /// * MAC_ADDRESS A media access control (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        ///
        /// * URL A web address, such as www.example.com.
        ///
        /// * AWS_ACCESS_KEY A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        /// * AWS_SECRET_KEY A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        ///
        ///
        ///
        /// * USA specific
        ///
        /// * US_BANK_ACCOUNT_NUMBER A US bank account number, which is typically 10 to 12 digits long.
        ///
        /// * US_BANK_ROUTING_NUMBER A US bank account routing number. These are typically nine digits long,
        ///
        /// * US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        ///
        /// * US_PASSPORT_NUMBER A US passport number. Passport numbers range from six to nine alphanumeric characters.
        ///
        /// * US_SOCIAL_SECURITY_NUMBER A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        ///
        ///
        ///
        ///
        /// * Canada specific
        ///
        /// * CA_HEALTH_NUMBER A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        ///
        /// * CA_SOCIAL_INSURANCE_NUMBER A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as 123-456-789. A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://www.wikipedia.org/wiki/Luhn_algorithm).
        ///
        ///
        ///
        ///
        /// * UK Specific
        ///
        /// * UK_NATIONAL_HEALTH_SERVICE_NUMBER A UK National Health Service Number is a 10-17 digit number, such as 485 777 3456. The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        ///
        /// * UK_NATIONAL_INSURANCE_NUMBER A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        ///
        /// * UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        ///
        ///
        ///
        ///
        /// * Custom
        ///
        /// * Regex filter - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The regular expression to configure for the guardrail.
    public struct GuardrailRegexConfig: Swift.Sendable {
        /// The guardrail action to configure when matching regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression to configure for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression to configure for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The regular expression pattern to configure for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about PII entities and regular expressions to configure for the guardrail.
    public struct GuardrailSensitiveInformationPolicyConfig: Swift.Sendable {
        /// A list of PII entities to configure to the guardrail.
        public var piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the guardrail.
        public var regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]?

        public init(
            piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]? = nil,
            regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]? = nil
        )
        {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailTopicType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about topics for the guardrail to identify and deny.
    public struct GuardrailTopicConfig: Swift.Sendable {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailTopicConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicConfig(type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about topics that the guardrail should identify and deny.
    public struct GuardrailTopicPolicyConfig: Swift.Sendable {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]?

        public init(
            topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]? = nil
        )
        {
            self.topicsConfig = topicsConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailManagedWordsType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordsType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The managed word list to configure for the guardrail.
    public struct GuardrailManagedWordsConfig: Swift.Sendable {
        /// The managed word type to configure for the guardrail.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// A word to configure for the guardrail.
    public struct GuardrailWordConfig: Swift.Sendable {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about the word policy to configured for the guardrail.
    public struct GuardrailWordPolicyConfig: Swift.Sendable {
        /// A list of managed words to configure for the guardrail.
        public var managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]?
        /// A list of words to configure for the guardrail.
        public var wordsConfig: [BedrockClientTypes.GuardrailWordConfig]?

        public init(
            managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]? = nil,
            wordsConfig: [BedrockClientTypes.GuardrailWordConfig]? = nil
        )
        {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }
    }
}

public struct CreateGuardrailInput: Swift.Sendable {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The content filter policies to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to create a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// The name to give the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The tags that you want to attach to the guardrail.
    public var tags: [BedrockClientTypes.Tag]?
    /// The topic policies to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy you configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientRequestToken = clientRequestToken
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.tags = tags
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension CreateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailOutput: Swift.Sendable {
    /// The time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail that was created.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The version of the guardrail that was created. This value will always be DRAFT.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct CreateGuardrailVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// A description of the guardrail version.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
    }
}

extension CreateGuardrailVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailVersionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailVersionOutput: Swift.Sendable {
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The number of the version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct DeleteGuardrailInput: Swift.Sendable {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

public struct DeleteGuardrailOutput: Swift.Sendable {

    public init() { }
}

public struct GetGuardrailInput: Swift.Sendable {
    /// The unique identifier of the guardrail for which to get details. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail for which to get details. If you don't specify a version, the response returns details for the DRAFT version.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

extension BedrockClientTypes {

    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate – Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults – Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual – Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence – Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html). This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentFilter: Swift.Sendable {
        /// The input modalities selected for the guardrail content filter.
        public var inputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The output modalities selected for the guardrail content filter.
        public var outputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFilter(inputStrength: \(Swift.String(describing: inputStrength)), outputStrength: \(Swift.String(describing: outputStrength)), type: \(Swift.String(describing: type)), inputModalities: \"CONTENT_REDACTED\", outputModalities: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about how to handle harmful content. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentPolicy: Swift.Sendable {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public var filters: [BedrockClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContentFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension BedrockClientTypes {

    /// The details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilter: Swift.Sendable {
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter type details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        )
        {
            self.threshold = threshold
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicy: Swift.Sendable {
        /// The filter details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension BedrockClientTypes {

    /// The PII entity configured for the guardrail.
    public struct GuardrailPiiEntity: Swift.Sendable {
        /// The configured guardrail action when PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The type of PII entity. For example, Social Security Number.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The regular expression configured for the guardrail.
    public struct GuardrailRegex: Swift.Sendable {
        /// The action taken when a match to the regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The pattern of the regular expression configured for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about PII entities and regular expressions configured for the guardrail.
    public struct GuardrailSensitiveInformationPolicy: Swift.Sendable {
        /// The list of PII entities configured for the guardrail.
        public var piiEntities: [BedrockClientTypes.GuardrailPiiEntity]?
        /// The list of regular expressions configured for the guardrail.
        public var regexes: [BedrockClientTypes.GuardrailRegex]?

        public init(
            piiEntities: [BedrockClientTypes.GuardrailPiiEntity]? = nil,
            regexes: [BedrockClientTypes.GuardrailRegex]? = nil
        )
        {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updating,
                .versioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about topics for the guardrail to identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopic: Swift.Sendable {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopic(type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about topics that the guardrail should identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopicPolicy: Swift.Sendable {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topics: [BedrockClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockClientTypes.GuardrailTopic]? = nil
        )
        {
            self.topics = topics
        }
    }
}

extension BedrockClientTypes {

    /// The managed word list that was configured for the guardrail. (This is a list of words that are pre-defined and managed by guardrails only.)
    public struct GuardrailManagedWords: Swift.Sendable {
        /// ManagedWords$type The managed word type that was configured for the guardrail. (For now, we only offer profanity word list)
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// A word configured for the guardrail.
    public struct GuardrailWord: Swift.Sendable {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about the word policy configured for the guardrail.
    public struct GuardrailWordPolicy: Swift.Sendable {
        /// A list of managed words configured for the guardrail.
        public var managedWordLists: [BedrockClientTypes.GuardrailManagedWords]?
        /// A list of words configured for the guardrail.
        public var words: [BedrockClientTypes.GuardrailWord]?

        public init(
            managedWordLists: [BedrockClientTypes.GuardrailManagedWords]? = nil,
            words: [BedrockClientTypes.GuardrailWord]? = nil
        )
        {
            self.managedWordLists = managedWordLists
            self.words = words
        }
    }
}

public struct GetGuardrailOutput: Swift.Sendable {
    /// The message that the guardrail returns when it blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message that the guardrail returns when it blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy that was configured for the guardrail.
    public var contentPolicy: BedrockClientTypes.GuardrailContentPolicy?
    /// The contextual grounding policy used in the guardrail.
    public var contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy?
    /// The date and time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the guardrail.
    public var description: Swift.String?
    /// Appears if the status of the guardrail is FAILED. A list of recommendations to carry out before retrying the request.
    public var failureRecommendations: [Swift.String]?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The ARN of the KMS key that encrypts the guardrail.
    public var kmsKeyArn: Swift.String?
    /// The name of the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy that was configured for the guardrail.
    public var sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy?
    /// The status of the guardrail.
    /// This member is required.
    public var status: BedrockClientTypes.GuardrailStatus?
    /// Appears if the status is FAILED. A list of reasons for why the guardrail failed to be created, updated, versioned, or deleted.
    public var statusReasons: [Swift.String]?
    /// The topic policy that was configured for the guardrail.
    public var topicPolicy: BedrockClientTypes.GuardrailTopicPolicy?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?
    /// The word policy that was configured for the guardrail.
    public var wordPolicy: BedrockClientTypes.GuardrailWordPolicy?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicy: BedrockClientTypes.GuardrailContentPolicy? = nil,
        contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        failureRecommendations: [Swift.String]? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy? = nil,
        status: BedrockClientTypes.GuardrailStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        topicPolicy: BedrockClientTypes.GuardrailTopicPolicy? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil,
        wordPolicy: BedrockClientTypes.GuardrailWordPolicy? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicy = contentPolicy
        self.contextualGroundingPolicy = contextualGroundingPolicy
        self.createdAt = createdAt
        self.description = description
        self.failureRecommendations = failureRecommendations
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.sensitiveInformationPolicy = sensitiveInformationPolicy
        self.status = status
        self.statusReasons = statusReasons
        self.topicPolicy = topicPolicy
        self.updatedAt = updatedAt
        self.version = version
        self.wordPolicy = wordPolicy
    }
}

extension GetGuardrailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGuardrailOutput(contentPolicy: \(Swift.String(describing: contentPolicy)), contextualGroundingPolicy: \(Swift.String(describing: contextualGroundingPolicy)), createdAt: \(Swift.String(describing: createdAt)), guardrailArn: \(Swift.String(describing: guardrailArn)), guardrailId: \(Swift.String(describing: guardrailId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), sensitiveInformationPolicy: \(Swift.String(describing: sensitiveInformationPolicy)), status: \(Swift.String(describing: status)), topicPolicy: \(Swift.String(describing: topicPolicy)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), wordPolicy: \(Swift.String(describing: wordPolicy)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", failureRecommendations: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", statusReasons: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsInput: Swift.Sendable {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    public var guardrailIdentifier: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// Contains details about a guardrail. This data type is used in the following API operations:
    ///
    /// * [ListGuardrails response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListGuardrails.html#API_ListGuardrails_ResponseSyntax)
    public struct GuardrailSummary: Swift.Sendable {
        /// The ARN of the guardrail.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time at which the guardrail was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the guardrail.
        public var description: Swift.String?
        /// The unique identifier of the guardrail.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the guardrail.
        /// This member is required.
        public var status: BedrockClientTypes.GuardrailStatus?
        /// The date and time at which the guardrail was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version of the guardrail.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockClientTypes.GuardrailStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

extension BedrockClientTypes.GuardrailSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsOutput: Swift.Sendable {
    /// A list of objects, each of which contains details about a guardrail.
    /// This member is required.
    public var guardrails: [BedrockClientTypes.GuardrailSummary]?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrails: [BedrockClientTypes.GuardrailSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrails = guardrails
        self.nextToken = nextToken
    }
}

public struct UpdateGuardrailInput: Swift.Sendable {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to update a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The ARN of the KMS key with which to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// A name for the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The topic policy to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy to configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension UpdateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGuardrailInput(contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGuardrailOutput: Swift.Sendable {
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension BedrockClientTypes {

    /// Contains information about the model or system-defined inference profile that is the source for an inference profile..
    public enum InferenceProfileModelSource: Swift.Sendable {
        /// The ARN of the model or system-defined inference profile that is the source for the inference profile.
        case copyfrom(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateInferenceProfileInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// A description for the inference profile.
    public var description: Swift.String?
    /// A name for the inference profile.
    /// This member is required.
    public var inferenceProfileName: Swift.String?
    /// The foundation model or system-defined inference profile that the inference profile will track metrics and costs for.
    /// This member is required.
    public var modelSource: BedrockClientTypes.InferenceProfileModelSource?
    /// An array of objects, each of which contains a tag and its value. For more information, see [Tagging resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        inferenceProfileName: Swift.String? = nil,
        modelSource: BedrockClientTypes.InferenceProfileModelSource? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.inferenceProfileName = inferenceProfileName
        self.modelSource = modelSource
        self.tags = tags
    }
}

extension CreateInferenceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInferenceProfileInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), modelSource: \(Swift.String(describing: modelSource)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum InferenceProfileStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileStatus] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateInferenceProfileOutput: Swift.Sendable {
    /// The ARN of the inference profile that you created.
    /// This member is required.
    public var inferenceProfileArn: Swift.String?
    /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
    public var status: BedrockClientTypes.InferenceProfileStatus?

    public init(
        inferenceProfileArn: Swift.String? = nil,
        status: BedrockClientTypes.InferenceProfileStatus? = nil
    )
    {
        self.inferenceProfileArn = inferenceProfileArn
        self.status = status
    }
}

public struct DeleteInferenceProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or ID of the application inference profile to delete.
    /// This member is required.
    public var inferenceProfileIdentifier: Swift.String?

    public init(
        inferenceProfileIdentifier: Swift.String? = nil
    )
    {
        self.inferenceProfileIdentifier = inferenceProfileIdentifier
    }
}

public struct DeleteInferenceProfileOutput: Swift.Sendable {

    public init() { }
}

public struct GetInferenceProfileInput: Swift.Sendable {
    /// The ID or Amazon Resource Name (ARN) of the inference profile.
    /// This member is required.
    public var inferenceProfileIdentifier: Swift.String?

    public init(
        inferenceProfileIdentifier: Swift.String? = nil
    )
    {
        self.inferenceProfileIdentifier = inferenceProfileIdentifier
    }
}

extension BedrockClientTypes {

    /// Contains information about a model.
    public struct InferenceProfileModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?

        public init(
            modelArn: Swift.String? = nil
        )
        {
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case systemDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileType] {
            return [
                .application,
                .systemDefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .systemDefined: return "SYSTEM_DEFINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetInferenceProfileOutput: Swift.Sendable {
    /// The time at which the inference profile was created.
    public var createdAt: Foundation.Date?
    /// The description of the inference profile.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the inference profile.
    /// This member is required.
    public var inferenceProfileArn: Swift.String?
    /// The unique identifier of the inference profile.
    /// This member is required.
    public var inferenceProfileId: Swift.String?
    /// The name of the inference profile.
    /// This member is required.
    public var inferenceProfileName: Swift.String?
    /// A list of information about each model in the inference profile.
    /// This member is required.
    public var models: [BedrockClientTypes.InferenceProfileModel]?
    /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
    /// This member is required.
    public var status: BedrockClientTypes.InferenceProfileStatus?
    /// The type of the inference profile. The following types are possible:
    ///
    /// * SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
    ///
    /// * APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
    /// This member is required.
    public var type: BedrockClientTypes.InferenceProfileType?
    /// The time at which the inference profile was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        inferenceProfileArn: Swift.String? = nil,
        inferenceProfileId: Swift.String? = nil,
        inferenceProfileName: Swift.String? = nil,
        models: [BedrockClientTypes.InferenceProfileModel]? = nil,
        status: BedrockClientTypes.InferenceProfileStatus? = nil,
        type: BedrockClientTypes.InferenceProfileType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.inferenceProfileArn = inferenceProfileArn
        self.inferenceProfileId = inferenceProfileId
        self.inferenceProfileName = inferenceProfileName
        self.models = models
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension GetInferenceProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInferenceProfileOutput(createdAt: \(Swift.String(describing: createdAt)), inferenceProfileArn: \(Swift.String(describing: inferenceProfileArn)), inferenceProfileId: \(Swift.String(describing: inferenceProfileId)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), models: \(Swift.String(describing: models)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListInferenceProfilesInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// Filters for inference profiles that match the type you specify.
    ///
    /// * SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
    ///
    /// * APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
    public var typeEquals: BedrockClientTypes.InferenceProfileType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        typeEquals: BedrockClientTypes.InferenceProfileType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeEquals = typeEquals
    }
}

extension BedrockClientTypes {

    /// Contains information about an inference profile.
    public struct InferenceProfileSummary: Swift.Sendable {
        /// The time at which the inference profile was created.
        public var createdAt: Foundation.Date?
        /// The description of the inference profile.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the inference profile.
        /// This member is required.
        public var inferenceProfileArn: Swift.String?
        /// The unique identifier of the inference profile.
        /// This member is required.
        public var inferenceProfileId: Swift.String?
        /// The name of the inference profile.
        /// This member is required.
        public var inferenceProfileName: Swift.String?
        /// A list of information about each model in the inference profile.
        /// This member is required.
        public var models: [BedrockClientTypes.InferenceProfileModel]?
        /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
        /// This member is required.
        public var status: BedrockClientTypes.InferenceProfileStatus?
        /// The type of the inference profile. The following types are possible:
        ///
        /// * SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
        ///
        /// * APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
        /// This member is required.
        public var type: BedrockClientTypes.InferenceProfileType?
        /// The time at which the inference profile was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            inferenceProfileArn: Swift.String? = nil,
            inferenceProfileId: Swift.String? = nil,
            inferenceProfileName: Swift.String? = nil,
            models: [BedrockClientTypes.InferenceProfileModel]? = nil,
            status: BedrockClientTypes.InferenceProfileStatus? = nil,
            type: BedrockClientTypes.InferenceProfileType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.inferenceProfileArn = inferenceProfileArn
            self.inferenceProfileId = inferenceProfileId
            self.inferenceProfileName = inferenceProfileName
            self.models = models
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockClientTypes.InferenceProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferenceProfileSummary(createdAt: \(Swift.String(describing: createdAt)), inferenceProfileArn: \(Swift.String(describing: inferenceProfileArn)), inferenceProfileId: \(Swift.String(describing: inferenceProfileId)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), models: \(Swift.String(describing: models)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListInferenceProfilesOutput: Swift.Sendable {
    /// A list of information about each inference profile that you can use.
    public var inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inferenceProfileSummaries = inferenceProfileSummaries
        self.nextToken = nextToken
    }
}

public struct DeleteModelInvocationLoggingConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct DeleteModelInvocationLoggingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct GetModelInvocationLoggingConfigurationInput: Swift.Sendable {

    public init() { }
}

extension BedrockClientTypes {

    /// S3 configuration for storing log data.
    public struct S3Config: Swift.Sendable {
        /// S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// S3 prefix.
        public var keyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }
    }
}

extension BedrockClientTypes {

    /// CloudWatch logging configuration.
    public struct CloudWatchConfig: Swift.Sendable {
        /// S3 configuration for delivering a large amount of data.
        public var largeDataDeliveryS3Config: BedrockClientTypes.S3Config?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The role Amazon Resource Name (ARN).
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            largeDataDeliveryS3Config: BedrockClientTypes.S3Config? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }
}

extension BedrockClientTypes {

    /// Configuration fields for invocation logging.
    public struct LoggingConfig: Swift.Sendable {
        /// CloudWatch logging configuration.
        public var cloudWatchConfig: BedrockClientTypes.CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public var embeddingDataDeliveryEnabled: Swift.Bool?
        /// Set to include image data in the log delivery.
        public var imageDataDeliveryEnabled: Swift.Bool?
        /// S3 configuration for storing log data.
        public var s3Config: BedrockClientTypes.S3Config?
        /// Set to include text data in the log delivery.
        public var textDataDeliveryEnabled: Swift.Bool?
        /// Set to include video data in the log delivery.
        public var videoDataDeliveryEnabled: Swift.Bool?

        public init(
            cloudWatchConfig: BedrockClientTypes.CloudWatchConfig? = nil,
            embeddingDataDeliveryEnabled: Swift.Bool? = nil,
            imageDataDeliveryEnabled: Swift.Bool? = nil,
            s3Config: BedrockClientTypes.S3Config? = nil,
            textDataDeliveryEnabled: Swift.Bool? = nil,
            videoDataDeliveryEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
            self.videoDataDeliveryEnabled = videoDataDeliveryEnabled
        }
    }
}

public struct GetModelInvocationLoggingConfigurationOutput: Swift.Sendable {
    /// The current configuration values.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationInput: Swift.Sendable {
    /// The logging configuration values to set.
    /// This member is required.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct CreateModelCopyJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the model copy.
    public var modelKmsKeyId: Swift.String?
    /// The Amazon Resource Name (ARN) of the model to be copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// A name for the copied model.
    /// This member is required.
    public var targetModelName: Swift.String?
    /// Tags to associate with the target model. For more information, see [Tag resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        modelKmsKeyId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.modelKmsKeyId = modelKmsKeyId
        self.sourceModelArn = sourceModelArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct CreateModelCopyJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelCopyJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

extension BedrockClientTypes {

    public enum ModelCopyJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCopyJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelCopyJobOutput: Swift.Sendable {
    /// The time at which the model copy job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// An error message for why the model copy job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The unique identifier of the account that the model being copied originated from.
    /// This member is required.
    public var sourceAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the original model being copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// The name of the original model being copied.
    public var sourceModelName: Swift.String?
    /// The status of the model copy job.
    /// This member is required.
    public var status: BedrockClientTypes.ModelCopyJobStatus?
    /// The Amazon Resource Name (ARN) of the copied model.
    /// This member is required.
    public var targetModelArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key encrypting the copied model.
    public var targetModelKmsKeyArn: Swift.String?
    /// The name of the copied model.
    public var targetModelName: Swift.String?
    /// The tags associated with the copied model.
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        creationTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        sourceAccountId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        sourceModelName: Swift.String? = nil,
        status: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelArn: Swift.String? = nil,
        targetModelKmsKeyArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.creationTime = creationTime
        self.failureMessage = failureMessage
        self.jobArn = jobArn
        self.sourceAccountId = sourceAccountId
        self.sourceModelArn = sourceModelArn
        self.sourceModelName = sourceModelName
        self.status = status
        self.targetModelArn = targetModelArn
        self.targetModelKmsKeyArn = targetModelKmsKeyArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct ListModelCopyJobsInput: Swift.Sendable {
    /// Filters for model copy jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Filters for model copy jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of model copy jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Filters for model copy jobs in which the account that the source model belongs to is equal to the value that you specify.
    public var sourceAccountEquals: Swift.String?
    /// Filters for model copy jobs in which the Amazon Resource Name (ARN) of the source model to is equal to the value that you specify.
    public var sourceModelArnEquals: Swift.String?
    /// Filters for model copy jobs whose status matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ModelCopyJobStatus?
    /// Filters for model copy jobs in which the name of the copied model contains the string that you specify.
    public var targetModelNameContains: Swift.String?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        sourceAccountEquals: Swift.String? = nil,
        sourceModelArnEquals: Swift.String? = nil,
        statusEquals: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelNameContains: Swift.String? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.sourceAccountEquals = sourceAccountEquals
        self.sourceModelArnEquals = sourceModelArnEquals
        self.statusEquals = statusEquals
        self.targetModelNameContains = targetModelNameContains
    }
}

extension BedrockClientTypes {

    /// Contains details about each model copy job. This data type is used in the following API operations:
    ///
    /// * [ListModelCopyJobs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListModelCopyJobs.html#API_ListModelCopyJobs_ResponseSyntax)
    public struct ModelCopyJobSummary: Swift.Sendable {
        /// The time that the model copy job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// If a model fails to be copied, a message describing why the job failed is included here.
        public var failureMessage: Swift.String?
        /// The Amazon Resoource Name (ARN) of the model copy job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The unique identifier of the account that the model being copied originated from.
        /// This member is required.
        public var sourceAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the original model being copied.
        /// This member is required.
        public var sourceModelArn: Swift.String?
        /// The name of the original model being copied.
        public var sourceModelName: Swift.String?
        /// The status of the model copy job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCopyJobStatus?
        /// The Amazon Resource Name (ARN) of the copied model.
        /// This member is required.
        public var targetModelArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the copied model.
        public var targetModelKmsKeyArn: Swift.String?
        /// The name of the copied model.
        public var targetModelName: Swift.String?
        /// Tags associated with the copied model.
        public var targetModelTags: [BedrockClientTypes.Tag]?

        public init(
            creationTime: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceModelArn: Swift.String? = nil,
            sourceModelName: Swift.String? = nil,
            status: BedrockClientTypes.ModelCopyJobStatus? = nil,
            targetModelArn: Swift.String? = nil,
            targetModelKmsKeyArn: Swift.String? = nil,
            targetModelName: Swift.String? = nil,
            targetModelTags: [BedrockClientTypes.Tag]? = nil
        )
        {
            self.creationTime = creationTime
            self.failureMessage = failureMessage
            self.jobArn = jobArn
            self.sourceAccountId = sourceAccountId
            self.sourceModelArn = sourceModelArn
            self.sourceModelName = sourceModelName
            self.status = status
            self.targetModelArn = targetModelArn
            self.targetModelKmsKeyArn = targetModelKmsKeyArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }
    }
}

public struct ListModelCopyJobsOutput: Swift.Sendable {
    /// A list of information about each model copy job.
    public var modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCopyJobSummaries = modelCopyJobSummaries
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// The Amazon S3 data source of the imported job.
    public struct S3DataSource: Swift.Sendable {
        /// The URI of the Amazon S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Data source for the imported model.
    public enum ModelDataSource: Swift.Sendable {
        /// The Amazon S3 data source of the imported model.
        case s3datasource(BedrockClientTypes.S3DataSource)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateModelImportJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyId: Swift.String?
    /// The name of the imported model.
    /// This member is required.
    public var importedModelName: Swift.String?
    /// Tags to attach to the imported model.
    public var importedModelTags: [BedrockClientTypes.Tag]?
    /// The name of the import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to this import job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// The data source for the imported model.
    /// This member is required.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// VPC configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for the import job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        importedModelKmsKeyId: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        importedModelTags: [BedrockClientTypes.Tag]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importedModelKmsKeyId = importedModelKmsKeyId
        self.importedModelName = importedModelName
        self.importedModelTags = importedModelTags
        self.jobName = jobName
        self.jobTags = jobTags
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelImportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct DeleteImportedModelInput: Swift.Sendable {
    /// Name of the imported model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteImportedModelOutput: Swift.Sendable {

    public init() { }
}

public struct GetImportedModelInput: Swift.Sendable {
    /// Name or Amazon Resource Name (ARN) of the imported model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct GetImportedModelOutput: Swift.Sendable {
    /// Creation time of the imported model.
    public var creationTime: Foundation.Date?
    /// Specifies if the imported model supports converse.
    public var instructSupported: Swift.Bool?
    /// Job Amazon Resource Name (ARN) associated with the imported model.
    public var jobArn: Swift.String?
    /// Job name associated with the imported model.
    public var jobName: Swift.String?
    /// The architecture of the imported model.
    public var modelArchitecture: Swift.String?
    /// The Amazon Resource Name (ARN) associated with this imported model.
    public var modelArn: Swift.String?
    /// The data source for this imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The imported model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var modelName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        instructSupported: Swift.Bool? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArchitecture: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.instructSupported = instructSupported
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArchitecture = modelArchitecture
        self.modelArn = modelArn
        self.modelDataSource = modelDataSource
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
    }
}

public struct GetModelImportJobInput: Swift.Sendable {
    /// The identifier of the import job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelImportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelImportJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelImportJobOutput: Swift.Sendable {
    /// The time the resource was created.
    public var creationTime: Foundation.Date?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the import job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported model.
    public var importedModelArn: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var importedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the import job.
    public var jobArn: Swift.String?
    /// The name of the import job.
    public var jobName: Swift.String?
    /// Time the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The data source for the imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the IAM role associated with this job.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the imported model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelImportJobStatus?
    /// The Virtual Private Cloud (VPC) configuration of the import model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        creationTime: Foundation.Date? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        importedModelArn: Swift.String? = nil,
        importedModelKmsKeyArn: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelImportJobStatus? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.creationTime = creationTime
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.importedModelArn = importedModelArn
        self.importedModelKmsKeyArn = importedModelKmsKeyArn
        self.importedModelName = importedModelName
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.status = status
        self.vpcConfig = vpcConfig
    }
}

extension BedrockClientTypes {

    public enum SortModelsBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortModelsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListImportedModelsInput: Swift.Sendable {
    /// Return imported models that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return imported models that created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported models only if the model name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// Specifies whetehr to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {

    /// Information about the imported model.
    public struct ImportedModelSummary: Swift.Sendable {
        /// Creation time of the imported model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Specifies if the imported model supports converse.
        public var instructSupported: Swift.Bool?
        /// The architecture of the imported model.
        public var modelArchitecture: Swift.String?
        /// The Amazon Resource Name (ARN) of the imported model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Name of the imported model.
        /// This member is required.
        public var modelName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            instructSupported: Swift.Bool? = nil,
            modelArchitecture: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.instructSupported = instructSupported
            self.modelArchitecture = modelArchitecture
            self.modelArn = modelArn
            self.modelName = modelName
        }
    }
}

public struct ListImportedModelsOutput: Swift.Sendable {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.ImportedModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.ImportedModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct ListModelImportJobsInput: Swift.Sendable {
    /// Return import jobs that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return import jobs that were created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return imported jobs with the specified status.
    public var statusEquals: BedrockClientTypes.ModelImportJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelImportJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Information about the import job.
    public struct ModelImportJobSummary: Swift.Sendable {
        /// The time import job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The time when import job ended.
        public var endTime: Foundation.Date?
        /// The Amazon resource Name (ARN) of the imported model.
        public var importedModelArn: Swift.String?
        /// The name of the imported model.
        public var importedModelName: Swift.String?
        /// The Amazon Resource Name (ARN) of the import job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the import job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time when the import job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the imported job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelImportJobStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            importedModelArn: Swift.String? = nil,
            importedModelName: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelImportJobStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.endTime = endTime
            self.importedModelArn = importedModelArn
            self.importedModelName = importedModelName
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

public struct ListModelImportJobsOutput: Swift.Sendable {
    /// Import job summaries.
    public var modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelImportJobSummaries = modelImportJobSummaries
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    public enum S3InputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFormat] {
            return [
                .jsonl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonl: return "JSONL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the input data.
    public struct ModelInvocationJobS3InputDataConfig: Swift.Sendable {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the input data.
        public var s3BucketOwner: Swift.String?
        /// The format of the input data.
        public var s3InputFormat: BedrockClientTypes.S3InputFormat?
        /// The S3 location of the input data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3InputFormat: BedrockClientTypes.S3InputFormat? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.s3BucketOwner = s3BucketOwner
            self.s3InputFormat = s3InputFormat
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Details about the location of the input to the batch inference job.
    public enum ModelInvocationJobInputDataConfig: Swift.Sendable {
        /// Contains the configuration of the S3 location of the input data.
        case s3inputdataconfig(BedrockClientTypes.ModelInvocationJobS3InputDataConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the output data.
    public struct ModelInvocationJobS3OutputDataConfig: Swift.Sendable {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the output data.
        public var s3BucketOwner: Swift.String?
        /// The unique identifier of the key that encrypts the S3 location of the output data.
        public var s3EncryptionKeyId: Swift.String?
        /// The S3 location of the output data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3EncryptionKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.s3BucketOwner = s3BucketOwner
            self.s3EncryptionKeyId = s3EncryptionKeyId
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the output data.
    public enum ModelInvocationJobOutputDataConfig: Swift.Sendable {
        /// Contains the configuration of the S3 location of the output data.
        case s3outputdataconfig(BedrockClientTypes.ModelInvocationJobS3OutputDataConfig)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateModelInvocationJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// A name to give the batch inference job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The unique identifier of the foundation model to use for the batch inference job.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// Any tags to associate with the batch inference job. For more information, see [Tagging Amazon Bedrock resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [BedrockClientTypes.Tag]?
    /// The number of hours after which to force the batch inference job to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.tags = tags
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelInvocationJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelInvocationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelInvocationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case partiallyCompleted
        case scheduled
        case stopped
        case stopping
        case submitted
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInvocationJobStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress,
                .partiallyCompleted,
                .scheduled,
                .stopped,
                .stopping,
                .submitted,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .expired: return "Expired"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .partiallyCompleted: return "PartiallyCompleted"
            case .scheduled: return "Scheduled"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .submitted: return "Submitted"
            case .validating: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelInvocationJobOutput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The time at which the batch inference job ended.
    public var endTime: Foundation.Date?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The time at which the batch inference job times or timed out.
    public var jobExpirationTime: Foundation.Date?
    /// The name of the batch inference job.
    public var jobName: Swift.String?
    /// The time at which the batch inference job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If the batch inference job failed, this field contains a message describing why the job failed.
    public var message: Swift.String?
    /// The unique identifier of the foundation model used for model inference.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the batch inference job. The following statuses are possible:
    ///
    /// * Submitted – This job has been submitted to a queue for validation.
    ///
    /// * Validating – This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
    ///
    /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
    ///
    /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
    ///
    /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
    ///
    ///
    ///
    ///
    /// * Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
    ///
    /// * Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
    ///
    /// * InProgress – This job has begun. You can start viewing the results in the output S3 location.
    ///
    /// * Completed – This job has successfully completed. View the output files in the output S3 location.
    ///
    /// * PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
    ///
    /// * Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
    ///
    /// * Stopped – This job was stopped by a user.
    ///
    /// * Stopping – This job is being stopped by a user.
    public var status: BedrockClientTypes.ModelInvocationJobStatus?
    /// The time at which the batch inference job was submitted.
    /// This member is required.
    public var submitTime: Foundation.Date?
    /// The number of hours after which batch inference job was set to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobArn: Swift.String? = nil,
        jobExpirationTime: Foundation.Date? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTime: Foundation.Date? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobArn = jobArn
        self.jobExpirationTime = jobExpirationTime
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.message = message
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
        self.submitTime = submitTime
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

extension GetModelInvocationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelInvocationJobOutput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsInput: Swift.Sendable {
    /// The maximum number of results to return. If there are more results than the number that you specify, a nextToken value is returned. Use the nextToken in a request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Specify a string to filter for batch inference jobs whose names contain the string.
    public var nameContains: Swift.String?
    /// If there were more results than the value you specified in the maxResults field in a previous ListModelInvocationJobs request, the response would have returned a nextToken value. To see the next batch of results, send the nextToken value in another request.
    public var nextToken: Swift.String?
    /// An attribute by which to sort the results.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results by ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Specify a status to filter for batch inference jobs whose statuses match the string you specify. The following statuses are possible:
    ///
    /// * Submitted – This job has been submitted to a queue for validation.
    ///
    /// * Validating – This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
    ///
    /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
    ///
    /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
    ///
    /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
    ///
    ///
    ///
    ///
    /// * Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
    ///
    /// * Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
    ///
    /// * InProgress – This job has begun. You can start viewing the results in the output S3 location.
    ///
    /// * Completed – This job has successfully completed. View the output files in the output S3 location.
    ///
    /// * PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
    ///
    /// * Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
    ///
    /// * Stopped – This job was stopped by a user.
    ///
    /// * Stopping – This job is being stopped by a user.
    public var statusEquals: BedrockClientTypes.ModelInvocationJobStatus?
    /// Specify a time to filter for batch inference jobs that were submitted after the time you specify.
    public var submitTimeAfter: Foundation.Date?
    /// Specify a time to filter for batch inference jobs that were submitted before the time you specify.
    public var submitTimeBefore: Foundation.Date?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTimeAfter: Foundation.Date? = nil,
        submitTimeBefore: Foundation.Date? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension BedrockClientTypes {

    /// A summary of a batch inference job.
    public struct ModelInvocationJobSummary: Swift.Sendable {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientRequestToken: Swift.String?
        /// The time at which the batch inference job ended.
        public var endTime: Foundation.Date?
        /// Details about the location of the input to the batch inference job.
        /// This member is required.
        public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
        /// The Amazon Resource Name (ARN) of the batch inference job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The time at which the batch inference job times or timed out.
        public var jobExpirationTime: Foundation.Date?
        /// The name of the batch inference job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// If the batch inference job failed, this field contains a message describing why the job failed.
        public var message: Swift.String?
        /// The unique identifier of the foundation model used for model inference.
        /// This member is required.
        public var modelId: Swift.String?
        /// Details about the location of the output of the batch inference job.
        /// This member is required.
        public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the batch inference job. The following statuses are possible:
        ///
        /// * Submitted – This job has been submitted to a queue for validation.
        ///
        /// * Validating – This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
        ///
        /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
        ///
        /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
        ///
        /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
        ///
        ///
        ///
        ///
        /// * Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
        ///
        /// * Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
        ///
        /// * InProgress – This job has begun. You can start viewing the results in the output S3 location.
        ///
        /// * Completed – This job has successfully completed. View the output files in the output S3 location.
        ///
        /// * PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
        ///
        /// * Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
        ///
        /// * Stopped – This job was stopped by a user.
        ///
        /// * Stopping – This job is being stopped by a user.
        public var status: BedrockClientTypes.ModelInvocationJobStatus?
        /// The time at which the batch inference job was submitted.
        /// This member is required.
        public var submitTime: Foundation.Date?
        /// The number of hours after which the batch inference job was set to time out.
        public var timeoutDurationInHours: Swift.Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
        public var vpcConfig: BedrockClientTypes.VpcConfig?

        public init(
            clientRequestToken: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
            jobArn: Swift.String? = nil,
            jobExpirationTime: Foundation.Date? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            modelId: Swift.String? = nil,
            outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
            submitTime: Foundation.Date? = nil,
            timeoutDurationInHours: Swift.Int? = nil,
            vpcConfig: BedrockClientTypes.VpcConfig? = nil
        )
        {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobArn = jobArn
            self.jobExpirationTime = jobExpirationTime
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.message = message
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
            self.submitTime = submitTime
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelInvocationJobSummary(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsOutput: Swift.Sendable {
    /// A list of items, each of which contains a summary about a batch inference job.
    public var invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]?
    /// If there are more results than can fit in the response, a nextToken is returned. Use the nextToken in a request to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invocationJobSummaries = invocationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelInvocationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelInvocationJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCustomModelInput: Swift.Sendable {
    /// Name of the model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteCustomModelOutput: Swift.Sendable {

    public init() { }
}

public struct GetCustomModelInput: Swift.Sendable {
    /// Name or Amazon Resource Name (ARN) of the custom model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    /// Details about a teacher model used for model customization.
    public struct TeacherModelConfig: Swift.Sendable {
        /// The maximum number of tokens requested when the customization job invokes the teacher model.
        public var maxResponseLengthForInference: Swift.Int?
        /// The identifier of the teacher model.
        /// This member is required.
        public var teacherModelIdentifier: Swift.String?

        public init(
            maxResponseLengthForInference: Swift.Int? = nil,
            teacherModelIdentifier: Swift.String? = nil
        )
        {
            self.maxResponseLengthForInference = maxResponseLengthForInference
            self.teacherModelIdentifier = teacherModelIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Settings for distilling a foundation model into a smaller and more efficient model.
    public struct DistillationConfig: Swift.Sendable {
        /// The teacher model configuration.
        /// This member is required.
        public var teacherModelConfig: BedrockClientTypes.TeacherModelConfig?

        public init(
            teacherModelConfig: BedrockClientTypes.TeacherModelConfig? = nil
        )
        {
            self.teacherModelConfig = teacherModelConfig
        }
    }
}

extension BedrockClientTypes {

    /// A model customization configuration
    public enum CustomizationConfig: Swift.Sendable {
        /// The distillation configuration for the custom model.
        case distillationconfig(BedrockClientTypes.DistillationConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum CustomizationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case distillation
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomizationType] {
            return [
                .continuedPreTraining,
                .distillation,
                .fineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .distillation: return "DISTILLATION"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// S3 Location of the output data.
    public struct OutputDataConfig: Swift.Sendable {
        /// The S3 URI where the output data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// A storage location for invocation logs.
    public enum InvocationLogSource: Swift.Sendable {
        /// The URI of an invocation log in a bucket.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// A mapping of a metadata key to a value that it should or should not equal.
    public struct RequestMetadataBaseFilters: Swift.Sendable {
        /// Include results where the key equals the value.
        public var equals: [Swift.String: Swift.String]?
        /// Include results where the key does not equal the value.
        public var notEquals: [Swift.String: Swift.String]?

        public init(
            equals: [Swift.String: Swift.String]? = nil,
            notEquals: [Swift.String: Swift.String]? = nil
        )
        {
            self.equals = equals
            self.notEquals = notEquals
        }
    }
}

extension BedrockClientTypes.RequestMetadataBaseFilters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestMetadataBaseFilters(equals: \"CONTENT_REDACTED\", notEquals: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Rules for filtering invocation logs. A filter can be a mapping of a metadata key to a value that it should or should not equal (a base filter), or a list of base filters that are all applied with AND or OR logical operators
    public enum RequestMetadataFilters: Swift.Sendable {
        /// Include results where the key equals the value.
        case equals([Swift.String: Swift.String])
        /// Include results where the key does not equal the value.
        case notequals([Swift.String: Swift.String])
        /// Include results where all of the based filters match.
        case andall([BedrockClientTypes.RequestMetadataBaseFilters])
        /// Include results where any of the base filters match.
        case orall([BedrockClientTypes.RequestMetadataBaseFilters])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Settings for using invocation logs to customize a model.
    public struct InvocationLogsConfig: Swift.Sendable {
        /// The source of the invocation logs.
        /// This member is required.
        public var invocationLogSource: BedrockClientTypes.InvocationLogSource?
        /// Rules for filtering invocation logs based on request metadata.
        public var requestMetadataFilters: BedrockClientTypes.RequestMetadataFilters?
        /// Whether to use the model's response for training, or just the prompt. The default value is False.
        public var usePromptResponse: Swift.Bool

        public init(
            invocationLogSource: BedrockClientTypes.InvocationLogSource? = nil,
            requestMetadataFilters: BedrockClientTypes.RequestMetadataFilters? = nil,
            usePromptResponse: Swift.Bool = false
        )
        {
            self.invocationLogSource = invocationLogSource
            self.requestMetadataFilters = requestMetadataFilters
            self.usePromptResponse = usePromptResponse
        }
    }
}

extension BedrockClientTypes {

    /// S3 Location of the training data.
    public struct TrainingDataConfig: Swift.Sendable {
        /// Settings for using invocation logs to customize a model.
        public var invocationLogsConfig: BedrockClientTypes.InvocationLogsConfig?
        /// The S3 URI where the training data is stored.
        public var s3Uri: Swift.String?

        public init(
            invocationLogsConfig: BedrockClientTypes.InvocationLogsConfig? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.invocationLogsConfig = invocationLogsConfig
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Metrics associated with the custom job.
    public struct TrainingMetrics: Swift.Sendable {
        /// Loss metric associated with the custom job.
        public var trainingLoss: Swift.Float?

        public init(
            trainingLoss: Swift.Float? = nil
        )
        {
            self.trainingLoss = trainingLoss
        }
    }
}

extension BedrockClientTypes {

    /// Information about a validator.
    public struct Validator: Swift.Sendable {
        /// The S3 URI where the validation data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Array of up to 10 validators.
    public struct ValidationDataConfig: Swift.Sendable {
        /// Information about the validators.
        /// This member is required.
        public var validators: [BedrockClientTypes.Validator]?

        public init(
            validators: [BedrockClientTypes.Validator]? = nil
        )
        {
            self.validators = validators
        }
    }
}

extension BedrockClientTypes {

    /// The metric for the validator.
    public struct ValidatorMetric: Swift.Sendable {
        /// The validation loss associated with this validator.
        public var validationLoss: Swift.Float?

        public init(
            validationLoss: Swift.Float? = nil
        )
        {
            self.validationLoss = validationLoss
        }
    }
}

public struct GetCustomModelOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// Creation time of the model.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The customization configuration for the custom model.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Hyperparameter values associated with this model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// Job Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var jobArn: Swift.String?
    /// Job name associated with this model.
    public var jobName: Swift.String?
    /// Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// Model name associated with this model.
    /// This member is required.
    public var modelName: Swift.String?
    /// Output data configuration associated with this custom model.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The validation metrics from the job creation.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?

    public init(
        baseModelArn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.creationTime = creationTime
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArn = modelArn
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.outputDataConfig = outputDataConfig
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
    }
}

public struct GetFoundationModelInput: Swift.Sendable {
    /// The model identifier.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomization: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case distillation
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomization] {
            return [
                .continuedPreTraining,
                .distillation,
                .fineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .distillation: return "DISTILLATION"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceType] {
            return [
                .onDemand,
                .provisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum ModelModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embedding
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelModality] {
            return [
                .embedding,
                .image,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embedding: return "EMBEDDING"
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum FoundationModelLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case legacy
        case sdkUnknown(Swift.String)

        public static var allCases: [FoundationModelLifecycleStatus] {
            return [
                .active,
                .legacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .legacy: return "LEGACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about whether a model version is available or deprecated.
    public struct FoundationModelLifecycle: Swift.Sendable {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        /// This member is required.
        public var status: BedrockClientTypes.FoundationModelLifecycleStatus?

        public init(
            status: BedrockClientTypes.FoundationModelLifecycleStatus? = nil
        )
        {
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// Information about a foundation model.
    public struct FoundationModelDetails: Swift.Sendable {
        /// The customization that the model supports.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The model Amazon Resource Name (ARN).
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model identifier.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The model name.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }
}

public struct GetFoundationModelOutput: Swift.Sendable {
    /// Information about the foundation model.
    public var modelDetails: BedrockClientTypes.FoundationModelDetails?

    public init(
        modelDetails: BedrockClientTypes.FoundationModelDetails? = nil
    )
    {
        self.modelDetails = modelDetails
    }
}

public struct ListCustomModelsInput: Swift.Sendable {
    /// Return custom models only if the base model Amazon Resource Name (ARN) matches this parameter.
    public var baseModelArnEquals: Swift.String?
    /// Return custom models created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return custom models created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// Return custom models only if the foundation model Amazon Resource Name (ARN) matches this parameter.
    public var foundationModelArnEquals: Swift.String?
    /// Return custom models depending on if the current account owns them (true) or if they were shared with the current account (false).
    public var isOwned: Swift.Bool?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return custom models only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        baseModelArnEquals: Swift.String? = nil,
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        foundationModelArnEquals: Swift.String? = nil,
        isOwned: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.baseModelArnEquals = baseModelArnEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.foundationModelArnEquals = foundationModelArnEquals
        self.isOwned = isOwned
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {

    /// Summary information for a custom model.
    public struct CustomModelSummary: Swift.Sendable {
        /// The base model Amazon Resource Name (ARN).
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// The base model name.
        /// This member is required.
        public var baseModelName: Swift.String?
        /// Creation time of the model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// The Amazon Resource Name (ARN) of the custom model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The name of the custom model.
        /// This member is required.
        public var modelName: Swift.String?
        /// The unique identifier of the account that owns the model.
        public var ownerAccountId: Swift.String?

        public init(
            baseModelArn: Swift.String? = nil,
            baseModelName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
            self.ownerAccountId = ownerAccountId
        }
    }
}

public struct ListCustomModelsOutput: Swift.Sendable {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.CustomModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.CustomModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct ListFoundationModelsInput: Swift.Sendable {
    /// Return models that support the customization type that you specify. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byCustomizationType: BedrockClientTypes.ModelCustomization?
    /// Return models that support the inference type that you specify. For more information, see [Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byInferenceType: BedrockClientTypes.InferenceType?
    /// Return models that support the output modality that you specify.
    public var byOutputModality: BedrockClientTypes.ModelModality?
    /// Return models belonging to the model provider that you specify.
    public var byProvider: Swift.String?

    public init(
        byCustomizationType: BedrockClientTypes.ModelCustomization? = nil,
        byInferenceType: BedrockClientTypes.InferenceType? = nil,
        byOutputModality: BedrockClientTypes.ModelModality? = nil,
        byProvider: Swift.String? = nil
    )
    {
        self.byCustomizationType = byCustomizationType
        self.byInferenceType = byInferenceType
        self.byOutputModality = byOutputModality
        self.byProvider = byProvider
    }
}

extension BedrockClientTypes {

    /// Summary information for a foundation model.
    public struct FoundationModelSummary: Swift.Sendable {
        /// Whether the model supports fine-tuning or continual pre-training.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The Amazon Resource Name (ARN) of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model ID of the foundation model.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated.
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }
}

public struct ListFoundationModelsOutput: Swift.Sendable {
    /// A list of Amazon Bedrock foundation models.
    public var modelSummaries: [BedrockClientTypes.FoundationModelSummary]?

    public init(
        modelSummaries: [BedrockClientTypes.FoundationModelSummary]? = nil
    )
    {
        self.modelSummaries = modelSummaries
    }
}

public struct GetPromptRouterInput: Swift.Sendable {
    /// The prompt router's ARN
    /// This member is required.
    public var promptRouterArn: Swift.String?

    public init(
        promptRouterArn: Swift.String? = nil
    )
    {
        self.promptRouterArn = promptRouterArn
    }
}

extension BedrockClientTypes {

    /// The target model for a prompt router.
    public struct PromptRouterTargetModel: Swift.Sendable {
        /// The target model's ARN.
        public var modelArn: Swift.String?

        public init(
            modelArn: Swift.String? = nil
        )
        {
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes {

    /// Routing criteria for a prompt router.
    public struct RoutingCriteria: Swift.Sendable {
        /// The criteria's response quality difference.
        /// This member is required.
        public var responseQualityDifference: Swift.Double?

        public init(
            responseQualityDifference: Swift.Double? = nil
        )
        {
            self.responseQualityDifference = responseQualityDifference
        }
    }
}

extension BedrockClientTypes {

    public enum PromptRouterStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptRouterStatus] {
            return [
                .available
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum PromptRouterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptRouterType] {
            return [
                .custom,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPromptRouterOutput: Swift.Sendable {
    /// When the router was created.
    public var createdAt: Foundation.Date?
    /// The router's description.
    public var description: Swift.String?
    /// The router's fallback model.
    /// This member is required.
    public var fallbackModel: BedrockClientTypes.PromptRouterTargetModel?
    /// The router's models.
    /// This member is required.
    public var models: [BedrockClientTypes.PromptRouterTargetModel]?
    /// The prompt router's ARN
    /// This member is required.
    public var promptRouterArn: Swift.String?
    /// The router's name.
    /// This member is required.
    public var promptRouterName: Swift.String?
    /// The router's routing criteria.
    /// This member is required.
    public var routingCriteria: BedrockClientTypes.RoutingCriteria?
    /// The router's status.
    /// This member is required.
    public var status: BedrockClientTypes.PromptRouterStatus?
    /// The router's type.
    /// This member is required.
    public var type: BedrockClientTypes.PromptRouterType?
    /// When the router was updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        fallbackModel: BedrockClientTypes.PromptRouterTargetModel? = nil,
        models: [BedrockClientTypes.PromptRouterTargetModel]? = nil,
        promptRouterArn: Swift.String? = nil,
        promptRouterName: Swift.String? = nil,
        routingCriteria: BedrockClientTypes.RoutingCriteria? = nil,
        status: BedrockClientTypes.PromptRouterStatus? = nil,
        type: BedrockClientTypes.PromptRouterType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.fallbackModel = fallbackModel
        self.models = models
        self.promptRouterArn = promptRouterArn
        self.promptRouterName = promptRouterName
        self.routingCriteria = routingCriteria
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension GetPromptRouterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPromptRouterOutput(createdAt: \(Swift.String(describing: createdAt)), fallbackModel: \(Swift.String(describing: fallbackModel)), models: \(Swift.String(describing: models)), promptRouterArn: \(Swift.String(describing: promptRouterArn)), promptRouterName: \(Swift.String(describing: promptRouterName)), routingCriteria: \(Swift.String(describing: routingCriteria)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPromptRoutersInput: Swift.Sendable {
    /// The maximum number of prompt routers to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// Details about a prompt router.
    public struct PromptRouterSummary: Swift.Sendable {
        /// When the router was created.
        public var createdAt: Foundation.Date?
        /// The router's description.
        public var description: Swift.String?
        /// The router's fallback model.
        /// This member is required.
        public var fallbackModel: BedrockClientTypes.PromptRouterTargetModel?
        /// The router's models.
        /// This member is required.
        public var models: [BedrockClientTypes.PromptRouterTargetModel]?
        /// The router's ARN.
        /// This member is required.
        public var promptRouterArn: Swift.String?
        /// The router's name.
        /// This member is required.
        public var promptRouterName: Swift.String?
        /// The router's routing criteria.
        /// This member is required.
        public var routingCriteria: BedrockClientTypes.RoutingCriteria?
        /// The router's status.
        /// This member is required.
        public var status: BedrockClientTypes.PromptRouterStatus?
        /// The summary's type.
        /// This member is required.
        public var type: BedrockClientTypes.PromptRouterType?
        /// When the router was updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            fallbackModel: BedrockClientTypes.PromptRouterTargetModel? = nil,
            models: [BedrockClientTypes.PromptRouterTargetModel]? = nil,
            promptRouterArn: Swift.String? = nil,
            promptRouterName: Swift.String? = nil,
            routingCriteria: BedrockClientTypes.RoutingCriteria? = nil,
            status: BedrockClientTypes.PromptRouterStatus? = nil,
            type: BedrockClientTypes.PromptRouterType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.fallbackModel = fallbackModel
            self.models = models
            self.promptRouterArn = promptRouterArn
            self.promptRouterName = promptRouterName
            self.routingCriteria = routingCriteria
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockClientTypes.PromptRouterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptRouterSummary(createdAt: \(Swift.String(describing: createdAt)), fallbackModel: \(Swift.String(describing: fallbackModel)), models: \(Swift.String(describing: models)), promptRouterArn: \(Swift.String(describing: promptRouterArn)), promptRouterName: \(Swift.String(describing: promptRouterName)), routingCriteria: \(Swift.String(describing: routingCriteria)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPromptRoutersOutput: Swift.Sendable {
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of prompt router summaries.
    public var promptRouterSummaries: [BedrockClientTypes.PromptRouterSummary]?

    public init(
        nextToken: Swift.String? = nil,
        promptRouterSummaries: [BedrockClientTypes.PromptRouterSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptRouterSummaries = promptRouterSummaries
    }
}

extension BedrockClientTypes {

    public enum CommitmentDuration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneMonth
        case sixMonths
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentDuration] {
            return [
                .oneMonth,
                .sixMonths
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .sixMonths: return "SixMonths"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisionedModelThroughputInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The commitment duration requested for the Provisioned Throughput. Billing occurs hourly and is discounted for longer commitment terms. To request a no-commit Provisioned Throughput, omit this field. Custom models support all levels of commitment. To see which base models support no commitment, see [Supported regions and models for Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/pt-supported.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html)
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The Amazon Resource Name (ARN) or name of the model to associate with this Provisioned Throughput. For a list of models for which you can purchase Provisioned Throughput, see [Amazon Bedrock model IDs for purchasing Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#prov-throughput-models) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    /// This member is required.
    public var modelId: Swift.String?
    /// Number of model units to allocate. A model unit delivers a specific throughput level for the specified model. The throughput level of a model unit specifies the total number of input and output tokens that it can process and generate within a span of one minute. By default, your account has no model units for purchasing Provisioned Throughputs with commitment. You must first visit the [Amazon Web Services support center](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase) to request MUs. For model unit quotas, see [Provisioned Throughput quotas](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html#prov-thru-quotas) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html). For more information about what an MU specifies, contact your Amazon Web Services account manager.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The name for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Tags to associate with this Provisioned Throughput.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        modelId: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.commitmentDuration = commitmentDuration
        self.modelId = modelId
        self.modelUnits = modelUnits
        self.provisionedModelName = provisionedModelName
        self.tags = tags
    }
}

public struct CreateProvisionedModelThroughputOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?

    public init(
        provisionedModelArn: Swift.String? = nil
    )
    {
        self.provisionedModelArn = provisionedModelArn
    }
}

public struct DeleteProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

public struct DeleteProvisionedModelThroughputOutput: Swift.Sendable {

    public init() { }
}

public struct GetProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

extension BedrockClientTypes {

    public enum ProvisionedModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case failed
        case inService
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedModelStatus] {
            return [
                .creating,
                .failed,
                .inService,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .inService: return "InService"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProvisionedModelThroughputOutput: Swift.Sendable {
    /// Commitment duration of the Provisioned Throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The timestamp for when the commitment term for the Provisioned Throughput expires.
    public var commitmentExpirationTime: Foundation.Date?
    /// The timestamp of the creation time for this Provisioned Throughput.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
    /// This member is required.
    public var desiredModelArn: Swift.String?
    /// The number of model units that was requested for this Provisioned Throughput.
    /// This member is required.
    public var desiredModelUnits: Swift.Int?
    /// A failure message for any issues that occurred during creation, updating, or deletion of the Provisioned Throughput.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
    /// This member is required.
    public var foundationModelArn: Swift.String?
    /// The timestamp of the last time that this Provisioned Throughput was modified.
    /// This member is required.
    public var lastModifiedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model associated with this Provisioned Throughput.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The number of model units allocated to this Provisioned Throughput.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?
    /// The name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// The status of the Provisioned Throughput.
    /// This member is required.
    public var status: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        commitmentExpirationTime: Foundation.Date? = nil,
        creationTime: Foundation.Date? = nil,
        desiredModelArn: Swift.String? = nil,
        desiredModelUnits: Swift.Int? = nil,
        failureMessage: Swift.String? = nil,
        foundationModelArn: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelArn: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelArn: Swift.String? = nil,
        provisionedModelName: Swift.String? = nil,
        status: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.commitmentDuration = commitmentDuration
        self.commitmentExpirationTime = commitmentExpirationTime
        self.creationTime = creationTime
        self.desiredModelArn = desiredModelArn
        self.desiredModelUnits = desiredModelUnits
        self.failureMessage = failureMessage
        self.foundationModelArn = foundationModelArn
        self.lastModifiedTime = lastModifiedTime
        self.modelArn = modelArn
        self.modelUnits = modelUnits
        self.provisionedModelArn = provisionedModelArn
        self.provisionedModelName = provisionedModelName
        self.status = status
    }
}

extension BedrockClientTypes {

    public enum SortByProvisionedModels: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByProvisionedModels] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProvisionedModelThroughputsInput: Swift.Sendable {
    /// A filter that returns Provisioned Throughputs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// A filter that returns Provisioned Throughputs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// THe maximum number of results to return in the response. If there are more results than the number you specified, the response returns a nextToken value. To see the next batch of results, send the nextToken value in another list request.
    public var maxResults: Swift.Int?
    /// A filter that returns Provisioned Throughputs whose model Amazon Resource Name (ARN) is equal to the value that you specify.
    public var modelArnEquals: Swift.String?
    /// A filter that returns Provisioned Throughputs if their name contains the expression that you specify.
    public var nameContains: Swift.String?
    /// If there are more results than the number you specified in the maxResults field, the response returns a nextToken value. To see the next batch of results, specify the nextToken value in this field.
    public var nextToken: Swift.String?
    /// The field by which to sort the returned list of Provisioned Throughputs.
    public var sortBy: BedrockClientTypes.SortByProvisionedModels?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter that returns Provisioned Throughputs if their statuses matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortByProvisionedModels? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// A summary of information about a Provisioned Throughput. This data type is used in the following API operations:
    ///
    /// * [ListProvisionedThroughputs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListProvisionedModelThroughputs.html#API_ListProvisionedModelThroughputs_ResponseSyntax)
    public struct ProvisionedModelSummary: Swift.Sendable {
        /// The duration for which the Provisioned Throughput was committed.
        public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
        /// The timestamp for when the commitment term of the Provisioned Throughput expires.
        public var commitmentExpirationTime: Foundation.Date?
        /// The time that the Provisioned Throughput was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        /// This member is required.
        public var desiredModelArn: Swift.String?
        /// The number of model units that was requested to be allocated to the Provisioned Throughput.
        /// This member is required.
        public var desiredModelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        /// This member is required.
        public var foundationModelArn: Swift.String?
        /// The time that the Provisioned Throughput was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model associated with the Provisioned Throughput.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The number of model units allocated to the Provisioned Throughput.
        /// This member is required.
        public var modelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelArn: Swift.String?
        /// The name of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelName: Swift.String?
        /// The status of the Provisioned Throughput.
        /// This member is required.
        public var status: BedrockClientTypes.ProvisionedModelStatus?

        public init(
            commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
            commitmentExpirationTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            desiredModelArn: Swift.String? = nil,
            desiredModelUnits: Swift.Int? = nil,
            foundationModelArn: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            modelArn: Swift.String? = nil,
            modelUnits: Swift.Int? = nil,
            provisionedModelArn: Swift.String? = nil,
            provisionedModelName: Swift.String? = nil,
            status: BedrockClientTypes.ProvisionedModelStatus? = nil
        )
        {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }
    }
}

public struct ListProvisionedModelThroughputsOutput: Swift.Sendable {
    /// If there are more results than the number you specified in the maxResults field, this value is returned. To see the next batch of results, include this value in the nextToken field in another list request.
    public var nextToken: Swift.String?
    /// A list of summaries, one for each Provisioned Throughput in the response.
    public var provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedModelSummaries = provisionedModelSummaries
    }
}

public struct UpdateProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new model to associate with this Provisioned Throughput. You can't specify this field if this Provisioned Throughput is associated with a base model. If this Provisioned Throughput is associated with a custom model, you can specify one of the following options:
    ///
    /// * The base model from which the custom model was customized.
    ///
    /// * Another custom model that was customized from the same base model as the custom model.
    public var desiredModelId: Swift.String?
    /// The new name for this Provisioned Throughput.
    public var desiredProvisionedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput to update.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        desiredModelId: Swift.String? = nil,
        desiredProvisionedModelName: Swift.String? = nil,
        provisionedModelId: Swift.String? = nil
    )
    {
        self.desiredModelId = desiredModelId
        self.desiredProvisionedModelName = desiredProvisionedModelName
        self.provisionedModelId = provisionedModelId
    }
}

public struct UpdateProvisionedModelThroughputOutput: Swift.Sendable {

    public init() { }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// An array of the tags associated with this resource.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tags to associate with the resource.
    /// This member is required.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CreateModelCustomizationJobInput: Swift.Sendable {
    /// Name of the base model.
    /// This member is required.
    public var baseModelIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var customModelKmsKeyId: Swift.String?
    /// A name for the resulting custom model.
    /// This member is required.
    public var customModelName: Swift.String?
    /// Tags to attach to the resulting custom model.
    public var customModelTags: [BedrockClientTypes.Tag]?
    /// The customization configuration for the model customization job.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The customization type.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Parameters related to tuning the model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A name for the fine-tuning job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// S3 location for the output data.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The configuration of the Virtual Private Cloud (VPC) that contains the resources that you're using for this job. For more information, see [Protect your model customization jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/vpc-model-customization.html).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelIdentifier: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        customModelKmsKeyId: Swift.String? = nil,
        customModelName: Swift.String? = nil,
        customModelTags: [BedrockClientTypes.Tag]? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelIdentifier = baseModelIdentifier
        self.clientRequestToken = clientRequestToken
        self.customModelKmsKeyId = customModelKmsKeyId
        self.customModelName = customModelName
        self.customModelTags = customModelTags
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.trainingDataConfig = trainingDataConfig
        self.validationDataConfig = validationDataConfig
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelCustomizationJobOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the fine tuning job
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelCustomizationJobInput: Swift.Sendable {
    /// Identifier for the customization job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomizationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomizationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelCustomizationJobOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// The token that you specified in the CreateCustomizationJob request.
    public var clientRequestToken: Swift.String?
    /// Time that the resource was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The customization configuration for the model customization job.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the job failed.
    public var failureMessage: Swift.String?
    /// The hyperparameter values for the job. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the customization job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the customization job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Time that the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Output data configuration
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of the output model.
    public var outputModelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var outputModelKmsKeyArn: Swift.String?
    /// The name of the output model.
    /// This member is required.
    public var outputModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelCustomizationJobStatus?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    /// This member is required.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The loss metric for each validator that you provided in the createjob request.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    /// VPC configuration for the custom model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        outputModelArn: Swift.String? = nil,
        outputModelKmsKeyArn: Swift.String? = nil,
        outputModelName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.clientRequestToken = clientRequestToken
        self.creationTime = creationTime
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.outputModelArn = outputModelArn
        self.outputModelKmsKeyArn = outputModelKmsKeyArn
        self.outputModelName = outputModelName
        self.roleArn = roleArn
        self.status = status
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
        self.vpcConfig = vpcConfig
    }
}

extension BedrockClientTypes {

    public enum FineTuningJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FineTuningJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListModelCustomizationJobsInput: Swift.Sendable {
    /// Return customization jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return customization jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return customization jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return customization jobs with the specified status.
    public var statusEquals: BedrockClientTypes.FineTuningJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.FineTuningJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Information about one customization job
    public struct ModelCustomizationJobSummary: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the base model.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// Creation time of the custom model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the custom model.
        public var customModelArn: Swift.String?
        /// Name of the custom model.
        public var customModelName: Swift.String?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// Time that the customization job ended.
        public var endTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the customization job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// Name of the customization job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Time that the customization job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// Status of the customization job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCustomizationJobStatus?

        public init(
            baseModelArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customModelArn: Swift.String? = nil,
            customModelName: Swift.String? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            endTime: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelCustomizationJobStatus? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.customizationType = customizationType
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

public struct ListModelCustomizationJobsOutput: Swift.Sendable {
    /// Job summaries.
    public var modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelCustomizationJobInput: Swift.Sendable {
    /// Job identifier of the job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelCustomizationJobOutput: Swift.Sendable {

    public init() { }
}

extension BedrockClientTypes {

    /// Specifies the filters to use on the metadata attributes/fields in the knowledge base data sources before returning results.
    public indirect enum RetrievalFilter: Swift.Sendable {
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is 'cat': "equals": { "key": "animal", "value": "cat" }
        case equals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is 'cat': "notEquals": { "key": "animal", "value": "cat" }
        case notequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than '1989': "greaterThan": { "key": "year", "value": 1989 }
        case greaterthan(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to '1989': "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterthanorequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to '1989': "lessThan": { "key": "year", "value": 1989 }
        case lessthan(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to '1989': "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessthanorequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either 'cat' or 'dog': "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither 'cat' nor 'dog': "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notin(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with 'ca' (for example, 'cat' or 'camel'). "startsWith": { "key": "animal", "value": "ca" }
        case startswith(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example, ["dog", "cat"]): "listContains": { "key": "animals", "value": "cat" }
        case listcontains(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following: A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example, 'cat'): "stringContains": { "key": "animal", "value": "at" } A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example, ["dog", "cat"]): "stringContains": { "key": "animals", "value": "at" }
        case stringcontains(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andall([BedrockClientTypes.RetrievalFilter])
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orall([BedrockClientTypes.RetrievalFilter])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details for returning the results from the knowledge base vector search.
    public struct KnowledgeBaseVectorSearchConfiguration: Swift.Sendable {
        /// Specifies the filters to use on the metadata fields in the knowledge base data sources before returning results.
        public var filter: BedrockClientTypes.RetrievalFilter?
        /// The number of text chunks to retrieve; the number of results to return.
        public var numberOfResults: Swift.Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available.
        public var overrideSearchType: BedrockClientTypes.SearchType?

        public init(
            filter: BedrockClientTypes.RetrievalFilter? = nil,
            numberOfResults: Swift.Int? = nil,
            overrideSearchType: BedrockClientTypes.SearchType? = nil
        )
        {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }
    }
}

extension BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseVectorSearchConfiguration(numberOfResults: \(Swift.String(describing: numberOfResults)), overrideSearchType: \(Swift.String(describing: overrideSearchType)), filter: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieving information from a knowledge base.
    public struct KnowledgeBaseRetrievalConfiguration: Swift.Sendable {
        /// Contains configuration details for returning the results from the vector search.
        /// This member is required.
        public var vectorSearchConfiguration: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        )
        {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieving information from a knowledge base and generating responses.
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public var generationConfiguration: BedrockClientTypes.GenerationConfiguration?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to generate responses.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Contains configuration details for the model to process the prompt prior to retrieval and response generation.
        public var orchestrationConfiguration: BedrockClientTypes.OrchestrationConfiguration?
        /// Contains configuration details for retrieving text chunks.
        public var retrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            generationConfiguration: BedrockClientTypes.GenerationConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            orchestrationConfiguration: BedrockClientTypes.OrchestrationConfiguration? = nil,
            retrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        )
        {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for retrieving information from a knowledge base.
    public struct RetrieveConfig: Swift.Sendable {
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Contains configuration details for knowledge base retrieval.
        /// This member is required.
        public var knowledgeBaseRetrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseRetrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        )
        {
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseRetrievalConfiguration = knowledgeBaseRetrievalConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for a knowledge base retrieval and response generation.
    public struct RetrieveAndGenerateConfiguration: Swift.Sendable {
        /// The configuration for the external source wrapper object in the retrieveAndGenerate function.
        public var externalSourcesConfiguration: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains configuration details for the knowledge base retrieval and response generation.
        public var knowledgeBaseConfiguration: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that contains your data for retrieving information and generating responses. If you choose to use EXTERNAL_SOURCES, then currently only Claude 3 Sonnet models for knowledge bases are supported.
        /// This member is required.
        public var type: BedrockClientTypes.RetrieveAndGenerateType?

        public init(
            externalSourcesConfiguration: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration? = nil,
            knowledgeBaseConfiguration: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockClientTypes.RetrieveAndGenerateType? = nil
        )
        {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for retrieving information from a knowledge base and generating responses.
    public indirect enum KnowledgeBaseConfig: Swift.Sendable {
        /// Contains configuration details for retrieving information from a knowledge base.
        case retrieveconfig(BedrockClientTypes.RetrieveConfig)
        /// Contains configuration details for retrieving information from a knowledge base and generating responses.
        case retrieveandgenerateconfig(BedrockClientTypes.RetrieveAndGenerateConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieval of information and response generation.
    public indirect enum RAGConfig: Swift.Sendable {
        /// Contains configuration details for knowledge base retrieval and response generation.
        case knowledgebaseconfig(BedrockClientTypes.KnowledgeBaseConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details of the inference model for an evaluation job. For automated model evaluation jobs, only a single model is supported. For human-based model evaluation jobs, your annotator can compare the responses for up to two different models.
    public indirect enum EvaluationInferenceConfig: Swift.Sendable {
        /// Specifies the inference models.
        case models([BedrockClientTypes.EvaluationModelConfig])
        /// Contains the configuration details of the inference for a knowledge base evaluation job, including either the retrieval only configuration or the retrieval with response generation configuration.
        case ragconfigs([BedrockClientTypes.RAGConfig])
        case sdkUnknown(Swift.String)
    }
}

public struct CreateEvaluationJobInput: Swift.Sendable {
    /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
    public var applicationType: BedrockClientTypes.ApplicationType?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Specify your customer managed encryption key Amazon Resource Name (ARN) that will be used to encrypt your evaluation job.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains the configuration details of either an automated or human-based evaluation job.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// Contains the configuration details of the inference model for the evaluation job. For model evaluation jobs, automated jobs support a single model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html), and jobs that use human workers support two models or inference profiles.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// A description of the evaluation job.
    public var jobDescription: Swift.String?
    /// A name for the evaluation job. Names must unique with your Amazon Web Services account, and your account's Amazon Web Services region.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the model evaluation job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// Contains the configuration details of the Amazon S3 bucket for storing the results of the evaluation job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. To learn more about the required permissions, see [Required permissions for model evaluations](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-security.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        applicationType: BedrockClientTypes.ApplicationType? = nil,
        clientRequestToken: Swift.String? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.applicationType = applicationType
        self.clientRequestToken = clientRequestToken
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.inferenceConfig = inferenceConfig
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
    }
}

extension CreateEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEvaluationJobInput(applicationType: \(Swift.String(describing: applicationType)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobName: \(Swift.String(describing: jobName)), jobTags: \(Swift.String(describing: jobTags)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), jobDescription: \"CONTENT_REDACTED\")"}
}

public struct GetEvaluationJobOutput: Swift.Sendable {
    /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
    public var applicationType: BedrockClientTypes.ApplicationType?
    /// The time the evaluation job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the customer managed encryption key specified when the evaluation job was created.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains the configuration details of either an automated or human-based evaluation job.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// A list of strings that specify why the evaluation job failed to create.
    public var failureMessages: [Swift.String]?
    /// Contains the configuration details of the inference model used for the evaluation job.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// The Amazon Resource Name (ARN) of the evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The description of the evaluation job.
    public var jobDescription: Swift.String?
    /// The name for the evaluation job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Specifies whether the evaluation job is automated or human-based.
    /// This member is required.
    public var jobType: BedrockClientTypes.EvaluationJobType?
    /// The time the evaluation job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Contains the configuration details of the Amazon S3 bucket for storing the results of the evaluation job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the IAM service role used in the evaluation job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The current status of the evaluation job.
    /// This member is required.
    public var status: BedrockClientTypes.EvaluationJobStatus?

    public init(
        applicationType: BedrockClientTypes.ApplicationType? = nil,
        creationTime: Foundation.Date? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        failureMessages: [Swift.String]? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobType: BedrockClientTypes.EvaluationJobType? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.applicationType = applicationType
        self.creationTime = creationTime
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.failureMessages = failureMessages
        self.inferenceConfig = inferenceConfig
        self.jobArn = jobArn
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobType = jobType
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
    }
}

extension GetEvaluationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobOutput(applicationType: \(Swift.String(describing: applicationType)), creationTime: \(Swift.String(describing: creationTime)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), failureMessages: \(Swift.String(describing: failureMessages)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobArn: \(Swift.String(describing: jobArn)), jobName: \(Swift.String(describing: jobName)), jobType: \(Swift.String(describing: jobType)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), jobDescription: \"CONTENT_REDACTED\")"}
}

extension BatchDeleteEvaluationJobInput {

    static func urlPathProvider(_ value: BatchDeleteEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs/batch-delete"
    }
}

extension CreateEvaluationJobInput {

    static func urlPathProvider(_ value: CreateEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension CreateGuardrailInput {

    static func urlPathProvider(_ value: CreateGuardrailInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension CreateGuardrailVersionInput {

    static func urlPathProvider(_ value: CreateGuardrailVersionInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension CreateInferenceProfileInput {

    static func urlPathProvider(_ value: CreateInferenceProfileInput) -> Swift.String? {
        return "/inference-profiles"
    }
}

extension CreateMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: CreateMarketplaceModelEndpointInput) -> Swift.String? {
        return "/marketplace-model/endpoints"
    }
}

extension CreateModelCopyJobInput {

    static func urlPathProvider(_ value: CreateModelCopyJobInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension CreateModelCustomizationJobInput {

    static func urlPathProvider(_ value: CreateModelCustomizationJobInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension CreateModelImportJobInput {

    static func urlPathProvider(_ value: CreateModelImportJobInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension CreateModelInvocationJobInput {

    static func urlPathProvider(_ value: CreateModelInvocationJobInput) -> Swift.String? {
        return "/model-invocation-job"
    }
}

extension CreateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: CreateProvisionedModelThroughputInput) -> Swift.String? {
        return "/provisioned-model-throughput"
    }
}

extension DeleteCustomModelInput {

    static func urlPathProvider(_ value: DeleteCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGuardrailInput {

    static func urlPathProvider(_ value: DeleteGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGuardrailInput {

    static func queryItemProvider(_ value: DeleteGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension DeleteImportedModelInput {

    static func urlPathProvider(_ value: DeleteImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteInferenceProfileInput {

    static func urlPathProvider(_ value: DeleteInferenceProfileInput) -> Swift.String? {
        guard let inferenceProfileIdentifier = value.inferenceProfileIdentifier else {
            return nil
        }
        return "/inference-profiles/\(inferenceProfileIdentifier.urlPercentEncoding())"
    }
}

extension DeleteMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: DeleteMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension DeleteModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension DeleteProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: DeleteProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension DeregisterMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: DeregisterMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())/registration"
    }
}

extension GetCustomModelInput {

    static func urlPathProvider(_ value: GetCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetEvaluationJobInput {

    static func urlPathProvider(_ value: GetEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetFoundationModelInput {

    static func urlPathProvider(_ value: GetFoundationModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/foundation-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func urlPathProvider(_ value: GetGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func queryItemProvider(_ value: GetGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension GetImportedModelInput {

    static func urlPathProvider(_ value: GetImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetInferenceProfileInput {

    static func urlPathProvider(_ value: GetInferenceProfileInput) -> Swift.String? {
        guard let inferenceProfileIdentifier = value.inferenceProfileIdentifier else {
            return nil
        }
        return "/inference-profiles/\(inferenceProfileIdentifier.urlPercentEncoding())"
    }
}

extension GetMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: GetMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension GetModelCopyJobInput {

    static func urlPathProvider(_ value: GetModelCopyJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/model-copy-jobs/\(jobArn.urlPercentEncoding())"
    }
}

extension GetModelCustomizationJobInput {

    static func urlPathProvider(_ value: GetModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelImportJobInput {

    static func urlPathProvider(_ value: GetModelImportJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-import-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationJobInput {

    static func urlPathProvider(_ value: GetModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension GetPromptRouterInput {

    static func urlPathProvider(_ value: GetPromptRouterInput) -> Swift.String? {
        guard let promptRouterArn = value.promptRouterArn else {
            return nil
        }
        return "/prompt-routers/\(promptRouterArn.urlPercentEncoding())"
    }
}

extension GetProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: GetProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension ListCustomModelsInput {

    static func urlPathProvider(_ value: ListCustomModelsInput) -> Swift.String? {
        return "/custom-models"
    }
}

extension ListCustomModelsInput {

    static func queryItemProvider(_ value: ListCustomModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let isOwned = value.isOwned {
            let isOwnedQueryItem = Smithy.URIQueryItem(name: "isOwned".urlPercentEncoding(), value: Swift.String(isOwned).urlPercentEncoding())
            items.append(isOwnedQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let baseModelArnEquals = value.baseModelArnEquals {
            let baseModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "baseModelArnEquals".urlPercentEncoding(), value: Swift.String(baseModelArnEquals).urlPercentEncoding())
            items.append(baseModelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let foundationModelArnEquals = value.foundationModelArnEquals {
            let foundationModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "foundationModelArnEquals".urlPercentEncoding(), value: Swift.String(foundationModelArnEquals).urlPercentEncoding())
            items.append(foundationModelArnEqualsQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListEvaluationJobsInput {

    static func urlPathProvider(_ value: ListEvaluationJobsInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension ListEvaluationJobsInput {

    static func queryItemProvider(_ value: ListEvaluationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let applicationTypeEquals = value.applicationTypeEquals {
            let applicationTypeEqualsQueryItem = Smithy.URIQueryItem(name: "applicationTypeEquals".urlPercentEncoding(), value: Swift.String(applicationTypeEquals.rawValue).urlPercentEncoding())
            items.append(applicationTypeEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListFoundationModelsInput {

    static func urlPathProvider(_ value: ListFoundationModelsInput) -> Swift.String? {
        return "/foundation-models"
    }
}

extension ListFoundationModelsInput {

    static func queryItemProvider(_ value: ListFoundationModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byOutputModality = value.byOutputModality {
            let byOutputModalityQueryItem = Smithy.URIQueryItem(name: "byOutputModality".urlPercentEncoding(), value: Swift.String(byOutputModality.rawValue).urlPercentEncoding())
            items.append(byOutputModalityQueryItem)
        }
        if let byCustomizationType = value.byCustomizationType {
            let byCustomizationTypeQueryItem = Smithy.URIQueryItem(name: "byCustomizationType".urlPercentEncoding(), value: Swift.String(byCustomizationType.rawValue).urlPercentEncoding())
            items.append(byCustomizationTypeQueryItem)
        }
        if let byProvider = value.byProvider {
            let byProviderQueryItem = Smithy.URIQueryItem(name: "byProvider".urlPercentEncoding(), value: Swift.String(byProvider).urlPercentEncoding())
            items.append(byProviderQueryItem)
        }
        if let byInferenceType = value.byInferenceType {
            let byInferenceTypeQueryItem = Smithy.URIQueryItem(name: "byInferenceType".urlPercentEncoding(), value: Swift.String(byInferenceType.rawValue).urlPercentEncoding())
            items.append(byInferenceTypeQueryItem)
        }
        return items
    }
}

extension ListGuardrailsInput {

    static func urlPathProvider(_ value: ListGuardrailsInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension ListGuardrailsInput {

    static func queryItemProvider(_ value: ListGuardrailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            let guardrailIdentifierQueryItem = Smithy.URIQueryItem(name: "guardrailIdentifier".urlPercentEncoding(), value: Swift.String(guardrailIdentifier).urlPercentEncoding())
            items.append(guardrailIdentifierQueryItem)
        }
        return items
    }
}

extension ListImportedModelsInput {

    static func urlPathProvider(_ value: ListImportedModelsInput) -> Swift.String? {
        return "/imported-models"
    }
}

extension ListImportedModelsInput {

    static func queryItemProvider(_ value: ListImportedModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListInferenceProfilesInput {

    static func urlPathProvider(_ value: ListInferenceProfilesInput) -> Swift.String? {
        return "/inference-profiles"
    }
}

extension ListInferenceProfilesInput {

    static func queryItemProvider(_ value: ListInferenceProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let typeEquals = value.typeEquals {
            let typeEqualsQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(typeEquals.rawValue).urlPercentEncoding())
            items.append(typeEqualsQueryItem)
        }
        return items
    }
}

extension ListMarketplaceModelEndpointsInput {

    static func urlPathProvider(_ value: ListMarketplaceModelEndpointsInput) -> Swift.String? {
        return "/marketplace-model/endpoints"
    }
}

extension ListMarketplaceModelEndpointsInput {

    static func queryItemProvider(_ value: ListMarketplaceModelEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let modelSourceEquals = value.modelSourceEquals {
            let modelSourceEqualsQueryItem = Smithy.URIQueryItem(name: "modelSourceIdentifier".urlPercentEncoding(), value: Swift.String(modelSourceEquals).urlPercentEncoding())
            items.append(modelSourceEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListModelCopyJobsInput {

    static func urlPathProvider(_ value: ListModelCopyJobsInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension ListModelCopyJobsInput {

    static func queryItemProvider(_ value: ListModelCopyJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sourceModelArnEquals = value.sourceModelArnEquals {
            let sourceModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "sourceModelArnEquals".urlPercentEncoding(), value: Swift.String(sourceModelArnEquals).urlPercentEncoding())
            items.append(sourceModelArnEqualsQueryItem)
        }
        if let sourceAccountEquals = value.sourceAccountEquals {
            let sourceAccountEqualsQueryItem = Smithy.URIQueryItem(name: "sourceAccountEquals".urlPercentEncoding(), value: Swift.String(sourceAccountEquals).urlPercentEncoding())
            items.append(sourceAccountEqualsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let targetModelNameContains = value.targetModelNameContains {
            let targetModelNameContainsQueryItem = Smithy.URIQueryItem(name: "outputModelNameContains".urlPercentEncoding(), value: Swift.String(targetModelNameContains).urlPercentEncoding())
            items.append(targetModelNameContainsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelCustomizationJobsInput {

    static func urlPathProvider(_ value: ListModelCustomizationJobsInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension ListModelCustomizationJobsInput {

    static func queryItemProvider(_ value: ListModelCustomizationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelImportJobsInput {

    static func urlPathProvider(_ value: ListModelImportJobsInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension ListModelImportJobsInput {

    static func queryItemProvider(_ value: ListModelImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelInvocationJobsInput {

    static func urlPathProvider(_ value: ListModelInvocationJobsInput) -> Swift.String? {
        return "/model-invocation-jobs"
    }
}

extension ListModelInvocationJobsInput {

    static func queryItemProvider(_ value: ListModelInvocationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let submitTimeAfter = value.submitTimeAfter {
            let submitTimeAfterQueryItem = Smithy.URIQueryItem(name: "submitTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeAfter)).urlPercentEncoding())
            items.append(submitTimeAfterQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let submitTimeBefore = value.submitTimeBefore {
            let submitTimeBeforeQueryItem = Smithy.URIQueryItem(name: "submitTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeBefore)).urlPercentEncoding())
            items.append(submitTimeBeforeQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListPromptRoutersInput {

    static func urlPathProvider(_ value: ListPromptRoutersInput) -> Swift.String? {
        return "/prompt-routers"
    }
}

extension ListPromptRoutersInput {

    static func queryItemProvider(_ value: ListPromptRoutersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListProvisionedModelThroughputsInput {

    static func urlPathProvider(_ value: ListProvisionedModelThroughputsInput) -> Swift.String? {
        return "/provisioned-model-throughputs"
    }
}

extension ListProvisionedModelThroughputsInput {

    static func queryItemProvider(_ value: ListProvisionedModelThroughputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let modelArnEquals = value.modelArnEquals {
            let modelArnEqualsQueryItem = Smithy.URIQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
            items.append(modelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension RegisterMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: RegisterMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointIdentifier = value.endpointIdentifier else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointIdentifier.urlPercentEncoding())/registration"
    }
}

extension StopEvaluationJobInput {

    static func urlPathProvider(_ value: StopEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelCustomizationJobInput {

    static func urlPathProvider(_ value: StopModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelInvocationJobInput {

    static func urlPathProvider(_ value: StopModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UpdateGuardrailInput {

    static func urlPathProvider(_ value: UpdateGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension UpdateMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: UpdateMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: UpdateProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension BatchDeleteEvaluationJobInput {

    static func write(value: BatchDeleteEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobIdentifiers"].writeList(value.jobIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEvaluationJobInput {

    static func write(value: CreateEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationType"].write(value.applicationType)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customerEncryptionKeyId"].write(value.customerEncryptionKeyId)
        try writer["evaluationConfig"].write(value.evaluationConfig, with: BedrockClientTypes.EvaluationConfig.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockClientTypes.EvaluationInferenceConfig.write(value:to:))
        try writer["jobDescription"].write(value.jobDescription)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.EvaluationOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension CreateGuardrailInput {

    static func write(value: CreateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension CreateGuardrailVersionInput {

    static func write(value: CreateGuardrailVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
    }
}

extension CreateInferenceProfileInput {

    static func write(value: CreateInferenceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["inferenceProfileName"].write(value.inferenceProfileName)
        try writer["modelSource"].write(value.modelSource, with: BedrockClientTypes.InferenceProfileModelSource.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMarketplaceModelEndpointInput {

    static func write(value: CreateMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceptEula"].write(value.acceptEula)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["endpointConfig"].write(value.endpointConfig, with: BedrockClientTypes.EndpointConfig.write(value:to:))
        try writer["endpointName"].write(value.endpointName)
        try writer["modelSourceIdentifier"].write(value.modelSourceIdentifier)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelCopyJobInput {

    static func write(value: CreateModelCopyJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["modelKmsKeyId"].write(value.modelKmsKeyId)
        try writer["sourceModelArn"].write(value.sourceModelArn)
        try writer["targetModelName"].write(value.targetModelName)
        try writer["targetModelTags"].writeList(value.targetModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelCustomizationJobInput {

    static func write(value: CreateModelCustomizationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseModelIdentifier"].write(value.baseModelIdentifier)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customModelKmsKeyId"].write(value.customModelKmsKeyId)
        try writer["customModelName"].write(value.customModelName)
        try writer["customModelTags"].writeList(value.customModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customizationConfig"].write(value.customizationConfig, with: BedrockClientTypes.CustomizationConfig.write(value:to:))
        try writer["customizationType"].write(value.customizationType)
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.OutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: BedrockClientTypes.TrainingDataConfig.write(value:to:))
        try writer["validationDataConfig"].write(value.validationDataConfig, with: BedrockClientTypes.ValidationDataConfig.write(value:to:))
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelImportJobInput {

    static func write(value: CreateModelImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["importedModelKmsKeyId"].write(value.importedModelKmsKeyId)
        try writer["importedModelName"].write(value.importedModelName)
        try writer["importedModelTags"].writeList(value.importedModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelDataSource"].write(value.modelDataSource, with: BedrockClientTypes.ModelDataSource.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelInvocationJobInput {

    static func write(value: CreateModelInvocationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["inputDataConfig"].write(value.inputDataConfig, with: BedrockClientTypes.ModelInvocationJobInputDataConfig.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["modelId"].write(value.modelId)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutDurationInHours"].write(value.timeoutDurationInHours)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateProvisionedModelThroughputInput {

    static func write(value: CreateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["commitmentDuration"].write(value.commitmentDuration)
        try writer["modelId"].write(value.modelId)
        try writer["modelUnits"].write(value.modelUnits)
        try writer["provisionedModelName"].write(value.provisionedModelName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func write(value: PutModelInvocationLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfig"].write(value.loggingConfig, with: BedrockClientTypes.LoggingConfig.write(value:to:))
    }
}

extension RegisterMarketplaceModelEndpointInput {

    static func write(value: RegisterMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSourceIdentifier"].write(value.modelSourceIdentifier)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGuardrailInput {

    static func write(value: UpdateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension UpdateMarketplaceModelEndpointInput {

    static func write(value: UpdateMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["endpointConfig"].write(value.endpointConfig, with: BedrockClientTypes.EndpointConfig.write(value:to:))
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func write(value: UpdateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredModelId"].write(value.desiredModelId)
        try writer["desiredProvisionedModelName"].write(value.desiredProvisionedModelName)
    }
}

extension BatchDeleteEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteEvaluationJobOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluationJobs = try reader["evaluationJobs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEvaluationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailVersionOutput()
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInferenceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInferenceProfileOutput()
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension CreateModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCopyJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCustomizationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelImportJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelInvocationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisionedModelThroughputOutput()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomModelOutput {
        return DeleteCustomModelOutput()
    }
}

extension DeleteGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGuardrailOutput {
        return DeleteGuardrailOutput()
    }
}

extension DeleteImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImportedModelOutput {
        return DeleteImportedModelOutput()
    }
}

extension DeleteInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInferenceProfileOutput {
        return DeleteInferenceProfileOutput()
    }
}

extension DeleteMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMarketplaceModelEndpointOutput {
        return DeleteMarketplaceModelEndpointOutput()
    }
}

extension DeleteModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelInvocationLoggingConfigurationOutput {
        return DeleteModelInvocationLoggingConfigurationOutput()
    }
}

extension DeleteProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedModelThroughputOutput {
        return DeleteProvisionedModelThroughputOutput()
    }
}

extension DeregisterMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterMarketplaceModelEndpointOutput {
        return DeregisterMarketplaceModelEndpointOutput()
    }
}

extension GetCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomModelOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationConfig = try reader["customizationConfig"].readIfPresent(with: BedrockClientTypes.CustomizationConfig.read(from:))
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvaluationJobOutput()
        value.applicationType = try reader["applicationType"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyId = try reader["customerEncryptionKeyId"].readIfPresent()
        value.evaluationConfig = try reader["evaluationConfig"].readIfPresent(with: BedrockClientTypes.EvaluationConfig.read(from:))
        value.failureMessages = try reader["failureMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceConfig = try reader["inferenceConfig"].readIfPresent(with: BedrockClientTypes.EvaluationInferenceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobDescription = try reader["jobDescription"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.EvaluationOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetFoundationModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFoundationModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFoundationModelOutput()
        value.modelDetails = try reader["modelDetails"].readIfPresent(with: BedrockClientTypes.FoundationModelDetails.read(from:))
        return value
    }
}

extension GetGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGuardrailOutput()
        value.blockedInputMessaging = try reader["blockedInputMessaging"].readIfPresent() ?? ""
        value.blockedOutputsMessaging = try reader["blockedOutputsMessaging"].readIfPresent() ?? ""
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContentPolicy.read(from:))
        value.contextualGroundingPolicy = try reader["contextualGroundingPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContextualGroundingPolicy.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.failureRecommendations = try reader["failureRecommendations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailSensitiveInformationPolicy.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailTopicPolicy.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailWordPolicy.read(from:))
        return value
    }
}

extension GetImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportedModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportedModelOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.instructSupported = try reader["instructSupported"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArchitecture = try reader["modelArchitecture"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        return value
    }
}

extension GetInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInferenceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInferenceProfileOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension GetModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCopyJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCustomizationJobOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationConfig = try reader["customizationConfig"].readIfPresent(with: BedrockClientTypes.CustomizationConfig.read(from:))
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.outputModelArn = try reader["outputModelArn"].readIfPresent()
        value.outputModelKmsKeyArn = try reader["outputModelKmsKeyArn"].readIfPresent()
        value.outputModelName = try reader["outputModelName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelImportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelKmsKeyArn = try reader["importedModelKmsKeyArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationJobOutput()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.message = try reader["message"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationLoggingConfigurationOutput()
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: BedrockClientTypes.LoggingConfig.read(from:))
        return value
    }
}

extension GetPromptRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPromptRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPromptRouterOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.fallbackModel = try reader["fallbackModel"].readIfPresent(with: BedrockClientTypes.PromptRouterTargetModel.read(from:))
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterTargetModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.promptRouterArn = try reader["promptRouterArn"].readIfPresent() ?? ""
        value.promptRouterName = try reader["promptRouterName"].readIfPresent() ?? ""
        value.routingCriteria = try reader["routingCriteria"].readIfPresent(with: BedrockClientTypes.RoutingCriteria.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedModelThroughputOutput()
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListCustomModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEvaluationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEvaluationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFoundationModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoundationModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoundationModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.FoundationModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGuardrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGuardrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGuardrailsOutput()
        value.guardrails = try reader["guardrails"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportedModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportedModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportedModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ImportedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInferenceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInferenceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInferenceProfilesOutput()
        value.inferenceProfileSummaries = try reader["inferenceProfileSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMarketplaceModelEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMarketplaceModelEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMarketplaceModelEndpointsOutput()
        value.marketplaceModelEndpoints = try reader["marketplaceModelEndpoints"].readListIfPresent(memberReadingClosure: BedrockClientTypes.MarketplaceModelEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCopyJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCopyJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCopyJobsOutput()
        value.modelCopyJobSummaries = try reader["modelCopyJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCopyJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCustomizationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCustomizationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCustomizationJobsOutput()
        value.modelCustomizationJobSummaries = try reader["modelCustomizationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomizationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelImportJobsOutput()
        value.modelImportJobSummaries = try reader["modelImportJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelInvocationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelInvocationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelInvocationJobsOutput()
        value.invocationJobSummaries = try reader["invocationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelInvocationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPromptRoutersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPromptRoutersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPromptRoutersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.promptRouterSummaries = try reader["promptRouterSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisionedModelThroughputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedModelThroughputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedModelThroughputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.provisionedModelSummaries = try reader["provisionedModelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ProvisionedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutModelInvocationLoggingConfigurationOutput {
        return PutModelInvocationLoggingConfigurationOutput()
    }
}

extension RegisterMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension StopEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopEvaluationJobOutput {
        return StopEvaluationJobOutput()
    }
}

extension StopModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelCustomizationJobOutput {
        return StopModelCustomizationJobOutput()
    }
}

extension StopModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelInvocationJobOutput {
        return StopModelInvocationJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGuardrailOutput()
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension UpdateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisionedModelThroughputOutput {
        return UpdateProvisionedModelThroughputOutput()
    }
}

enum BatchDeleteEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFoundationModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPromptRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEvaluationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoundationModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGuardrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportedModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInferenceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMarketplaceModelEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCopyJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCustomizationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelInvocationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPromptRoutersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedModelThroughputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobError {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobError()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobItem()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.MarketplaceModelEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MarketplaceModelEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MarketplaceModelEndpoint()
        value.endpointArn = try reader["endpointArn"].readIfPresent() ?? ""
        value.modelSourceIdentifier = try reader["modelSourceIdentifier"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endpointConfig = try reader["endpointConfig"].readIfPresent(with: BedrockClientTypes.EndpointConfig.read(from:))
        value.endpointStatus = try reader["endpointStatus"].readIfPresent() ?? ""
        value.endpointStatusMessage = try reader["endpointStatusMessage"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EndpointConfig {

    static func write(value: BedrockClientTypes.EndpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .sagemaker(sagemaker):
                try writer["sageMaker"].write(sagemaker, with: BedrockClientTypes.SageMakerEndpoint.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EndpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "sageMaker":
                return .sagemaker(try reader["sageMaker"].read(with: BedrockClientTypes.SageMakerEndpoint.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.SageMakerEndpoint {

    static func write(value: BedrockClientTypes.SageMakerEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionRole"].write(value.executionRole)
        try writer["initialInstanceCount"].write(value.initialInstanceCount)
        try writer["instanceType"].write(value.instanceType)
        try writer["kmsEncryptionKey"].write(value.kmsEncryptionKey)
        try writer["vpc"].write(value.vpc, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.SageMakerEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.SageMakerEndpoint()
        value.initialInstanceCount = try reader["initialInstanceCount"].readIfPresent() ?? 0
        value.instanceType = try reader["instanceType"].readIfPresent() ?? ""
        value.executionRole = try reader["executionRole"].readIfPresent() ?? ""
        value.kmsEncryptionKey = try reader["kmsEncryptionKey"].readIfPresent()
        value.vpc = try reader["vpc"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.VpcConfig {

    static func write(value: BedrockClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.TrainingDataConfig {

    static func write(value: BedrockClientTypes.TrainingDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationLogsConfig"].write(value.invocationLogsConfig, with: BedrockClientTypes.InvocationLogsConfig.write(value:to:))
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        value.invocationLogsConfig = try reader["invocationLogsConfig"].readIfPresent(with: BedrockClientTypes.InvocationLogsConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.InvocationLogsConfig {

    static func write(value: BedrockClientTypes.InvocationLogsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationLogSource"].write(value.invocationLogSource, with: BedrockClientTypes.InvocationLogSource.write(value:to:))
        try writer["requestMetadataFilters"].write(value.requestMetadataFilters, with: BedrockClientTypes.RequestMetadataFilters.write(value:to:))
        try writer["usePromptResponse"].write(value.usePromptResponse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InvocationLogsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InvocationLogsConfig()
        value.usePromptResponse = try reader["usePromptResponse"].readIfPresent() ?? false
        value.invocationLogSource = try reader["invocationLogSource"].readIfPresent(with: BedrockClientTypes.InvocationLogSource.read(from:))
        value.requestMetadataFilters = try reader["requestMetadataFilters"].readIfPresent(with: BedrockClientTypes.RequestMetadataFilters.read(from:))
        return value
    }
}

extension BedrockClientTypes.RequestMetadataFilters {

    static func write(value: BedrockClientTypes.RequestMetadataFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockClientTypes.RequestMetadataBaseFilters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].writeMap(equals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .notequals(notequals):
                try writer["notEquals"].writeMap(notequals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockClientTypes.RequestMetadataBaseFilters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RequestMetadataFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "equals":
                return .equals(try reader["equals"].readMap(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            case "notEquals":
                return .notequals(try reader["notEquals"].readMap(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            case "andAll":
                return .andall(try reader["andAll"].readList(memberReadingClosure: BedrockClientTypes.RequestMetadataBaseFilters.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "orAll":
                return .orall(try reader["orAll"].readList(memberReadingClosure: BedrockClientTypes.RequestMetadataBaseFilters.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RequestMetadataBaseFilters {

    static func write(value: BedrockClientTypes.RequestMetadataBaseFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["equals"].writeMap(value.equals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["notEquals"].writeMap(value.notEquals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RequestMetadataBaseFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RequestMetadataBaseFilters()
        value.equals = try reader["equals"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.notEquals = try reader["notEquals"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.InvocationLogSource {

    static func write(value: BedrockClientTypes.InvocationLogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InvocationLogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ValidationDataConfig {

    static func write(value: BedrockClientTypes.ValidationDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["validators"].writeList(value.validators, memberWritingClosure: BedrockClientTypes.Validator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidationDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidationDataConfig()
        value.validators = try reader["validators"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Validator.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.Validator {

    static func write(value: BedrockClientTypes.Validator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Validator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Validator()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.OutputDataConfig {

    static func write(value: BedrockClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.TrainingMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingMetrics()
        value.trainingLoss = try reader["trainingLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ValidatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidatorMetric()
        value.validationLoss = try reader["validationLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CustomizationConfig {

    static func write(value: BedrockClientTypes.CustomizationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .distillationconfig(distillationconfig):
                try writer["distillationConfig"].write(distillationconfig, with: BedrockClientTypes.DistillationConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomizationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "distillationConfig":
                return .distillationconfig(try reader["distillationConfig"].read(with: BedrockClientTypes.DistillationConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.DistillationConfig {

    static func write(value: BedrockClientTypes.DistillationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["teacherModelConfig"].write(value.teacherModelConfig, with: BedrockClientTypes.TeacherModelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.DistillationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.DistillationConfig()
        value.teacherModelConfig = try reader["teacherModelConfig"].readIfPresent(with: BedrockClientTypes.TeacherModelConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.TeacherModelConfig {

    static func write(value: BedrockClientTypes.TeacherModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResponseLengthForInference"].write(value.maxResponseLengthForInference)
        try writer["teacherModelIdentifier"].write(value.teacherModelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TeacherModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TeacherModelConfig()
        value.teacherModelIdentifier = try reader["teacherModelIdentifier"].readIfPresent() ?? ""
        value.maxResponseLengthForInference = try reader["maxResponseLengthForInference"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EvaluationConfig {

    static func write(value: BedrockClientTypes.EvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automated(automated):
                try writer["automated"].write(automated, with: BedrockClientTypes.AutomatedEvaluationConfig.write(value:to:))
            case let .human(human):
                try writer["human"].write(human, with: BedrockClientTypes.HumanEvaluationConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "automated":
                return .automated(try reader["automated"].read(with: BedrockClientTypes.AutomatedEvaluationConfig.read(from:)))
            case "human":
                return .human(try reader["human"].read(with: BedrockClientTypes.HumanEvaluationConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.HumanEvaluationConfig {

    static func write(value: BedrockClientTypes.HumanEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetrics"].writeList(value.customMetrics, memberWritingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["humanWorkflowConfig"].write(value.humanWorkflowConfig, with: BedrockClientTypes.HumanWorkflowConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationConfig()
        value.humanWorkflowConfig = try reader["humanWorkflowConfig"].readIfPresent(with: BedrockClientTypes.HumanWorkflowConfig.read(from:))
        value.customMetrics = try reader["customMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationDatasetMetricConfig {

    static func write(value: BedrockClientTypes.EvaluationDatasetMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataset"].write(value.dataset, with: BedrockClientTypes.EvaluationDataset.write(value:to:))
        try writer["metricNames"].writeList(value.metricNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskType"].write(value.taskType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetMetricConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDatasetMetricConfig()
        value.taskType = try reader["taskType"].readIfPresent() ?? .sdkUnknown("")
        value.dataset = try reader["dataset"].readIfPresent(with: BedrockClientTypes.EvaluationDataset.read(from:))
        value.metricNames = try reader["metricNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationDataset {

    static func write(value: BedrockClientTypes.EvaluationDataset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetLocation"].write(value.datasetLocation, with: BedrockClientTypes.EvaluationDatasetLocation.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDataset()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.datasetLocation = try reader["datasetLocation"].readIfPresent(with: BedrockClientTypes.EvaluationDatasetLocation.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationDatasetLocation {

    static func write(value: BedrockClientTypes.EvaluationDatasetLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.HumanEvaluationCustomMetric {

    static func write(value: BedrockClientTypes.HumanEvaluationCustomMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["ratingMethod"].write(value.ratingMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationCustomMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationCustomMetric()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.ratingMethod = try reader["ratingMethod"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.HumanWorkflowConfig {

    static func write(value: BedrockClientTypes.HumanWorkflowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowDefinitionArn"].write(value.flowDefinitionArn)
        try writer["instructions"].write(value.instructions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanWorkflowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanWorkflowConfig()
        value.flowDefinitionArn = try reader["flowDefinitionArn"].readIfPresent() ?? ""
        value.instructions = try reader["instructions"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedEvaluationConfig {

    static func write(value: BedrockClientTypes.AutomatedEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["evaluatorModelConfig"].write(value.evaluatorModelConfig, with: BedrockClientTypes.EvaluatorModelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedEvaluationConfig()
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluatorModelConfig = try reader["evaluatorModelConfig"].readIfPresent(with: BedrockClientTypes.EvaluatorModelConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluatorModelConfig {

    static func write(value: BedrockClientTypes.EvaluatorModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockevaluatormodels(bedrockevaluatormodels):
                try writer["bedrockEvaluatorModels"].writeList(bedrockevaluatormodels, memberWritingClosure: BedrockClientTypes.BedrockEvaluatorModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluatorModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockEvaluatorModels":
                return .bedrockevaluatormodels(try reader["bedrockEvaluatorModels"].readList(memberReadingClosure: BedrockClientTypes.BedrockEvaluatorModel.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.BedrockEvaluatorModel {

    static func write(value: BedrockClientTypes.BedrockEvaluatorModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BedrockEvaluatorModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BedrockEvaluatorModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationInferenceConfig {

    static func write(value: BedrockClientTypes.EvaluationInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .models(models):
                try writer["models"].writeList(models, memberWritingClosure: BedrockClientTypes.EvaluationModelConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .ragconfigs(ragconfigs):
                try writer["ragConfigs"].writeList(ragconfigs, memberWritingClosure: BedrockClientTypes.RAGConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "models":
                return .models(try reader["models"].readList(memberReadingClosure: BedrockClientTypes.EvaluationModelConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "ragConfigs":
                return .ragconfigs(try reader["ragConfigs"].readList(memberReadingClosure: BedrockClientTypes.RAGConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RAGConfig {

    static func write(value: BedrockClientTypes.RAGConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .knowledgebaseconfig(knowledgebaseconfig):
                try writer["knowledgeBaseConfig"].write(knowledgebaseconfig, with: BedrockClientTypes.KnowledgeBaseConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RAGConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "knowledgeBaseConfig":
                return .knowledgebaseconfig(try reader["knowledgeBaseConfig"].read(with: BedrockClientTypes.KnowledgeBaseConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.KnowledgeBaseConfig {

    static func write(value: BedrockClientTypes.KnowledgeBaseConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .retrieveandgenerateconfig(retrieveandgenerateconfig):
                try writer["retrieveAndGenerateConfig"].write(retrieveandgenerateconfig, with: BedrockClientTypes.RetrieveAndGenerateConfiguration.write(value:to:))
            case let .retrieveconfig(retrieveconfig):
                try writer["retrieveConfig"].write(retrieveconfig, with: BedrockClientTypes.RetrieveConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "retrieveConfig":
                return .retrieveconfig(try reader["retrieveConfig"].read(with: BedrockClientTypes.RetrieveConfig.read(from:)))
            case "retrieveAndGenerateConfig":
                return .retrieveandgenerateconfig(try reader["retrieveAndGenerateConfig"].read(with: BedrockClientTypes.RetrieveAndGenerateConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.RetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalSourcesConfiguration"].write(value.externalSourcesConfiguration, with: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RetrieveAndGenerateConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.knowledgeBaseConfiguration = try reader["knowledgeBaseConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.read(from:))
        value.externalSourcesConfiguration = try reader["externalSourcesConfiguration"].readIfPresent(with: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockClientTypes.ExternalSourcesGenerationConfiguration.write(value:to:))
        try writer["modelArn"].write(value.modelArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: BedrockClientTypes.ExternalSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ExternalSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.generationConfiguration = try reader["generationConfiguration"].readIfPresent(with: BedrockClientTypes.ExternalSourcesGenerationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.ExternalSourcesGenerationConfiguration {

    static func write(value: BedrockClientTypes.ExternalSourcesGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["kbInferenceConfig"].write(value.kbInferenceConfig, with: BedrockClientTypes.KbInferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockClientTypes.PromptTemplate.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSourcesGenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSourcesGenerationConfiguration()
        value.promptTemplate = try reader["promptTemplate"].readIfPresent(with: BedrockClientTypes.PromptTemplate.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockClientTypes.GuardrailConfiguration.read(from:))
        value.kbInferenceConfig = try reader["kbInferenceConfig"].readIfPresent(with: BedrockClientTypes.KbInferenceConfig.read(from:))
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.KbInferenceConfig {

    static func write(value: BedrockClientTypes.KbInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textInferenceConfig"].write(value.textInferenceConfig, with: BedrockClientTypes.TextInferenceConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KbInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KbInferenceConfig()
        value.textInferenceConfig = try reader["textInferenceConfig"].readIfPresent(with: BedrockClientTypes.TextInferenceConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.TextInferenceConfig {

    static func write(value: BedrockClientTypes.TextInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TextInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TextInferenceConfig()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.maxTokens = try reader["maxTokens"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailConfiguration {

    static func write(value: BedrockClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailId"].write(value.guardrailId)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailConfiguration()
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.guardrailVersion = try reader["guardrailVersion"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.PromptTemplate {

    static func write(value: BedrockClientTypes.PromptTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textPromptTemplate"].write(value.textPromptTemplate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptTemplate()
        value.textPromptTemplate = try reader["textPromptTemplate"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ExternalSource {

    static func write(value: BedrockClientTypes.ExternalSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteContent"].write(value.byteContent, with: BedrockClientTypes.ByteContentDoc.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: BedrockClientTypes.S3ObjectDoc.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSource()
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockClientTypes.S3ObjectDoc.read(from:))
        value.byteContent = try reader["byteContent"].readIfPresent(with: BedrockClientTypes.ByteContentDoc.read(from:))
        return value
    }
}

extension BedrockClientTypes.ByteContentDoc {

    static func write(value: BedrockClientTypes.ByteContentDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["data"].write(value.data)
        try writer["identifier"].write(value.identifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ByteContentDoc {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ByteContentDoc()
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.data = try reader["data"].readIfPresent() ?? Foundation.Data("".utf8)
        return value
    }
}

extension BedrockClientTypes.S3ObjectDoc {

    static func write(value: BedrockClientTypes.S3ObjectDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3ObjectDoc {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3ObjectDoc()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockClientTypes.GenerationConfiguration.write(value:to:))
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["modelArn"].write(value.modelArn)
        try writer["orchestrationConfiguration"].write(value.orchestrationConfiguration, with: BedrockClientTypes.OrchestrationConfiguration.write(value:to:))
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.retrievalConfiguration = try reader["retrievalConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.read(from:))
        value.generationConfiguration = try reader["generationConfiguration"].readIfPresent(with: BedrockClientTypes.GenerationConfiguration.read(from:))
        value.orchestrationConfiguration = try reader["orchestrationConfiguration"].readIfPresent(with: BedrockClientTypes.OrchestrationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.OrchestrationConfiguration {

    static func write(value: BedrockClientTypes.OrchestrationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queryTransformationConfiguration"].write(value.queryTransformationConfiguration, with: BedrockClientTypes.QueryTransformationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OrchestrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OrchestrationConfiguration()
        value.queryTransformationConfiguration = try reader["queryTransformationConfiguration"].readIfPresent(with: BedrockClientTypes.QueryTransformationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.QueryTransformationConfiguration {

    static func write(value: BedrockClientTypes.QueryTransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.QueryTransformationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.QueryTransformationConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GenerationConfiguration {

    static func write(value: BedrockClientTypes.GenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["kbInferenceConfig"].write(value.kbInferenceConfig, with: BedrockClientTypes.KbInferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockClientTypes.PromptTemplate.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GenerationConfiguration()
        value.promptTemplate = try reader["promptTemplate"].readIfPresent(with: BedrockClientTypes.PromptTemplate.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockClientTypes.GuardrailConfiguration.read(from:))
        value.kbInferenceConfig = try reader["kbInferenceConfig"].readIfPresent(with: BedrockClientTypes.KbInferenceConfig.read(from:))
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseRetrievalConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseRetrievalConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseRetrievalConfiguration()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockClientTypes.RetrievalFilter.write(value:to:))
        try writer["numberOfResults"].write(value.numberOfResults)
        try writer["overrideSearchType"].write(value.overrideSearchType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration()
        value.numberOfResults = try reader["numberOfResults"].readIfPresent()
        value.overrideSearchType = try reader["overrideSearchType"].readIfPresent()
        value.filter = try reader["filter"].readIfPresent(with: BedrockClientTypes.RetrievalFilter.read(from:))
        return value
    }
}

extension BedrockClientTypes.RetrievalFilter {

    static func write(value: BedrockClientTypes.RetrievalFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].write(equals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthanorequals(greaterthanorequals):
                try writer["greaterThanOrEquals"].write(greaterthanorequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .`in`(`in`):
                try writer["in"].write(`in`, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .lessthanorequals(lessthanorequals):
                try writer["lessThanOrEquals"].write(lessthanorequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .listcontains(listcontains):
                try writer["listContains"].write(listcontains, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .notequals(notequals):
                try writer["notEquals"].write(notequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .notin(notin):
                try writer["notIn"].write(notin, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .startswith(startswith):
                try writer["startsWith"].write(startswith, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .stringcontains(stringcontains):
                try writer["stringContains"].write(stringcontains, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrievalFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "equals":
                return .equals(try reader["equals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "notEquals":
                return .notequals(try reader["notEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "greaterThan":
                return .greaterthan(try reader["greaterThan"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "greaterThanOrEquals":
                return .greaterthanorequals(try reader["greaterThanOrEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "lessThan":
                return .lessthan(try reader["lessThan"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "lessThanOrEquals":
                return .lessthanorequals(try reader["lessThanOrEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "in":
                return .`in`(try reader["in"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "notIn":
                return .notin(try reader["notIn"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "startsWith":
                return .startswith(try reader["startsWith"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "listContains":
                return .listcontains(try reader["listContains"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "stringContains":
                return .stringcontains(try reader["stringContains"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "andAll":
                return .andall(try reader["andAll"].readList(memberReadingClosure: BedrockClientTypes.RetrievalFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "orAll":
                return .orall(try reader["orAll"].readList(memberReadingClosure: BedrockClientTypes.RetrievalFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.FilterAttribute {

    static func write(value: BedrockClientTypes.FilterAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FilterAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FilterAttribute()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? [:]
        return value
    }
}

extension BedrockClientTypes.RetrieveConfig {

    static func write(value: BedrockClientTypes.RetrieveConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["knowledgeBaseRetrievalConfiguration"].write(value.knowledgeBaseRetrievalConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrieveConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RetrieveConfig()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseRetrievalConfiguration = try reader["knowledgeBaseRetrievalConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationModelConfig {

    static func write(value: BedrockClientTypes.EvaluationModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockmodel(bedrockmodel):
                try writer["bedrockModel"].write(bedrockmodel, with: BedrockClientTypes.EvaluationBedrockModel.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockModel":
                return .bedrockmodel(try reader["bedrockModel"].read(with: BedrockClientTypes.EvaluationBedrockModel.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel {

    static func write(value: BedrockClientTypes.EvaluationBedrockModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inferenceParams"].write(value.inferenceParams)
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationBedrockModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationBedrockModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        value.inferenceParams = try reader["inferenceParams"].readIfPresent() ?? "{}"
        return value
    }
}

extension BedrockClientTypes.EvaluationOutputDataConfig {

    static func write(value: BedrockClientTypes.EvaluationOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationOutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.FoundationModelDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelDetails()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.FoundationModelLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelLifecycle()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopicPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopicPolicy()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.examples = try reader["examples"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailContentPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.inputStrength = try reader["inputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.outputStrength = try reader["outputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.GuardrailModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.GuardrailModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailWordPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWordPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWordPolicy()
        value.words = try reader["words"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailManagedWords.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailManagedWords {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailManagedWords {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailManagedWords()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWord()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSensitiveInformationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSensitiveInformationPolicy()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailPiiEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailRegex.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailRegex {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailRegex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailRegex()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.pattern = try reader["pattern"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailPiiEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailPiiEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailPiiEntity()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContextualGroundingFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? 0.0
        return value
    }
}

extension BedrockClientTypes.ModelDataSource {

    static func write(value: BedrockClientTypes.ModelDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3datasource(s3datasource):
                try writer["s3DataSource"].write(s3datasource, with: BedrockClientTypes.S3DataSource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3DataSource":
                return .s3datasource(try reader["s3DataSource"].read(with: BedrockClientTypes.S3DataSource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.S3DataSource {

    static func write(value: BedrockClientTypes.S3DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3DataSource()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.InferenceProfileModel {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileModel()
        value.modelArn = try reader["modelArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.Tag {

    static func write(value: BedrockClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobInputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobInputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3inputdataconfig(s3inputdataconfig):
                try writer["s3InputDataConfig"].write(s3inputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobInputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3InputDataConfig":
                return .s3inputdataconfig(try reader["s3InputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobS3InputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3InputFormat"].write(value.s3InputFormat)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3InputDataConfig()
        value.s3InputFormat = try reader["s3InputFormat"].readIfPresent()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobOutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3outputdataconfig(s3outputdataconfig):
                try writer["s3OutputDataConfig"].write(s3outputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3OutputDataConfig":
                return .s3outputdataconfig(try reader["s3OutputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3EncryptionKeyId"].write(value.s3EncryptionKeyId)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3EncryptionKeyId = try reader["s3EncryptionKeyId"].readIfPresent()
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.LoggingConfig {

    static func write(value: BedrockClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchConfig"].write(value.cloudWatchConfig, with: BedrockClientTypes.CloudWatchConfig.write(value:to:))
        try writer["embeddingDataDeliveryEnabled"].write(value.embeddingDataDeliveryEnabled)
        try writer["imageDataDeliveryEnabled"].write(value.imageDataDeliveryEnabled)
        try writer["s3Config"].write(value.s3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["textDataDeliveryEnabled"].write(value.textDataDeliveryEnabled)
        try writer["videoDataDeliveryEnabled"].write(value.videoDataDeliveryEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LoggingConfig()
        value.cloudWatchConfig = try reader["cloudWatchConfig"].readIfPresent(with: BedrockClientTypes.CloudWatchConfig.read(from:))
        value.s3Config = try reader["s3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        value.textDataDeliveryEnabled = try reader["textDataDeliveryEnabled"].readIfPresent()
        value.imageDataDeliveryEnabled = try reader["imageDataDeliveryEnabled"].readIfPresent()
        value.embeddingDataDeliveryEnabled = try reader["embeddingDataDeliveryEnabled"].readIfPresent()
        value.videoDataDeliveryEnabled = try reader["videoDataDeliveryEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.S3Config {

    static func write(value: BedrockClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keyPrefix"].write(value.keyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3Config()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CloudWatchConfig {

    static func write(value: BedrockClientTypes.CloudWatchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["largeDataDeliveryS3Config"].write(value.largeDataDeliveryS3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["logGroupName"].write(value.logGroupName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CloudWatchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CloudWatchConfig()
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.largeDataDeliveryS3Config = try reader["largeDataDeliveryS3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        return value
    }
}

extension BedrockClientTypes.RoutingCriteria {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RoutingCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RoutingCriteria()
        value.responseQualityDifference = try reader["responseQualityDifference"].readIfPresent() ?? 0.0
        return value
    }
}

extension BedrockClientTypes.PromptRouterTargetModel {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptRouterTargetModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptRouterTargetModel()
        value.modelArn = try reader["modelArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CustomModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.baseModelName = try reader["baseModelName"].readIfPresent() ?? ""
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EvaluationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.evaluationTaskTypes = try reader["evaluationTaskTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.EvaluationTaskType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modelIdentifiers = try reader["modelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ragIdentifiers = try reader["ragIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluatorModelIdentifiers = try reader["evaluatorModelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationType = try reader["applicationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.FoundationModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.GuardrailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.ImportedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ImportedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ImportedModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructSupported = try reader["instructSupported"].readIfPresent()
        value.modelArchitecture = try reader["modelArchitecture"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.InferenceProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileSummary()
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.MarketplaceModelEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MarketplaceModelEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MarketplaceModelEndpointSummary()
        value.endpointArn = try reader["endpointArn"].readIfPresent() ?? ""
        value.modelSourceIdentifier = try reader["modelSourceIdentifier"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.ModelCopyJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCopyJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCopyJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelCustomizationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCustomizationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCustomizationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customModelArn = try reader["customModelArn"].readIfPresent()
        value.customModelName = try reader["customModelName"].readIfPresent()
        value.customizationType = try reader["customizationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelImportJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.PromptRouterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptRouterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptRouterSummary()
        value.promptRouterName = try reader["promptRouterName"].readIfPresent() ?? ""
        value.routingCriteria = try reader["routingCriteria"].readIfPresent(with: BedrockClientTypes.RoutingCriteria.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.promptRouterArn = try reader["promptRouterArn"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterTargetModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fallbackModel = try reader["fallbackModel"].readIfPresent(with: BedrockClientTypes.PromptRouterTargetModel.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.ProvisionedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ProvisionedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ProvisionedModelSummary()
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicsConfig"].writeList(value.topicsConfig, memberWritingClosure: BedrockClientTypes.GuardrailTopicConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailTopicConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["examples"].writeList(value.examples, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContentPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContentPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContentFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailContentFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContentFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputModalities"].writeList(value.inputModalities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockClientTypes.GuardrailModality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputStrength"].write(value.inputStrength)
        try writer["outputModalities"].writeList(value.outputModalities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockClientTypes.GuardrailModality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputStrength"].write(value.outputStrength)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailWordPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailWordPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managedWordListsConfig"].writeList(value.managedWordListsConfig, memberWritingClosure: BedrockClientTypes.GuardrailManagedWordsConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["wordsConfig"].writeList(value.wordsConfig, memberWritingClosure: BedrockClientTypes.GuardrailWordConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailManagedWordsConfig {

    static func write(value: BedrockClientTypes.GuardrailManagedWordsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailWordConfig {

    static func write(value: BedrockClientTypes.GuardrailWordConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntitiesConfig"].writeList(value.piiEntitiesConfig, memberWritingClosure: BedrockClientTypes.GuardrailPiiEntityConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regexesConfig"].writeList(value.regexesConfig, memberWritingClosure: BedrockClientTypes.GuardrailRegexConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailRegexConfig {

    static func write(value: BedrockClientTypes.GuardrailRegexConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["pattern"].write(value.pattern)
    }
}

extension BedrockClientTypes.GuardrailPiiEntityConfig {

    static func write(value: BedrockClientTypes.GuardrailPiiEntityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContextualGroundingFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["threshold"].write(value.threshold)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.InferenceProfileModelSource {

    static func write(value: BedrockClientTypes.InferenceProfileModelSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .copyfrom(copyfrom):
                try writer["copyFrom"].write(copyfrom)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum BedrockClientTypes {}
