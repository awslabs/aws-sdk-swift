// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes.AutomatedEvaluationConfig {

    static func write(value: BedrockClientTypes.AutomatedEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedEvaluationConfig()
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Use to specify a automatic model evaluation job. The EvaluationDatasetMetricConfig object is used to specify the prompt datasets, task type, and metric names.
    public struct AutomatedEvaluationConfig {
        /// Specifies the required elements for an automatic model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?

        public init(
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil
        )
        {
            self.datasetMetricConfigs = datasetMetricConfigs
        }
    }

}

public enum BedrockClientTypes {}

extension BedrockClientTypes.CloudWatchConfig {

    static func write(value: BedrockClientTypes.CloudWatchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["largeDataDeliveryS3Config"].write(value.largeDataDeliveryS3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["logGroupName"].write(value.logGroupName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CloudWatchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CloudWatchConfig()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.largeDataDeliveryS3Config = try reader["largeDataDeliveryS3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        return value
    }
}

extension BedrockClientTypes {
    /// CloudWatch logging configuration.
    public struct CloudWatchConfig {
        /// S3 configuration for delivering a large amount of data.
        public var largeDataDeliveryS3Config: BedrockClientTypes.S3Config?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The role Amazon Resource Name (ARN).
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            largeDataDeliveryS3Config: BedrockClientTypes.S3Config? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }

}

extension BedrockClientTypes {

    public enum CommitmentDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneMonth
        case sixMonths
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentDuration] {
            return [
                .oneMonth,
                .sixMonths,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .sixMonths: return "SixMonths"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Error occurred because of a conflict while performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEvaluationJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobName: \(Swift.String(describing: jobName)), jobTags: \(Swift.String(describing: jobTags)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), jobDescription: \"CONTENT_REDACTED\")"}
}

extension CreateEvaluationJobInput {

    static func urlPathProvider(_ value: CreateEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension CreateEvaluationJobInput {

    static func write(value: CreateEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customerEncryptionKeyId"].write(value.customerEncryptionKeyId)
        try writer["evaluationConfig"].write(value.evaluationConfig, with: BedrockClientTypes.EvaluationConfig.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockClientTypes.EvaluationInferenceConfig.write(value:to:))
        try writer["jobDescription"].write(value.jobDescription)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.EvaluationOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

public struct CreateEvaluationJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Specify your customer managed key ARN that will be used to encrypt your model evaluation job.
    public var customerEncryptionKeyId: Swift.String?
    /// Specifies whether the model evaluation job is automatic or uses human worker.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// Specify the models you want to use in your model evaluation job. Automatic model evaluation jobs support a single model, and model evaluation job that use human workers support two models.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// A description of the model evaluation job.
    public var jobDescription: Swift.String?
    /// The name of the model evaluation job. Model evaluation job names must unique with your AWS account, and your account's AWS region.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the model evaluation job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// An object that defines where the results of model evaluation job will be saved in Amazon S3.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. The service role must have Amazon Bedrock as the service principal, and provide access to any Amazon S3 buckets specified in the EvaluationConfig object. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission. To learn more about the required permissions, see [Required permissions](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-security.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.inferenceConfig = inferenceConfig
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
    }
}

extension CreateEvaluationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEvaluationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent()
        return value
    }
}

public struct CreateEvaluationJobOutput {
    /// The ARN of the model evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

enum CreateEvaluationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateGuardrailInput {

    static func urlPathProvider(_ value: CreateGuardrailInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension CreateGuardrailInput {

    static func write(value: CreateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

public struct CreateGuardrailInput {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The content filter policies to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// The name to give the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The tags that you want to attach to the guardrail.
    public var tags: [BedrockClientTypes.Tag]?
    /// The topic policies to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy you configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientRequestToken = clientRequestToken
        self.contentPolicyConfig = contentPolicyConfig
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.tags = tags
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension CreateGuardrailOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.guardrailArn = try reader["guardrailArn"].readIfPresent()
        value.guardrailId = try reader["guardrailId"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

public struct CreateGuardrailOutput {
    /// The time at which the guardrail was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The ARN of the guardrail that was created.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail that was created.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The version of the guardrail that was created. This value should be 1.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.version = version
    }
}

enum CreateGuardrailOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGuardrailVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailVersionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), description: \"CONTENT_REDACTED\")"}
}

extension CreateGuardrailVersionInput {

    static func urlPathProvider(_ value: CreateGuardrailVersionInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension CreateGuardrailVersionInput {

    static func write(value: CreateGuardrailVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
    }
}

public struct CreateGuardrailVersionInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// A description of the guardrail version.
    public var description: Swift.String?
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
    }
}

extension CreateGuardrailVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGuardrailVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailVersionOutput()
        value.guardrailId = try reader["guardrailId"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

public struct CreateGuardrailVersionOutput {
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The number of the version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailId = guardrailId
        self.version = version
    }
}

enum CreateGuardrailVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateModelCustomizationJobInput {

    static func urlPathProvider(_ value: CreateModelCustomizationJobInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension CreateModelCustomizationJobInput {

    static func write(value: CreateModelCustomizationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseModelIdentifier"].write(value.baseModelIdentifier)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customModelKmsKeyId"].write(value.customModelKmsKeyId)
        try writer["customModelName"].write(value.customModelName)
        try writer["customModelTags"].writeList(value.customModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customizationType"].write(value.customizationType)
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.OutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: BedrockClientTypes.TrainingDataConfig.write(value:to:))
        try writer["validationDataConfig"].write(value.validationDataConfig, with: BedrockClientTypes.ValidationDataConfig.write(value:to:))
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

public struct CreateModelCustomizationJobInput {
    /// Name of the base model.
    /// This member is required.
    public var baseModelIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var customModelKmsKeyId: Swift.String?
    /// A name for the resulting custom model.
    /// This member is required.
    public var customModelName: Swift.String?
    /// Tags to attach to the resulting custom model.
    public var customModelTags: [BedrockClientTypes.Tag]?
    /// The customization type.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Parameters related to tuning the model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    /// This member is required.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// A name for the fine-tuning job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// S3 location for the output data.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// VPC configuration (optional). Configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for this job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelIdentifier: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        customModelKmsKeyId: Swift.String? = nil,
        customModelName: Swift.String? = nil,
        customModelTags: [BedrockClientTypes.Tag]? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelIdentifier = baseModelIdentifier
        self.clientRequestToken = clientRequestToken
        self.customModelKmsKeyId = customModelKmsKeyId
        self.customModelName = customModelName
        self.customModelTags = customModelTags
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.trainingDataConfig = trainingDataConfig
        self.validationDataConfig = validationDataConfig
        self.vpcConfig = vpcConfig
    }
}

extension CreateModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCustomizationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent()
        return value
    }
}

public struct CreateModelCustomizationJobOutput {
    /// Amazon Resource Name (ARN) of the fine tuning job
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

enum CreateModelCustomizationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: CreateProvisionedModelThroughputInput) -> Swift.String? {
        return "/provisioned-model-throughput"
    }
}

extension CreateProvisionedModelThroughputInput {

    static func write(value: CreateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["commitmentDuration"].write(value.commitmentDuration)
        try writer["modelId"].write(value.modelId)
        try writer["modelUnits"].write(value.modelUnits)
        try writer["provisionedModelName"].write(value.provisionedModelName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateProvisionedModelThroughputInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The commitment duration requested for the Provisioned Throughput. Billing occurs hourly and is discounted for longer commitment terms. To request a no-commit Provisioned Throughput, omit this field. Custom models support all levels of commitment. To see which base models support no commitment, see [Supported regions and models for Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/pt-supported.html) in the Amazon Bedrock User Guide
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The Amazon Resource Name (ARN) or name of the model to associate with this Provisioned Throughput. For a list of models for which you can purchase Provisioned Throughput, see [Amazon Bedrock model IDs for purchasing Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#prov-throughput-models) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// Number of model units to allocate. A model unit delivers a specific throughput level for the specified model. The throughput level of a model unit specifies the total number of input and output tokens that it can process and generate within a span of one minute. By default, your account has no model units for purchasing Provisioned Throughputs with commitment. You must first visit the [Amazon Web Services support center](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase) to request MUs. For model unit quotas, see [Provisioned Throughput quotas](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html#prov-thru-quotas) in the Amazon Bedrock User Guide. For more information about what an MU specifies, contact your Amazon Web Services account manager.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The name for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Tags to associate with this Provisioned Throughput.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        modelId: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.commitmentDuration = commitmentDuration
        self.modelId = modelId
        self.modelUnits = modelUnits
        self.provisionedModelName = provisionedModelName
        self.tags = tags
    }
}

extension CreateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisionedModelThroughputOutput()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent()
        return value
    }
}

public struct CreateProvisionedModelThroughputOutput {
    /// The Amazon Resource Name (ARN) for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?

    public init(
        provisionedModelArn: Swift.String? = nil
    )
    {
        self.provisionedModelArn = provisionedModelArn
    }
}

enum CreateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.CustomModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.baseModelArn = try reader["baseModelArn"].readIfPresent()
        value.baseModelName = try reader["baseModelName"].readIfPresent()
        value.customizationType = try reader["customizationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Summary information for a custom model.
    public struct CustomModelSummary {
        /// The base model Amazon Resource Name (ARN).
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// The base model name.
        /// This member is required.
        public var baseModelName: Swift.String?
        /// Creation time of the model.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// The Amazon Resource Name (ARN) of the custom model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The name of the custom model.
        /// This member is required.
        public var modelName: Swift.String?

        public init(
            baseModelArn: Swift.String? = nil,
            baseModelName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
        }
    }

}

extension BedrockClientTypes {

    public enum CustomizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomizationType] {
            return [
                .continuedPreTraining,
                .fineTuning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeleteCustomModelInput {

    static func urlPathProvider(_ value: DeleteCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteCustomModelInput {
    /// Name of the model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension DeleteCustomModelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteCustomModelOutput {
        return DeleteCustomModelOutput()
    }
}

public struct DeleteCustomModelOutput {

    public init() { }
}

enum DeleteCustomModelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGuardrailInput {

    static func queryItemProvider(_ value: DeleteGuardrailInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension DeleteGuardrailInput {

    static func urlPathProvider(_ value: DeleteGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteGuardrailInput {
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

extension DeleteGuardrailOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGuardrailOutput {
        return DeleteGuardrailOutput()
    }
}

public struct DeleteGuardrailOutput {

    public init() { }
}

enum DeleteGuardrailOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

public struct DeleteModelInvocationLoggingConfigurationInput {

    public init() { }
}

extension DeleteModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteModelInvocationLoggingConfigurationOutput {
        return DeleteModelInvocationLoggingConfigurationOutput()
    }
}

public struct DeleteModelInvocationLoggingConfigurationOutput {

    public init() { }
}

enum DeleteModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: DeleteProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

public struct DeleteProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

extension DeleteProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteProvisionedModelThroughputOutput {
        return DeleteProvisionedModelThroughputOutput()
    }
}

public struct DeleteProvisionedModelThroughputOutput {

    public init() { }
}

enum DeleteProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationBedrockModel(modelIdentifier: \(Swift.String(describing: modelIdentifier)), inferenceParams: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.EvaluationBedrockModel {

    static func write(value: BedrockClientTypes.EvaluationBedrockModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inferenceParams"].write(value.inferenceParams)
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationBedrockModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationBedrockModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent()
        value.inferenceParams = try reader["inferenceParams"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Contains the ARN of the Amazon Bedrock models specified in your model evaluation job. Each Amazon Bedrock model supports different inferenceParams. To learn more about supported inference parameters for Amazon Bedrock models, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-prompt-datasets-custom.html). The inferenceParams are specified using JSON. To successfully insert JSON as string make sure that all quotations are properly escaped. For example, "temperature":"0.25" key value pair would need to be formatted as \"temperature\":\"0.25\" to successfully accepted in the request.
    public struct EvaluationBedrockModel {
        /// Each Amazon Bedrock support different inference parameters that change how the model behaves during inference.
        /// This member is required.
        public var inferenceParams: Swift.String?
        /// The ARN of the Amazon Bedrock model specified.
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            inferenceParams: Swift.String? = nil,
            modelIdentifier: Swift.String? = nil
        )
        {
            self.inferenceParams = inferenceParams
            self.modelIdentifier = modelIdentifier
        }
    }

}

extension BedrockClientTypes.EvaluationConfig {

    static func write(value: BedrockClientTypes.EvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automated(automated):
                try writer["automated"].write(automated, with: BedrockClientTypes.AutomatedEvaluationConfig.write(value:to:))
            case let .human(human):
                try writer["human"].write(human, with: BedrockClientTypes.HumanEvaluationConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "automated":
                return .automated(try reader["automated"].read(with: BedrockClientTypes.AutomatedEvaluationConfig.read(from:)))
            case "human":
                return .human(try reader["human"].read(with: BedrockClientTypes.HumanEvaluationConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes {
    /// Used to specify either a AutomatedEvaluationConfig or HumanEvaluationConfig object.
    public enum EvaluationConfig {
        /// Used to specify an automated model evaluation job. See AutomatedEvaluationConfig to view the required parameters.
        case automated(BedrockClientTypes.AutomatedEvaluationConfig)
        /// Used to specify a model evaluation job that uses human workers.See HumanEvaluationConfig to view the required parameters.
        case human(BedrockClientTypes.HumanEvaluationConfig)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes.EvaluationDataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDataset(datasetLocation: \(Swift.String(describing: datasetLocation)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.EvaluationDataset {

    static func write(value: BedrockClientTypes.EvaluationDataset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetLocation"].write(value.datasetLocation, with: BedrockClientTypes.EvaluationDatasetLocation.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDataset()
        value.name = try reader["name"].readIfPresent()
        value.datasetLocation = try reader["datasetLocation"].readIfPresent(with: BedrockClientTypes.EvaluationDatasetLocation.read(from:))
        return value
    }
}

extension BedrockClientTypes {
    /// Used to specify the name of a built-in prompt dataset and optionally, the Amazon S3 bucket where a custom prompt dataset is saved.
    public struct EvaluationDataset {
        /// For custom prompt datasets, you must specify the location in Amazon S3 where the prompt dataset is saved.
        public var datasetLocation: BedrockClientTypes.EvaluationDatasetLocation?
        /// Used to specify supported built-in prompt datasets. Valid values are Builtin.Bold, Builtin.BoolQ, Builtin.NaturalQuestions, Builtin.Gigaword, Builtin.RealToxicityPrompts, Builtin.TriviaQa, Builtin.T-Rex, Builtin.WomensEcommerceClothingReviews and Builtin.Wikitext2.
        /// This member is required.
        public var name: Swift.String?

        public init(
            datasetLocation: BedrockClientTypes.EvaluationDatasetLocation? = nil,
            name: Swift.String? = nil
        )
        {
            self.datasetLocation = datasetLocation
            self.name = name
        }
    }

}

extension BedrockClientTypes.EvaluationDatasetLocation {

    static func write(value: BedrockClientTypes.EvaluationDatasetLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes {
    /// The location in Amazon S3 where your prompt dataset is stored.
    public enum EvaluationDatasetLocation {
        /// The S3 URI of the S3 bucket specified in the job.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes.EvaluationDatasetMetricConfig {

    static func write(value: BedrockClientTypes.EvaluationDatasetMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataset"].write(value.dataset, with: BedrockClientTypes.EvaluationDataset.write(value:to:))
        try writer["metricNames"].writeList(value.metricNames, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskType"].write(value.taskType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetMetricConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDatasetMetricConfig()
        value.taskType = try reader["taskType"].readIfPresent()
        value.dataset = try reader["dataset"].readIfPresent(with: BedrockClientTypes.EvaluationDataset.read(from:))
        value.metricNames = try reader["metricNames"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Defines the built-in prompt datasets, built-in metric names and custom metric names, and the task type.
    public struct EvaluationDatasetMetricConfig {
        /// Specifies the prompt dataset.
        /// This member is required.
        public var dataset: BedrockClientTypes.EvaluationDataset?
        /// The names of the metrics used. For automated model evaluation jobs valid values are "Builtin.Accuracy", "Builtin.Robustness", and "Builtin.Toxicity". In human-based model evaluation jobs the array of strings must match the name parameter specified in HumanEvaluationCustomMetric.
        /// This member is required.
        public var metricNames: [Swift.String]?
        /// The task type you want the model to carry out.
        /// This member is required.
        public var taskType: BedrockClientTypes.EvaluationTaskType?

        public init(
            dataset: BedrockClientTypes.EvaluationDataset? = nil,
            metricNames: [Swift.String]? = nil,
            taskType: BedrockClientTypes.EvaluationTaskType? = nil
        )
        {
            self.dataset = dataset
            self.metricNames = metricNames
            self.taskType = taskType
        }
    }

}

extension BedrockClientTypes.EvaluationInferenceConfig {

    static func write(value: BedrockClientTypes.EvaluationInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .models(models):
                try writer["models"].writeList(models, memberWritingClosure: BedrockClientTypes.EvaluationModelConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "models":
                return .models(try reader["models"].readList(memberReadingClosure: BedrockClientTypes.EvaluationModelConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes {
    /// Used to define the models you want used in your model evaluation job. Automated model evaluation jobs support only a single model. In a human-based model evaluation job, your annotator can compare the responses for up to two different models.
    public enum EvaluationInferenceConfig {
        /// Used to specify the models.
        case models([BedrockClientTypes.EvaluationModelConfig])
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {

    public enum EvaluationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum EvaluationJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automated
        case human
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobType] {
            return [
                .automated,
                .human,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automated: return "Automated"
            case .human: return "Human"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.EvaluationModelConfig {

    static func write(value: BedrockClientTypes.EvaluationModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockmodel(bedrockmodel):
                try writer["bedrockModel"].write(bedrockmodel, with: BedrockClientTypes.EvaluationBedrockModel.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockModel":
                return .bedrockmodel(try reader["bedrockModel"].read(with: BedrockClientTypes.EvaluationBedrockModel.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes {
    /// Defines the models used in the model evaluation job.
    public enum EvaluationModelConfig {
        /// Defines the Amazon Bedrock model and inference parameters you want used.
        case bedrockmodel(BedrockClientTypes.EvaluationBedrockModel)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes.EvaluationOutputDataConfig {

    static func write(value: BedrockClientTypes.EvaluationOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationOutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// The Amazon S3 location where the results of your model evaluation job are saved.
    public struct EvaluationOutputDataConfig {
        /// The Amazon S3 URI where the results of model evaluation job are saved.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes.EvaluationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationSummary()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.jobType = try reader["jobType"].readIfPresent()
        value.evaluationTaskTypes = try reader["evaluationTaskTypes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationTaskType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelIdentifiers = try reader["modelIdentifiers"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// A summary of the model evaluation job.
    public struct EvaluationSummary {
        /// When the model evaluation job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// What task type was used in the model evaluation job.
        /// This member is required.
        public var evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]?
        /// The Amazon Resource Name (ARN) of the model evaluation job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the model evaluation job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The type, either human or automatic, of model evaluation job.
        /// This member is required.
        public var jobType: BedrockClientTypes.EvaluationJobType?
        /// The Amazon Resource Names (ARNs) of the model(s) used in the model evaluation job.
        /// This member is required.
        public var modelIdentifiers: [Swift.String]?
        /// The current status of the model evaluation job.
        /// This member is required.
        public var status: BedrockClientTypes.EvaluationJobStatus?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: BedrockClientTypes.EvaluationJobType? = nil,
            modelIdentifiers: [Swift.String]? = nil,
            status: BedrockClientTypes.EvaluationJobStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.evaluationTaskTypes = evaluationTaskTypes
            self.jobArn = jobArn
            self.jobName = jobName
            self.jobType = jobType
            self.modelIdentifiers = modelIdentifiers
            self.status = status
        }
    }

}

extension BedrockClientTypes {

    public enum EvaluationTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classification
        case custom
        case generation
        case questionAndAnswer
        case summarization
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationTaskType] {
            return [
                .classification,
                .custom,
                .generation,
                .questionAndAnswer,
                .summarization,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classification: return "Classification"
            case .custom: return "Custom"
            case .generation: return "Generation"
            case .questionAndAnswer: return "QuestionAndAnswer"
            case .summarization: return "Summarization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum FineTuningJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FineTuningJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.FoundationModelDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelDetails()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelModality.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelModality.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomization.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes {
    /// Information about a foundation model.
    public struct FoundationModelDetails {
        /// The customization that the model supports.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The model Amazon Resource Name (ARN).
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model identifier.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The model name.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

extension BedrockClientTypes.FoundationModelLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelLifecycle()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Details about whether a model version is available or deprecated.
    public struct FoundationModelLifecycle {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        /// This member is required.
        public var status: BedrockClientTypes.FoundationModelLifecycleStatus?

        public init(
            status: BedrockClientTypes.FoundationModelLifecycleStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension BedrockClientTypes {

    public enum FoundationModelLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case legacy
        case sdkUnknown(Swift.String)

        public static var allCases: [FoundationModelLifecycleStatus] {
            return [
                .active,
                .legacy,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .legacy: return "LEGACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.FoundationModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelModality.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelModality.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomization.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes {
    /// Summary information for a foundation model.
    public struct FoundationModelSummary {
        /// Whether the model supports fine-tuning or continual pre-training.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The Amazon Resource Name (ARN) of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model ID of the foundation model.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated.
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

extension GetCustomModelInput {

    static func urlPathProvider(_ value: GetCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct GetCustomModelInput {
    /// Name or Amazon Resource Name (ARN) of the custom model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension GetCustomModelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCustomModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomModelOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct GetCustomModelOutput {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// Creation time of the model.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Hyperparameter values associated with this model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String:Swift.String]?
    /// Job Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var jobArn: Swift.String?
    /// Job name associated with this model.
    public var jobName: Swift.String?
    /// Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// Model name associated with this model.
    /// This member is required.
    public var modelName: Swift.String?
    /// Output data configuration associated with this custom model.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The validation metrics from the job creation.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?

    public init(
        baseModelArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArn = modelArn
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.outputDataConfig = outputDataConfig
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
    }
}

enum GetCustomModelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension GetEvaluationJobInput {

    static func urlPathProvider(_ value: GetEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

public struct GetEvaluationJobInput {
    /// The Amazon Resource Name (ARN) of the model evaluation job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension GetEvaluationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobOutput(creationTime: \(Swift.String(describing: creationTime)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), failureMessages: \(Swift.String(describing: failureMessages)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobArn: \(Swift.String(describing: jobArn)), jobName: \(Swift.String(describing: jobName)), jobType: \(Swift.String(describing: jobType)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), jobDescription: \"CONTENT_REDACTED\")"}
}

extension GetEvaluationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvaluationJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.customerEncryptionKeyId = try reader["customerEncryptionKeyId"].readIfPresent()
        value.evaluationConfig = try reader["evaluationConfig"].readIfPresent(with: BedrockClientTypes.EvaluationConfig.read(from:))
        value.failureMessages = try reader["failureMessages"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceConfig = try reader["inferenceConfig"].readIfPresent(with: BedrockClientTypes.EvaluationInferenceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobDescription = try reader["jobDescription"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.jobType = try reader["jobType"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: .dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.EvaluationOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetEvaluationJobOutput {
    /// When the model evaluation job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the customer managed key specified when the model evaluation job was created.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains details about the type of model evaluation job, the metrics used, the task type selected, the datasets used, and any custom metrics you defined.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// An array of strings the specify why the model evaluation job has failed.
    public var failureMessages: [Swift.String]?
    /// Details about the models you specified in your model evaluation job.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// The Amazon Resource Name (ARN) of the model evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The description of the model evaluation job.
    public var jobDescription: Swift.String?
    /// The name of the model evaluation job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The type of model evaluation job.
    /// This member is required.
    public var jobType: BedrockClientTypes.EvaluationJobType?
    /// When the model evaluation job was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// Amazon S3 location for where output data is saved.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the IAM service role used in the model evaluation job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the model evaluation job.
    /// This member is required.
    public var status: BedrockClientTypes.EvaluationJobStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        failureMessages: [Swift.String]? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobType: BedrockClientTypes.EvaluationJobType? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.failureMessages = failureMessages
        self.inferenceConfig = inferenceConfig
        self.jobArn = jobArn
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobType = jobType
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
    }
}

enum GetEvaluationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetFoundationModelInput {

    static func urlPathProvider(_ value: GetFoundationModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/foundation-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct GetFoundationModelInput {
    /// The model identifier.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension GetFoundationModelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetFoundationModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFoundationModelOutput()
        value.modelDetails = try reader["modelDetails"].readIfPresent(with: BedrockClientTypes.FoundationModelDetails.read(from:))
        return value
    }
}

public struct GetFoundationModelOutput {
    /// Information about the foundation model.
    public var modelDetails: BedrockClientTypes.FoundationModelDetails?

    public init(
        modelDetails: BedrockClientTypes.FoundationModelDetails? = nil
    )
    {
        self.modelDetails = modelDetails
    }
}

enum GetFoundationModelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGuardrailInput {

    static func queryItemProvider(_ value: GetGuardrailInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension GetGuardrailInput {

    static func urlPathProvider(_ value: GetGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

public struct GetGuardrailInput {
    /// The unique identifier of the guardrail for which to get details.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail for which to get details. If you don't specify a version, the response returns details for the DRAFT version.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

extension GetGuardrailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGuardrailOutput(contentPolicy: \(Swift.String(describing: contentPolicy)), createdAt: \(Swift.String(describing: createdAt)), failureRecommendations: \(Swift.String(describing: failureRecommendations)), guardrailArn: \(Swift.String(describing: guardrailArn)), guardrailId: \(Swift.String(describing: guardrailId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), sensitiveInformationPolicy: \(Swift.String(describing: sensitiveInformationPolicy)), status: \(Swift.String(describing: status)), statusReasons: \(Swift.String(describing: statusReasons)), topicPolicy: \(Swift.String(describing: topicPolicy)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), wordPolicy: \(Swift.String(describing: wordPolicy)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetGuardrailOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGuardrailOutput()
        value.blockedInputMessaging = try reader["blockedInputMessaging"].readIfPresent()
        value.blockedOutputsMessaging = try reader["blockedOutputsMessaging"].readIfPresent()
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContentPolicy.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        value.failureRecommendations = try reader["failureRecommendations"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailArn = try reader["guardrailArn"].readIfPresent()
        value.guardrailId = try reader["guardrailId"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailSensitiveInformationPolicy.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailTopicPolicy.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.version = try reader["version"].readIfPresent()
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailWordPolicy.read(from:))
        return value
    }
}

public struct GetGuardrailOutput {
    /// The message that the guardrail returns when it blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message that the guardrail returns when it blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy that was configured for the guardrail.
    public var contentPolicy: BedrockClientTypes.GuardrailContentPolicy?
    /// The date and time at which the guardrail was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The description of the guardrail.
    public var description: Swift.String?
    /// Appears if the status of the guardrail is FAILED. A list of recommendations to carry out before retrying the request.
    public var failureRecommendations: [Swift.String]?
    /// The ARN of the guardrail that was created.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The ARN of the KMS key that encrypts the guardrail.
    public var kmsKeyArn: Swift.String?
    /// The name of the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy that was configured for the guardrail.
    public var sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy?
    /// The status of the guardrail.
    /// This member is required.
    public var status: BedrockClientTypes.GuardrailStatus?
    /// Appears if the status is FAILED. A list of reasons for why the guardrail failed to be created, updated, versioned, or deleted.
    public var statusReasons: [Swift.String]?
    /// The topic policy that was configured for the guardrail.
    public var topicPolicy: BedrockClientTypes.GuardrailTopicPolicy?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?
    /// The word policy that was configured for the guardrail.
    public var wordPolicy: BedrockClientTypes.GuardrailWordPolicy?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicy: BedrockClientTypes.GuardrailContentPolicy? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        failureRecommendations: [Swift.String]? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy? = nil,
        status: BedrockClientTypes.GuardrailStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        topicPolicy: BedrockClientTypes.GuardrailTopicPolicy? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        version: Swift.String? = nil,
        wordPolicy: BedrockClientTypes.GuardrailWordPolicy? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicy = contentPolicy
        self.createdAt = createdAt
        self.description = description
        self.failureRecommendations = failureRecommendations
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.sensitiveInformationPolicy = sensitiveInformationPolicy
        self.status = status
        self.statusReasons = statusReasons
        self.topicPolicy = topicPolicy
        self.updatedAt = updatedAt
        self.version = version
        self.wordPolicy = wordPolicy
    }
}

enum GetGuardrailOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetModelCustomizationJobInput {

    static func urlPathProvider(_ value: GetModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

public struct GetModelCustomizationJobInput {
    /// Identifier for the customization job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension GetModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCustomizationJobOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: .dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.outputModelArn = try reader["outputModelArn"].readIfPresent()
        value.outputModelKmsKeyArn = try reader["outputModelKmsKeyArn"].readIfPresent()
        value.outputModelName = try reader["outputModelName"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

public struct GetModelCustomizationJobOutput {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// The token that you specified in the CreateCustomizationJob request.
    public var clientRequestToken: Swift.String?
    /// Time that the resource was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Time that the resource transitioned to terminal state.
    public var endTime: ClientRuntime.Date?
    /// Information about why the job failed.
    public var failureMessage: Swift.String?
    /// The hyperparameter values for the job. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    /// This member is required.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of the customization job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the customization job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Time that the resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// Output data configuration
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of the output model.
    public var outputModelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var outputModelKmsKeyArn: Swift.String?
    /// The name of the output model.
    /// This member is required.
    public var outputModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelCustomizationJobStatus?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    /// This member is required.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The loss metric for each validator that you provided in the createjob request.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    /// VPC configuration for the custom model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        endTime: ClientRuntime.Date? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        outputModelArn: Swift.String? = nil,
        outputModelKmsKeyArn: Swift.String? = nil,
        outputModelName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.clientRequestToken = clientRequestToken
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.outputModelArn = outputModelArn
        self.outputModelKmsKeyArn = outputModelKmsKeyArn
        self.outputModelName = outputModelName
        self.roleArn = roleArn
        self.status = status
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
        self.vpcConfig = vpcConfig
    }
}

enum GetModelCustomizationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

public struct GetModelInvocationLoggingConfigurationInput {

    public init() { }
}

extension GetModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetModelInvocationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationLoggingConfigurationOutput()
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: BedrockClientTypes.LoggingConfig.read(from:))
        return value
    }
}

public struct GetModelInvocationLoggingConfigurationOutput {
    /// The current configuration values.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

enum GetModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: GetProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

public struct GetProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

extension GetProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedModelThroughputOutput()
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent()
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: .dateTime)
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelUnits = try reader["modelUnits"].readIfPresent()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent()
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetProvisionedModelThroughputOutput {
    /// Commitment duration of the Provisioned Throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The timestamp for when the commitment term for the Provisioned Throughput expires.
    public var commitmentExpirationTime: ClientRuntime.Date?
    /// The timestamp of the creation time for this Provisioned Throughput.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
    /// This member is required.
    public var desiredModelArn: Swift.String?
    /// The number of model units that was requested for this Provisioned Throughput.
    /// This member is required.
    public var desiredModelUnits: Swift.Int?
    /// A failure message for any issues that occurred during creation, updating, or deletion of the Provisioned Throughput.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
    /// This member is required.
    public var foundationModelArn: Swift.String?
    /// The timestamp of the last time that this Provisioned Throughput was modified.
    /// This member is required.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the model associated with this Provisioned Throughput.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The number of model units allocated to this Provisioned Throughput.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?
    /// The name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// The status of the Provisioned Throughput.
    /// This member is required.
    public var status: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        commitmentExpirationTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        desiredModelArn: Swift.String? = nil,
        desiredModelUnits: Swift.Int? = nil,
        failureMessage: Swift.String? = nil,
        foundationModelArn: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        modelArn: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelArn: Swift.String? = nil,
        provisionedModelName: Swift.String? = nil,
        status: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.commitmentDuration = commitmentDuration
        self.commitmentExpirationTime = commitmentExpirationTime
        self.creationTime = creationTime
        self.desiredModelArn = desiredModelArn
        self.desiredModelUnits = desiredModelUnits
        self.failureMessage = failureMessage
        self.foundationModelArn = foundationModelArn
        self.lastModifiedTime = lastModifiedTime
        self.modelArn = modelArn
        self.modelUnits = modelUnits
        self.provisionedModelArn = provisionedModelArn
        self.provisionedModelName = provisionedModelName
        self.status = status
    }
}

enum GetProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent()
        value.inputStrength = try reader["inputStrength"].readIfPresent()
        value.outputStrength = try reader["outputStrength"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate  Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults  Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual  Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence  Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html). This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentFilter {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailContentFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContentFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputStrength"].write(value.inputStrength)
        try writer["outputStrength"].write(value.outputStrength)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes {
    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate  Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults  Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual  Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence  Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html). This data type is used in the following API operations:
    ///
    /// * [CreateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateGuardrail.html#API_CreateGuardrail_RequestSyntax)
    ///
    /// * [UpdateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_UpdateGuardrail.html#API_UpdateGuardrail_RequestSyntax)
    public struct GuardrailContentFilterConfig {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailContentFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailContentPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Contains details about how to handle harmful content. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentPolicy {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public var filters: [BedrockClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContentFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension BedrockClientTypes.GuardrailContentPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContentPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContentFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes {
    /// Contains details about how to handle harmful content. This data type is used in the following API operations:
    ///
    /// * [CreateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateGuardrail.html#API_CreateGuardrail_RequestSyntax)
    ///
    /// * [UpdateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_UpdateGuardrail.html#API_UpdateGuardrail_RequestSyntax)
    public struct GuardrailContentPolicyConfig {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]? = nil
        )
        {
            self.filtersConfig = filtersConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailFilterStrength: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailManagedWords {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailManagedWords {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailManagedWords()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// The managed word list that was configured for the guardrail. (This is a list of words that are pre-defined and managed by Guardrails only.)
    public struct GuardrailManagedWords {
        /// ManagedWords$type The managed word type that was configured for the guardrail. (For now, we only offer profanity word list)
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailManagedWordsConfig {

    static func write(value: BedrockClientTypes.GuardrailManagedWordsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes {
    /// The managed word list to configure for the guardrail.
    public struct GuardrailManagedWordsConfig {
        /// The managed word type to configure for the guardrail.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailManagedWordsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordsType] {
            return [
                .profanity,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailPiiEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailPiiEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailPiiEntity()
        value.type = try reader["type"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// The PII entity configured for the guardrail.
    public struct GuardrailPiiEntity {
        /// The configured guardrail action when PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The type of PII entity. For example, Social Security Number.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailPiiEntityConfig {

    static func write(value: BedrockClientTypes.GuardrailPiiEntityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes {
    /// The PII entity to configure for the guardrail.
    public struct GuardrailPiiEntityConfig {
        /// Configure guardrail action when the PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Configure guardrail type when the PII entity is detected.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailPiiEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailRegex {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailRegex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailRegex()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.pattern = try reader["pattern"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// The regular expression configured for the guardrail.
    public struct GuardrailRegex {
        /// The action taken when a match to the regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The pattern of the regular expression configured for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }

}

extension BedrockClientTypes.GuardrailRegexConfig {

    static func write(value: BedrockClientTypes.GuardrailRegexConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["pattern"].write(value.pattern)
    }
}

extension BedrockClientTypes {
    /// The regular expression to configure for the guardrail.
    public struct GuardrailRegexConfig {
        /// The guardrail action to configure when matching regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression to configure for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression to configure for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The regular expression pattern to configure for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailSensitiveInformationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymize
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationAction] {
            return [
                .anonymize,
                .block,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymize: return "ANONYMIZE"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSensitiveInformationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSensitiveInformationPolicy()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailPiiEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailRegex.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Contains details about PII entities and regular expressions configured for the guardrail.
    public struct GuardrailSensitiveInformationPolicy {
        /// The list of PII entities configured for the guardrail.
        public var piiEntities: [BedrockClientTypes.GuardrailPiiEntity]?
        /// The list of regular expressions configured for the guardrail.
        public var regexes: [BedrockClientTypes.GuardrailRegex]?

        public init(
            piiEntities: [BedrockClientTypes.GuardrailPiiEntity]? = nil,
            regexes: [BedrockClientTypes.GuardrailRegex]? = nil
        )
        {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }

}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntitiesConfig"].writeList(value.piiEntitiesConfig, memberWritingClosure: BedrockClientTypes.GuardrailPiiEntityConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regexesConfig"].writeList(value.regexesConfig, memberWritingClosure: BedrockClientTypes.GuardrailRegexConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes {
    /// Contains details about PII entities and regular expressions to configure for the guardrail.
    public struct GuardrailSensitiveInformationPolicyConfig {
        /// A list of PII entities to configure to the guardrail.
        public var piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the guardrail.
        public var regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]?

        public init(
            piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]? = nil,
            regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]? = nil
        )
        {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updating,
                .versioning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.GuardrailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockClientTypes {
    /// Contains details about a guardrail. This data type is used in the following API operations:
    ///
    /// * [ListGuardrails response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListGuardrails.html#API_ListGuardrails_ResponseSyntax)
    public struct GuardrailSummary {
        /// The ARN of the guardrail.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time at which the guardrail was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A description of the guardrail.
        public var description: Swift.String?
        /// The unique identifier of the guardrail.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the guardrail.
        /// This member is required.
        public var status: BedrockClientTypes.GuardrailStatus?
        /// The date and time at which the guardrail was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The version of the guardrail.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockClientTypes.GuardrailStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension BedrockClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopic(examples: \(Swift.String(describing: examples)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent()
        value.examples = try reader["examples"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Details about topics for the guardrail to identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopic {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailTopicConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicConfig(examples: \(Swift.String(describing: examples)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.GuardrailTopicConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["examples"].writeList(value.examples, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes {
    /// Details about topics for the guardrail to identify and deny. This data type is used in the following API operations:
    ///
    /// * [CreateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateGuardrail.html#API_CreateGuardrail_RequestSyntax)
    ///
    /// * [UpdateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_UpdateGuardrail.html#API_UpdateGuardrail_RequestSyntax)
    public struct GuardrailTopicConfig {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailTopicPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopicPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopicPolicy()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Contains details about topics that the guardrail should identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopicPolicy {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topics: [BedrockClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockClientTypes.GuardrailTopic]? = nil
        )
        {
            self.topics = topics
        }
    }

}

extension BedrockClientTypes.GuardrailTopicPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicsConfig"].writeList(value.topicsConfig, memberWritingClosure: BedrockClientTypes.GuardrailTopicConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes {
    /// Contains details about topics that the guardrail should identify and deny. This data type is used in the following API operations:
    ///
    /// * [CreateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateGuardrail.html#API_CreateGuardrail_RequestSyntax)
    ///
    /// * [UpdateGuardrail request body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_UpdateGuardrail.html#API_UpdateGuardrail_RequestSyntax)
    public struct GuardrailTopicPolicyConfig {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]?

        public init(
            topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]? = nil
        )
        {
            self.topicsConfig = topicsConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailTopicType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.GuardrailWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWord()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// A word configured for the guardrail.
    public struct GuardrailWord {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockClientTypes.GuardrailWordConfig {

    static func write(value: BedrockClientTypes.GuardrailWordConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockClientTypes {
    /// A word to configure for the guardrail.
    public struct GuardrailWordConfig {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockClientTypes.GuardrailWordPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWordPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWordPolicy()
        value.words = try reader["words"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailManagedWords.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Contains details about the word policy configured for the guardrail.
    public struct GuardrailWordPolicy {
        /// A list of managed words configured for the guardrail.
        public var managedWordLists: [BedrockClientTypes.GuardrailManagedWords]?
        /// A list of words configured for the guardrail.
        public var words: [BedrockClientTypes.GuardrailWord]?

        public init(
            managedWordLists: [BedrockClientTypes.GuardrailManagedWords]? = nil,
            words: [BedrockClientTypes.GuardrailWord]? = nil
        )
        {
            self.managedWordLists = managedWordLists
            self.words = words
        }
    }

}

extension BedrockClientTypes.GuardrailWordPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailWordPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managedWordListsConfig"].writeList(value.managedWordListsConfig, memberWritingClosure: BedrockClientTypes.GuardrailManagedWordsConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["wordsConfig"].writeList(value.wordsConfig, memberWritingClosure: BedrockClientTypes.GuardrailWordConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes {
    /// Contains details about the word policy to configured for the guardrail.
    public struct GuardrailWordPolicyConfig {
        /// A list of managed words to configure for the guardrail.
        public var managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]?
        /// A list of words to configure for the guardrail.
        public var wordsConfig: [BedrockClientTypes.GuardrailWordConfig]?

        public init(
            managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]? = nil,
            wordsConfig: [BedrockClientTypes.GuardrailWordConfig]? = nil
        )
        {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }
    }

}

extension BedrockClientTypes.HumanEvaluationConfig {

    static func write(value: BedrockClientTypes.HumanEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetrics"].writeList(value.customMetrics, memberWritingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["humanWorkflowConfig"].write(value.humanWorkflowConfig, with: BedrockClientTypes.HumanWorkflowConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationConfig()
        value.humanWorkflowConfig = try reader["humanWorkflowConfig"].readIfPresent(with: BedrockClientTypes.HumanWorkflowConfig.read(from:))
        value.customMetrics = try reader["customMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Specifies the custom metrics, how tasks will be rated, the flow definition ARN, and your custom prompt datasets. Model evaluation jobs use human workers only support the use of custom prompt datasets. To learn more about custom prompt datasets and the required format, see [Custom prompt datasets](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-prompt-datasets-custom.html). When you create custom metrics in HumanEvaluationCustomMetric you must specify the metric's name. The list of names specified in the HumanEvaluationCustomMetric array, must match the metricNames array of strings specified in EvaluationDatasetMetricConfig. For example, if in the HumanEvaluationCustomMetric array your specified the names "accuracy", "toxicity", "readability" as custom metrics then the metricNames array would need to look like the following ["accuracy", "toxicity", "readability"] in EvaluationDatasetMetricConfig.
    public struct HumanEvaluationConfig {
        /// A HumanEvaluationCustomMetric object. It contains the names the metrics, how the metrics are to be evaluated, an optional description.
        public var customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]?
        /// Use to specify the metrics, task, and prompt dataset to be used in your model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// The parameters of the human workflow.
        public var humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig?

        public init(
            customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]? = nil,
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig? = nil
        )
        {
            self.customMetrics = customMetrics
            self.datasetMetricConfigs = datasetMetricConfigs
            self.humanWorkflowConfig = humanWorkflowConfig
        }
    }

}

extension BedrockClientTypes.HumanEvaluationCustomMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanEvaluationCustomMetric(ratingMethod: \(Swift.String(describing: ratingMethod)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.HumanEvaluationCustomMetric {

    static func write(value: BedrockClientTypes.HumanEvaluationCustomMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["ratingMethod"].write(value.ratingMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationCustomMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationCustomMetric()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ratingMethod = try reader["ratingMethod"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// In a model evaluation job that uses human workers you must define the name of the metric, and how you want that metric rated ratingMethod, and an optional description of the metric.
    public struct HumanEvaluationCustomMetric {
        /// An optional description of the metric. Use this parameter to provide more details about the metric.
        public var description: Swift.String?
        /// The name of the metric. Your human evaluators will see this name in the evaluation UI.
        /// This member is required.
        public var name: Swift.String?
        /// Choose how you want your human workers to evaluation your model. Valid values for rating methods are ThumbsUpDown, IndividualLikertScale,ComparisonLikertScale, ComparisonChoice, and ComparisonRank
        /// This member is required.
        public var ratingMethod: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ratingMethod: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ratingMethod = ratingMethod
        }
    }

}

extension BedrockClientTypes.HumanWorkflowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanWorkflowConfig(flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), instructions: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes.HumanWorkflowConfig {

    static func write(value: BedrockClientTypes.HumanWorkflowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowDefinitionArn"].write(value.flowDefinitionArn)
        try writer["instructions"].write(value.instructions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanWorkflowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanWorkflowConfig()
        value.flowDefinitionArn = try reader["flowDefinitionArn"].readIfPresent()
        value.instructions = try reader["instructions"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Contains SageMakerFlowDefinition object. The object is used to specify the prompt dataset, task type, rating method and metric names.
    public struct HumanWorkflowConfig {
        /// The Amazon Resource Number (ARN) for the flow definition
        /// This member is required.
        public var flowDefinitionArn: Swift.String?
        /// Instructions for the flow definition
        public var instructions: Swift.String?

        public init(
            flowDefinitionArn: Swift.String? = nil,
            instructions: Swift.String? = nil
        )
        {
            self.flowDefinitionArn = flowDefinitionArn
            self.instructions = instructions
        }
    }

}

extension BedrockClientTypes {

    public enum InferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceType] {
            return [
                .onDemand,
                .provisioned,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListCustomModelsInput {

    static func queryItemProvider(_ value: ListCustomModelsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = ClientRuntime.SDKURLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let baseModelArnEquals = value.baseModelArnEquals {
            let baseModelArnEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "baseModelArnEquals".urlPercentEncoding(), value: Swift.String(baseModelArnEquals).urlPercentEncoding())
            items.append(baseModelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let foundationModelArnEquals = value.foundationModelArnEquals {
            let foundationModelArnEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "foundationModelArnEquals".urlPercentEncoding(), value: Swift.String(foundationModelArnEquals).urlPercentEncoding())
            items.append(foundationModelArnEqualsQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListCustomModelsInput {

    static func urlPathProvider(_ value: ListCustomModelsInput) -> Swift.String? {
        return "/custom-models"
    }
}

public struct ListCustomModelsInput {
    /// Return custom models only if the base model Amazon Resource Name (ARN) matches this parameter.
    public var baseModelArnEquals: Swift.String?
    /// Return custom models created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return custom models created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Return custom models only if the foundation model Amazon Resource Name (ARN) matches this parameter.
    public var foundationModelArnEquals: Swift.String?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// Return custom models only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        baseModelArnEquals: Swift.String? = nil,
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        foundationModelArnEquals: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.baseModelArnEquals = baseModelArnEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.foundationModelArnEquals = foundationModelArnEquals
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension ListCustomModelsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCustomModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListCustomModelsOutput {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.CustomModelSummary]?
    /// Continuation token for the next request to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.CustomModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

enum ListCustomModelsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEvaluationJobsInput {

    static func queryItemProvider(_ value: ListEvaluationJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = ClientRuntime.SDKURLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListEvaluationJobsInput {

    static func urlPathProvider(_ value: ListEvaluationJobsInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

public struct ListEvaluationJobsInput {
    /// A filter that includes model evaluation jobs created after the time specified.
    public var creationTimeAfter: ClientRuntime.Date?
    /// A filter that includes model evaluation jobs created prior to the time specified.
    public var creationTimeBefore: ClientRuntime.Date?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Query parameter string for model evaluation job names.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// Allows you to sort model evaluation jobs by when they were created.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// How you want the order of jobs sorted.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Only return jobs where the status condition is met.
    public var statusEquals: BedrockClientTypes.EvaluationJobStatus?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension ListEvaluationJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEvaluationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListEvaluationJobsOutput {
    /// A summary of the model evaluation jobs.
    public var jobSummaries: [BedrockClientTypes.EvaluationSummary]?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [BedrockClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

enum ListEvaluationJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListFoundationModelsInput {

    static func queryItemProvider(_ value: ListFoundationModelsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let byOutputModality = value.byOutputModality {
            let byOutputModalityQueryItem = ClientRuntime.SDKURLQueryItem(name: "byOutputModality".urlPercentEncoding(), value: Swift.String(byOutputModality.rawValue).urlPercentEncoding())
            items.append(byOutputModalityQueryItem)
        }
        if let byCustomizationType = value.byCustomizationType {
            let byCustomizationTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "byCustomizationType".urlPercentEncoding(), value: Swift.String(byCustomizationType.rawValue).urlPercentEncoding())
            items.append(byCustomizationTypeQueryItem)
        }
        if let byProvider = value.byProvider {
            let byProviderQueryItem = ClientRuntime.SDKURLQueryItem(name: "byProvider".urlPercentEncoding(), value: Swift.String(byProvider).urlPercentEncoding())
            items.append(byProviderQueryItem)
        }
        if let byInferenceType = value.byInferenceType {
            let byInferenceTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "byInferenceType".urlPercentEncoding(), value: Swift.String(byInferenceType.rawValue).urlPercentEncoding())
            items.append(byInferenceTypeQueryItem)
        }
        return items
    }
}

extension ListFoundationModelsInput {

    static func urlPathProvider(_ value: ListFoundationModelsInput) -> Swift.String? {
        return "/foundation-models"
    }
}

public struct ListFoundationModelsInput {
    /// Return models that support the customization type that you specify. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html) in the Amazon Bedrock User Guide.
    public var byCustomizationType: BedrockClientTypes.ModelCustomization?
    /// Return models that support the inference type that you specify. For more information, see [Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html) in the Amazon Bedrock User Guide.
    public var byInferenceType: BedrockClientTypes.InferenceType?
    /// Return models that support the output modality that you specify.
    public var byOutputModality: BedrockClientTypes.ModelModality?
    /// Return models belonging to the model provider that you specify.
    public var byProvider: Swift.String?

    public init(
        byCustomizationType: BedrockClientTypes.ModelCustomization? = nil,
        byInferenceType: BedrockClientTypes.InferenceType? = nil,
        byOutputModality: BedrockClientTypes.ModelModality? = nil,
        byProvider: Swift.String? = nil
    )
    {
        self.byCustomizationType = byCustomizationType
        self.byInferenceType = byInferenceType
        self.byOutputModality = byOutputModality
        self.byProvider = byProvider
    }
}

extension ListFoundationModelsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListFoundationModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoundationModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.FoundationModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListFoundationModelsOutput {
    /// A list of Amazon Bedrock foundation models.
    public var modelSummaries: [BedrockClientTypes.FoundationModelSummary]?

    public init(
        modelSummaries: [BedrockClientTypes.FoundationModelSummary]? = nil
    )
    {
        self.modelSummaries = modelSummaries
    }
}

enum ListFoundationModelsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGuardrailsInput {

    static func queryItemProvider(_ value: ListGuardrailsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            let guardrailIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "guardrailIdentifier".urlPercentEncoding(), value: Swift.String(guardrailIdentifier).urlPercentEncoding())
            items.append(guardrailIdentifierQueryItem)
        }
        return items
    }
}

extension ListGuardrailsInput {

    static func urlPathProvider(_ value: ListGuardrailsInput) -> Swift.String? {
        return "/guardrails"
    }
}

public struct ListGuardrailsInput {
    /// The unique identifier of the guardrail.
    public var guardrailIdentifier: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGuardrailsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGuardrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGuardrailsOutput()
        value.guardrails = try reader["guardrails"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListGuardrailsOutput {
    /// A list of objects, each of which contains details about a guardrail.
    /// This member is required.
    public var guardrails: [BedrockClientTypes.GuardrailSummary]?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrails: [BedrockClientTypes.GuardrailSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrails = guardrails
        self.nextToken = nextToken
    }
}

enum ListGuardrailsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListModelCustomizationJobsInput {

    static func queryItemProvider(_ value: ListModelCustomizationJobsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = ClientRuntime.SDKURLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelCustomizationJobsInput {

    static func urlPathProvider(_ value: ListModelCustomizationJobsInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

public struct ListModelCustomizationJobsInput {
    /// Return customization jobs created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return customization jobs created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// Return customization jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return customization jobs with the specified status.
    public var statusEquals: BedrockClientTypes.FineTuningJobStatus?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.FineTuningJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension ListModelCustomizationJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListModelCustomizationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCustomizationJobsOutput()
        value.modelCustomizationJobSummaries = try reader["modelCustomizationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomizationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListModelCustomizationJobsOutput {
    /// Job summaries.
    public var modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
    /// Page continuation token to use in the next request.
    public var nextToken: Swift.String?

    public init(
        modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
        self.nextToken = nextToken
    }
}

enum ListModelCustomizationJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListProvisionedModelThroughputsInput {

    static func queryItemProvider(_ value: ListProvisionedModelThroughputsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = ClientRuntime.SDKURLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let modelArnEquals = value.modelArnEquals {
            let modelArnEqualsQueryItem = ClientRuntime.SDKURLQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
            items.append(modelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = ClientRuntime.SDKURLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.SDKURLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListProvisionedModelThroughputsInput {

    static func urlPathProvider(_ value: ListProvisionedModelThroughputsInput) -> Swift.String? {
        return "/provisioned-model-throughputs"
    }
}

public struct ListProvisionedModelThroughputsInput {
    /// A filter that returns Provisioned Throughputs created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// A filter that returns Provisioned Throughputs created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// THe maximum number of results to return in the response. If there are more results than the number you specified, the response returns a nextToken value. To see the next batch of results, send the nextToken value in another list request.
    public var maxResults: Swift.Int?
    /// A filter that returns Provisioned Throughputs whose model Amazon Resource Name (ARN) is equal to the value that you specify.
    public var modelArnEquals: Swift.String?
    /// A filter that returns Provisioned Throughputs if their name contains the expression that you specify.
    public var nameContains: Swift.String?
    /// If there are more results than the number you specified in the maxResults field, the response returns a nextToken value. To see the next batch of results, specify the nextToken value in this field.
    public var nextToken: Swift.String?
    /// The field by which to sort the returned list of Provisioned Throughputs.
    public var sortBy: BedrockClientTypes.SortByProvisionedModels?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter that returns Provisioned Throughputs if their statuses matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortByProvisionedModels? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension ListProvisionedModelThroughputsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListProvisionedModelThroughputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedModelThroughputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.provisionedModelSummaries = try reader["provisionedModelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ProvisionedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListProvisionedModelThroughputsOutput {
    /// If there are more results than the number you specified in the maxResults field, this value is returned. To see the next batch of results, include this value in the nextToken field in another list request.
    public var nextToken: Swift.String?
    /// A list of summaries, one for each Provisioned Throughput in the response.
    public var provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedModelSummaries = provisionedModelSummaries
    }
}

enum ListProvisionedModelThroughputsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// An array of the tags associated with this resource.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.LoggingConfig {

    static func write(value: BedrockClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchConfig"].write(value.cloudWatchConfig, with: BedrockClientTypes.CloudWatchConfig.write(value:to:))
        try writer["embeddingDataDeliveryEnabled"].write(value.embeddingDataDeliveryEnabled)
        try writer["imageDataDeliveryEnabled"].write(value.imageDataDeliveryEnabled)
        try writer["s3Config"].write(value.s3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["textDataDeliveryEnabled"].write(value.textDataDeliveryEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LoggingConfig()
        value.cloudWatchConfig = try reader["cloudWatchConfig"].readIfPresent(with: BedrockClientTypes.CloudWatchConfig.read(from:))
        value.s3Config = try reader["s3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        value.textDataDeliveryEnabled = try reader["textDataDeliveryEnabled"].readIfPresent()
        value.imageDataDeliveryEnabled = try reader["imageDataDeliveryEnabled"].readIfPresent()
        value.embeddingDataDeliveryEnabled = try reader["embeddingDataDeliveryEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Configuration fields for invocation logging.
    public struct LoggingConfig {
        /// CloudWatch logging configuration.
        public var cloudWatchConfig: BedrockClientTypes.CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public var embeddingDataDeliveryEnabled: Swift.Bool?
        /// Set to include image data in the log delivery.
        public var imageDataDeliveryEnabled: Swift.Bool?
        /// S3 configuration for storing log data.
        public var s3Config: BedrockClientTypes.S3Config?
        /// Set to include text data in the log delivery.
        public var textDataDeliveryEnabled: Swift.Bool?

        public init(
            cloudWatchConfig: BedrockClientTypes.CloudWatchConfig? = nil,
            embeddingDataDeliveryEnabled: Swift.Bool? = nil,
            imageDataDeliveryEnabled: Swift.Bool? = nil,
            s3Config: BedrockClientTypes.S3Config? = nil,
            textDataDeliveryEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
        }
    }

}

extension BedrockClientTypes {

    public enum ModelCustomization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomization] {
            return [
                .continuedPreTraining,
                .fineTuning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum ModelCustomizationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomizationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.ModelCustomizationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCustomizationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCustomizationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: .dateTime)
        value.customModelArn = try reader["customModelArn"].readIfPresent()
        value.customModelName = try reader["customModelName"].readIfPresent()
        value.customizationType = try reader["customizationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Information about one customization job
    public struct ModelCustomizationJobSummary {
        /// Amazon Resource Name (ARN) of the base model.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// Creation time of the custom model.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the custom model.
        public var customModelArn: Swift.String?
        /// Name of the custom model.
        public var customModelName: Swift.String?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// Time that the customization job ended.
        public var endTime: ClientRuntime.Date?
        /// Amazon Resource Name (ARN) of the customization job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// Name of the customization job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Time that the customization job was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Status of the customization job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCustomizationJobStatus?

        public init(
            baseModelArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customModelArn: Swift.String? = nil,
            customModelName: Swift.String? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: BedrockClientTypes.ModelCustomizationJobStatus? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.customizationType = customizationType
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension BedrockClientTypes {

    public enum ModelModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embedding
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelModality] {
            return [
                .embedding,
                .image,
                .text,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embedding: return "EMBEDDING"
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.OutputDataConfig {

    static func write(value: BedrockClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// S3 Location of the output data.
    public struct OutputDataConfig {
        /// The S3 URI where the output data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {

    public enum ProvisionedModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case failed
        case inService
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedModelStatus] {
            return [
                .creating,
                .failed,
                .inService,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .inService: return "InService"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes.ProvisionedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ProvisionedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ProvisionedModelSummary()
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent()
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent()
        value.modelUnits = try reader["modelUnits"].readIfPresent()
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: .dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: .dateTime)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockClientTypes {
    /// A summary of information about a Provisioned Throughput. This data type is used in the following API operations:
    ///
    /// * [ListProvisionedThroughputs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListProvisionedModelThroughputs.html#API_ListProvisionedModelThroughputs_ResponseSyntax)
    public struct ProvisionedModelSummary {
        /// The duration for which the Provisioned Throughput was committed.
        public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
        /// The timestamp for when the commitment term of the Provisioned Throughput expires.
        public var commitmentExpirationTime: ClientRuntime.Date?
        /// The time that the Provisioned Throughput was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        /// This member is required.
        public var desiredModelArn: Swift.String?
        /// The number of model units that was requested to be allocated to the Provisioned Throughput.
        /// This member is required.
        public var desiredModelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        /// This member is required.
        public var foundationModelArn: Swift.String?
        /// The time that the Provisioned Throughput was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the model associated with the Provisioned Throughput.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The number of model units allocated to the Provisioned Throughput.
        /// This member is required.
        public var modelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelArn: Swift.String?
        /// The name of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelName: Swift.String?
        /// The status of the Provisioned Throughput.
        /// This member is required.
        public var status: BedrockClientTypes.ProvisionedModelStatus?

        public init(
            commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
            commitmentExpirationTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            desiredModelArn: Swift.String? = nil,
            desiredModelUnits: Swift.Int? = nil,
            foundationModelArn: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            modelArn: Swift.String? = nil,
            modelUnits: Swift.Int? = nil,
            provisionedModelArn: Swift.String? = nil,
            provisionedModelName: Swift.String? = nil,
            status: BedrockClientTypes.ProvisionedModelStatus? = nil
        )
        {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }
    }

}

extension PutModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func write(value: PutModelInvocationLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfig"].write(value.loggingConfig, with: BedrockClientTypes.LoggingConfig.write(value:to:))
    }
}

public struct PutModelInvocationLoggingConfigurationInput {
    /// The logging configuration values to set.
    /// This member is required.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

extension PutModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutModelInvocationLoggingConfigurationOutput {
        return PutModelInvocationLoggingConfigurationOutput()
    }
}

public struct PutModelInvocationLoggingConfigurationOutput {

    public init() { }
}

enum PutModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes.S3Config {

    static func write(value: BedrockClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keyPrefix"].write(value.keyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3Config()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// S3 configuration for storing log data.
    public struct S3Config {
        /// S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// S3 prefix.
        public var keyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes {

    public enum SortByProvisionedModels: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByProvisionedModels] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortJobsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortJobsBy] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortModelsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortModelsBy] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StopEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension StopEvaluationJobInput {

    static func urlPathProvider(_ value: StopEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

public struct StopEvaluationJobInput {
    /// The ARN of the model evaluation job you want to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension StopEvaluationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopEvaluationJobOutput {
        return StopEvaluationJobOutput()
    }
}

public struct StopEvaluationJobOutput {

    public init() { }
}

enum StopEvaluationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopModelCustomizationJobInput {

    static func urlPathProvider(_ value: StopModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

public struct StopModelCustomizationJobInput {
    /// Job identifier of the job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension StopModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopModelCustomizationJobOutput {
        return StopModelCustomizationJobOutput()
    }
}

public struct StopModelCustomizationJobOutput {

    public init() { }
}

enum StopModelCustomizationJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.Tag {

    static func write(value: BedrockClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Tag()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Definition of the key/value pair for a tag.
    public struct Tag {
        /// Key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tags to associate with the resource.
    /// This member is required.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request contains more tags than can be associated with a resource (50 tags per resource). The maximum number of tags includes both existing tags and those included in your current request.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension BedrockClientTypes.TrainingDataConfig {

    static func write(value: BedrockClientTypes.TrainingDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// S3 Location of the training data.
    public struct TrainingDataConfig {
        /// The S3 URI where the training data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes.TrainingMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingMetrics()
        value.trainingLoss = try reader["trainingLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Metrics associated with the custom job.
    public struct TrainingMetrics {
        /// Loss metric associated with the custom job.
        public var trainingLoss: Swift.Float?

        public init(
            trainingLoss: Swift.Float? = nil
        )
        {
            self.trainingLoss = trainingLoss
        }
    }

}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGuardrailInput(contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateGuardrailInput {

    static func urlPathProvider(_ value: UpdateGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension UpdateGuardrailInput {

    static func write(value: UpdateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

public struct UpdateGuardrailInput {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The unique identifier of the guardrail
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The ARN of the KMS key with which to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// A name for the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The topic policy to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy to configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicyConfig = contentPolicyConfig
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension UpdateGuardrailOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGuardrailOutput()
        value.guardrailArn = try reader["guardrailArn"].readIfPresent()
        value.guardrailId = try reader["guardrailId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

public struct UpdateGuardrailOutput {
    /// The ARN of the guardrail that was created.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.updatedAt = updatedAt
        self.version = version
    }
}

enum UpdateGuardrailOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: UpdateProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func write(value: UpdateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredModelId"].write(value.desiredModelId)
        try writer["desiredProvisionedModelName"].write(value.desiredProvisionedModelName)
    }
}

public struct UpdateProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) of the new model to associate with this Provisioned Throughput. You can't specify this field if this Provisioned Throughput is associated with a base model. If this Provisioned Throughput is associated with a custom model, you can specify one of the following options:
    ///
    /// * The base model from which the custom model was customized.
    ///
    /// * Another custom model that was customized from the same base model as the custom model.
    public var desiredModelId: Swift.String?
    /// The new name for this Provisioned Throughput.
    public var desiredProvisionedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput to update.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        desiredModelId: Swift.String? = nil,
        desiredProvisionedModelName: Swift.String? = nil,
        provisionedModelId: Swift.String? = nil
    )
    {
        self.desiredModelId = desiredModelId
        self.desiredProvisionedModelName = desiredProvisionedModelName
        self.provisionedModelId = provisionedModelId
    }
}

extension UpdateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateProvisionedModelThroughputOutput {
        return UpdateProvisionedModelThroughputOutput()
    }
}

public struct UpdateProvisionedModelThroughputOutput {

    public init() { }
}

enum UpdateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockClientTypes.ValidationDataConfig {

    static func write(value: BedrockClientTypes.ValidationDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["validators"].writeList(value.validators, memberWritingClosure: BedrockClientTypes.Validator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidationDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidationDataConfig()
        value.validators = try reader["validators"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Validator.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// Array of up to 10 validators.
    public struct ValidationDataConfig {
        /// Information about the validators.
        /// This member is required.
        public var validators: [BedrockClientTypes.Validator]?

        public init(
            validators: [BedrockClientTypes.Validator]? = nil
        )
        {
            self.validators = validators
        }
    }

}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes.Validator {

    static func write(value: BedrockClientTypes.Validator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Validator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Validator()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// Information about a validator.
    public struct Validator {
        /// The S3 URI where the validation data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes.ValidatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidatorMetric()
        value.validationLoss = try reader["validationLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes {
    /// The metric for the validator.
    public struct ValidatorMetric {
        /// The validation loss associated with this validator.
        public var validationLoss: Swift.Float?

        public init(
            validationLoss: Swift.Float? = nil
        )
        {
            self.validationLoss = validationLoss
        }
    }

}

extension BedrockClientTypes.VpcConfig {

    static func write(value: BedrockClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes {
    /// VPC configuration.
    public struct VpcConfig {
        /// VPC configuration security group Ids.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// VPC configuration subnets.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
