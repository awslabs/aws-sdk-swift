// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockClientTypes.CloudWatchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case largeDataDeliveryS3Config
        case logGroupName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let largeDataDeliveryS3Config = self.largeDataDeliveryS3Config {
            try encodeContainer.encode(largeDataDeliveryS3Config, forKey: .largeDataDeliveryS3Config)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let largeDataDeliveryS3ConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.S3Config.self, forKey: .largeDataDeliveryS3Config)
        largeDataDeliveryS3Config = largeDataDeliveryS3ConfigDecoded
    }
}

extension BedrockClientTypes {
    /// CloudWatch logging configuration.
    public struct CloudWatchConfig: Swift.Equatable {
        /// S3 configuration for delivering a large amount of data.
        public var largeDataDeliveryS3Config: BedrockClientTypes.S3Config?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The role ARN.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            largeDataDeliveryS3Config: BedrockClientTypes.S3Config? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }

}

extension BedrockClientTypes {
    public enum CommitmentDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneMonth
        case sixMonths
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentDuration] {
            return [
                .oneMonth,
                .sixMonths,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .sixMonths: return "SixMonths"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommitmentDuration(rawValue: rawValue) ?? CommitmentDuration.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Error occurred because of a conflict while performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateModelCustomizationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelIdentifier
        case clientRequestToken
        case customModelKmsKeyId
        case customModelName
        case customModelTags
        case customizationType
        case hyperParameters
        case jobName
        case jobTags
        case outputDataConfig
        case roleArn
        case trainingDataConfig
        case validationDataConfig
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseModelIdentifier = self.baseModelIdentifier {
            try encodeContainer.encode(baseModelIdentifier, forKey: .baseModelIdentifier)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let customModelKmsKeyId = self.customModelKmsKeyId {
            try encodeContainer.encode(customModelKmsKeyId, forKey: .customModelKmsKeyId)
        }
        if let customModelName = self.customModelName {
            try encodeContainer.encode(customModelName, forKey: .customModelName)
        }
        if let customModelTags = customModelTags {
            var customModelTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customModelTags)
            for tag0 in customModelTags {
                try customModelTagsContainer.encode(tag0)
            }
        }
        if let customizationType = self.customizationType {
            try encodeContainer.encode(customizationType.rawValue, forKey: .customizationType)
        }
        if let hyperParameters = hyperParameters {
            var hyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hyperParameters)
            for (dictKey0, modelCustomizationHyperParameters0) in hyperParameters {
                try hyperParametersContainer.encode(modelCustomizationHyperParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobTags)
            for tag0 in jobTags {
                try jobTagsContainer.encode(tag0)
            }
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let trainingDataConfig = self.trainingDataConfig {
            try encodeContainer.encode(trainingDataConfig, forKey: .trainingDataConfig)
        }
        if let validationDataConfig = self.validationDataConfig {
            try encodeContainer.encode(validationDataConfig, forKey: .validationDataConfig)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateModelCustomizationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/model-customization-jobs"
    }
}

public struct CreateModelCustomizationJobInput: Swift.Equatable {
    /// Name of the base model.
    /// This member is required.
    public var baseModelIdentifier: Swift.String?
    /// Unique token value that you can provide. The GetModelCustomizationJob response includes the same token value.
    public var clientRequestToken: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var customModelKmsKeyId: Swift.String?
    /// Enter a name for the custom model.
    /// This member is required.
    public var customModelName: Swift.String?
    /// Assign tags to the custom model.
    public var customModelTags: [BedrockClientTypes.Tag]?
    /// The customization type.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Parameters related to tuning the model.
    /// This member is required.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// Enter a unique name for the fine-tuning job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Assign tags to the job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// S3 location for the output data.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// VPC configuration (optional). Configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for this job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelIdentifier: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        customModelKmsKeyId: Swift.String? = nil,
        customModelName: Swift.String? = nil,
        customModelTags: [BedrockClientTypes.Tag]? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelIdentifier = baseModelIdentifier
        self.clientRequestToken = clientRequestToken
        self.customModelKmsKeyId = customModelKmsKeyId
        self.customModelName = customModelName
        self.customModelTags = customModelTags
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.trainingDataConfig = trainingDataConfig
        self.validationDataConfig = validationDataConfig
        self.vpcConfig = vpcConfig
    }
}

struct CreateModelCustomizationJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let customModelName: Swift.String?
    let roleArn: Swift.String?
    let clientRequestToken: Swift.String?
    let baseModelIdentifier: Swift.String?
    let customizationType: BedrockClientTypes.CustomizationType?
    let customModelKmsKeyId: Swift.String?
    let jobTags: [BedrockClientTypes.Tag]?
    let customModelTags: [BedrockClientTypes.Tag]?
    let trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    let validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    let outputDataConfig: BedrockClientTypes.OutputDataConfig?
    let hyperParameters: [Swift.String:Swift.String]?
    let vpcConfig: BedrockClientTypes.VpcConfig?
}

extension CreateModelCustomizationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelIdentifier
        case clientRequestToken
        case customModelKmsKeyId
        case customModelName
        case customModelTags
        case customizationType
        case hyperParameters
        case jobName
        case jobTags
        case outputDataConfig
        case roleArn
        case trainingDataConfig
        case validationDataConfig
        case vpcConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let customModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customModelName)
        customModelName = customModelNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let baseModelIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelIdentifier)
        baseModelIdentifier = baseModelIdentifierDecoded
        let customizationTypeDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CustomizationType.self, forKey: .customizationType)
        customizationType = customizationTypeDecoded
        let customModelKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customModelKmsKeyId)
        customModelKmsKeyId = customModelKmsKeyIdDecoded
        let jobTagsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Tag?].self, forKey: .jobTags)
        var jobTagsDecoded0:[BedrockClientTypes.Tag]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [BedrockClientTypes.Tag]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
        let customModelTagsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Tag?].self, forKey: .customModelTags)
        var customModelTagsDecoded0:[BedrockClientTypes.Tag]? = nil
        if let customModelTagsContainer = customModelTagsContainer {
            customModelTagsDecoded0 = [BedrockClientTypes.Tag]()
            for structure0 in customModelTagsContainer {
                if let structure0 = structure0 {
                    customModelTagsDecoded0?.append(structure0)
                }
            }
        }
        customModelTags = customModelTagsDecoded0
        let trainingDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.TrainingDataConfig.self, forKey: .trainingDataConfig)
        trainingDataConfig = trainingDataConfigDecoded
        let validationDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ValidationDataConfig.self, forKey: .validationDataConfig)
        validationDataConfig = validationDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension CreateModelCustomizationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateModelCustomizationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobArn = output.jobArn
        } else {
            self.jobArn = nil
        }
    }
}

public struct CreateModelCustomizationJobOutput: Swift.Equatable {
    /// ARN of the fine tuning job
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

struct CreateModelCustomizationJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
}

extension CreateModelCustomizationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
    }
}

enum CreateModelCustomizationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProvisionedModelThroughputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case commitmentDuration
        case modelId
        case modelUnits
        case provisionedModelName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let commitmentDuration = self.commitmentDuration {
            try encodeContainer.encode(commitmentDuration.rawValue, forKey: .commitmentDuration)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelUnits = self.modelUnits {
            try encodeContainer.encode(modelUnits, forKey: .modelUnits)
        }
        if let provisionedModelName = self.provisionedModelName {
            try encodeContainer.encode(provisionedModelName, forKey: .provisionedModelName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProvisionedModelThroughputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/provisioned-model-throughput"
    }
}

public struct CreateProvisionedModelThroughputInput: Swift.Equatable {
    /// Unique token value that you can provide. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientRequestToken: Swift.String?
    /// Commitment duration requested for the provisioned throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// Name or ARN of the model to associate with this provisioned throughput.
    /// This member is required.
    public var modelId: Swift.String?
    /// Number of model units to allocate.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// Unique name for this provisioned throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Tags to associate with this provisioned throughput.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        modelId: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.commitmentDuration = commitmentDuration
        self.modelId = modelId
        self.modelUnits = modelUnits
        self.provisionedModelName = provisionedModelName
        self.tags = tags
    }
}

struct CreateProvisionedModelThroughputInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let modelUnits: Swift.Int?
    let provisionedModelName: Swift.String?
    let modelId: Swift.String?
    let commitmentDuration: BedrockClientTypes.CommitmentDuration?
    let tags: [BedrockClientTypes.Tag]?
}

extension CreateProvisionedModelThroughputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case commitmentDuration
        case modelId
        case modelUnits
        case provisionedModelName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let modelUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modelUnits)
        modelUnits = modelUnitsDecoded
        let provisionedModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelName)
        provisionedModelName = provisionedModelNameDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let commitmentDurationDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CommitmentDuration.self, forKey: .commitmentDuration)
        commitmentDuration = commitmentDurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BedrockClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BedrockClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProvisionedModelThroughputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProvisionedModelThroughputOutputBody = try responseDecoder.decode(responseBody: data)
            self.provisionedModelArn = output.provisionedModelArn
        } else {
            self.provisionedModelArn = nil
        }
    }
}

public struct CreateProvisionedModelThroughputOutput: Swift.Equatable {
    /// The ARN for this provisioned throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?

    public init(
        provisionedModelArn: Swift.String? = nil
    )
    {
        self.provisionedModelArn = provisionedModelArn
    }
}

struct CreateProvisionedModelThroughputOutputBody: Swift.Equatable {
    let provisionedModelArn: Swift.String?
}

extension CreateProvisionedModelThroughputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedModelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelArn)
        provisionedModelArn = provisionedModelArnDecoded
    }
}

enum CreateProvisionedModelThroughputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes.CustomModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelArn
        case baseModelName
        case creationTime
        case customizationType
        case modelArn
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseModelArn = self.baseModelArn {
            try encodeContainer.encode(baseModelArn, forKey: .baseModelArn)
        }
        if let baseModelName = self.baseModelName {
            try encodeContainer.encode(baseModelName, forKey: .baseModelName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let customizationType = self.customizationType {
            try encodeContainer.encode(customizationType.rawValue, forKey: .customizationType)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let baseModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelArn)
        baseModelArn = baseModelArnDecoded
        let baseModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelName)
        baseModelName = baseModelNameDecoded
        let customizationTypeDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CustomizationType.self, forKey: .customizationType)
        customizationType = customizationTypeDecoded
    }
}

extension BedrockClientTypes {
    /// Summary information for a custom model.
    public struct CustomModelSummary: Swift.Equatable {
        /// The base model ARN.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// The base model name.
        /// This member is required.
        public var baseModelName: Swift.String?
        /// Creation time of the model.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// The ARN of the custom model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The name of the custom model.
        /// This member is required.
        public var modelName: Swift.String?

        public init(
            baseModelArn: Swift.String? = nil,
            baseModelName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
        }
    }

}

extension BedrockClientTypes {
    public enum CustomizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomizationType] {
            return [
                .continuedPreTraining,
                .fineTuning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomizationType(rawValue: rawValue) ?? CustomizationType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteCustomModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let modelIdentifier = modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteCustomModelInput: Swift.Equatable {
    /// Name of the model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

struct DeleteCustomModelInputBody: Swift.Equatable {
}

extension DeleteCustomModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelInvocationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging/modelinvocations"
    }
}

public struct DeleteModelInvocationLoggingConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DeleteModelInvocationLoggingConfigurationInputBody: Swift.Equatable {
}

extension DeleteModelInvocationLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelInvocationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteModelInvocationLoggingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteModelInvocationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProvisionedModelThroughputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provisionedModelId = provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

public struct DeleteProvisionedModelThroughputInput: Swift.Equatable {
    /// The ARN or name of the provisioned throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

struct DeleteProvisionedModelThroughputInputBody: Swift.Equatable {
}

extension DeleteProvisionedModelThroughputInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProvisionedModelThroughputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProvisionedModelThroughputOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProvisionedModelThroughputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes {
    public enum FineTuningJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FineTuningJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FineTuningJobStatus(rawValue: rawValue) ?? FineTuningJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes.FoundationModelDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customizationsSupported
        case inferenceTypesSupported
        case inputModalities
        case modelArn
        case modelId
        case modelLifecycle
        case modelName
        case outputModalities
        case providerName
        case responseStreamingSupported
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customizationsSupported = customizationsSupported {
            var customizationsSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customizationsSupported)
            for modelcustomization0 in customizationsSupported {
                try customizationsSupportedContainer.encode(modelcustomization0.rawValue)
            }
        }
        if let inferenceTypesSupported = inferenceTypesSupported {
            var inferenceTypesSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceTypesSupported)
            for inferencetype0 in inferenceTypesSupported {
                try inferenceTypesSupportedContainer.encode(inferencetype0.rawValue)
            }
        }
        if let inputModalities = inputModalities {
            var inputModalitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputModalities)
            for modelmodality0 in inputModalities {
                try inputModalitiesContainer.encode(modelmodality0.rawValue)
            }
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelLifecycle = self.modelLifecycle {
            try encodeContainer.encode(modelLifecycle, forKey: .modelLifecycle)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let outputModalities = outputModalities {
            var outputModalitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputModalities)
            for modelmodality0 in outputModalities {
                try outputModalitiesContainer.encode(modelmodality0.rawValue)
            }
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let responseStreamingSupported = self.responseStreamingSupported {
            try encodeContainer.encode(responseStreamingSupported, forKey: .responseStreamingSupported)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let inputModalitiesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelModality?].self, forKey: .inputModalities)
        var inputModalitiesDecoded0:[BedrockClientTypes.ModelModality]? = nil
        if let inputModalitiesContainer = inputModalitiesContainer {
            inputModalitiesDecoded0 = [BedrockClientTypes.ModelModality]()
            for enum0 in inputModalitiesContainer {
                if let enum0 = enum0 {
                    inputModalitiesDecoded0?.append(enum0)
                }
            }
        }
        inputModalities = inputModalitiesDecoded0
        let outputModalitiesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelModality?].self, forKey: .outputModalities)
        var outputModalitiesDecoded0:[BedrockClientTypes.ModelModality]? = nil
        if let outputModalitiesContainer = outputModalitiesContainer {
            outputModalitiesDecoded0 = [BedrockClientTypes.ModelModality]()
            for enum0 in outputModalitiesContainer {
                if let enum0 = enum0 {
                    outputModalitiesDecoded0?.append(enum0)
                }
            }
        }
        outputModalities = outputModalitiesDecoded0
        let responseStreamingSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .responseStreamingSupported)
        responseStreamingSupported = responseStreamingSupportedDecoded
        let customizationsSupportedContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelCustomization?].self, forKey: .customizationsSupported)
        var customizationsSupportedDecoded0:[BedrockClientTypes.ModelCustomization]? = nil
        if let customizationsSupportedContainer = customizationsSupportedContainer {
            customizationsSupportedDecoded0 = [BedrockClientTypes.ModelCustomization]()
            for enum0 in customizationsSupportedContainer {
                if let enum0 = enum0 {
                    customizationsSupportedDecoded0?.append(enum0)
                }
            }
        }
        customizationsSupported = customizationsSupportedDecoded0
        let inferenceTypesSupportedContainer = try containerValues.decodeIfPresent([BedrockClientTypes.InferenceType?].self, forKey: .inferenceTypesSupported)
        var inferenceTypesSupportedDecoded0:[BedrockClientTypes.InferenceType]? = nil
        if let inferenceTypesSupportedContainer = inferenceTypesSupportedContainer {
            inferenceTypesSupportedDecoded0 = [BedrockClientTypes.InferenceType]()
            for enum0 in inferenceTypesSupportedContainer {
                if let enum0 = enum0 {
                    inferenceTypesSupportedDecoded0?.append(enum0)
                }
            }
        }
        inferenceTypesSupported = inferenceTypesSupportedDecoded0
        let modelLifecycleDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.FoundationModelLifecycle.self, forKey: .modelLifecycle)
        modelLifecycle = modelLifecycleDecoded
    }
}

extension BedrockClientTypes {
    /// Information about a foundation model.
    public struct FoundationModelDetails: Swift.Equatable {
        /// The customization that the model supports.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The model ARN.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model identifier.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The model name.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// he model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

extension BedrockClientTypes.FoundationModelLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.FoundationModelLifecycleStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension BedrockClientTypes {
    /// Details about whether a model version is available or deprecated.
    public struct FoundationModelLifecycle: Swift.Equatable {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        /// This member is required.
        public var status: BedrockClientTypes.FoundationModelLifecycleStatus?

        public init(
            status: BedrockClientTypes.FoundationModelLifecycleStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension BedrockClientTypes {
    public enum FoundationModelLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case legacy
        case sdkUnknown(Swift.String)

        public static var allCases: [FoundationModelLifecycleStatus] {
            return [
                .active,
                .legacy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .legacy: return "LEGACY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FoundationModelLifecycleStatus(rawValue: rawValue) ?? FoundationModelLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes.FoundationModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customizationsSupported
        case inferenceTypesSupported
        case inputModalities
        case modelArn
        case modelId
        case modelLifecycle
        case modelName
        case outputModalities
        case providerName
        case responseStreamingSupported
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customizationsSupported = customizationsSupported {
            var customizationsSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customizationsSupported)
            for modelcustomization0 in customizationsSupported {
                try customizationsSupportedContainer.encode(modelcustomization0.rawValue)
            }
        }
        if let inferenceTypesSupported = inferenceTypesSupported {
            var inferenceTypesSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceTypesSupported)
            for inferencetype0 in inferenceTypesSupported {
                try inferenceTypesSupportedContainer.encode(inferencetype0.rawValue)
            }
        }
        if let inputModalities = inputModalities {
            var inputModalitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputModalities)
            for modelmodality0 in inputModalities {
                try inputModalitiesContainer.encode(modelmodality0.rawValue)
            }
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelLifecycle = self.modelLifecycle {
            try encodeContainer.encode(modelLifecycle, forKey: .modelLifecycle)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let outputModalities = outputModalities {
            var outputModalitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputModalities)
            for modelmodality0 in outputModalities {
                try outputModalitiesContainer.encode(modelmodality0.rawValue)
            }
        }
        if let providerName = self.providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let responseStreamingSupported = self.responseStreamingSupported {
            try encodeContainer.encode(responseStreamingSupported, forKey: .responseStreamingSupported)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let inputModalitiesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelModality?].self, forKey: .inputModalities)
        var inputModalitiesDecoded0:[BedrockClientTypes.ModelModality]? = nil
        if let inputModalitiesContainer = inputModalitiesContainer {
            inputModalitiesDecoded0 = [BedrockClientTypes.ModelModality]()
            for enum0 in inputModalitiesContainer {
                if let enum0 = enum0 {
                    inputModalitiesDecoded0?.append(enum0)
                }
            }
        }
        inputModalities = inputModalitiesDecoded0
        let outputModalitiesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelModality?].self, forKey: .outputModalities)
        var outputModalitiesDecoded0:[BedrockClientTypes.ModelModality]? = nil
        if let outputModalitiesContainer = outputModalitiesContainer {
            outputModalitiesDecoded0 = [BedrockClientTypes.ModelModality]()
            for enum0 in outputModalitiesContainer {
                if let enum0 = enum0 {
                    outputModalitiesDecoded0?.append(enum0)
                }
            }
        }
        outputModalities = outputModalitiesDecoded0
        let responseStreamingSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .responseStreamingSupported)
        responseStreamingSupported = responseStreamingSupportedDecoded
        let customizationsSupportedContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelCustomization?].self, forKey: .customizationsSupported)
        var customizationsSupportedDecoded0:[BedrockClientTypes.ModelCustomization]? = nil
        if let customizationsSupportedContainer = customizationsSupportedContainer {
            customizationsSupportedDecoded0 = [BedrockClientTypes.ModelCustomization]()
            for enum0 in customizationsSupportedContainer {
                if let enum0 = enum0 {
                    customizationsSupportedDecoded0?.append(enum0)
                }
            }
        }
        customizationsSupported = customizationsSupportedDecoded0
        let inferenceTypesSupportedContainer = try containerValues.decodeIfPresent([BedrockClientTypes.InferenceType?].self, forKey: .inferenceTypesSupported)
        var inferenceTypesSupportedDecoded0:[BedrockClientTypes.InferenceType]? = nil
        if let inferenceTypesSupportedContainer = inferenceTypesSupportedContainer {
            inferenceTypesSupportedDecoded0 = [BedrockClientTypes.InferenceType]()
            for enum0 in inferenceTypesSupportedContainer {
                if let enum0 = enum0 {
                    inferenceTypesSupportedDecoded0?.append(enum0)
                }
            }
        }
        inferenceTypesSupported = inferenceTypesSupportedDecoded0
        let modelLifecycleDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.FoundationModelLifecycle.self, forKey: .modelLifecycle)
        modelLifecycle = modelLifecycleDecoded
    }
}

extension BedrockClientTypes {
    /// Summary information for a foundation model.
    public struct FoundationModelSummary: Swift.Equatable {
        /// Whether the model supports fine-tuning or continual pre-training.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The ARN of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model Id of the foundation model.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated.
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

extension GetCustomModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let modelIdentifier = modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct GetCustomModelInput: Swift.Equatable {
    /// Name or ARN of the custom model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

struct GetCustomModelInputBody: Swift.Equatable {
}

extension GetCustomModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCustomModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCustomModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseModelArn = output.baseModelArn
            self.creationTime = output.creationTime
            self.customizationType = output.customizationType
            self.hyperParameters = output.hyperParameters
            self.jobArn = output.jobArn
            self.jobName = output.jobName
            self.modelArn = output.modelArn
            self.modelKmsKeyArn = output.modelKmsKeyArn
            self.modelName = output.modelName
            self.outputDataConfig = output.outputDataConfig
            self.trainingDataConfig = output.trainingDataConfig
            self.trainingMetrics = output.trainingMetrics
            self.validationDataConfig = output.validationDataConfig
            self.validationMetrics = output.validationMetrics
        } else {
            self.baseModelArn = nil
            self.creationTime = nil
            self.customizationType = nil
            self.hyperParameters = nil
            self.jobArn = nil
            self.jobName = nil
            self.modelArn = nil
            self.modelKmsKeyArn = nil
            self.modelName = nil
            self.outputDataConfig = nil
            self.trainingDataConfig = nil
            self.trainingMetrics = nil
            self.validationDataConfig = nil
            self.validationMetrics = nil
        }
    }
}

public struct GetCustomModelOutput: Swift.Equatable {
    /// ARN of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// Creation time of the model.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Hyperparameter values associated with this model.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// Job ARN associated with this model.
    /// This member is required.
    public var jobArn: Swift.String?
    /// Job name associated with this model.
    public var jobName: Swift.String?
    /// ARN associated with this model.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// Model name associated with this model.
    /// This member is required.
    public var modelName: Swift.String?
    /// Output data configuration associated with this custom model.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// The training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Array of up to 10 validators.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The validation metrics from the job creation.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?

    public init(
        baseModelArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArn = modelArn
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.outputDataConfig = outputDataConfig
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
    }
}

struct GetCustomModelOutputBody: Swift.Equatable {
    let modelArn: Swift.String?
    let modelName: Swift.String?
    let jobName: Swift.String?
    let jobArn: Swift.String?
    let baseModelArn: Swift.String?
    let customizationType: BedrockClientTypes.CustomizationType?
    let modelKmsKeyArn: Swift.String?
    let hyperParameters: [Swift.String:Swift.String]?
    let trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    let validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    let outputDataConfig: BedrockClientTypes.OutputDataConfig?
    let trainingMetrics: BedrockClientTypes.TrainingMetrics?
    let validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    let creationTime: ClientRuntime.Date?
}

extension GetCustomModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelArn
        case creationTime
        case customizationType
        case hyperParameters
        case jobArn
        case jobName
        case modelArn
        case modelKmsKeyArn
        case modelName
        case outputDataConfig
        case trainingDataConfig
        case trainingMetrics
        case validationDataConfig
        case validationMetrics
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let baseModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelArn)
        baseModelArn = baseModelArnDecoded
        let customizationTypeDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CustomizationType.self, forKey: .customizationType)
        customizationType = customizationTypeDecoded
        let modelKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelKmsKeyArn)
        modelKmsKeyArn = modelKmsKeyArnDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let trainingDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.TrainingDataConfig.self, forKey: .trainingDataConfig)
        trainingDataConfig = trainingDataConfigDecoded
        let validationDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ValidationDataConfig.self, forKey: .validationDataConfig)
        validationDataConfig = validationDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let trainingMetricsDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.TrainingMetrics.self, forKey: .trainingMetrics)
        trainingMetrics = trainingMetricsDecoded
        let validationMetricsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ValidatorMetric?].self, forKey: .validationMetrics)
        var validationMetricsDecoded0:[BedrockClientTypes.ValidatorMetric]? = nil
        if let validationMetricsContainer = validationMetricsContainer {
            validationMetricsDecoded0 = [BedrockClientTypes.ValidatorMetric]()
            for structure0 in validationMetricsContainer {
                if let structure0 = structure0 {
                    validationMetricsDecoded0?.append(structure0)
                }
            }
        }
        validationMetrics = validationMetricsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

enum GetCustomModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFoundationModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let modelIdentifier = modelIdentifier else {
            return nil
        }
        return "/foundation-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

public struct GetFoundationModelInput: Swift.Equatable {
    /// The model identifier.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

struct GetFoundationModelInputBody: Swift.Equatable {
}

extension GetFoundationModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFoundationModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFoundationModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelDetails = output.modelDetails
        } else {
            self.modelDetails = nil
        }
    }
}

public struct GetFoundationModelOutput: Swift.Equatable {
    /// Information about the foundation model.
    public var modelDetails: BedrockClientTypes.FoundationModelDetails?

    public init(
        modelDetails: BedrockClientTypes.FoundationModelDetails? = nil
    )
    {
        self.modelDetails = modelDetails
    }
}

struct GetFoundationModelOutputBody: Swift.Equatable {
    let modelDetails: BedrockClientTypes.FoundationModelDetails?
}

extension GetFoundationModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDetailsDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.FoundationModelDetails.self, forKey: .modelDetails)
        modelDetails = modelDetailsDecoded
    }
}

enum GetFoundationModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelCustomizationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobIdentifier = jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

public struct GetModelCustomizationJobInput: Swift.Equatable {
    /// Identifier for the customization job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

struct GetModelCustomizationJobInputBody: Swift.Equatable {
}

extension GetModelCustomizationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelCustomizationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelCustomizationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseModelArn = output.baseModelArn
            self.clientRequestToken = output.clientRequestToken
            self.creationTime = output.creationTime
            self.customizationType = output.customizationType
            self.endTime = output.endTime
            self.failureMessage = output.failureMessage
            self.hyperParameters = output.hyperParameters
            self.jobArn = output.jobArn
            self.jobName = output.jobName
            self.lastModifiedTime = output.lastModifiedTime
            self.outputDataConfig = output.outputDataConfig
            self.outputModelArn = output.outputModelArn
            self.outputModelKmsKeyArn = output.outputModelKmsKeyArn
            self.outputModelName = output.outputModelName
            self.roleArn = output.roleArn
            self.status = output.status
            self.trainingDataConfig = output.trainingDataConfig
            self.trainingMetrics = output.trainingMetrics
            self.validationDataConfig = output.validationDataConfig
            self.validationMetrics = output.validationMetrics
            self.vpcConfig = output.vpcConfig
        } else {
            self.baseModelArn = nil
            self.clientRequestToken = nil
            self.creationTime = nil
            self.customizationType = nil
            self.endTime = nil
            self.failureMessage = nil
            self.hyperParameters = nil
            self.jobArn = nil
            self.jobName = nil
            self.lastModifiedTime = nil
            self.outputDataConfig = nil
            self.outputModelArn = nil
            self.outputModelKmsKeyArn = nil
            self.outputModelName = nil
            self.roleArn = nil
            self.status = nil
            self.trainingDataConfig = nil
            self.trainingMetrics = nil
            self.validationDataConfig = nil
            self.validationMetrics = nil
            self.vpcConfig = nil
        }
    }
}

public struct GetModelCustomizationJobOutput: Swift.Equatable {
    /// ARN of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// The token that you specified in the CreateCustomizationJob request.
    public var clientRequestToken: Swift.String?
    /// Time that the resource was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Time that the resource transitioned to terminal state.
    public var endTime: ClientRuntime.Date?
    /// Information about why the job failed.
    public var failureMessage: Swift.String?
    /// The hyperparameter values for the job. For information about hyperparameters for specific models, see [Guidelines for model customization](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-guidelines.html).
    /// This member is required.
    public var hyperParameters: [Swift.String:Swift.String]?
    /// The ARN of the customization job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the customization job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Time that the resource was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// Output data configuration
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The ARN of the output model.
    public var outputModelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var outputModelKmsKeyArn: Swift.String?
    /// The name of the output model.
    /// This member is required.
    public var outputModelName: Swift.String?
    /// The ARN of the IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelCustomizationJobStatus?
    /// S3 Location of the training data.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Metrics associated with the custom job.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Array of up to 10 validators.
    /// This member is required.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The loss metric for each validator that you provided in the createjob request.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    /// VPC configuration for the custom model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        endTime: ClientRuntime.Date? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String:Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        outputModelArn: Swift.String? = nil,
        outputModelKmsKeyArn: Swift.String? = nil,
        outputModelName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.clientRequestToken = clientRequestToken
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.outputModelArn = outputModelArn
        self.outputModelKmsKeyArn = outputModelKmsKeyArn
        self.outputModelName = outputModelName
        self.roleArn = roleArn
        self.status = status
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
        self.vpcConfig = vpcConfig
    }
}

struct GetModelCustomizationJobOutputBody: Swift.Equatable {
    let jobArn: Swift.String?
    let jobName: Swift.String?
    let outputModelName: Swift.String?
    let outputModelArn: Swift.String?
    let clientRequestToken: Swift.String?
    let roleArn: Swift.String?
    let status: BedrockClientTypes.ModelCustomizationJobStatus?
    let failureMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let baseModelArn: Swift.String?
    let hyperParameters: [Swift.String:Swift.String]?
    let trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    let validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    let outputDataConfig: BedrockClientTypes.OutputDataConfig?
    let customizationType: BedrockClientTypes.CustomizationType?
    let outputModelKmsKeyArn: Swift.String?
    let trainingMetrics: BedrockClientTypes.TrainingMetrics?
    let validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    let vpcConfig: BedrockClientTypes.VpcConfig?
}

extension GetModelCustomizationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelArn
        case clientRequestToken
        case creationTime
        case customizationType
        case endTime
        case failureMessage
        case hyperParameters
        case jobArn
        case jobName
        case lastModifiedTime
        case outputDataConfig
        case outputModelArn
        case outputModelKmsKeyArn
        case outputModelName
        case roleArn
        case status
        case trainingDataConfig
        case trainingMetrics
        case validationDataConfig
        case validationMetrics
        case vpcConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputModelName)
        outputModelName = outputModelNameDecoded
        let outputModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputModelArn)
        outputModelArn = outputModelArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ModelCustomizationJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let baseModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelArn)
        baseModelArn = baseModelArnDecoded
        let hyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hyperParameters)
        var hyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let hyperParametersContainer = hyperParametersContainer {
            hyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in hyperParametersContainer {
                if let string0 = string0 {
                    hyperParametersDecoded0?[key0] = string0
                }
            }
        }
        hyperParameters = hyperParametersDecoded0
        let trainingDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.TrainingDataConfig.self, forKey: .trainingDataConfig)
        trainingDataConfig = trainingDataConfigDecoded
        let validationDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ValidationDataConfig.self, forKey: .validationDataConfig)
        validationDataConfig = validationDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let customizationTypeDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CustomizationType.self, forKey: .customizationType)
        customizationType = customizationTypeDecoded
        let outputModelKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputModelKmsKeyArn)
        outputModelKmsKeyArn = outputModelKmsKeyArnDecoded
        let trainingMetricsDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.TrainingMetrics.self, forKey: .trainingMetrics)
        trainingMetrics = trainingMetricsDecoded
        let validationMetricsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ValidatorMetric?].self, forKey: .validationMetrics)
        var validationMetricsDecoded0:[BedrockClientTypes.ValidatorMetric]? = nil
        if let validationMetricsContainer = validationMetricsContainer {
            validationMetricsDecoded0 = [BedrockClientTypes.ValidatorMetric]()
            for structure0 in validationMetricsContainer {
                if let structure0 = structure0 {
                    validationMetricsDecoded0?.append(structure0)
                }
            }
        }
        validationMetrics = validationMetricsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

enum GetModelCustomizationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelInvocationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging/modelinvocations"
    }
}

public struct GetModelInvocationLoggingConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetModelInvocationLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetModelInvocationLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelInvocationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelInvocationLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfig = output.loggingConfig
        } else {
            self.loggingConfig = nil
        }
    }
}

public struct GetModelInvocationLoggingConfigurationOutput: Swift.Equatable {
    /// The current configuration values.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

struct GetModelInvocationLoggingConfigurationOutputBody: Swift.Equatable {
    let loggingConfig: BedrockClientTypes.LoggingConfig?
}

extension GetModelInvocationLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
    }
}

enum GetModelInvocationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProvisionedModelThroughputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provisionedModelId = provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

public struct GetProvisionedModelThroughputInput: Swift.Equatable {
    /// The ARN or name of the provisioned throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

struct GetProvisionedModelThroughputInputBody: Swift.Equatable {
}

extension GetProvisionedModelThroughputInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProvisionedModelThroughputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProvisionedModelThroughputOutputBody = try responseDecoder.decode(responseBody: data)
            self.commitmentDuration = output.commitmentDuration
            self.commitmentExpirationTime = output.commitmentExpirationTime
            self.creationTime = output.creationTime
            self.desiredModelArn = output.desiredModelArn
            self.desiredModelUnits = output.desiredModelUnits
            self.failureMessage = output.failureMessage
            self.foundationModelArn = output.foundationModelArn
            self.lastModifiedTime = output.lastModifiedTime
            self.modelArn = output.modelArn
            self.modelUnits = output.modelUnits
            self.provisionedModelArn = output.provisionedModelArn
            self.provisionedModelName = output.provisionedModelName
            self.status = output.status
        } else {
            self.commitmentDuration = nil
            self.commitmentExpirationTime = nil
            self.creationTime = nil
            self.desiredModelArn = nil
            self.desiredModelUnits = nil
            self.failureMessage = nil
            self.foundationModelArn = nil
            self.lastModifiedTime = nil
            self.modelArn = nil
            self.modelUnits = nil
            self.provisionedModelArn = nil
            self.provisionedModelName = nil
            self.status = nil
        }
    }
}

public struct GetProvisionedModelThroughputOutput: Swift.Equatable {
    /// Commitment duration of the provisioned throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// Commitment expiration time for the provisioned throughput.
    public var commitmentExpirationTime: ClientRuntime.Date?
    /// The timestamp of the creation time for this provisioned throughput.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The ARN of the new model to asssociate with this provisioned throughput.
    /// This member is required.
    public var desiredModelArn: Swift.String?
    /// The desired number of model units that was requested to be available for this provisioned throughput.
    /// This member is required.
    public var desiredModelUnits: Swift.Int?
    /// Failure message for any issues that the create operation encounters.
    public var failureMessage: Swift.String?
    /// ARN of the foundation model.
    /// This member is required.
    public var foundationModelArn: Swift.String?
    /// The timestamp of the last modified time of this provisioned throughput.
    /// This member is required.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The ARN or name of the model associated with this provisioned throughput.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The current number of model units requested to be available for this provisioned throughput.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The ARN of the provisioned throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?
    /// The name of the provisioned throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Status of the provisioned throughput.
    /// This member is required.
    public var status: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        commitmentExpirationTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        desiredModelArn: Swift.String? = nil,
        desiredModelUnits: Swift.Int? = nil,
        failureMessage: Swift.String? = nil,
        foundationModelArn: Swift.String? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        modelArn: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelArn: Swift.String? = nil,
        provisionedModelName: Swift.String? = nil,
        status: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.commitmentDuration = commitmentDuration
        self.commitmentExpirationTime = commitmentExpirationTime
        self.creationTime = creationTime
        self.desiredModelArn = desiredModelArn
        self.desiredModelUnits = desiredModelUnits
        self.failureMessage = failureMessage
        self.foundationModelArn = foundationModelArn
        self.lastModifiedTime = lastModifiedTime
        self.modelArn = modelArn
        self.modelUnits = modelUnits
        self.provisionedModelArn = provisionedModelArn
        self.provisionedModelName = provisionedModelName
        self.status = status
    }
}

struct GetProvisionedModelThroughputOutputBody: Swift.Equatable {
    let modelUnits: Swift.Int?
    let desiredModelUnits: Swift.Int?
    let provisionedModelName: Swift.String?
    let provisionedModelArn: Swift.String?
    let modelArn: Swift.String?
    let desiredModelArn: Swift.String?
    let foundationModelArn: Swift.String?
    let status: BedrockClientTypes.ProvisionedModelStatus?
    let creationTime: ClientRuntime.Date?
    let lastModifiedTime: ClientRuntime.Date?
    let failureMessage: Swift.String?
    let commitmentDuration: BedrockClientTypes.CommitmentDuration?
    let commitmentExpirationTime: ClientRuntime.Date?
}

extension GetProvisionedModelThroughputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentDuration
        case commitmentExpirationTime
        case creationTime
        case desiredModelArn
        case desiredModelUnits
        case failureMessage
        case foundationModelArn
        case lastModifiedTime
        case modelArn
        case modelUnits
        case provisionedModelArn
        case provisionedModelName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modelUnits)
        modelUnits = modelUnitsDecoded
        let desiredModelUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredModelUnits)
        desiredModelUnits = desiredModelUnitsDecoded
        let provisionedModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelName)
        provisionedModelName = provisionedModelNameDecoded
        let provisionedModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelArn)
        provisionedModelArn = provisionedModelArnDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let desiredModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredModelArn)
        desiredModelArn = desiredModelArnDecoded
        let foundationModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModelArn)
        foundationModelArn = foundationModelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ProvisionedModelStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let commitmentDurationDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CommitmentDuration.self, forKey: .commitmentDuration)
        commitmentDuration = commitmentDurationDecoded
        let commitmentExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .commitmentExpirationTime)
        commitmentExpirationTime = commitmentExpirationTimeDecoded
    }
}

enum GetProvisionedModelThroughputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes {
    public enum InferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case onDemand
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceType] {
            return [
                .onDemand,
                .provisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InferenceType(rawValue: rawValue) ?? InferenceType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCustomModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nameContains = nameContains {
                let nameContainsQueryItem = ClientRuntime.URLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
                items.append(nameContainsQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let creationTimeAfter = creationTimeAfter {
                let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
                items.append(creationTimeAfterQueryItem)
            }
            if let baseModelArnEquals = baseModelArnEquals {
                let baseModelArnEqualsQueryItem = ClientRuntime.URLQueryItem(name: "baseModelArnEquals".urlPercentEncoding(), value: Swift.String(baseModelArnEquals).urlPercentEncoding())
                items.append(baseModelArnEqualsQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let foundationModelArnEquals = foundationModelArnEquals {
                let foundationModelArnEqualsQueryItem = ClientRuntime.URLQueryItem(name: "foundationModelArnEquals".urlPercentEncoding(), value: Swift.String(foundationModelArnEquals).urlPercentEncoding())
                items.append(foundationModelArnEqualsQueryItem)
            }
            if let creationTimeBefore = creationTimeBefore {
                let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
                items.append(creationTimeBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListCustomModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/custom-models"
    }
}

public struct ListCustomModelsInput: Swift.Equatable {
    /// Return custom models only if the base model ARN matches this parameter.
    public var baseModelArnEquals: Swift.String?
    /// Return custom models created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return custom models created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Return custom models only if the foundation model ARN matches this parameter.
    public var foundationModelArnEquals: Swift.String?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// Return custom models only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        baseModelArnEquals: Swift.String? = nil,
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        foundationModelArnEquals: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.baseModelArnEquals = baseModelArnEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.foundationModelArnEquals = foundationModelArnEquals
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListCustomModelsInputBody: Swift.Equatable {
}

extension ListCustomModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCustomModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelSummaries = output.modelSummaries
            self.nextToken = output.nextToken
        } else {
            self.modelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomModelsOutput: Swift.Equatable {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.CustomModelSummary]?
    /// Continuation token for the next request to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.CustomModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

struct ListCustomModelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let modelSummaries: [BedrockClientTypes.CustomModelSummary]?
}

extension ListCustomModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelSummariesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.CustomModelSummary?].self, forKey: .modelSummaries)
        var modelSummariesDecoded0:[BedrockClientTypes.CustomModelSummary]? = nil
        if let modelSummariesContainer = modelSummariesContainer {
            modelSummariesDecoded0 = [BedrockClientTypes.CustomModelSummary]()
            for structure0 in modelSummariesContainer {
                if let structure0 = structure0 {
                    modelSummariesDecoded0?.append(structure0)
                }
            }
        }
        modelSummaries = modelSummariesDecoded0
    }
}

enum ListCustomModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFoundationModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let byOutputModality = byOutputModality {
                let byOutputModalityQueryItem = ClientRuntime.URLQueryItem(name: "byOutputModality".urlPercentEncoding(), value: Swift.String(byOutputModality.rawValue).urlPercentEncoding())
                items.append(byOutputModalityQueryItem)
            }
            if let byCustomizationType = byCustomizationType {
                let byCustomizationTypeQueryItem = ClientRuntime.URLQueryItem(name: "byCustomizationType".urlPercentEncoding(), value: Swift.String(byCustomizationType.rawValue).urlPercentEncoding())
                items.append(byCustomizationTypeQueryItem)
            }
            if let byProvider = byProvider {
                let byProviderQueryItem = ClientRuntime.URLQueryItem(name: "byProvider".urlPercentEncoding(), value: Swift.String(byProvider).urlPercentEncoding())
                items.append(byProviderQueryItem)
            }
            if let byInferenceType = byInferenceType {
                let byInferenceTypeQueryItem = ClientRuntime.URLQueryItem(name: "byInferenceType".urlPercentEncoding(), value: Swift.String(byInferenceType.rawValue).urlPercentEncoding())
                items.append(byInferenceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListFoundationModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/foundation-models"
    }
}

public struct ListFoundationModelsInput: Swift.Equatable {
    /// List by customization type.
    public var byCustomizationType: BedrockClientTypes.ModelCustomization?
    /// List by inference type.
    public var byInferenceType: BedrockClientTypes.InferenceType?
    /// List by output modality type.
    public var byOutputModality: BedrockClientTypes.ModelModality?
    /// A Amazon Bedrock model provider.
    public var byProvider: Swift.String?

    public init(
        byCustomizationType: BedrockClientTypes.ModelCustomization? = nil,
        byInferenceType: BedrockClientTypes.InferenceType? = nil,
        byOutputModality: BedrockClientTypes.ModelModality? = nil,
        byProvider: Swift.String? = nil
    )
    {
        self.byCustomizationType = byCustomizationType
        self.byInferenceType = byInferenceType
        self.byOutputModality = byOutputModality
        self.byProvider = byProvider
    }
}

struct ListFoundationModelsInputBody: Swift.Equatable {
}

extension ListFoundationModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFoundationModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFoundationModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelSummaries = output.modelSummaries
        } else {
            self.modelSummaries = nil
        }
    }
}

public struct ListFoundationModelsOutput: Swift.Equatable {
    /// A list of Amazon Bedrock foundation models.
    public var modelSummaries: [BedrockClientTypes.FoundationModelSummary]?

    public init(
        modelSummaries: [BedrockClientTypes.FoundationModelSummary]? = nil
    )
    {
        self.modelSummaries = modelSummaries
    }
}

struct ListFoundationModelsOutputBody: Swift.Equatable {
    let modelSummaries: [BedrockClientTypes.FoundationModelSummary]?
}

extension ListFoundationModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSummariesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.FoundationModelSummary?].self, forKey: .modelSummaries)
        var modelSummariesDecoded0:[BedrockClientTypes.FoundationModelSummary]? = nil
        if let modelSummariesContainer = modelSummariesContainer {
            modelSummariesDecoded0 = [BedrockClientTypes.FoundationModelSummary]()
            for structure0 in modelSummariesContainer {
                if let structure0 = structure0 {
                    modelSummariesDecoded0?.append(structure0)
                }
            }
        }
        modelSummaries = modelSummariesDecoded0
    }
}

enum ListFoundationModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListModelCustomizationJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nameContains = nameContains {
                let nameContainsQueryItem = ClientRuntime.URLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
                items.append(nameContainsQueryItem)
            }
            if let statusEquals = statusEquals {
                let statusEqualsQueryItem = ClientRuntime.URLQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
                items.append(statusEqualsQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let creationTimeAfter = creationTimeAfter {
                let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
                items.append(creationTimeAfterQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let creationTimeBefore = creationTimeBefore {
                let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
                items.append(creationTimeBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListModelCustomizationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/model-customization-jobs"
    }
}

public struct ListModelCustomizationJobsInput: Swift.Equatable {
    /// Return customization jobs created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return customization jobs created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// Maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// Return customization jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return customization jobs with the specified status.
    public var statusEquals: BedrockClientTypes.FineTuningJobStatus?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.FineTuningJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListModelCustomizationJobsInputBody: Swift.Equatable {
}

extension ListModelCustomizationJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListModelCustomizationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListModelCustomizationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelCustomizationJobSummaries = output.modelCustomizationJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.modelCustomizationJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelCustomizationJobsOutput: Swift.Equatable {
    /// Job summaries.
    public var modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
    /// Page continuation token to use in the next request.
    public var nextToken: Swift.String?

    public init(
        modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
        self.nextToken = nextToken
    }
}

struct ListModelCustomizationJobsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
}

extension ListModelCustomizationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelCustomizationJobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelCustomizationJobSummariesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ModelCustomizationJobSummary?].self, forKey: .modelCustomizationJobSummaries)
        var modelCustomizationJobSummariesDecoded0:[BedrockClientTypes.ModelCustomizationJobSummary]? = nil
        if let modelCustomizationJobSummariesContainer = modelCustomizationJobSummariesContainer {
            modelCustomizationJobSummariesDecoded0 = [BedrockClientTypes.ModelCustomizationJobSummary]()
            for structure0 in modelCustomizationJobSummariesContainer {
                if let structure0 = structure0 {
                    modelCustomizationJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        modelCustomizationJobSummaries = modelCustomizationJobSummariesDecoded0
    }
}

enum ListModelCustomizationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProvisionedModelThroughputsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nameContains = nameContains {
                let nameContainsQueryItem = ClientRuntime.URLQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
                items.append(nameContainsQueryItem)
            }
            if let statusEquals = statusEquals {
                let statusEqualsQueryItem = ClientRuntime.URLQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
                items.append(statusEqualsQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let creationTimeAfter = creationTimeAfter {
                let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
                items.append(creationTimeAfterQueryItem)
            }
            if let modelArnEquals = modelArnEquals {
                let modelArnEqualsQueryItem = ClientRuntime.URLQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
                items.append(modelArnEqualsQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if let creationTimeBefore = creationTimeBefore {
                let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
                items.append(creationTimeBeforeQueryItem)
            }
            return items
        }
    }
}

extension ListProvisionedModelThroughputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/provisioned-model-throughputs"
    }
}

public struct ListProvisionedModelThroughputsInput: Swift.Equatable {
    /// Return provisioned capacities created after the specified time.
    public var creationTimeAfter: ClientRuntime.Date?
    /// Return provisioned capacities created before the specified time.
    public var creationTimeBefore: ClientRuntime.Date?
    /// THe maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// Return the list of provisioned capacities where their model ARN is equal to this parameter.
    public var modelArnEquals: Swift.String?
    /// Return the list of provisioned capacities if their name contains these characters.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of provisioned capacities.
    public var sortBy: BedrockClientTypes.SortByProvisionedModels?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return the list of provisioned capacities that match the specified status.
    public var statusEquals: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortByProvisionedModels? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

struct ListProvisionedModelThroughputsInputBody: Swift.Equatable {
}

extension ListProvisionedModelThroughputsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProvisionedModelThroughputsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProvisionedModelThroughputsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.provisionedModelSummaries = output.provisionedModelSummaries
        } else {
            self.nextToken = nil
            self.provisionedModelSummaries = nil
        }
    }
}

public struct ListProvisionedModelThroughputsOutput: Swift.Equatable {
    /// Continuation token for the next request to list the next set of results.
    public var nextToken: Swift.String?
    /// List of summaries, one for each provisioned throughput in the response.
    public var provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedModelSummaries = provisionedModelSummaries
    }
}

struct ListProvisionedModelThroughputsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?
}

extension ListProvisionedModelThroughputsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case provisionedModelSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let provisionedModelSummariesContainer = try containerValues.decodeIfPresent([BedrockClientTypes.ProvisionedModelSummary?].self, forKey: .provisionedModelSummaries)
        var provisionedModelSummariesDecoded0:[BedrockClientTypes.ProvisionedModelSummary]? = nil
        if let provisionedModelSummariesContainer = provisionedModelSummariesContainer {
            provisionedModelSummariesDecoded0 = [BedrockClientTypes.ProvisionedModelSummary]()
            for structure0 in provisionedModelSummariesContainer {
                if let structure0 = structure0 {
                    provisionedModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        provisionedModelSummaries = provisionedModelSummariesDecoded0
    }
}

enum ListProvisionedModelThroughputsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An array of the tags associated with this resource.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [BedrockClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BedrockClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BedrockClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes.LoggingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchConfig
        case embeddingDataDeliveryEnabled
        case imageDataDeliveryEnabled
        case s3Config
        case textDataDeliveryEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchConfig = self.cloudWatchConfig {
            try encodeContainer.encode(cloudWatchConfig, forKey: .cloudWatchConfig)
        }
        if let embeddingDataDeliveryEnabled = self.embeddingDataDeliveryEnabled {
            try encodeContainer.encode(embeddingDataDeliveryEnabled, forKey: .embeddingDataDeliveryEnabled)
        }
        if let imageDataDeliveryEnabled = self.imageDataDeliveryEnabled {
            try encodeContainer.encode(imageDataDeliveryEnabled, forKey: .imageDataDeliveryEnabled)
        }
        if let s3Config = self.s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
        if let textDataDeliveryEnabled = self.textDataDeliveryEnabled {
            try encodeContainer.encode(textDataDeliveryEnabled, forKey: .textDataDeliveryEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CloudWatchConfig.self, forKey: .cloudWatchConfig)
        cloudWatchConfig = cloudWatchConfigDecoded
        let s3ConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
        let textDataDeliveryEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .textDataDeliveryEnabled)
        textDataDeliveryEnabled = textDataDeliveryEnabledDecoded
        let imageDataDeliveryEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageDataDeliveryEnabled)
        imageDataDeliveryEnabled = imageDataDeliveryEnabledDecoded
        let embeddingDataDeliveryEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .embeddingDataDeliveryEnabled)
        embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabledDecoded
    }
}

extension BedrockClientTypes {
    /// Configuration fields for invokation logging.
    public struct LoggingConfig: Swift.Equatable {
        /// CloudWatch logging configuration.
        public var cloudWatchConfig: BedrockClientTypes.CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public var embeddingDataDeliveryEnabled: Swift.Bool?
        /// Set to include image data in the log delivery.
        public var imageDataDeliveryEnabled: Swift.Bool?
        /// S3 configuration for storing log data.
        public var s3Config: BedrockClientTypes.S3Config?
        /// Set to include text data in the log delivery.
        public var textDataDeliveryEnabled: Swift.Bool?

        public init(
            cloudWatchConfig: BedrockClientTypes.CloudWatchConfig? = nil,
            embeddingDataDeliveryEnabled: Swift.Bool? = nil,
            imageDataDeliveryEnabled: Swift.Bool? = nil,
            s3Config: BedrockClientTypes.S3Config? = nil,
            textDataDeliveryEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
        }
    }

}

extension BedrockClientTypes {
    public enum ModelCustomization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomization] {
            return [
                .continuedPreTraining,
                .fineTuning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelCustomization(rawValue: rawValue) ?? ModelCustomization.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes {
    public enum ModelCustomizationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomizationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelCustomizationJobStatus(rawValue: rawValue) ?? ModelCustomizationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes.ModelCustomizationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseModelArn
        case creationTime
        case customModelArn
        case customModelName
        case customizationType
        case endTime
        case jobArn
        case jobName
        case lastModifiedTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseModelArn = self.baseModelArn {
            try encodeContainer.encode(baseModelArn, forKey: .baseModelArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let customModelArn = self.customModelArn {
            try encodeContainer.encode(customModelArn, forKey: .customModelArn)
        }
        if let customModelName = self.customModelName {
            try encodeContainer.encode(customModelName, forKey: .customModelName)
        }
        if let customizationType = self.customizationType {
            try encodeContainer.encode(customizationType.rawValue, forKey: .customizationType)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: .lastModifiedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let baseModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseModelArn)
        baseModelArn = baseModelArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ModelCustomizationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let customModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customModelArn)
        customModelArn = customModelArnDecoded
        let customModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customModelName)
        customModelName = customModelNameDecoded
        let customizationTypeDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CustomizationType.self, forKey: .customizationType)
        customizationType = customizationTypeDecoded
    }
}

extension BedrockClientTypes {
    /// Information about one customization job
    public struct ModelCustomizationJobSummary: Swift.Equatable {
        /// ARN of the base model.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// Creation time of the custom model.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// ARN of the custom model.
        public var customModelArn: Swift.String?
        /// Name of the custom model.
        public var customModelName: Swift.String?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// Time that the customization job ended.
        public var endTime: ClientRuntime.Date?
        /// ARN of the customization job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// Name of the customization job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Time that the customization job was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// Status of the customization job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCustomizationJobStatus?

        public init(
            baseModelArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            customModelArn: Swift.String? = nil,
            customModelName: Swift.String? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: BedrockClientTypes.ModelCustomizationJobStatus? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.customizationType = customizationType
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension BedrockClientTypes {
    public enum ModelModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case embedding
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelModality] {
            return [
                .embedding,
                .image,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .embedding: return "EMBEDDING"
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelModality(rawValue: rawValue) ?? ModelModality.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BedrockClientTypes {
    /// S3 Location of the output data.
    public struct OutputDataConfig: Swift.Equatable {
        /// The S3 URI where the output data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    public enum ProvisionedModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case failed
        case inService
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedModelStatus] {
            return [
                .creating,
                .failed,
                .inService,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .inService: return "InService"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedModelStatus(rawValue: rawValue) ?? ProvisionedModelStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes.ProvisionedModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitmentDuration
        case commitmentExpirationTime
        case creationTime
        case desiredModelArn
        case desiredModelUnits
        case foundationModelArn
        case lastModifiedTime
        case modelArn
        case modelUnits
        case provisionedModelArn
        case provisionedModelName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitmentDuration = self.commitmentDuration {
            try encodeContainer.encode(commitmentDuration.rawValue, forKey: .commitmentDuration)
        }
        if let commitmentExpirationTime = self.commitmentExpirationTime {
            try encodeContainer.encodeTimestamp(commitmentExpirationTime, format: .dateTime, forKey: .commitmentExpirationTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let desiredModelArn = self.desiredModelArn {
            try encodeContainer.encode(desiredModelArn, forKey: .desiredModelArn)
        }
        if let desiredModelUnits = self.desiredModelUnits {
            try encodeContainer.encode(desiredModelUnits, forKey: .desiredModelUnits)
        }
        if let foundationModelArn = self.foundationModelArn {
            try encodeContainer.encode(foundationModelArn, forKey: .foundationModelArn)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .dateTime, forKey: .lastModifiedTime)
        }
        if let modelArn = self.modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelUnits = self.modelUnits {
            try encodeContainer.encode(modelUnits, forKey: .modelUnits)
        }
        if let provisionedModelArn = self.provisionedModelArn {
            try encodeContainer.encode(provisionedModelArn, forKey: .provisionedModelArn)
        }
        if let provisionedModelName = self.provisionedModelName {
            try encodeContainer.encode(provisionedModelName, forKey: .provisionedModelName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelName)
        provisionedModelName = provisionedModelNameDecoded
        let provisionedModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedModelArn)
        provisionedModelArn = provisionedModelArnDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let desiredModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredModelArn)
        desiredModelArn = desiredModelArnDecoded
        let foundationModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModelArn)
        foundationModelArn = foundationModelArnDecoded
        let modelUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modelUnits)
        modelUnits = modelUnitsDecoded
        let desiredModelUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredModelUnits)
        desiredModelUnits = desiredModelUnitsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.ProvisionedModelStatus.self, forKey: .status)
        status = statusDecoded
        let commitmentDurationDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.CommitmentDuration.self, forKey: .commitmentDuration)
        commitmentDuration = commitmentDurationDecoded
        let commitmentExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .commitmentExpirationTime)
        commitmentExpirationTime = commitmentExpirationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension BedrockClientTypes {
    /// Set of fields associated with a provisioned throughput.
    public struct ProvisionedModelSummary: Swift.Equatable {
        /// Commitment duration for the provisioned throughput.
        public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
        /// Commitment expiration time for the provisioned throughput.
        public var commitmentExpirationTime: ClientRuntime.Date?
        /// The time that this provisioned throughput was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Desired model ARN.
        /// This member is required.
        public var desiredModelArn: Swift.String?
        /// Desired model units.
        /// This member is required.
        public var desiredModelUnits: Swift.Int?
        /// Foundation model ARN.
        /// This member is required.
        public var foundationModelArn: Swift.String?
        /// The time that this provisioned throughput was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The ARN of the model associated with this provisioned throughput.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The number of model units allocated.
        /// This member is required.
        public var modelUnits: Swift.Int?
        /// The ARN of the provisioned throughput.
        /// This member is required.
        public var provisionedModelArn: Swift.String?
        /// The name of the provisioned throughput.
        /// This member is required.
        public var provisionedModelName: Swift.String?
        /// Status of the provisioned throughput.
        /// This member is required.
        public var status: BedrockClientTypes.ProvisionedModelStatus?

        public init(
            commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
            commitmentExpirationTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            desiredModelArn: Swift.String? = nil,
            desiredModelUnits: Swift.Int? = nil,
            foundationModelArn: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            modelArn: Swift.String? = nil,
            modelUnits: Swift.Int? = nil,
            provisionedModelArn: Swift.String? = nil,
            provisionedModelName: Swift.String? = nil,
            status: BedrockClientTypes.ProvisionedModelStatus? = nil
        )
        {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }
    }

}

extension PutModelInvocationLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
    }
}

extension PutModelInvocationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging/modelinvocations"
    }
}

public struct PutModelInvocationLoggingConfigurationInput: Swift.Equatable {
    /// The logging configuration values to set.
    /// This member is required.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

struct PutModelInvocationLoggingConfigurationInputBody: Swift.Equatable {
    let loggingConfig: BedrockClientTypes.LoggingConfig?
}

extension PutModelInvocationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigDecoded = try containerValues.decodeIfPresent(BedrockClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
    }
}

extension PutModelInvocationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutModelInvocationLoggingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutModelInvocationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource ARN was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case keyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let keyPrefix = self.keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension BedrockClientTypes {
    /// S3 configuration for storing log data.
    public struct S3Config: Swift.Equatable {
        /// S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// S3 prefix.
        public var keyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockClientTypes {
    public enum SortByProvisionedModels: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByProvisionedModels] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortByProvisionedModels(rawValue: rawValue) ?? SortByProvisionedModels.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes {
    public enum SortJobsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortJobsBy] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortJobsBy(rawValue: rawValue) ?? SortJobsBy.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes {
    public enum SortModelsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortModelsBy] {
            return [
                .creationTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortModelsBy(rawValue: rawValue) ?? SortModelsBy.sdkUnknown(rawValue)
        }
    }
}

extension BedrockClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StopModelCustomizationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobIdentifier = jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

public struct StopModelCustomizationJobInput: Swift.Equatable {
    /// Job identifier of the job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

struct StopModelCustomizationJobInputBody: Swift.Equatable {
}

extension StopModelCustomizationJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopModelCustomizationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopModelCustomizationJobOutput: Swift.Equatable {

    public init() { }
}

enum StopModelCustomizationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension BedrockClientTypes {
    /// Definition of the key/value pair for a tag.
    public struct Tag: Swift.Equatable {
        /// Key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tags to associate with the resource.
    /// This member is required.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [BedrockClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[BedrockClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [BedrockClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request contains more tags than can be associated with a resource (50 tags per resource). The maximum number of tags includes both existing tags and those included in your current request.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension BedrockClientTypes.TrainingDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BedrockClientTypes {
    /// S3 Location of the training data.
    public struct TrainingDataConfig: Swift.Equatable {
        /// The S3 URI where the training data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes.TrainingMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trainingLoss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trainingLoss = self.trainingLoss {
            try encodeContainer.encode(trainingLoss, forKey: .trainingLoss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trainingLossDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .trainingLoss)
        trainingLoss = trainingLossDecoded
    }
}

extension BedrockClientTypes {
    /// Metrics associated with the custom job.
    public struct TrainingMetrics: Swift.Equatable {
        /// Loss metric associated with the custom job.
        public var trainingLoss: Swift.Float?

        public init(
            trainingLoss: Swift.Float? = nil
        )
        {
            self.trainingLoss = trainingLoss
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProvisionedModelThroughputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredModelId
        case desiredProvisionedModelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredModelId = self.desiredModelId {
            try encodeContainer.encode(desiredModelId, forKey: .desiredModelId)
        }
        if let desiredProvisionedModelName = self.desiredProvisionedModelName {
            try encodeContainer.encode(desiredProvisionedModelName, forKey: .desiredProvisionedModelName)
        }
    }
}

extension UpdateProvisionedModelThroughputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provisionedModelId = provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

public struct UpdateProvisionedModelThroughputInput: Swift.Equatable {
    /// The ARN of the new model to associate with this provisioned throughput.
    public var desiredModelId: Swift.String?
    /// The new name for this provisioned throughput.
    public var desiredProvisionedModelName: Swift.String?
    /// The ARN or name of the provisioned throughput to update.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        desiredModelId: Swift.String? = nil,
        desiredProvisionedModelName: Swift.String? = nil,
        provisionedModelId: Swift.String? = nil
    )
    {
        self.desiredModelId = desiredModelId
        self.desiredProvisionedModelName = desiredProvisionedModelName
        self.provisionedModelId = provisionedModelId
    }
}

struct UpdateProvisionedModelThroughputInputBody: Swift.Equatable {
    let desiredProvisionedModelName: Swift.String?
    let desiredModelId: Swift.String?
}

extension UpdateProvisionedModelThroughputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredModelId
        case desiredProvisionedModelName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredProvisionedModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredProvisionedModelName)
        desiredProvisionedModelName = desiredProvisionedModelNameDecoded
        let desiredModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredModelId)
        desiredModelId = desiredModelIdDecoded
    }
}

extension UpdateProvisionedModelThroughputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProvisionedModelThroughputOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProvisionedModelThroughputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockClientTypes.ValidationDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validators
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validator0 in validators {
                try validatorsContainer.encode(validator0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validatorsContainer = try containerValues.decodeIfPresent([BedrockClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[BedrockClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [BedrockClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension BedrockClientTypes {
    /// Array of up to 10 validators.
    public struct ValidationDataConfig: Swift.Equatable {
        /// Information about the validators.
        /// This member is required.
        public var validators: [BedrockClientTypes.Validator]?

        public init(
            validators: [BedrockClientTypes.Validator]? = nil
        )
        {
            self.validators = validators
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockClientTypes.Validator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension BedrockClientTypes {
    /// Information about a validator.
    public struct Validator: Swift.Equatable {
        /// The S3 URI where the validation data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes.ValidatorMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validationLoss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let validationLoss = self.validationLoss {
            try encodeContainer.encode(validationLoss, forKey: .validationLoss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationLossDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .validationLoss)
        validationLoss = validationLossDecoded
    }
}

extension BedrockClientTypes {
    /// The metric for the validator.
    public struct ValidatorMetric: Swift.Equatable {
        /// The validation loss associated with this validator.
        public var validationLoss: Swift.Float?

        public init(
            validationLoss: Swift.Float? = nil
        )
        {
            self.validationLoss = validationLoss
        }
    }

}

extension BedrockClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetid0 in subnetIds {
                try subnetIdsContainer.encode(subnetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension BedrockClientTypes {
    /// VPC configuration.
    public struct VpcConfig: Swift.Equatable {
        /// VPC configuration security group Ids.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// VPC configuration subnets.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
