//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem

/// You do not have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An unexpected server-side error occurred during request processing.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The operation timed out.
public struct OperationTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource was not found. You can only access or modify a resource that already exists.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied because too many requests were made in a short period, exceeding the service rate limits. Amazon Managed Workflows for Apache Airflow Serverless implements throttling controls to ensure fair resource allocation across all customers in the multi-tenant environment. This helps maintain service stability and performance. If you encounter throttling, implement exponential backoff and retry logic in your applications, or consider distributing your API calls over a longer time period.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension MWAAServerlessClientTypes {

    /// Contains information about a field that failed validation, including the field name and a descriptive error message.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message that describes why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension MWAAServerlessClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified request parameters are invalid, missing, or inconsistent with Amazon Managed Workflows for Apache Airflow Serverless service requirements. This can occur when workflow definitions contain unsupported operators, when required IAM permissions are missing, when S3 locations are inaccessible, or when network configurations are invalid. The service validates workflow definitions, execution roles, and resource configurations to ensure compatibility with the managed Airflow environment and security requirements.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The fields that failed validation.
        public internal(set) var fieldList: [MWAAServerlessClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: MWAAServerlessClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [MWAAServerlessClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MWAAServerlessClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of tags that are associated with the resource, where each tag consists of a key-value pair.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of tags to add to the resource. Each tag consists of a key-value pair.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct GetTaskInstanceInput: Swift.Sendable {
    /// The unique identifier of the workflow run that contains the task instance.
    /// This member is required.
    public var runId: Swift.String?
    /// The unique identifier of the task instance to retrieve.
    /// This member is required.
    public var taskInstanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow that contains the task instance.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        runId: Swift.String? = nil,
        taskInstanceId: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.runId = runId
        self.taskInstanceId = taskInstanceId
        self.workflowArn = workflowArn
    }
}

extension MWAAServerlessClientTypes {

    public enum TaskInstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case deferred
        case failed
        case `none`
        case queued
        case removed
        case restarting
        case running
        case scheduled
        case success
        case timeout
        case upstreamFailed
        case upForReschedule
        case upForRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskInstanceStatus] {
            return [
                .cancelled,
                .deferred,
                .failed,
                .none,
                .queued,
                .removed,
                .restarting,
                .running,
                .scheduled,
                .success,
                .timeout,
                .upstreamFailed,
                .upForReschedule,
                .upForRetry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .deferred: return "DEFERRED"
            case .failed: return "FAILED"
            case .none: return "NONE"
            case .queued: return "QUEUED"
            case .removed: return "REMOVED"
            case .restarting: return "RESTARTING"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .success: return "SUCCESS"
            case .timeout: return "TIMEOUT"
            case .upstreamFailed: return "UPSTREAM_FAILED"
            case .upForReschedule: return "UP_FOR_RESCHEDULE"
            case .upForRetry: return "UP_FOR_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTaskInstanceOutput: Swift.Sendable {
    /// The attempt number for this task instance.
    public var attemptNumber: Swift.Int?
    /// The duration of the task instance execution in seconds. This value is null if the task is not complete.
    public var durationInSeconds: Swift.Int?
    /// The timestamp when the task instance completed execution, in ISO 8601 date-time format. This value is null if the task is not complete.
    public var endedAt: Foundation.Date?
    /// The error message if the task instance failed. This value is null if the task completed successfully.
    public var errorMessage: Swift.String?
    /// The CloudWatch log stream name for this task instance execution.
    public var logStream: Swift.String?
    /// The timestamp when the task instance was last modified, in ISO 8601 date-time format.
    public var modifiedAt: Foundation.Date?
    /// The name of the Apache Airflow operator used for this task instance.
    public var operatorName: Swift.String?
    /// The unique identifier of the workflow run that contains this task instance.
    /// This member is required.
    public var runId: Swift.String?
    /// The timestamp when the task instance started execution, in ISO 8601 date-time format. This value is null if the task has not started.
    public var startedAt: Foundation.Date?
    /// The current status of the task instance.
    public var status: MWAAServerlessClientTypes.TaskInstanceStatus?
    /// The unique identifier of the task definition within the workflow.
    public var taskId: Swift.String?
    /// The unique identifier of this task instance.
    /// This member is required.
    public var taskInstanceId: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow that contains this task instance.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The version of the workflow that contains this task instance.
    public var workflowVersion: Swift.String?
    /// Cross-communication data exchanged between tasks in the workflow execution.
    public var xcom: [Swift.String: Swift.String]?

    public init(
        attemptNumber: Swift.Int? = nil,
        durationInSeconds: Swift.Int? = nil,
        endedAt: Foundation.Date? = nil,
        errorMessage: Swift.String? = nil,
        logStream: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        operatorName: Swift.String? = nil,
        runId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: MWAAServerlessClientTypes.TaskInstanceStatus? = nil,
        taskId: Swift.String? = nil,
        taskInstanceId: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil,
        xcom: [Swift.String: Swift.String]? = nil
    ) {
        self.attemptNumber = attemptNumber
        self.durationInSeconds = durationInSeconds
        self.endedAt = endedAt
        self.errorMessage = errorMessage
        self.logStream = logStream
        self.modifiedAt = modifiedAt
        self.operatorName = operatorName
        self.runId = runId
        self.startedAt = startedAt
        self.status = status
        self.taskId = taskId
        self.taskInstanceId = taskInstanceId
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
        self.xcom = xcom
    }
}

public struct ListTaskInstancesInput: Swift.Sendable {
    /// The maximum number of task instances to return in a single response.
    public var maxResults: Swift.Int?
    /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListTaskInstances.
    public var nextToken: Swift.String?
    /// The unique identifier of the workflow run for which you want a list of task instances.
    /// This member is required.
    public var runId: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow that contains the run.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        runId: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.runId = runId
        self.workflowArn = workflowArn
    }
}

extension MWAAServerlessClientTypes {

    /// Summary information about a task instance within a workflow run, including its status and execution details.
    public struct TaskInstanceSummary: Swift.Sendable {
        /// The duration of the task instance execution in seconds. This value is null if the task is not complete.
        public var durationInSeconds: Swift.Int?
        /// The name of the Apache Airflow operator used for this task instance.
        public var operatorName: Swift.String?
        /// The unique identifier of the workflow run that contains this task instance.
        public var runId: Swift.String?
        /// The current status of the task instance.
        public var status: MWAAServerlessClientTypes.TaskInstanceStatus?
        /// The unique identifier of this task instance.
        public var taskInstanceId: Swift.String?
        /// The Amazon Resource Name (ARN) of the workflow that contains this task instance.
        public var workflowArn: Swift.String?
        /// The version of the workflow that contains this task instance.
        public var workflowVersion: Swift.String?

        public init(
            durationInSeconds: Swift.Int? = nil,
            operatorName: Swift.String? = nil,
            runId: Swift.String? = nil,
            status: MWAAServerlessClientTypes.TaskInstanceStatus? = nil,
            taskInstanceId: Swift.String? = nil,
            workflowArn: Swift.String? = nil,
            workflowVersion: Swift.String? = nil
        ) {
            self.durationInSeconds = durationInSeconds
            self.operatorName = operatorName
            self.runId = runId
            self.status = status
            self.taskInstanceId = taskInstanceId
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }
    }
}

public struct ListTaskInstancesOutput: Swift.Sendable {
    /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of task instance summaries for the specified workflow run.
    public var taskInstances: [MWAAServerlessClientTypes.TaskInstanceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        taskInstances: [MWAAServerlessClientTypes.TaskInstanceSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.taskInstances = taskInstances
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource. Only the keys are required; the values are ignored.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// You cannot create a resource that already exists, or the resource is in a state that prevents the requested operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request exceeds the service quota for Amazon Managed Workflows for Apache Airflow Serverless resources. This can occur when you attempt to create more workflows than allowed, exceed concurrent workflow run limits, or surpass task execution limits. Amazon Managed Workflows for Apache Airflow Serverless implements admission control using DynamoDB-based counters to manage resource utilization across the multi-tenant environment. Contact Amazon Web Services Support to request quota increases if you need higher limits for your use case.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique identifier of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension MWAAServerlessClientTypes {

    /// Specifies the Amazon S3 location of a workflow definition file. This structure contains the bucket name, object key, and optional version ID for the workflow definition. Amazon Managed Workflows for Apache Airflow Serverless takes a snapshot of the definition file at the time of workflow creation or update, ensuring that the workflow behavior remains consistent even if the source file is modified. The definition must be a valid YAML file that uses supported Amazon Web Services operators and Amazon Managed Workflows for Apache Airflow Serverless syntax.
    public struct DefinitionS3Location: Swift.Sendable {
        /// The name of the Amazon S3 bucket that contains the workflow definition file.
        /// This member is required.
        public var bucket: Swift.String?
        /// The key (name) of the workflow definition file within the S3 bucket.
        /// This member is required.
        public var objectKey: Swift.String?
        /// Optional. The version ID of the workflow definition file in Amazon S3. If not specified, the latest version is used.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            objectKey: Swift.String? = nil,
            versionId: Swift.String? = nil
        ) {
            self.bucket = bucket
            self.objectKey = objectKey
            self.versionId = versionId
        }
    }
}

extension MWAAServerlessClientTypes {

    public enum EncryptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManagedKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .awsManagedKey,
                .customerManagedKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManagedKey: return "AWS_MANAGED_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MWAAServerlessClientTypes {

    /// Configuration for encrypting workflow data at rest and in transit. Amazon Managed Workflows for Apache Airflow Serverless provides comprehensive encryption capabilities to protect sensitive workflow data, parameters, and execution logs. When using customer-managed keys, the service integrates with Amazon Web Services KMS to provide fine-grained access control and audit capabilities. Encryption is applied consistently across the distributed execution environment including task containers, metadata storage, and log streams.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// The ID or ARN of the Amazon Web Services KMS key to use for encryption. Required when Type is CUSTOMER_MANAGED_KEY.
        public var kmsKeyId: Swift.String?
        /// The type of encryption to use. Values are AWS_MANAGED_KEY (Amazon Web Services manages the encryption key) or CUSTOMER_MANAGED_KEY (you provide a KMS key).
        /// This member is required.
        public var type: MWAAServerlessClientTypes.EncryptionType?

        public init(
            kmsKeyId: Swift.String? = nil,
            type: MWAAServerlessClientTypes.EncryptionType? = nil
        ) {
            self.kmsKeyId = kmsKeyId
            self.type = type
        }
    }
}

public enum EngineVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
    /// Engine version 1 of Amazon Managed Workflows for Apache Airflow Serverless
    case one
    case sdkUnknown(Swift.Int)

    public static var allCases: [EngineVersion] {
        return [
            .one
        ]
    }

    public init(rawValue: Swift.Int) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }

    public var rawValue: Swift.Int {
        switch self {
        case .one: return 1
        case let .sdkUnknown(s): return s
        }
    }
}

extension MWAAServerlessClientTypes {

    /// Configuration for workflow logging that specifies where you should store your workflow execution logs. Amazon Managed Workflows for Apache Airflow Serverless provides comprehensive logging capabilities that capture workflow execution details, task-level information, and system events. Logs are automatically exported to your specified CloudWatch log group using remote logging functionality, providing centralized observability across the distributed, multi-tenant execution environment. This enables effective debugging, monitoring, and compliance auditing of workflow executions.
    public struct LoggingConfiguration: Swift.Sendable {
        /// The name of the CloudWatch log group where workflow execution logs are stored.
        /// This member is required.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        ) {
            self.logGroupName = logGroupName
        }
    }
}

extension MWAAServerlessClientTypes {

    /// Network configuration for workflow execution. Specifies VPC security groups and subnets for secure network access. When provided, Amazon Managed Workflows for Apache Airflow Serverless deploys ECS worker tasks in your specified VPC configuration, enabling secure access to VPC-only resources. The service uses a proxy API container architecture where one container handles external communication while the worker container connects to your VPC for task execution. This design provides both security isolation and connectivity flexibility.
    public struct NetworkConfiguration: Swift.Sendable {
        /// A list of VPC security group IDs to associate with the workflow execution environment.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs where the workflow execution environment is deployed.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        ) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

public struct CreateWorkflowInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token prevents duplicate workflow creation requests.
    public var clientToken: Swift.String?
    /// The Amazon S3 location where the workflow definition file is stored. This must point to a valid YAML file that defines the workflow structure using supported Amazon Web Services operators and tasks. Amazon Managed Workflows for Apache Airflow Serverless takes a snapshot of the definition at creation time, so subsequent changes to the Amazon S3 object will not affect the workflow unless you create a new version. In your YAML definition, include task dependencies, scheduling information, and operator configurations that are compatible with the Amazon Managed Workflows for Apache Airflow Serverless execution environment.
    /// This member is required.
    public var definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location?
    /// An optional description of the workflow that you can use to provide additional context about the workflow's purpose and functionality.
    public var description: Swift.String?
    /// The configuration for encrypting workflow data at rest and in transit. Specifies the encryption type and optional KMS key for customer-managed encryption.
    public var encryptionConfiguration: MWAAServerlessClientTypes.EncryptionConfiguration?
    /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that you want to use for this workflow. This determines the feature set, supported operators, and execution environment capabilities available to your workflow. Amazon Managed Workflows for Apache Airflow Serverless maintains backward compatibility across versions while introducing new features and improvements. Currently supports version 1 with plans for additional versions as the service evolves.
    public var engineVersion: EngineVersion?
    /// The configuration for workflow logging. Specifies the CloudWatch log group where workflow execution logs are stored. Amazon Managed Workflows for Apache Airflow Serverless automatically exports worker logs and task-level information to the specified log group in your account using remote logging functionality. This provides comprehensive observability for debugging and monitoring workflow execution across the distributed, serverless environment.
    public var loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration?
    /// The name of the workflow. You must use unique workflow names within your Amazon Web Services account. The service generates a unique identifier that is appended to ensure temporal uniqueness across the account lifecycle.
    /// This member is required.
    public var name: Swift.String?
    /// Network configuration for the workflow execution environment, including VPC security groups and subnets for secure network access. When specified, Amazon Managed Workflows for Apache Airflow Serverless deploys ECS worker tasks in your customer VPC to provide secure connectivity to your resources. If not specified, tasks run in the service's default worker VPC with network isolation from other customers. This configuration enables secure access to VPC-only resources like RDS databases or private endpoints.
    public var networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the IAM role that Amazon Managed Workflows for Apache Airflow Serverless assumes when executing the workflow. This role must have the necessary permissions to access the required Amazon Web Services services and resources that your workflow tasks will interact with. The role is used for task execution in the isolated, multi-tenant environment and should follow the principle of least privilege. Amazon Managed Workflows for Apache Airflow Serverless validates role access during workflow creation but runtime permission checks are performed by the target services.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A map of tags to assign to the workflow resource. Tags are key-value pairs that are used for resource organization and cost allocation.
    public var tags: [Swift.String: Swift.String]?
    /// The trigger mode for the workflow execution.
    public var triggerMode: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location? = nil,
        description: Swift.String? = nil,
        encryptionConfiguration: MWAAServerlessClientTypes.EncryptionConfiguration? = nil,
        engineVersion: EngineVersion? = nil,
        loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        triggerMode: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.definitionS3Location = definitionS3Location
        self.description = description
        self.encryptionConfiguration = encryptionConfiguration
        self.engineVersion = engineVersion
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.roleArn = roleArn
        self.tags = tags
        self.triggerMode = triggerMode
    }
}

extension MWAAServerlessClientTypes {

    public enum WorkflowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .deleting,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkflowOutput: Swift.Sendable {
    /// The timestamp when the workflow was created, in ISO 8601 date-time format.
    public var createdAt: Foundation.Date?
    /// A Boolean flag that indicates whether this workflow version is the latest version of the workflow.
    public var isLatestVersion: Swift.Bool?
    /// A unique identifier for this revision of the workflow configuration. This ID changes when the workflow is updated and you can use it for optimistic concurrency control in update operations. The revision ID helps prevent conflicting updates and ensures that updates are applied to the expected version of the workflow configuration.
    public var revisionId: Swift.String?
    /// Warning messages generated during workflow creation.
    public var warnings: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the newly created workflow. This ARN uniquely identifies the workflow resource.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The current status of the workflow. Possible values are READY (workflow is ready to run) and DELETING (workflow is being deleted).
    public var workflowStatus: MWAAServerlessClientTypes.WorkflowStatus?
    /// The version identifier of the workflow. This is a service-generated alphanumeric string that uniquely identifies this version of the workflow. Amazon Managed Workflows for Apache Airflow Serverless uses a version-first approach where each workflow can have multiple immutable versions, which allows you to maintain different configurations and roll back to previous versions as needed. The version identifier is used in ARNs and API operations to reference specific workflow versions.
    public var workflowVersion: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        isLatestVersion: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        warnings: [Swift.String]? = nil,
        workflowArn: Swift.String? = nil,
        workflowStatus: MWAAServerlessClientTypes.WorkflowStatus? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.isLatestVersion = isLatestVersion
        self.revisionId = revisionId
        self.warnings = warnings
        self.workflowArn = workflowArn
        self.workflowStatus = workflowStatus
        self.workflowVersion = workflowVersion
    }
}

public struct DeleteWorkflowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the workflow you want to delete.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// Optional. The specific version of the workflow to delete. If not specified, all versions of the workflow are deleted.
    public var workflowVersion: Swift.String?

    public init(
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

public struct DeleteWorkflowOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted workflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The version of the workflow that was deleted.
    public var workflowVersion: Swift.String?

    public init(
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

public struct GetWorkflowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the workflow you want to retrieve.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// Optional. The specific version of the workflow to retrieve. If not specified, the latest version is returned.
    public var workflowVersion: Swift.String?

    public init(
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

extension MWAAServerlessClientTypes {

    /// The configuration to use to schedule automated workflow execution using cron expressions. Amazon Managed Workflows for Apache Airflow Serverless integrates with EventBridge Scheduler to provide cost-effective, timezone-aware scheduling capabilities. The service supports both time-based and event-based scheduling (event-based scheduling available post-GA). When a workflow definition includes scheduling information, Amazon Managed Workflows for Apache Airflow Serverless automatically configures the appropriate triggers and ensures only one version of a workflow has an active schedule at any time.
    public struct ScheduleConfiguration: Swift.Sendable {
        /// A cron expression that defines when the workflow is automatically executed. Uses standard cron syntax.
        public var cronExpression: Swift.String?

        public init(
            cronExpression: Swift.String? = nil
        ) {
            self.cronExpression = cronExpression
        }
    }
}

public struct GetWorkflowOutput: Swift.Sendable {
    /// The timestamp when the workflow was created, in ISO 8601 date-time format.
    public var createdAt: Foundation.Date?
    /// The Amazon S3 location of the workflow definition file.
    public var definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location?
    /// The description of the workflow.
    public var description: Swift.String?
    /// The encryption configuration for the workflow.
    public var encryptionConfiguration: MWAAServerlessClientTypes.EncryptionConfiguration?
    /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that this workflow uses.
    public var engineVersion: EngineVersion?
    /// The logging configuration for the workflow.
    public var loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration?
    /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
    public var modifiedAt: Foundation.Date?
    /// The name of the workflow.
    public var name: Swift.String?
    /// The network configuration for the workflow execution environment.
    public var networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the IAM role used for workflow execution.
    public var roleArn: Swift.String?
    /// The schedule configuration for the workflow, including cron expressions for automated execution. Amazon Managed Workflows for Apache Airflow Serverless uses EventBridge Scheduler for cost-effective, timezone-aware scheduling. When a workflow includes schedule information in its YAML definition, the service automatically configures the appropriate triggers for automated execution. Only one version of a workflow can have an active schedule at any given time.
    public var scheduleConfiguration: MWAAServerlessClientTypes.ScheduleConfiguration?
    /// The trigger mode for the workflow execution.
    public var triggerMode: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The workflow definition content.
    public var workflowDefinition: Swift.String?
    /// The current status of the workflow.
    public var workflowStatus: MWAAServerlessClientTypes.WorkflowStatus?
    /// The version identifier of the workflow.
    public var workflowVersion: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location? = nil,
        description: Swift.String? = nil,
        encryptionConfiguration: MWAAServerlessClientTypes.EncryptionConfiguration? = nil,
        engineVersion: EngineVersion? = nil,
        loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration? = nil,
        roleArn: Swift.String? = nil,
        scheduleConfiguration: MWAAServerlessClientTypes.ScheduleConfiguration? = nil,
        triggerMode: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowDefinition: Swift.String? = nil,
        workflowStatus: MWAAServerlessClientTypes.WorkflowStatus? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.definitionS3Location = definitionS3Location
        self.description = description
        self.encryptionConfiguration = encryptionConfiguration
        self.engineVersion = engineVersion
        self.loggingConfiguration = loggingConfiguration
        self.modifiedAt = modifiedAt
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.roleArn = roleArn
        self.scheduleConfiguration = scheduleConfiguration
        self.triggerMode = triggerMode
        self.workflowArn = workflowArn
        self.workflowDefinition = workflowDefinition
        self.workflowStatus = workflowStatus
        self.workflowVersion = workflowVersion
    }
}

public struct ListWorkflowsInput: Swift.Sendable {
    /// The maximum number of workflows you want to return in a single response.
    public var maxResults: Swift.Int?
    /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflows.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MWAAServerlessClientTypes {

    /// Summary information about a workflow, including basic identification and metadata.
    public struct WorkflowSummary: Swift.Sendable {
        /// The timestamp when the workflow was created, in ISO 8601 date-time format.
        public var createdAt: Foundation.Date?
        /// The description of the workflow.
        public var description: Swift.String?
        /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
        public var modifiedAt: Foundation.Date?
        /// The name of the workflow.
        public var name: Swift.String?
        /// The trigger mode for the workflow execution.
        public var triggerMode: Swift.String?
        /// The Amazon Resource Name (ARN) of the workflow.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The current status of the workflow.
        public var workflowStatus: MWAAServerlessClientTypes.WorkflowStatus?
        /// The version identifier of the workflow.
        public var workflowVersion: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            triggerMode: Swift.String? = nil,
            workflowArn: Swift.String? = nil,
            workflowStatus: MWAAServerlessClientTypes.WorkflowStatus? = nil,
            workflowVersion: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.modifiedAt = modifiedAt
            self.name = name
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
            self.workflowStatus = workflowStatus
            self.workflowVersion = workflowVersion
        }
    }
}

public struct ListWorkflowsOutput: Swift.Sendable {
    /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of workflow summaries for all workflows in your account.
    /// This member is required.
    public var workflows: [MWAAServerlessClientTypes.WorkflowSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflows: [MWAAServerlessClientTypes.WorkflowSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.workflows = workflows
    }
}

public struct UpdateWorkflowInput: Swift.Sendable {
    /// The Amazon S3 location where the updated workflow definition file is stored.
    /// This member is required.
    public var definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location?
    /// An updated description for the workflow.
    public var description: Swift.String?
    /// The version of the Amazon Managed Workflows for Apache Airflow Serverless engine that you want to use for the updated workflow.
    public var engineVersion: EngineVersion?
    /// Updated logging configuration for the workflow.
    public var loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration?
    /// Updated network configuration for the workflow execution environment.
    public var networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration?
    /// The Amazon Resource Name (ARN) of the IAM role that Amazon Managed Workflows for Apache Airflow Serverless assumes when it executes the updated workflow.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The trigger mode for the workflow execution.
    public var triggerMode: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow you want to update.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location? = nil,
        description: Swift.String? = nil,
        engineVersion: EngineVersion? = nil,
        loggingConfiguration: MWAAServerlessClientTypes.LoggingConfiguration? = nil,
        networkConfiguration: MWAAServerlessClientTypes.NetworkConfiguration? = nil,
        roleArn: Swift.String? = nil,
        triggerMode: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.definitionS3Location = definitionS3Location
        self.description = description
        self.engineVersion = engineVersion
        self.loggingConfiguration = loggingConfiguration
        self.networkConfiguration = networkConfiguration
        self.roleArn = roleArn
        self.triggerMode = triggerMode
        self.workflowArn = workflowArn
    }
}

public struct UpdateWorkflowOutput: Swift.Sendable {
    /// The timestamp when the workflow was last modified, in ISO 8601 date-time format.
    public var modifiedAt: Foundation.Date?
    /// Warning messages generated during workflow update.
    public var warnings: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the updated workflow.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// The version identifier of the updated workflow.
    public var workflowVersion: Swift.String?

    public init(
        modifiedAt: Foundation.Date? = nil,
        warnings: [Swift.String]? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.modifiedAt = modifiedAt
        self.warnings = warnings
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

public struct GetWorkflowRunInput: Swift.Sendable {
    /// The unique identifier of the workflow run to retrieve.
    /// This member is required.
    public var runId: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow that contains the run.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        runId: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.runId = runId
        self.workflowArn = workflowArn
    }
}

extension MWAAServerlessClientTypes {

    public enum WorkflowRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case queued
        case running
        case starting
        case stopped
        case stopping
        case success
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowRunStatus] {
            return [
                .failed,
                .queued,
                .running,
                .starting,
                .stopped,
                .stopping,
                .success,
                .timeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .success: return "SUCCESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MWAAServerlessClientTypes {

    public enum RunType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RunType] {
            return [
                .onDemand,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MWAAServerlessClientTypes {

    /// Detailed information about a workflow run execution, including timing, status, error information, and associated task instances. This structure provides comprehensive visibility into the workflow execution lifecycle within the Amazon Managed Workflows for Apache Airflow Serverless serverless environment. The service tracks execution across distributed ECS worker tasks and provides detailed timing information, error diagnostics, and task instance relationships to support effective monitoring and troubleshooting of complex workflow executions.
    public struct WorkflowRunDetail: Swift.Sendable {
        /// The timestamp when the workflow run completed execution, in ISO 8601 date-time format. This value is null if the run is not complete.
        public var completedOn: Foundation.Date?
        /// The timestamp when the workflow run was created, in ISO 8601 date-time format.
        public var createdAt: Foundation.Date?
        /// The total duration of the workflow run execution in seconds. This value is null if the run is not complete.
        public var duration: Swift.Int?
        /// The error message if the workflow run failed. This value is null if the run completed successfully.
        public var errorMessage: Swift.String?
        /// The timestamp when the workflow run was last modified, in ISO 8601 date-time format.
        public var modifiedAt: Foundation.Date?
        /// The unique identifier of this workflow run.
        public var runId: Swift.String?
        /// The current execution state of the workflow run.
        public var runState: MWAAServerlessClientTypes.WorkflowRunStatus?
        /// The type of workflow run.
        public var runType: MWAAServerlessClientTypes.RunType?
        /// The timestamp when the workflow run started execution, in ISO 8601 date-time format.
        public var startedOn: Foundation.Date?
        /// A list of task instance IDs that are part of this workflow run.
        public var taskInstances: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the workflow that contains this run.
        public var workflowArn: Swift.String?
        /// The version of the workflow used for this run.
        public var workflowVersion: Swift.String?

        public init(
            completedOn: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            duration: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            runId: Swift.String? = nil,
            runState: MWAAServerlessClientTypes.WorkflowRunStatus? = nil,
            runType: MWAAServerlessClientTypes.RunType? = nil,
            startedOn: Foundation.Date? = nil,
            taskInstances: [Swift.String]? = nil,
            workflowArn: Swift.String? = nil,
            workflowVersion: Swift.String? = nil
        ) {
            self.completedOn = completedOn
            self.createdAt = createdAt
            self.duration = duration
            self.errorMessage = errorMessage
            self.modifiedAt = modifiedAt
            self.runId = runId
            self.runState = runState
            self.runType = runType
            self.startedOn = startedOn
            self.taskInstances = taskInstances
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }
    }
}

public struct GetWorkflowRunOutput: Swift.Sendable {
    /// Parameters that were overridden for this specific workflow run.
    public var overrideParameters: [Swift.String: Smithy.Document]?
    /// Detailed information about the workflow run execution, including timing, status, and task instances.
    public var runDetail: MWAAServerlessClientTypes.WorkflowRunDetail?
    /// The unique identifier of this workflow run.
    public var runId: Swift.String?
    /// The type of workflow run. Values are ON_DEMAND (manually triggered) or SCHEDULED (automatically triggered by schedule).
    public var runType: MWAAServerlessClientTypes.RunType?
    /// The Amazon Resource Name (ARN) of the workflow that contains this run.
    public var workflowArn: Swift.String?
    /// The version of the workflow that is used for this run.
    public var workflowVersion: Swift.String?

    public init(
        overrideParameters: [Swift.String: Smithy.Document]? = nil,
        runDetail: MWAAServerlessClientTypes.WorkflowRunDetail? = nil,
        runId: Swift.String? = nil,
        runType: MWAAServerlessClientTypes.RunType? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.overrideParameters = overrideParameters
        self.runDetail = runDetail
        self.runId = runId
        self.runType = runType
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

extension GetWorkflowRunOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkflowRunOutput(runDetail: \(Swift.String(describing: runDetail)), runId: \(Swift.String(describing: runId)), runType: \(Swift.String(describing: runType)), workflowArn: \(Swift.String(describing: workflowArn)), workflowVersion: \(Swift.String(describing: workflowVersion)), overrideParameters: \"CONTENT_REDACTED\")"}
}

public struct ListWorkflowRunsInput: Swift.Sendable {
    /// The maximum number of workflow runs to return in a single response.
    public var maxResults: Swift.Int?
    /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflowRuns.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow for which you want a list of runs.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// Optional. The specific version of the workflow for which you want a list of runs. If not specified, runs for all versions are returned.
    public var workflowVersion: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

extension MWAAServerlessClientTypes {

    /// Summary information about a workflow run's execution details, including status and timing information.
    public struct RunDetailSummary: Swift.Sendable {
        /// The timestamp when the workflow run was created, in ISO 8601 date-time format.
        public var createdOn: Foundation.Date?
        /// The timestamp when the workflow run completed execution, in ISO 8601 date-time format. This value is null if the run is not complete.
        public var endedAt: Foundation.Date?
        /// The timestamp when the workflow run started execution, in ISO 8601 date-time format.
        public var startedAt: Foundation.Date?
        /// The current status of the workflow run.
        public var status: MWAAServerlessClientTypes.WorkflowRunStatus?

        public init(
            createdOn: Foundation.Date? = nil,
            endedAt: Foundation.Date? = nil,
            startedAt: Foundation.Date? = nil,
            status: MWAAServerlessClientTypes.WorkflowRunStatus? = nil
        ) {
            self.createdOn = createdOn
            self.endedAt = endedAt
            self.startedAt = startedAt
            self.status = status
        }
    }
}

extension MWAAServerlessClientTypes {

    /// Summary information about a workflow run, including basic identification and status information.
    public struct WorkflowRunSummary: Swift.Sendable {
        /// Summary details about the workflow run execution.
        public var runDetailSummary: MWAAServerlessClientTypes.RunDetailSummary?
        /// The unique identifier of the workflow run.
        public var runId: Swift.String?
        /// The type of workflow run.
        public var runType: MWAAServerlessClientTypes.RunType?
        /// The Amazon Resource Name (ARN) of the workflow that contains this run.
        public var workflowArn: Swift.String?
        /// The version of the workflow used for this run.
        public var workflowVersion: Swift.String?

        public init(
            runDetailSummary: MWAAServerlessClientTypes.RunDetailSummary? = nil,
            runId: Swift.String? = nil,
            runType: MWAAServerlessClientTypes.RunType? = nil,
            workflowArn: Swift.String? = nil,
            workflowVersion: Swift.String? = nil
        ) {
            self.runDetailSummary = runDetailSummary
            self.runId = runId
            self.runType = runType
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }
    }
}

public struct ListWorkflowRunsOutput: Swift.Sendable {
    /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of workflow run summaries for the specified workflow.
    public var workflowRuns: [MWAAServerlessClientTypes.WorkflowRunSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowRuns: [MWAAServerlessClientTypes.WorkflowRunSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.workflowRuns = workflowRuns
    }
}

public struct StartWorkflowRunInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token prevents duplicate workflow run requests.
    public var clientToken: Swift.String?
    /// Optional parameters to override default workflow parameters for this specific run. These parameters are passed to the workflow during execution and can be used to customize behavior without modifying the workflow definition. Parameters are made available as environment variables to tasks and you can reference them within the YAML workflow definition using standard parameter substitution syntax.
    public var overrideParameters: [Swift.String: Smithy.Document]?
    /// The Amazon Resource Name (ARN) of the workflow you want to run.
    /// This member is required.
    public var workflowArn: Swift.String?
    /// Optional. The specific version of the workflow to execute. If not specified, the latest version is used.
    public var workflowVersion: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        overrideParameters: [Swift.String: Smithy.Document]? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.overrideParameters = overrideParameters
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

extension StartWorkflowRunInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartWorkflowRunInput(clientToken: \(Swift.String(describing: clientToken)), workflowArn: \(Swift.String(describing: workflowArn)), workflowVersion: \(Swift.String(describing: workflowVersion)), overrideParameters: \"CONTENT_REDACTED\")"}
}

public struct StartWorkflowRunOutput: Swift.Sendable {
    /// The unique identifier of the newly started workflow run.
    public var runId: Swift.String?
    /// The timestamp when the workflow run was started, in ISO 8601 date-time format.
    public var startedAt: Foundation.Date?
    /// The initial status of the workflow run. This is typically STARTING when you first create the run.
    public var status: MWAAServerlessClientTypes.WorkflowRunStatus?

    public init(
        runId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: MWAAServerlessClientTypes.WorkflowRunStatus? = nil
    ) {
        self.runId = runId
        self.startedAt = startedAt
        self.status = status
    }
}

public struct StopWorkflowRunInput: Swift.Sendable {
    /// The unique identifier of the workflow run to stop.
    /// This member is required.
    public var runId: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow that contains the run you want to stop.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        runId: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.runId = runId
        self.workflowArn = workflowArn
    }
}

public struct StopWorkflowRunOutput: Swift.Sendable {
    /// The unique identifier of the stopped workflow run.
    public var runId: Swift.String?
    /// The status of the workflow run after the stop operation. This is typically STOPPING or STOPPED.
    public var status: MWAAServerlessClientTypes.WorkflowRunStatus?
    /// The Amazon Resource Name (ARN) of the workflow that contains the stopped run.
    public var workflowArn: Swift.String?
    /// The version of the workflow that was stopped.
    public var workflowVersion: Swift.String?

    public init(
        runId: Swift.String? = nil,
        status: MWAAServerlessClientTypes.WorkflowRunStatus? = nil,
        workflowArn: Swift.String? = nil,
        workflowVersion: Swift.String? = nil
    ) {
        self.runId = runId
        self.status = status
        self.workflowArn = workflowArn
        self.workflowVersion = workflowVersion
    }
}

public struct ListWorkflowVersionsInput: Swift.Sendable {
    /// The maximum number of workflow versions to return in a single response.
    public var maxResults: Swift.Int?
    /// The pagination token you need to use to retrieve the next set of results. This value is returned from a previous call to ListWorkflowVersions.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the workflow for which you want to list versions.
    /// This member is required.
    public var workflowArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workflowArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workflowArn = workflowArn
    }
}

extension MWAAServerlessClientTypes {

    /// Summary information about a workflow version, including identification and configuration details.
    public struct WorkflowVersionSummary: Swift.Sendable {
        /// The timestamp when the workflow version was created, in ISO 8601 date-time format.
        public var createdAt: Foundation.Date?
        /// The Amazon S3 location of the workflow definition file for this version.
        public var definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location?
        /// Boolean flag that indicates whether this is the latest version of the workflow.
        public var isLatestVersion: Swift.Bool?
        /// The timestamp when the workflow version was last modified, in ISO 8601 date-time format.
        public var modifiedAt: Foundation.Date?
        /// The schedule configuration for this workflow version.
        public var scheduleConfiguration: MWAAServerlessClientTypes.ScheduleConfiguration?
        /// The trigger mode for the workflow execution.
        public var triggerMode: Swift.String?
        /// The Amazon Resource Name (ARN) of the workflow that contains this version.
        /// This member is required.
        public var workflowArn: Swift.String?
        /// The version identifier of the workflow version.
        /// This member is required.
        public var workflowVersion: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            definitionS3Location: MWAAServerlessClientTypes.DefinitionS3Location? = nil,
            isLatestVersion: Swift.Bool? = nil,
            modifiedAt: Foundation.Date? = nil,
            scheduleConfiguration: MWAAServerlessClientTypes.ScheduleConfiguration? = nil,
            triggerMode: Swift.String? = nil,
            workflowArn: Swift.String? = nil,
            workflowVersion: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.definitionS3Location = definitionS3Location
            self.isLatestVersion = isLatestVersion
            self.modifiedAt = modifiedAt
            self.scheduleConfiguration = scheduleConfiguration
            self.triggerMode = triggerMode
            self.workflowArn = workflowArn
            self.workflowVersion = workflowVersion
        }
    }
}

public struct ListWorkflowVersionsOutput: Swift.Sendable {
    /// The pagination token you need to use to retrieve the next set of results. This value is null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of workflow version summaries for the specified workflow.
    public var workflowVersions: [MWAAServerlessClientTypes.WorkflowVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workflowVersions: [MWAAServerlessClientTypes.WorkflowVersionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.workflowVersions = workflowVersions
    }
}

extension CreateWorkflowInput {

    static func urlPathProvider(_ value: CreateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkflowInput {

    static func urlPathProvider(_ value: DeleteWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkflowInput {

    static func queryItemProvider(_ value: DeleteWorkflowInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension GetTaskInstanceInput {

    static func urlPathProvider(_ value: GetTaskInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowInput {

    static func urlPathProvider(_ value: GetWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkflowInput {

    static func queryItemProvider(_ value: GetWorkflowInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension GetWorkflowRunInput {

    static func urlPathProvider(_ value: GetWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTaskInstancesInput {

    static func urlPathProvider(_ value: ListTaskInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTaskInstancesInput {

    static func queryItemProvider(_ value: ListTaskInstancesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListWorkflowRunsInput {

    static func urlPathProvider(_ value: ListWorkflowRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkflowRunsInput {

    static func queryItemProvider(_ value: ListWorkflowRunsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListWorkflowsInput {

    static func urlPathProvider(_ value: ListWorkflowsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkflowsInput {

    static func queryItemProvider(_ value: ListWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListWorkflowVersionsInput {

    static func urlPathProvider(_ value: ListWorkflowVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkflowVersionsInput {

    static func queryItemProvider(_ value: ListWorkflowVersionsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension StartWorkflowRunInput {

    static func urlPathProvider(_ value: StartWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopWorkflowRunInput {

    static func urlPathProvider(_ value: StopWorkflowRunInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension UpdateWorkflowInput {

    static func urlPathProvider(_ value: UpdateWorkflowInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkflowInput {

    static func write(value: CreateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DefinitionS3Location"].write(value.definitionS3Location, with: MWAAServerlessClientTypes.DefinitionS3Location.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: MWAAServerlessClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["LoggingConfiguration"].write(value.loggingConfiguration, with: MWAAServerlessClientTypes.LoggingConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["NetworkConfiguration"].write(value.networkConfiguration, with: MWAAServerlessClientTypes.NetworkConfiguration.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TriggerMode"].write(value.triggerMode)
    }
}

extension DeleteWorkflowInput {

    static func write(value: DeleteWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkflowArn"].write(value.workflowArn)
        try writer["WorkflowVersion"].write(value.workflowVersion)
    }
}

extension GetTaskInstanceInput {

    static func write(value: GetTaskInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
        try writer["TaskInstanceId"].write(value.taskInstanceId)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension GetWorkflowInput {

    static func write(value: GetWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkflowArn"].write(value.workflowArn)
        try writer["WorkflowVersion"].write(value.workflowVersion)
    }
}

extension GetWorkflowRunInput {

    static func write(value: GetWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListTaskInstancesInput {

    static func write(value: ListTaskInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RunId"].write(value.runId)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension ListWorkflowRunsInput {

    static func write(value: ListWorkflowRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkflowArn"].write(value.workflowArn)
        try writer["WorkflowVersion"].write(value.workflowVersion)
    }
}

extension ListWorkflowsInput {

    static func write(value: ListWorkflowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListWorkflowVersionsInput {

    static func write(value: ListWorkflowVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension StartWorkflowRunInput {

    static func write(value: StartWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["OverrideParameters"].writeMap(value.overrideParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkflowArn"].write(value.workflowArn)
        try writer["WorkflowVersion"].write(value.workflowVersion)
    }
}

extension StopWorkflowRunInput {

    static func write(value: StopWorkflowRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunId"].write(value.runId)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWorkflowInput {

    static func write(value: UpdateWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefinitionS3Location"].write(value.definitionS3Location, with: MWAAServerlessClientTypes.DefinitionS3Location.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["LoggingConfiguration"].write(value.loggingConfiguration, with: MWAAServerlessClientTypes.LoggingConfiguration.write(value:to:))
        try writer["NetworkConfiguration"].write(value.networkConfiguration, with: MWAAServerlessClientTypes.NetworkConfiguration.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["TriggerMode"].write(value.triggerMode)
        try writer["WorkflowArn"].write(value.workflowArn)
    }
}

extension CreateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkflowOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.isLatestVersion = try reader["IsLatestVersion"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.warnings = try reader["Warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowStatus = try reader["WorkflowStatus"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

extension DeleteWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkflowOutput()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

extension GetTaskInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaskInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaskInstanceOutput()
        value.attemptNumber = try reader["AttemptNumber"].readIfPresent()
        value.durationInSeconds = try reader["DurationInSeconds"].readIfPresent()
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.logStream = try reader["LogStream"].readIfPresent()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.operatorName = try reader["OperatorName"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskInstanceId = try reader["TaskInstanceId"].readIfPresent() ?? ""
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        value.xcom = try reader["Xcom"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.definitionS3Location = try reader["DefinitionS3Location"].readIfPresent(with: MWAAServerlessClientTypes.DefinitionS3Location.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: MWAAServerlessClientTypes.EncryptionConfiguration.read(from:))
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: MWAAServerlessClientTypes.LoggingConfiguration.read(from:))
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["Name"].readIfPresent()
        value.networkConfiguration = try reader["NetworkConfiguration"].readIfPresent(with: MWAAServerlessClientTypes.NetworkConfiguration.read(from:))
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.scheduleConfiguration = try reader["ScheduleConfiguration"].readIfPresent(with: MWAAServerlessClientTypes.ScheduleConfiguration.read(from:))
        value.triggerMode = try reader["TriggerMode"].readIfPresent()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowDefinition = try reader["WorkflowDefinition"].readIfPresent()
        value.workflowStatus = try reader["WorkflowStatus"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

extension GetWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkflowRunOutput()
        value.overrideParameters = try reader["OverrideParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.runDetail = try reader["RunDetail"].readIfPresent(with: MWAAServerlessClientTypes.WorkflowRunDetail.read(from:))
        value.runId = try reader["RunId"].readIfPresent()
        value.runType = try reader["RunType"].readIfPresent()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTaskInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTaskInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTaskInstancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskInstances = try reader["TaskInstances"].readListIfPresent(memberReadingClosure: MWAAServerlessClientTypes.TaskInstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowRunsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflowRuns = try reader["WorkflowRuns"].readListIfPresent(memberReadingClosure: MWAAServerlessClientTypes.WorkflowRunSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflows = try reader["Workflows"].readListIfPresent(memberReadingClosure: MWAAServerlessClientTypes.WorkflowSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkflowVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkflowVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkflowVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workflowVersions = try reader["WorkflowVersions"].readListIfPresent(memberReadingClosure: MWAAServerlessClientTypes.WorkflowVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartWorkflowRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension StopWorkflowRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopWorkflowRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopWorkflowRunOutput()
        value.runId = try reader["RunId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkflowOutput()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.warnings = try reader["Warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        return value
    }
}

enum CreateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaskInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTaskInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkflowVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopWorkflowRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationTimeoutException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationTimeoutException {
        let reader = baseError.errorBodyReader
        var value = OperationTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["FieldList"].readListIfPresent(memberReadingClosure: MWAAServerlessClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MWAAServerlessClientTypes.DefinitionS3Location {

    static func write(value: MWAAServerlessClientTypes.DefinitionS3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["ObjectKey"].write(value.objectKey)
        try writer["VersionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.DefinitionS3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.DefinitionS3Location()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.objectKey = try reader["ObjectKey"].readIfPresent() ?? ""
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.EncryptionConfiguration {

    static func write(value: MWAAServerlessClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.EncryptionConfiguration()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.LoggingConfiguration {

    static func write(value: MWAAServerlessClientTypes.LoggingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogGroupName"].write(value.logGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.LoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.LoggingConfiguration()
        value.logGroupName = try reader["LogGroupName"].readIfPresent() ?? ""
        return value
    }
}

extension MWAAServerlessClientTypes.NetworkConfiguration {

    static func write(value: MWAAServerlessClientTypes.NetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.NetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.NetworkConfiguration()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MWAAServerlessClientTypes.RunDetailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.RunDetailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.RunDetailSummary()
        value.status = try reader["Status"].readIfPresent()
        value.createdOn = try reader["CreatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MWAAServerlessClientTypes.ScheduleConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.ScheduleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.ScheduleConfiguration()
        value.cronExpression = try reader["CronExpression"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.TaskInstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.TaskInstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.TaskInstanceSummary()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        value.taskInstanceId = try reader["TaskInstanceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.durationInSeconds = try reader["DurationInSeconds"].readIfPresent()
        value.operatorName = try reader["OperatorName"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension MWAAServerlessClientTypes.WorkflowRunDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.WorkflowRunDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.WorkflowRunDetail()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        value.runId = try reader["RunId"].readIfPresent()
        value.runType = try reader["RunType"].readIfPresent()
        value.startedOn = try reader["StartedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.completedOn = try reader["CompletedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.duration = try reader["Duration"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.taskInstances = try reader["TaskInstances"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.runState = try reader["RunState"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.WorkflowRunSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.WorkflowRunSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.WorkflowRunSummary()
        value.runId = try reader["RunId"].readIfPresent()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        value.runType = try reader["RunType"].readIfPresent()
        value.runDetailSummary = try reader["RunDetailSummary"].readIfPresent(with: MWAAServerlessClientTypes.RunDetailSummary.read(from:))
        return value
    }
}

extension MWAAServerlessClientTypes.WorkflowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.WorkflowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.WorkflowSummary()
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.workflowStatus = try reader["WorkflowStatus"].readIfPresent()
        value.triggerMode = try reader["TriggerMode"].readIfPresent()
        return value
    }
}

extension MWAAServerlessClientTypes.WorkflowVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MWAAServerlessClientTypes.WorkflowVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MWAAServerlessClientTypes.WorkflowVersionSummary()
        value.workflowVersion = try reader["WorkflowVersion"].readIfPresent() ?? ""
        value.workflowArn = try reader["WorkflowArn"].readIfPresent() ?? ""
        value.isLatestVersion = try reader["IsLatestVersion"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.definitionS3Location = try reader["DefinitionS3Location"].readIfPresent(with: MWAAServerlessClientTypes.DefinitionS3Location.read(from:))
        value.scheduleConfiguration = try reader["ScheduleConfiguration"].readIfPresent(with: MWAAServerlessClientTypes.ScheduleConfiguration.read(from:))
        value.triggerMode = try reader["TriggerMode"].readIfPresent()
        return value
    }
}

public enum MWAAServerlessClientTypes {}
