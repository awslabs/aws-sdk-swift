//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers


public struct PublishOutput: Swift.Sendable {

    public init() { }
}

/// The specified version does not match the version of the document.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified combination of HTTP verb and URI is not supported.
public struct MethodNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MethodNotAllowedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The document encoding is not supported.
public struct UnsupportedDocumentEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedDocumentEncodingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the DeleteThingShadow operation.
public struct DeleteThingShadowInput: Swift.Sendable {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

/// The output from the DeleteThingShadow operation.
public struct DeleteThingShadowOutput: Swift.Sendable {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: Foundation.Data?

    public init(
        payload: Foundation.Data? = nil
    )
    {
        self.payload = payload
    }
}

/// The input for the GetRetainedMessage operation.
public struct GetRetainedMessageInput: Swift.Sendable {
    /// The topic name of the retained message to retrieve.
    /// This member is required.
    public var topic: Swift.String?

    public init(
        topic: Swift.String? = nil
    )
    {
        self.topic = topic
    }
}

/// The output from the GetRetainedMessage operation.
public struct GetRetainedMessageOutput: Swift.Sendable {
    /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
    public var lastModifiedTime: Swift.Int
    /// The Base64-encoded message payload of the retained message body.
    public var payload: Foundation.Data?
    /// The quality of service (QoS) level used to publish the retained message.
    public var qos: Swift.Int
    /// The topic name to which the retained message was published.
    public var topic: Swift.String?
    /// A base64-encoded JSON string that includes an array of JSON objects, or null if the retained message doesn't include any user properties. The following example userProperties parameter is a JSON string that represents two user properties. Note that it will be base64-encoded: [{"deviceName": "alpha"}, {"deviceCnt": "45"}]
    public var userProperties: Foundation.Data?

    public init(
        lastModifiedTime: Swift.Int = 0,
        payload: Foundation.Data? = nil,
        qos: Swift.Int = 0,
        topic: Swift.String? = nil,
        userProperties: Foundation.Data? = nil
    )
    {
        self.lastModifiedTime = lastModifiedTime
        self.payload = payload
        self.qos = qos
        self.topic = topic
        self.userProperties = userProperties
    }
}

/// The input for the GetThingShadow operation.
public struct GetThingShadowInput: Swift.Sendable {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

/// The output from the GetThingShadow operation.
public struct GetThingShadowOutput: Swift.Sendable {
    /// The state information, in JSON format.
    public var payload: Foundation.Data?

    public init(
        payload: Foundation.Data? = nil
    )
    {
        self.payload = payload
    }
}

public struct ListNamedShadowsForThingInput: Swift.Sendable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.thingName = thingName
    }
}

public struct ListNamedShadowsForThingOutput: Swift.Sendable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of shadows for the specified thing.
    public var results: [Swift.String]?
    /// The Epoch date and time the response was generated by IoT.
    public var timestamp: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        results: [Swift.String]? = nil,
        timestamp: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.results = results
        self.timestamp = timestamp
    }
}

public struct ListRetainedMessagesInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTDataPlaneClientTypes {

    /// Information about a single retained message.
    public struct RetainedMessageSummary: Swift.Sendable {
        /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
        public var lastModifiedTime: Swift.Int
        /// The size of the retained message's payload in bytes.
        public var payloadSize: Swift.Int
        /// The quality of service (QoS) level used to publish the retained message.
        public var qos: Swift.Int
        /// The topic name to which the retained message was published.
        public var topic: Swift.String?

        public init(
            lastModifiedTime: Swift.Int = 0,
            payloadSize: Swift.Int = 0,
            qos: Swift.Int = 0,
            topic: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.payloadSize = payloadSize
            self.qos = qos
            self.topic = topic
        }
    }
}

public struct ListRetainedMessagesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A summary list the account's retained messages. The information returned doesn't include the message payloads of the retained messages.
    public var retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.retainedTopics = retainedTopics
    }
}

extension IoTDataPlaneClientTypes {

    public enum PayloadFormatIndicator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case unspecifiedBytes
        case utf8Data
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadFormatIndicator] {
            return [
                .unspecifiedBytes,
                .utf8Data
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .unspecifiedBytes: return "UNSPECIFIED_BYTES"
            case .utf8Data: return "UTF8_DATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input for the Publish operation.
public struct PublishInput: Swift.Sendable {
    /// A UTF-8 encoded string that describes the content of the publishing message.
    public var contentType: Swift.String?
    /// The base64-encoded binary data used by the sender of the request message to identify which request the response message is for when it's received. correlationData is an HTTP header value in the API.
    public var correlationData: Swift.String?
    /// A user-defined integer value that represents the message expiry interval in seconds. If absent, the message doesn't expire. For more information about the limits of messageExpiry, see [Amazon Web Services IoT Core message broker and protocol limits and quotas ](https://docs.aws.amazon.com/general/latest/gr/iot-core.html#message-broker-limits) from the Amazon Web Services Reference Guide.
    public var messageExpiry: Swift.Int?
    /// The message body. MQTT accepts text, binary, and empty (null) message payloads. Publishing an empty (null) payload with retain = true deletes the retained message identified by topic from Amazon Web Services IoT Core.
    public var payload: Foundation.Data?
    /// An Enum string value that indicates whether the payload is formatted as UTF-8. payloadFormatIndicator is an HTTP header value in the API.
    public var payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator?
    /// The Quality of Service (QoS) level. The default QoS level is 0.
    public var qos: Swift.Int?
    /// A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic which the receiver should publish to as part of the request-response flow. The topic must not contain wildcard characters.
    public var responseTopic: Swift.String?
    /// A Boolean value that determines whether to set the RETAIN flag when the message is published. Setting the RETAIN flag causes the message to be retained and sent to new subscribers to the topic. Valid values: true | false Default value: false
    public var retain: Swift.Bool?
    /// The name of the MQTT topic.
    /// This member is required.
    public var topic: Swift.String?
    /// A JSON string that contains an array of JSON objects. If you don’t use Amazon Web Services SDK or CLI, you must encode the JSON string to base64 format before adding it to the HTTP header. userProperties is an HTTP header value in the API. The following example userProperties parameter is a JSON string which represents two User Properties. Note that it needs to be base64-encoded: [{"deviceName": "alpha"}, {"deviceCnt": "45"}]
    public var userProperties: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        correlationData: Swift.String? = nil,
        messageExpiry: Swift.Int? = 0,
        payload: Foundation.Data? = nil,
        payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator? = nil,
        qos: Swift.Int? = 0,
        responseTopic: Swift.String? = nil,
        retain: Swift.Bool? = false,
        topic: Swift.String? = nil,
        userProperties: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.correlationData = correlationData
        self.messageExpiry = messageExpiry
        self.payload = payload
        self.payloadFormatIndicator = payloadFormatIndicator
        self.qos = qos
        self.responseTopic = responseTopic
        self.retain = retain
        self.topic = topic
        self.userProperties = userProperties
    }
}

/// The payload exceeds the maximum size allowed.
public struct RequestEntityTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestEntityTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the UpdateThingShadow operation.
public struct UpdateThingShadowInput: Swift.Sendable {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: Foundation.Data?
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        payload: Foundation.Data? = nil,
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.payload = payload
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

/// The output from the UpdateThingShadow operation.
public struct UpdateThingShadowOutput: Swift.Sendable {
    /// The state information, in JSON format.
    public var payload: Foundation.Data?

    public init(
        payload: Foundation.Data? = nil
    )
    {
        self.payload = payload
    }
}

extension DeleteThingShadowInput {

    static func urlPathProvider(_ value: DeleteThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

extension DeleteThingShadowInput {

    static func queryItemProvider(_ value: DeleteThingShadowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension GetRetainedMessageInput {

    static func urlPathProvider(_ value: GetRetainedMessageInput) -> Swift.String? {
        guard let topic = value.topic else {
            return nil
        }
        return "/retainedMessage/\(topic.urlPercentEncoding())"
    }
}

extension GetThingShadowInput {

    static func urlPathProvider(_ value: GetThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

extension GetThingShadowInput {

    static func queryItemProvider(_ value: GetThingShadowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension ListNamedShadowsForThingInput {

    static func urlPathProvider(_ value: ListNamedShadowsForThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/api/things/shadow/ListNamedShadowsForThing/\(thingName.urlPercentEncoding())"
    }
}

extension ListNamedShadowsForThingInput {

    static func queryItemProvider(_ value: ListNamedShadowsForThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = Smithy.URIQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListRetainedMessagesInput {

    static func urlPathProvider(_ value: ListRetainedMessagesInput) -> Swift.String? {
        return "/retainedMessage"
    }
}

extension ListRetainedMessagesInput {

    static func queryItemProvider(_ value: ListRetainedMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PublishInput {

    static func urlPathProvider(_ value: PublishInput) -> Swift.String? {
        guard let topic = value.topic else {
            return nil
        }
        return "/topics/\(topic.urlPercentEncoding())"
    }
}

extension PublishInput {

    static func headerProvider(_ value: PublishInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let correlationData = value.correlationData {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-mqtt5-correlation-data", value: Swift.String(correlationData)))
        }
        if let payloadFormatIndicator = value.payloadFormatIndicator {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-mqtt5-payload-format-indicator", value: Swift.String(payloadFormatIndicator.rawValue)))
        }
        if let userProperties = value.userProperties {
            do {
                let base64EncodedValue = try userProperties.base64EncodedString()
                items.add(SmithyHTTPAPI.Header(name: "x-amz-mqtt5-user-properties", value: Swift.String(base64EncodedValue)))
            } catch {
            }
        }
        return items
    }
}

extension PublishInput {

    static func queryItemProvider(_ value: PublishInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let qos = value.qos {
            let qosQueryItem = Smithy.URIQueryItem(name: "qos".urlPercentEncoding(), value: Swift.String(qos).urlPercentEncoding())
            items.append(qosQueryItem)
        }
        if let retain = value.retain {
            let retainQueryItem = Smithy.URIQueryItem(name: "retain".urlPercentEncoding(), value: Swift.String(retain).urlPercentEncoding())
            items.append(retainQueryItem)
        }
        if let responseTopic = value.responseTopic {
            let responseTopicQueryItem = Smithy.URIQueryItem(name: "responseTopic".urlPercentEncoding(), value: Swift.String(responseTopic).urlPercentEncoding())
            items.append(responseTopicQueryItem)
        }
        if let contentType = value.contentType {
            let contentTypeQueryItem = Smithy.URIQueryItem(name: "contentType".urlPercentEncoding(), value: Swift.String(contentType).urlPercentEncoding())
            items.append(contentTypeQueryItem)
        }
        if let messageExpiry = value.messageExpiry {
            let messageExpiryQueryItem = Smithy.URIQueryItem(name: "messageExpiry".urlPercentEncoding(), value: Swift.String(messageExpiry).urlPercentEncoding())
            items.append(messageExpiryQueryItem)
        }
        return items
    }
}

extension UpdateThingShadowInput {

    static func urlPathProvider(_ value: UpdateThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

extension UpdateThingShadowInput {

    static func queryItemProvider(_ value: UpdateThingShadowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension PublishInput {

    static func write(value: PublishInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

extension UpdateThingShadowInput {

    static func write(value: UpdateThingShadowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

extension DeleteThingShadowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThingShadowOutput {
        var value = DeleteThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

extension GetRetainedMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRetainedMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRetainedMessageOutput()
        value.lastModifiedTime = try reader["lastModifiedTime"].readIfPresent() ?? 0
        value.payload = try reader["payload"].readIfPresent()
        value.qos = try reader["qos"].readIfPresent() ?? 0
        value.topic = try reader["topic"].readIfPresent()
        value.userProperties = try reader["userProperties"].readIfPresent()
        return value
    }
}

extension GetThingShadowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetThingShadowOutput {
        var value = GetThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

extension ListNamedShadowsForThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamedShadowsForThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamedShadowsForThingOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestamp = try reader["timestamp"].readIfPresent() ?? 0
        return value
    }
}

extension ListRetainedMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRetainedMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRetainedMessagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.retainedTopics = try reader["retainedTopics"].readListIfPresent(memberReadingClosure: IoTDataPlaneClientTypes.RetainedMessageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PublishOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishOutput {
        return PublishOutput()
    }
}

extension UpdateThingShadowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThingShadowOutput {
        var value = UpdateThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

enum DeleteThingShadowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRetainedMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetThingShadowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamedShadowsForThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRetainedMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThingShadowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "RequestEntityTooLargeException": return try RequestEntityTooLargeException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MethodNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MethodNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = MethodNotAllowedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedDocumentEncodingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedDocumentEncodingException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedDocumentEncodingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestEntityTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestEntityTooLargeException {
        let reader = baseError.errorBodyReader
        var value = RequestEntityTooLargeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTDataPlaneClientTypes.RetainedMessageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTDataPlaneClientTypes.RetainedMessageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTDataPlaneClientTypes.RetainedMessageSummary()
        value.topic = try reader["topic"].readIfPresent()
        value.payloadSize = try reader["payloadSize"].readIfPresent() ?? 0
        value.qos = try reader["qos"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["lastModifiedTime"].readIfPresent() ?? 0
        return value
    }
}

public enum IoTDataPlaneClientTypes {}
