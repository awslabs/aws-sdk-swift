// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified version does not match the version of the document.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteThingShadowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let shadowName = shadowName {
                let shadowNameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
                items.append(shadowNameQueryItem)
            }
            return items
        }
    }
}

extension DeleteThingShadowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

/// The input for the DeleteThingShadow operation.
public struct DeleteThingShadowInput: Swift.Equatable {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

struct DeleteThingShadowInputBody: Swift.Equatable {
}

extension DeleteThingShadowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThingShadowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThingShadowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentEncodingException" : self = .unsupportedDocumentEncodingException(try UnsupportedDocumentEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteThingShadowOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unsupportedDocumentEncodingException(UnsupportedDocumentEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThingShadowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.payload = data
        } else {
            self.payload = nil
        }
    }
}

/// The output from the DeleteThingShadow operation.
public struct DeleteThingShadowOutputResponse: Swift.Equatable {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: ClientRuntime.Data?

    public init (
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

struct DeleteThingShadowOutputResponseBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension DeleteThingShadowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension GetRetainedMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let topic = topic else {
            return nil
        }
        return "/retainedMessage/\(topic.urlPercentEncoding())"
    }
}

/// The input for the GetRetainedMessage operation.
public struct GetRetainedMessageInput: Swift.Equatable {
    /// The topic name of the retained message to retrieve.
    /// This member is required.
    public var topic: Swift.String?

    public init (
        topic: Swift.String? = nil
    )
    {
        self.topic = topic
    }
}

struct GetRetainedMessageInputBody: Swift.Equatable {
}

extension GetRetainedMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRetainedMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRetainedMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRetainedMessageOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRetainedMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRetainedMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedTime = output.lastModifiedTime
            self.payload = output.payload
            self.qos = output.qos
            self.topic = output.topic
        } else {
            self.lastModifiedTime = 0
            self.payload = nil
            self.qos = 0
            self.topic = nil
        }
    }
}

/// The output from the GetRetainedMessage operation.
public struct GetRetainedMessageOutputResponse: Swift.Equatable {
    /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
    public var lastModifiedTime: Swift.Int
    /// The Base64-encoded message payload of the retained message body.
    public var payload: ClientRuntime.Data?
    /// The quality of service (QoS) level used to publish the retained message.
    public var qos: Swift.Int
    /// The topic name to which the retained message was published.
    public var topic: Swift.String?

    public init (
        lastModifiedTime: Swift.Int = 0,
        payload: ClientRuntime.Data? = nil,
        qos: Swift.Int = 0,
        topic: Swift.String? = nil
    )
    {
        self.lastModifiedTime = lastModifiedTime
        self.payload = payload
        self.qos = qos
        self.topic = topic
    }
}

struct GetRetainedMessageOutputResponseBody: Swift.Equatable {
    let topic: Swift.String?
    let payload: ClientRuntime.Data?
    let qos: Swift.Int
    let lastModifiedTime: Swift.Int
}

extension GetRetainedMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedTime
        case payload
        case qos
        case topic
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
        let qosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .qos) ?? 0
        qos = qosDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension GetThingShadowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let shadowName = shadowName {
                let shadowNameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
                items.append(shadowNameQueryItem)
            }
            return items
        }
    }
}

extension GetThingShadowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

/// The input for the GetThingShadow operation.
public struct GetThingShadowInput: Swift.Equatable {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

struct GetThingShadowInputBody: Swift.Equatable {
}

extension GetThingShadowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThingShadowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThingShadowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentEncodingException" : self = .unsupportedDocumentEncodingException(try UnsupportedDocumentEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetThingShadowOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unsupportedDocumentEncodingException(UnsupportedDocumentEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThingShadowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.payload = data
        } else {
            self.payload = nil
        }
    }
}

/// The output from the GetThingShadow operation.
public struct GetThingShadowOutputResponse: Swift.Equatable {
    /// The state information, in JSON format.
    public var payload: ClientRuntime.Data?

    public init (
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

struct GetThingShadowOutputResponseBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension GetThingShadowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListNamedShadowsForThingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let pageSize = pageSize {
                let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
                items.append(pageSizeQueryItem)
            }
            return items
        }
    }
}

extension ListNamedShadowsForThingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/api/things/shadow/ListNamedShadowsForThing/\(thingName.urlPercentEncoding())"
    }
}

public struct ListNamedShadowsForThingInput: Swift.Equatable {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.thingName = thingName
    }
}

struct ListNamedShadowsForThingInputBody: Swift.Equatable {
}

extension ListNamedShadowsForThingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNamedShadowsForThingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamedShadowsForThingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListNamedShadowsForThingOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamedShadowsForThingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListNamedShadowsForThingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
            self.timestamp = output.timestamp
        } else {
            self.nextToken = nil
            self.results = nil
            self.timestamp = 0
        }
    }
}

public struct ListNamedShadowsForThingOutputResponse: Swift.Equatable {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of shadows for the specified thing.
    public var results: [Swift.String]?
    /// The Epoch date and time the response was generated by IoT.
    public var timestamp: Swift.Int

    public init (
        nextToken: Swift.String? = nil,
        results: [Swift.String]? = nil,
        timestamp: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.results = results
        self.timestamp = timestamp
    }
}

struct ListNamedShadowsForThingOutputResponseBody: Swift.Equatable {
    let results: [Swift.String]?
    let nextToken: Swift.String?
    let timestamp: Swift.Int
}

extension ListNamedShadowsForThingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
        case timestamp
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .results)
        var resultsDecoded0:[Swift.String]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [Swift.String]()
            for string0 in resultsContainer {
                if let string0 = string0 {
                    resultsDecoded0?.append(string0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timestamp) ?? 0
        timestamp = timestampDecoded
    }
}

extension ListRetainedMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListRetainedMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/retainedMessage"
    }
}

public struct ListRetainedMessagesInput: Swift.Equatable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRetainedMessagesInputBody: Swift.Equatable {
}

extension ListRetainedMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRetainedMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRetainedMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRetainedMessagesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRetainedMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRetainedMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.retainedTopics = output.retainedTopics
        } else {
            self.nextToken = nil
            self.retainedTopics = nil
        }
    }
}

public struct ListRetainedMessagesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A summary list the account's retained messages. The information returned doesn't include the message payloads of the retained messages.
    public var retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]?

    public init (
        nextToken: Swift.String? = nil,
        retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.retainedTopics = retainedTopics
    }
}

struct ListRetainedMessagesOutputResponseBody: Swift.Equatable {
    let retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]?
    let nextToken: Swift.String?
}

extension ListRetainedMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case retainedTopics
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retainedTopicsContainer = try containerValues.decodeIfPresent([IoTDataPlaneClientTypes.RetainedMessageSummary?].self, forKey: .retainedTopics)
        var retainedTopicsDecoded0:[IoTDataPlaneClientTypes.RetainedMessageSummary]? = nil
        if let retainedTopicsContainer = retainedTopicsContainer {
            retainedTopicsDecoded0 = [IoTDataPlaneClientTypes.RetainedMessageSummary]()
            for structure0 in retainedTopicsContainer {
                if let structure0 = structure0 {
                    retainedTopicsDecoded0?.append(structure0)
                }
            }
        }
        retainedTopics = retainedTopicsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MethodNotAllowedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MethodNotAllowedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified combination of HTTP verb and URI is not supported.
public struct MethodNotAllowedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MethodNotAllowedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MethodNotAllowedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTDataPlaneClientTypes {
    public enum PayloadFormatIndicator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unspecifiedBytes
        case utf8Data
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadFormatIndicator] {
            return [
                .unspecifiedBytes,
                .utf8Data,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unspecifiedBytes: return "UNSPECIFIED_BYTES"
            case .utf8Data: return "UTF8_DATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PayloadFormatIndicator(rawValue: rawValue) ?? PayloadFormatIndicator.sdkUnknown(rawValue)
        }
    }
}

public struct PublishInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PublishOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloaddata = payload
            let payloadbody = ClientRuntime.HttpBody.data(payloaddata)
            input.builder.withBody(payloadbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PublishInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

extension PublishInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let correlationData = correlationData {
            items.add(Header(name: "x-amz-mqtt5-correlation-data", value: Swift.String(correlationData)))
        }
        if let payloadFormatIndicator = payloadFormatIndicator {
            items.add(Header(name: "x-amz-mqtt5-payload-format-indicator", value: Swift.String(payloadFormatIndicator.rawValue)))
        }
        if let userProperties = userProperties {
            do {
                let base64EncodedValue = try userProperties.base64EncodedString()
                items.add(Header(name: "x-amz-mqtt5-user-properties", value: Swift.String(base64EncodedValue)))
            } catch let err {
            }
        }
        return items
    }
}

extension PublishInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if qos != 0 {
                let qosQueryItem = ClientRuntime.URLQueryItem(name: "qos".urlPercentEncoding(), value: Swift.String(qos).urlPercentEncoding())
                items.append(qosQueryItem)
            }
            if retain != false {
                let retainQueryItem = ClientRuntime.URLQueryItem(name: "retain".urlPercentEncoding(), value: Swift.String(retain).urlPercentEncoding())
                items.append(retainQueryItem)
            }
            if let responseTopic = responseTopic {
                let responseTopicQueryItem = ClientRuntime.URLQueryItem(name: "responseTopic".urlPercentEncoding(), value: Swift.String(responseTopic).urlPercentEncoding())
                items.append(responseTopicQueryItem)
            }
            if let contentType = contentType {
                let contentTypeQueryItem = ClientRuntime.URLQueryItem(name: "contentType".urlPercentEncoding(), value: Swift.String(contentType).urlPercentEncoding())
                items.append(contentTypeQueryItem)
            }
            if messageExpiry != 0 {
                let messageExpiryQueryItem = ClientRuntime.URLQueryItem(name: "messageExpiry".urlPercentEncoding(), value: Swift.String(messageExpiry).urlPercentEncoding())
                items.append(messageExpiryQueryItem)
            }
            return items
        }
    }
}

extension PublishInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let topic = topic else {
            return nil
        }
        return "/topics/\(topic.urlPercentEncoding())"
    }
}

/// The input for the Publish operation.
public struct PublishInput: Swift.Equatable {
    /// A UTF-8 encoded string that describes the content of the publishing message.
    public var contentType: Swift.String?
    /// The base64-encoded binary data used by the sender of the request message to identify which request the response message is for when it's received. correlationData is an HTTP header value in the API.
    public var correlationData: Swift.String?
    /// A user-defined integer value that represents the message expiry interval in seconds. If absent, the message doesn't expire. For more information about the limits of messageExpiry, see [Amazon Web Services IoT Core message broker and protocol limits and quotas ](https://docs.aws.amazon.com/general/latest/gr/iot-core.html#message-broker-limits) from the Amazon Web Services Reference Guide.
    public var messageExpiry: Swift.Int
    /// The message body. MQTT accepts text, binary, and empty (null) message payloads. Publishing an empty (null) payload with retain = true deletes the retained message identified by topic from Amazon Web Services IoT Core.
    public var payload: ClientRuntime.Data?
    /// An Enum string value that indicates whether the payload is formatted as UTF-8. payloadFormatIndicator is an HTTP header value in the API.
    public var payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator?
    /// The Quality of Service (QoS) level. The default QoS level is 0.
    public var qos: Swift.Int
    /// A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic which the receiver should publish to as part of the request-response flow. The topic must not contain wildcard characters.
    public var responseTopic: Swift.String?
    /// A Boolean value that determines whether to set the RETAIN flag when the message is published. Setting the RETAIN flag causes the message to be retained and sent to new subscribers to the topic. Valid values: true | false Default value: false
    public var retain: Swift.Bool
    /// The name of the MQTT topic.
    /// This member is required.
    public var topic: Swift.String?
    /// A JSON string that contains an array of JSON objects. If you donâ€™t use Amazon Web Services SDK or CLI, you must encode the JSON string to base64 format before adding it to the HTTP header. userProperties is an HTTP header value in the API. The following example userProperties parameter is a JSON string which represents two User Properties. Note that it needs to be base64-encoded: [{"deviceName": "alpha"}, {"deviceCnt": "45"}]
    public var userProperties: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        correlationData: Swift.String? = nil,
        messageExpiry: Swift.Int = 0,
        payload: ClientRuntime.Data? = nil,
        payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator? = nil,
        qos: Swift.Int = 0,
        responseTopic: Swift.String? = nil,
        retain: Swift.Bool = false,
        topic: Swift.String? = nil,
        userProperties: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.correlationData = correlationData
        self.messageExpiry = messageExpiry
        self.payload = payload
        self.payloadFormatIndicator = payloadFormatIndicator
        self.qos = qos
        self.responseTopic = responseTopic
        self.retain = retain
        self.topic = topic
        self.userProperties = userProperties
    }
}

struct PublishInputBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension PublishInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension PublishOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PublishOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PublishOutputResponse: Swift.Equatable {

    public init () { }
}

extension RequestEntityTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestEntityTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The payload exceeds the maximum size allowed.
public struct RequestEntityTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestEntityTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestEntityTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTDataPlaneClientTypes.RetainedMessageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedTime
        case payloadSize
        case qos
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if payloadSize != 0 {
            try encodeContainer.encode(payloadSize, forKey: .payloadSize)
        }
        if qos != 0 {
            try encodeContainer.encode(qos, forKey: .qos)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let payloadSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .payloadSize) ?? 0
        payloadSize = payloadSizeDecoded
        let qosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .qos) ?? 0
        qos = qosDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension IoTDataPlaneClientTypes {
    /// Information about a single retained message.
    public struct RetainedMessageSummary: Swift.Equatable {
        /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
        public var lastModifiedTime: Swift.Int
        /// The size of the retained message's payload in bytes.
        public var payloadSize: Swift.Int
        /// The quality of service (QoS) level used to publish the retained message.
        public var qos: Swift.Int
        /// The topic name to which the retained message was published.
        public var topic: Swift.String?

        public init (
            lastModifiedTime: Swift.Int = 0,
            payloadSize: Swift.Int = 0,
            qos: Swift.Int = 0,
            topic: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.payloadSize = payloadSize
            self.qos = qos
            self.topic = topic
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedDocumentEncodingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedDocumentEncodingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The document encoding is not supported.
public struct UnsupportedDocumentEncodingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message for the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedDocumentEncodingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedDocumentEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateThingShadowInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThingShadowInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThingShadowInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateThingShadowOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let payload = input.operationInput.payload {
            let payloaddata = payload
            let payloadbody = ClientRuntime.HttpBody.data(payloaddata)
            input.builder.withBody(payloadbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThingShadowInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThingShadowOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateThingShadowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = self.payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

extension UpdateThingShadowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let shadowName = shadowName {
                let shadowNameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
                items.append(shadowNameQueryItem)
            }
            return items
        }
    }
}

extension UpdateThingShadowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

/// The input for the UpdateThingShadow operation.
public struct UpdateThingShadowInput: Swift.Equatable {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: ClientRuntime.Data?
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init (
        payload: ClientRuntime.Data? = nil,
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.payload = payload
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

struct UpdateThingShadowInputBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension UpdateThingShadowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension UpdateThingShadowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThingShadowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestEntityTooLargeException" : self = .requestEntityTooLargeException(try RequestEntityTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedDocumentEncodingException" : self = .unsupportedDocumentEncodingException(try UnsupportedDocumentEncodingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThingShadowOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case methodNotAllowedException(MethodNotAllowedException)
    case requestEntityTooLargeException(RequestEntityTooLargeException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unsupportedDocumentEncodingException(UnsupportedDocumentEncodingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThingShadowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.payload = data
        } else {
            self.payload = nil
        }
    }
}

/// The output from the UpdateThingShadow operation.
public struct UpdateThingShadowOutputResponse: Swift.Equatable {
    /// The state information, in JSON format.
    public var payload: ClientRuntime.Data?

    public init (
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

struct UpdateThingShadowOutputResponseBody: Swift.Equatable {
    let payload: ClientRuntime.Data?
}

extension UpdateThingShadowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}
