// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified version does not match the version of the document.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeleteThingShadowInput {

    static func queryItemProvider(_ value: DeleteThingShadowInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension DeleteThingShadowInput {

    static func urlPathProvider(_ value: DeleteThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

/// The input for the DeleteThingShadow operation.
public struct DeleteThingShadowInput {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

extension DeleteThingShadowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteThingShadowOutput {
        var value = DeleteThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

/// The output from the DeleteThingShadow operation.
public struct DeleteThingShadowOutput {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: ClientRuntime.Data?

    public init(
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

enum DeleteThingShadowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRetainedMessageInput {

    static func urlPathProvider(_ value: GetRetainedMessageInput) -> Swift.String? {
        guard let topic = value.topic else {
            return nil
        }
        return "/retainedMessage/\(topic.urlPercentEncoding())"
    }
}

/// The input for the GetRetainedMessage operation.
public struct GetRetainedMessageInput {
    /// The topic name of the retained message to retrieve.
    /// This member is required.
    public var topic: Swift.String?

    public init(
        topic: Swift.String? = nil
    )
    {
        self.topic = topic
    }
}

extension GetRetainedMessageOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRetainedMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRetainedMessageOutput()
        value.lastModifiedTime = try reader["lastModifiedTime"].readIfPresent() ?? 0
        value.payload = try reader["payload"].readIfPresent()
        value.qos = try reader["qos"].readIfPresent() ?? 0
        value.topic = try reader["topic"].readIfPresent()
        value.userProperties = try reader["userProperties"].readIfPresent()
        return value
    }
}

/// The output from the GetRetainedMessage operation.
public struct GetRetainedMessageOutput {
    /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
    public var lastModifiedTime: Swift.Int
    /// The Base64-encoded message payload of the retained message body.
    public var payload: ClientRuntime.Data?
    /// The quality of service (QoS) level used to publish the retained message.
    public var qos: Swift.Int
    /// The topic name to which the retained message was published.
    public var topic: Swift.String?
    /// A base64-encoded JSON string that includes an array of JSON objects, or null if the retained message doesn't include any user properties. The following example userProperties parameter is a JSON string that represents two user properties. Note that it will be base64-encoded: [{"deviceName": "alpha"}, {"deviceCnt": "45"}]
    public var userProperties: ClientRuntime.Data?

    public init(
        lastModifiedTime: Swift.Int = 0,
        payload: ClientRuntime.Data? = nil,
        qos: Swift.Int = 0,
        topic: Swift.String? = nil,
        userProperties: ClientRuntime.Data? = nil
    )
    {
        self.lastModifiedTime = lastModifiedTime
        self.payload = payload
        self.qos = qos
        self.topic = topic
        self.userProperties = userProperties
    }
}

enum GetRetainedMessageOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetThingShadowInput {

    static func queryItemProvider(_ value: GetThingShadowInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension GetThingShadowInput {

    static func urlPathProvider(_ value: GetThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

/// The input for the GetThingShadow operation.
public struct GetThingShadowInput {
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

extension GetThingShadowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetThingShadowOutput {
        var value = GetThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

/// The output from the GetThingShadow operation.
public struct GetThingShadowOutput {
    /// The state information, in JSON format.
    public var payload: ClientRuntime.Data?

    public init(
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

enum GetThingShadowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum IoTDataPlaneClientTypes {}

extension ListNamedShadowsForThingInput {

    static func queryItemProvider(_ value: ListNamedShadowsForThingInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = value.pageSize {
            let pageSizeQueryItem = ClientRuntime.SDKURLQueryItem(name: "pageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListNamedShadowsForThingInput {

    static func urlPathProvider(_ value: ListNamedShadowsForThingInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/api/things/shadow/ListNamedShadowsForThing/\(thingName.urlPercentEncoding())"
    }
}

public struct ListNamedShadowsForThingInput {
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The result page size.
    public var pageSize: Swift.Int?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.thingName = thingName
    }
}

extension ListNamedShadowsForThingOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNamedShadowsForThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamedShadowsForThingOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestamp = try reader["timestamp"].readIfPresent() ?? 0
        return value
    }
}

public struct ListNamedShadowsForThingOutput {
    /// The token to use to get the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// The list of shadows for the specified thing.
    public var results: [Swift.String]?
    /// The Epoch date and time the response was generated by IoT.
    public var timestamp: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        results: [Swift.String]? = nil,
        timestamp: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.results = results
        self.timestamp = timestamp
    }
}

enum ListNamedShadowsForThingOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRetainedMessagesInput {

    static func queryItemProvider(_ value: ListRetainedMessagesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRetainedMessagesInput {

    static func urlPathProvider(_ value: ListRetainedMessagesInput) -> Swift.String? {
        return "/retainedMessage"
    }
}

public struct ListRetainedMessagesInput {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// To retrieve the next set of results, the nextToken value from a previous response; otherwise null to receive the first set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListRetainedMessagesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRetainedMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRetainedMessagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.retainedTopics = try reader["retainedTopics"].readListIfPresent(memberReadingClosure: IoTDataPlaneClientTypes.RetainedMessageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListRetainedMessagesOutput {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A summary list the account's retained messages. The information returned doesn't include the message payloads of the retained messages.
    public var retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        retainedTopics: [IoTDataPlaneClientTypes.RetainedMessageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.retainedTopics = retainedTopics
    }
}

enum ListRetainedMessagesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension MethodNotAllowedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> MethodNotAllowedException {
        let reader = baseError.errorBodyReader
        var value = MethodNotAllowedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified combination of HTTP verb and URI is not supported.
public struct MethodNotAllowedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MethodNotAllowedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTDataPlaneClientTypes {

    public enum PayloadFormatIndicator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case unspecifiedBytes
        case utf8Data
        case sdkUnknown(Swift.String)

        public static var allCases: [PayloadFormatIndicator] {
            return [
                .unspecifiedBytes,
                .utf8Data,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .unspecifiedBytes: return "UNSPECIFIED_BYTES"
            case .utf8Data: return "UTF8_DATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PublishInput {

    static func headerProvider(_ value: PublishInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let correlationData = value.correlationData {
            items.add(Header(name: "x-amz-mqtt5-correlation-data", value: Swift.String(correlationData)))
        }
        if let payloadFormatIndicator = value.payloadFormatIndicator {
            items.add(Header(name: "x-amz-mqtt5-payload-format-indicator", value: Swift.String(payloadFormatIndicator.rawValue)))
        }
        if let userProperties = value.userProperties {
            do {
                let base64EncodedValue = try userProperties.base64EncodedString()
                items.add(Header(name: "x-amz-mqtt5-user-properties", value: Swift.String(base64EncodedValue)))
            } catch let err {
            }
        }
        return items
    }
}

extension PublishInput {

    static func queryItemProvider(_ value: PublishInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let qos = value.qos {
            let qosQueryItem = ClientRuntime.SDKURLQueryItem(name: "qos".urlPercentEncoding(), value: Swift.String(qos).urlPercentEncoding())
            items.append(qosQueryItem)
        }
        if let retain = value.retain {
            let retainQueryItem = ClientRuntime.SDKURLQueryItem(name: "retain".urlPercentEncoding(), value: Swift.String(retain).urlPercentEncoding())
            items.append(retainQueryItem)
        }
        if let responseTopic = value.responseTopic {
            let responseTopicQueryItem = ClientRuntime.SDKURLQueryItem(name: "responseTopic".urlPercentEncoding(), value: Swift.String(responseTopic).urlPercentEncoding())
            items.append(responseTopicQueryItem)
        }
        if let contentType = value.contentType {
            let contentTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "contentType".urlPercentEncoding(), value: Swift.String(contentType).urlPercentEncoding())
            items.append(contentTypeQueryItem)
        }
        if let messageExpiry = value.messageExpiry {
            let messageExpiryQueryItem = ClientRuntime.SDKURLQueryItem(name: "messageExpiry".urlPercentEncoding(), value: Swift.String(messageExpiry).urlPercentEncoding())
            items.append(messageExpiryQueryItem)
        }
        return items
    }
}

extension PublishInput {

    static func urlPathProvider(_ value: PublishInput) -> Swift.String? {
        guard let topic = value.topic else {
            return nil
        }
        return "/topics/\(topic.urlPercentEncoding())"
    }
}

extension PublishInput {

    static func write(value: PublishInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

/// The input for the Publish operation.
public struct PublishInput {
    /// A UTF-8 encoded string that describes the content of the publishing message.
    public var contentType: Swift.String?
    /// The base64-encoded binary data used by the sender of the request message to identify which request the response message is for when it's received. correlationData is an HTTP header value in the API.
    public var correlationData: Swift.String?
    /// A user-defined integer value that represents the message expiry interval in seconds. If absent, the message doesn't expire. For more information about the limits of messageExpiry, see [Amazon Web Services IoT Core message broker and protocol limits and quotas ](https://docs.aws.amazon.com/general/latest/gr/iot-core.html#message-broker-limits) from the Amazon Web Services Reference Guide.
    public var messageExpiry: Swift.Int?
    /// The message body. MQTT accepts text, binary, and empty (null) message payloads. Publishing an empty (null) payload with retain = true deletes the retained message identified by topic from Amazon Web Services IoT Core.
    public var payload: ClientRuntime.Data?
    /// An Enum string value that indicates whether the payload is formatted as UTF-8. payloadFormatIndicator is an HTTP header value in the API.
    public var payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator?
    /// The Quality of Service (QoS) level. The default QoS level is 0.
    public var qos: Swift.Int?
    /// A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic which the receiver should publish to as part of the request-response flow. The topic must not contain wildcard characters.
    public var responseTopic: Swift.String?
    /// A Boolean value that determines whether to set the RETAIN flag when the message is published. Setting the RETAIN flag causes the message to be retained and sent to new subscribers to the topic. Valid values: true | false Default value: false
    public var retain: Swift.Bool?
    /// The name of the MQTT topic.
    /// This member is required.
    public var topic: Swift.String?
    /// A JSON string that contains an array of JSON objects. If you donâ€™t use Amazon Web Services SDK or CLI, you must encode the JSON string to base64 format before adding it to the HTTP header. userProperties is an HTTP header value in the API. The following example userProperties parameter is a JSON string which represents two User Properties. Note that it needs to be base64-encoded: [{"deviceName": "alpha"}, {"deviceCnt": "45"}]
    public var userProperties: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        correlationData: Swift.String? = nil,
        messageExpiry: Swift.Int? = nil,
        payload: ClientRuntime.Data? = nil,
        payloadFormatIndicator: IoTDataPlaneClientTypes.PayloadFormatIndicator? = nil,
        qos: Swift.Int? = nil,
        responseTopic: Swift.String? = nil,
        retain: Swift.Bool? = nil,
        topic: Swift.String? = nil,
        userProperties: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.correlationData = correlationData
        self.messageExpiry = messageExpiry
        self.payload = payload
        self.payloadFormatIndicator = payloadFormatIndicator
        self.qos = qos
        self.responseTopic = responseTopic
        self.retain = retain
        self.topic = topic
        self.userProperties = userProperties
    }
}

extension PublishOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PublishOutput {
        return PublishOutput()
    }
}

public struct PublishOutput {

    public init() { }
}

enum PublishOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RequestEntityTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestEntityTooLargeException {
        let reader = baseError.errorBodyReader
        var value = RequestEntityTooLargeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The payload exceeds the maximum size allowed.
public struct RequestEntityTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestEntityTooLargeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTDataPlaneClientTypes.RetainedMessageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTDataPlaneClientTypes.RetainedMessageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTDataPlaneClientTypes.RetainedMessageSummary()
        value.topic = try reader["topic"].readIfPresent()
        value.payloadSize = try reader["payloadSize"].readIfPresent() ?? 0
        value.qos = try reader["qos"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["lastModifiedTime"].readIfPresent() ?? 0
        return value
    }
}

extension IoTDataPlaneClientTypes {
    /// Information about a single retained message.
    public struct RetainedMessageSummary {
        /// The Epoch date and time, in milliseconds, when the retained message was stored by IoT.
        public var lastModifiedTime: Swift.Int
        /// The size of the retained message's payload in bytes.
        public var payloadSize: Swift.Int
        /// The quality of service (QoS) level used to publish the retained message.
        public var qos: Swift.Int
        /// The topic name to which the retained message was published.
        public var topic: Swift.String?

        public init(
            lastModifiedTime: Swift.Int = 0,
            payloadSize: Swift.Int = 0,
            qos: Swift.Int = 0,
            topic: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.payloadSize = payloadSize
            self.qos = qos
            self.topic = topic
        }
    }

}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnsupportedDocumentEncodingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedDocumentEncodingException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedDocumentEncodingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The document encoding is not supported.
public struct UnsupportedDocumentEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The message for the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedDocumentEncodingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UpdateThingShadowInput {

    static func queryItemProvider(_ value: UpdateThingShadowInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let shadowName = value.shadowName {
            let shadowNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(shadowName).urlPercentEncoding())
            items.append(shadowNameQueryItem)
        }
        return items
    }
}

extension UpdateThingShadowInput {

    static func urlPathProvider(_ value: UpdateThingShadowInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/things/\(thingName.urlPercentEncoding())/shadow"
    }
}

extension UpdateThingShadowInput {

    static func write(value: UpdateThingShadowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
    }
}

/// The input for the UpdateThingShadow operation.
public struct UpdateThingShadowInput {
    /// The state information, in JSON format.
    /// This member is required.
    public var payload: ClientRuntime.Data?
    /// The name of the shadow.
    public var shadowName: Swift.String?
    /// The name of the thing.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        payload: ClientRuntime.Data? = nil,
        shadowName: Swift.String? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.payload = payload
        self.shadowName = shadowName
        self.thingName = thingName
    }
}

extension UpdateThingShadowOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateThingShadowOutput {
        var value = UpdateThingShadowOutput()
        switch httpResponse.body {
        case .data(let data):
            value.payload = data
        case .stream(let stream):
            value.payload = try stream.readToEnd()
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

/// The output from the UpdateThingShadow operation.
public struct UpdateThingShadowOutput {
    /// The state information, in JSON format.
    public var payload: ClientRuntime.Data?

    public init(
        payload: ClientRuntime.Data? = nil
    )
    {
        self.payload = payload
    }
}

enum UpdateThingShadowOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MethodNotAllowedException": return try MethodNotAllowedException.makeError(baseError: baseError)
            case "RequestEntityTooLargeException": return try RequestEntityTooLargeException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnsupportedDocumentEncodingException": return try UnsupportedDocumentEncodingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}
