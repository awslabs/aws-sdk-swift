//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access to perform this action. Make sure you have the required permissions and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Occurs when a conflict with the current status of your resource. Fix any inconsistencies with your resource and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the conflict.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Occurs when there is an internal failure in the Oracle Database@Amazon Web Services service. Wait and try again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request after an internal server error.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request after being throttled.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension OdbClientTypes {

    /// The input failed to meet the constraints specified by the service in a specified field. Make sure you provided the correct input and try again.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name for which validation failed.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension OdbClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request has failed validation because it is missing required fields or has invalid inputs.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [OdbClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why the validation failed.
        /// This member is required.
        public internal(set) var reason: OdbClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [OdbClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: OdbClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcceptMarketplaceRegistrationInput: Swift.Sendable {
    /// The registration token that's generated by Amazon Web Services Marketplace and sent to Oracle Database@Amazon Web Services.
    /// This member is required.
    public var marketplaceRegistrationToken: Swift.String?

    public init(
        marketplaceRegistrationToken: Swift.String? = nil
    ) {
        self.marketplaceRegistrationToken = marketplaceRegistrationToken
    }
}

public struct AcceptMarketplaceRegistrationOutput: Swift.Sendable {

    public init() { }
}

extension OdbClientTypes {

    public enum Access: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Access] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum ResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case failed
        case maintenanceInProgress
        case provisioning
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .failed,
                .maintenanceInProgress,
                .provisioning,
                .terminated,
                .terminating,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .failed: return "FAILED"
            case .maintenanceInProgress: return "MAINTENANCE_IN_PROGRESS"
            case .provisioning: return "PROVISIONING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// A summary of an Autonomous Virtual Machine (VM) within an Autonomous VM cluster.
    public struct AutonomousVirtualMachineSummary: Swift.Sendable {
        /// The unique identifier of the Autonomous VM.
        public var autonomousVirtualMachineId: Swift.String?
        /// The IP address used by clients to connect to this Autonomous VM.
        public var clientIpAddress: Swift.String?
        /// The unique identifier of the Autonomous VM cluster containing this Autonomous VM.
        public var cloudAutonomousVmClusterId: Swift.String?
        /// The number of CPU cores allocated to this Autonomous VM.
        public var cpuCoreCount: Swift.Int?
        /// The amount of storage allocated to this Autonomous Virtual Machine, in gigabytes (GB).
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The display name of the database server hosting this Autonomous VM.
        public var dbServerDisplayName: Swift.String?
        /// The unique identifier of the database server hosting this Autonomous VM.
        public var dbServerId: Swift.String?
        /// The amount of memory allocated to this Autonomous VM, in gigabytes (GB).
        public var memorySizeInGBs: Swift.Int?
        /// The name of the Oracle Cloud Infrastructure (OCI) resource anchor associated with this Autonomous VM.
        public var ociResourceAnchorName: Swift.String?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM.
        public var ocid: Swift.String?
        /// The current status of the Autonomous VM.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the Autonomous VM, if applicable.
        public var statusReason: Swift.String?
        /// The name of the Autonomous VM.
        public var vmName: Swift.String?

        public init(
            autonomousVirtualMachineId: Swift.String? = nil,
            clientIpAddress: Swift.String? = nil,
            cloudAutonomousVmClusterId: Swift.String? = nil,
            cpuCoreCount: Swift.Int? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerDisplayName: Swift.String? = nil,
            dbServerId: Swift.String? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ocid: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            vmName: Swift.String? = nil
        ) {
            self.autonomousVirtualMachineId = autonomousVirtualMachineId
            self.clientIpAddress = clientIpAddress
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cpuCoreCount = cpuCoreCount
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerDisplayName = dbServerDisplayName
            self.dbServerId = dbServerId
            self.memorySizeInGBs = memorySizeInGBs
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ocid = ocid
            self.status = status
            self.statusReason = statusReason
            self.vmName = vmName
        }
    }
}

extension OdbClientTypes {

    public enum ComputeModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ecpu
        case ocpu
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeModel] {
            return [
                .ecpu,
                .ocpu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ecpu: return "ECPU"
            case .ocpu: return "OCPU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum LicenseModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bringYourOwnLicense
        case licenseIncluded
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseModel] {
            return [
                .bringYourOwnLicense,
                .licenseIncluded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bringYourOwnLicense: return "BRING_YOUR_OWN_LICENSE"
            case .licenseIncluded: return "LICENSE_INCLUDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum DayOfWeekName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeekName] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// An enumeration of days of the week used for scheduling maintenance windows.
    public struct DayOfWeek: Swift.Sendable {
        /// The name of the day of the week.
        public var name: OdbClientTypes.DayOfWeekName?

        public init(
            name: OdbClientTypes.DayOfWeekName? = nil
        ) {
            self.name = name
        }
    }
}

extension OdbClientTypes {

    public enum MonthName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case april
        case august
        case december
        case february
        case january
        case july
        case june
        case march
        case may
        case november
        case october
        case september
        case sdkUnknown(Swift.String)

        public static var allCases: [MonthName] {
            return [
                .april,
                .august,
                .december,
                .february,
                .january,
                .july,
                .june,
                .march,
                .may,
                .november,
                .october,
                .september
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .april: return "APRIL"
            case .august: return "AUGUST"
            case .december: return "DECEMBER"
            case .february: return "FEBRUARY"
            case .january: return "JANUARY"
            case .july: return "JULY"
            case .june: return "JUNE"
            case .march: return "MARCH"
            case .may: return "MAY"
            case .november: return "NOVEMBER"
            case .october: return "OCTOBER"
            case .september: return "SEPTEMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// An enumeration of months used for scheduling maintenance windows.
    public struct Month: Swift.Sendable {
        /// The name of the month.
        public var name: OdbClientTypes.MonthName?

        public init(
            name: OdbClientTypes.MonthName? = nil
        ) {
            self.name = name
        }
    }
}

extension OdbClientTypes {

    public enum PatchingModeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonrolling
        case rolling
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchingModeType] {
            return [
                .nonrolling,
                .rolling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonrolling: return "NONROLLING"
            case .rolling: return "ROLLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum PreferenceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customPreference
        case noPreference
        case sdkUnknown(Swift.String)

        public static var allCases: [PreferenceType] {
            return [
                .customPreference,
                .noPreference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customPreference: return "CUSTOM_PREFERENCE"
            case .noPreference: return "NO_PREFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
    public struct MaintenanceWindow: Swift.Sendable {
        /// The custom action timeout in minutes for the maintenance window.
        public var customActionTimeoutInMins: Swift.Int?
        /// The days of the week when maintenance can be performed.
        public var daysOfWeek: [OdbClientTypes.DayOfWeek]?
        /// The hours of the day when maintenance can be performed.
        public var hoursOfDay: [Swift.Int]?
        /// Indicates whether custom action timeout is enabled for the maintenance window.
        public var isCustomActionTimeoutEnabled: Swift.Bool?
        /// The lead time in weeks before the maintenance window.
        public var leadTimeInWeeks: Swift.Int?
        /// The months when maintenance can be performed.
        public var months: [OdbClientTypes.Month]?
        /// The patching mode for the maintenance window.
        public var patchingMode: OdbClientTypes.PatchingModeType?
        /// The preference for the maintenance window scheduling.
        public var preference: OdbClientTypes.PreferenceType?
        /// Indicates whether to skip release updates during maintenance.
        public var skipRu: Swift.Bool?
        /// The weeks of the month when maintenance can be performed.
        public var weeksOfMonth: [Swift.Int]?

        public init(
            customActionTimeoutInMins: Swift.Int? = nil,
            daysOfWeek: [OdbClientTypes.DayOfWeek]? = nil,
            hoursOfDay: [Swift.Int]? = nil,
            isCustomActionTimeoutEnabled: Swift.Bool? = nil,
            leadTimeInWeeks: Swift.Int? = nil,
            months: [OdbClientTypes.Month]? = nil,
            patchingMode: OdbClientTypes.PatchingModeType? = nil,
            preference: OdbClientTypes.PreferenceType? = nil,
            skipRu: Swift.Bool? = nil,
            weeksOfMonth: [Swift.Int]? = nil
        ) {
            self.customActionTimeoutInMins = customActionTimeoutInMins
            self.daysOfWeek = daysOfWeek
            self.hoursOfDay = hoursOfDay
            self.isCustomActionTimeoutEnabled = isCustomActionTimeoutEnabled
            self.leadTimeInWeeks = leadTimeInWeeks
            self.months = months
            self.patchingMode = patchingMode
            self.preference = preference
            self.skipRu = skipRu
            self.weeksOfMonth = weeksOfMonth
        }
    }
}

extension OdbClientTypes {

    /// Information about an Autonomous VM cluster resource.
    public struct CloudAutonomousVmCluster: Swift.Sendable {
        /// The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.
        public var autonomousDataStoragePercentage: Swift.Float?
        /// The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.
        public var autonomousDataStorageSizeInTBs: Swift.Double?
        /// The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.
        public var availableAutonomousDataStorageSizeInTBs: Swift.Double?
        /// The number of Autonomous CDBs that you can create with the currently available storage.
        public var availableContainerDatabases: Swift.Int?
        /// The number of CPU cores available for allocation to Autonomous Databases.
        public var availableCpus: Swift.Float?
        /// The Amazon Resource Name (ARN) for the Autonomous VM cluster.
        public var cloudAutonomousVmClusterArn: Swift.String?
        /// The unique identifier of the Autonomous VM cluster.
        /// This member is required.
        public var cloudAutonomousVmClusterId: Swift.String?
        /// The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The compute model of the Autonomous VM cluster: ECPU or OCPU.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The total number of CPU cores in the Autonomous VM cluster.
        public var cpuCoreCount: Swift.Int?
        /// The number of CPU cores enabled per node in the Autonomous VM cluster.
        public var cpuCoreCountPerNode: Swift.Int?
        /// The percentage of total CPU cores currently in use in the Autonomous VM cluster.
        public var cpuPercentage: Swift.Float?
        /// The date and time when the Autonomous VM cluster was created.
        public var createdAt: Foundation.Date?
        /// The total data storage allocated to the Autonomous VM cluster, in GB.
        public var dataStorageSizeInGBs: Swift.Double?
        /// The total data storage allocated to the Autonomous VM cluster, in TB.
        public var dataStorageSizeInTBs: Swift.Double?
        /// The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The list of database servers associated with the Autonomous VM cluster.
        public var dbServers: [Swift.String]?
        /// The user-provided description of the Autonomous VM cluster.
        public var description: Swift.String?
        /// The display name of the Autonomous VM cluster.
        public var displayName: Swift.String?
        /// The domain name for the Autonomous VM cluster.
        public var domain: Swift.String?
        /// The minimum value to which you can scale down the Exadata storage, in TB.
        public var exadataStorageInTBsLowestScaledValue: Swift.Double?
        /// The hostname for the Autonomous VM cluster.
        public var hostname: Swift.String?
        /// Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.
        public var isMtlsEnabledVmCluster: Swift.Bool?
        /// The Oracle license model that applies to the Autonomous VM cluster. Valid values are LICENSE_INCLUDED or BRING_YOUR_OWN_LICENSE.
        public var licenseModel: OdbClientTypes.LicenseModel?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
        /// The minimum value to which you can scale down the maximum number of Autonomous CDBs.
        public var maxAcdsLowestScaledValue: Swift.Int?
        /// The amount of memory allocated per Oracle Compute Unit, in GB.
        public var memoryPerOracleComputeUnitInGBs: Swift.Int?
        /// The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).
        public var memorySizeInGBs: Swift.Int?
        /// The number of database server nodes in the Autonomous VM cluster.
        public var nodeCount: Swift.Int?
        /// The number of Autonomous CDBs that can't be provisioned because of resource constraints.
        public var nonProvisionableAutonomousContainerDatabases: Swift.Int?
        /// The name of the OCI resource anchor associated with this Autonomous VM cluster.
        public var ociResourceAnchorName: Swift.String?
        /// The URL for accessing the OCI console page for this Autonomous VM cluster.
        public var ociUrl: Swift.String?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.
        public var ocid: Swift.String?
        /// The unique identifier of the ODB network associated with this Autonomous VM cluster.
        public var odbNetworkId: Swift.String?
        /// The progress of the current operation on the Autonomous VM cluster, as a percentage.
        public var percentProgress: Swift.Float?
        /// The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.
        public var provisionableAutonomousContainerDatabases: Swift.Int?
        /// The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.
        public var provisionedAutonomousContainerDatabases: Swift.Int?
        /// The number of CPU cores currently provisioned in the Autonomous VM cluster.
        public var provisionedCpus: Swift.Float?
        /// The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.
        public var reclaimableCpus: Swift.Float?
        /// The number of CPU cores reserved for system operations and redundancy.
        public var reservedCpus: Swift.Float?
        /// The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.
        public var scanListenerPortNonTls: Swift.Int?
        /// The SCAN listener port for TLS (TCP) protocol. The default is 2484.
        public var scanListenerPortTls: Swift.Int?
        /// The shape of the Exadata infrastructure for the Autonomous VM cluster.
        public var shape: Swift.String?
        /// The current state of the Autonomous VM cluster. Possible values include CREATING, AVAILABLE, UPDATING, DELETING, DELETED, FAILED.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the Autonomous VM cluster.
        public var statusReason: Swift.String?
        /// The expiration date and time of the database SSL certificate.
        public var timeDatabaseSslCertificateExpires: Foundation.Date?
        /// The expiration date and time of the Oracle REST Data Services (ORDS) certificate.
        public var timeOrdsCertificateExpires: Foundation.Date?
        /// The time zone of the Autonomous VM cluster.
        public var timeZone: Swift.String?
        /// The total number of Autonomous Container Databases that can be created with the allocated local storage.
        public var totalContainerDatabases: Swift.Int?

        public init(
            autonomousDataStoragePercentage: Swift.Float? = nil,
            autonomousDataStorageSizeInTBs: Swift.Double? = nil,
            availableAutonomousDataStorageSizeInTBs: Swift.Double? = nil,
            availableContainerDatabases: Swift.Int? = nil,
            availableCpus: Swift.Float? = nil,
            cloudAutonomousVmClusterArn: Swift.String? = nil,
            cloudAutonomousVmClusterId: Swift.String? = nil,
            cloudExadataInfrastructureId: Swift.String? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            cpuCoreCountPerNode: Swift.Int? = nil,
            cpuPercentage: Swift.Float? = nil,
            createdAt: Foundation.Date? = nil,
            dataStorageSizeInGBs: Swift.Double? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServers: [Swift.String]? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domain: Swift.String? = nil,
            exadataStorageInTBsLowestScaledValue: Swift.Double? = nil,
            hostname: Swift.String? = nil,
            isMtlsEnabledVmCluster: Swift.Bool? = nil,
            licenseModel: OdbClientTypes.LicenseModel? = nil,
            maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
            maxAcdsLowestScaledValue: Swift.Int? = nil,
            memoryPerOracleComputeUnitInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            nonProvisionableAutonomousContainerDatabases: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            provisionableAutonomousContainerDatabases: Swift.Int? = nil,
            provisionedAutonomousContainerDatabases: Swift.Int? = nil,
            provisionedCpus: Swift.Float? = nil,
            reclaimableCpus: Swift.Float? = nil,
            reservedCpus: Swift.Float? = nil,
            scanListenerPortNonTls: Swift.Int? = nil,
            scanListenerPortTls: Swift.Int? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            timeDatabaseSslCertificateExpires: Foundation.Date? = nil,
            timeOrdsCertificateExpires: Foundation.Date? = nil,
            timeZone: Swift.String? = nil,
            totalContainerDatabases: Swift.Int? = nil
        ) {
            self.autonomousDataStoragePercentage = autonomousDataStoragePercentage
            self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
            self.availableAutonomousDataStorageSizeInTBs = availableAutonomousDataStorageSizeInTBs
            self.availableContainerDatabases = availableContainerDatabases
            self.availableCpus = availableCpus
            self.cloudAutonomousVmClusterArn = cloudAutonomousVmClusterArn
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.cpuCoreCountPerNode = cpuCoreCountPerNode
            self.cpuPercentage = cpuPercentage
            self.createdAt = createdAt
            self.dataStorageSizeInGBs = dataStorageSizeInGBs
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.description = description
            self.displayName = displayName
            self.domain = domain
            self.exadataStorageInTBsLowestScaledValue = exadataStorageInTBsLowestScaledValue
            self.hostname = hostname
            self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
            self.licenseModel = licenseModel
            self.maintenanceWindow = maintenanceWindow
            self.maxAcdsLowestScaledValue = maxAcdsLowestScaledValue
            self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.nonProvisionableAutonomousContainerDatabases = nonProvisionableAutonomousContainerDatabases
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.provisionableAutonomousContainerDatabases = provisionableAutonomousContainerDatabases
            self.provisionedAutonomousContainerDatabases = provisionedAutonomousContainerDatabases
            self.provisionedCpus = provisionedCpus
            self.reclaimableCpus = reclaimableCpus
            self.reservedCpus = reservedCpus
            self.scanListenerPortNonTls = scanListenerPortNonTls
            self.scanListenerPortTls = scanListenerPortTls
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.timeDatabaseSslCertificateExpires = timeDatabaseSslCertificateExpires
            self.timeOrdsCertificateExpires = timeOrdsCertificateExpires
            self.timeZone = timeZone
            self.totalContainerDatabases = totalContainerDatabases
        }
    }
}

extension OdbClientTypes {

    /// A summary of an Autonomous VM cluster.
    public struct CloudAutonomousVmClusterSummary: Swift.Sendable {
        /// The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.
        public var autonomousDataStoragePercentage: Swift.Float?
        /// The total data storage allocated for Autonomous Databases in the Autonomous VM cluster, in TB.
        public var autonomousDataStorageSizeInTBs: Swift.Double?
        /// The available data storage for Autonomous Databases in the Autonomous VM cluster, in TB.
        public var availableAutonomousDataStorageSizeInTBs: Swift.Double?
        /// The number of Autonomous Container Databases that you can create with the currently available storage.
        public var availableContainerDatabases: Swift.Int?
        /// The number of CPU cores available for allocation to Autonomous Databases.
        public var availableCpus: Swift.Float?
        /// The Amazon Resource Name (ARN) for the Autonomous VM cluster.
        public var cloudAutonomousVmClusterArn: Swift.String?
        /// The unique identifier of the Autonomous VM cluster.
        /// This member is required.
        public var cloudAutonomousVmClusterId: Swift.String?
        /// The unique identifier of the Exadata infrastructure containing this Autonomous VM cluster.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The compute model of the Autonomous VM cluster: ECPU or OCPU.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The total number of CPU cores in the Autonomous VM cluster.
        public var cpuCoreCount: Swift.Int?
        /// The number of CPU cores per node in the Autonomous VM cluster.
        public var cpuCoreCountPerNode: Swift.Int?
        /// The percentage of total CPU cores currently in use in the Autonomous VM cluster.
        public var cpuPercentage: Swift.Float?
        /// The date and time when the Autonomous VM cluster was created.
        public var createdAt: Foundation.Date?
        /// The total data storage allocated to the Autonomous VM cluster, in GB.
        public var dataStorageSizeInGBs: Swift.Double?
        /// The total data storage allocated to the Autonomous VM cluster, in TB.
        public var dataStorageSizeInTBs: Swift.Double?
        /// The local node storage allocated to the Autonomous VM cluster, in GB.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The list of database servers associated with the Autonomous VM cluster.
        public var dbServers: [Swift.String]?
        /// The user-provided description of the Autonomous VM cluster.
        public var description: Swift.String?
        /// The user-friendly name for the Autonomous VM cluster.
        public var displayName: Swift.String?
        /// The domain name for the Autonomous VM cluster.
        public var domain: Swift.String?
        /// The lowest value to which Exadata storage can be scaled down, in TB.
        public var exadataStorageInTBsLowestScaledValue: Swift.Double?
        /// The host name for the Autonomous VM cluster.
        public var hostname: Swift.String?
        /// Indicates if mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.
        public var isMtlsEnabledVmCluster: Swift.Bool?
        /// The Oracle license model that applies to the Autonomous VM cluster.
        public var licenseModel: OdbClientTypes.LicenseModel?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
        /// The lowest value to which you can scale down the maximum number of Autonomous CDBs.
        public var maxAcdsLowestScaledValue: Swift.Int?
        /// The amount of memory allocated per Oracle Compute Unit (OCU), in GB.
        public var memoryPerOracleComputeUnitInGBs: Swift.Int?
        /// The total amount of memory allocated to the Autonomous VM cluster, in GB.
        public var memorySizeInGBs: Swift.Int?
        /// The number of database server nodes in the Autonomous VM cluster.
        public var nodeCount: Swift.Int?
        /// The number of Autonomous CDBs that can't be provisioned because of resource constraints.
        public var nonProvisionableAutonomousContainerDatabases: Swift.Int?
        /// The name of the OCI resource anchor associated with this Autonomous VM cluster.
        public var ociResourceAnchorName: Swift.String?
        /// The URL for accessing the OCI console page for this Autonomous VM cluster.
        public var ociUrl: Swift.String?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.
        public var ocid: Swift.String?
        /// The unique identifier of the ODB network associated with this Autonomous VM cluster.
        public var odbNetworkId: Swift.String?
        /// The progress of the current operation on the Autonomous VM cluster, as a percentage.
        public var percentProgress: Swift.Float?
        /// The number of Autonomous CDBs that you can provision in the Autonomous VM cluster.
        public var provisionableAutonomousContainerDatabases: Swift.Int?
        /// The number of Autonomous Container Databases currently provisioned in the Autonomous VM cluster.
        public var provisionedAutonomousContainerDatabases: Swift.Int?
        /// The number of CPUs currently provisioned in the Autonomous VM cluster.
        public var provisionedCpus: Swift.Float?
        /// The number of CPUs that can be reclaimed from terminated or scaled-down Autonomous Databases.
        public var reclaimableCpus: Swift.Float?
        /// The number of CPUs reserved for system operations and redundancy.
        public var reservedCpus: Swift.Float?
        /// The SCAN listener port for non-TLS (TCP) protocol.
        public var scanListenerPortNonTls: Swift.Int?
        /// The SCAN listener port for TLS (TCP) protocol.
        public var scanListenerPortTls: Swift.Int?
        /// The shape of the Exadata infrastructure for the Autonomous VM cluster.
        public var shape: Swift.String?
        /// The current status of the Autonomous VM cluster.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the Autonomous VM cluster, if applicable.
        public var statusReason: Swift.String?
        /// The expiration date and time of the database SSL certificate.
        public var timeDatabaseSslCertificateExpires: Foundation.Date?
        /// The expiration date and time of the Oracle REST Data Services (ORDS) certificate.
        public var timeOrdsCertificateExpires: Foundation.Date?
        /// The time zone of the Autonomous VM cluster.
        public var timeZone: Swift.String?
        /// The total number of Autonomous Container Databases that can be created in the Autonomous VM cluster.
        public var totalContainerDatabases: Swift.Int?

        public init(
            autonomousDataStoragePercentage: Swift.Float? = nil,
            autonomousDataStorageSizeInTBs: Swift.Double? = nil,
            availableAutonomousDataStorageSizeInTBs: Swift.Double? = nil,
            availableContainerDatabases: Swift.Int? = nil,
            availableCpus: Swift.Float? = nil,
            cloudAutonomousVmClusterArn: Swift.String? = nil,
            cloudAutonomousVmClusterId: Swift.String? = nil,
            cloudExadataInfrastructureId: Swift.String? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            cpuCoreCountPerNode: Swift.Int? = nil,
            cpuPercentage: Swift.Float? = nil,
            createdAt: Foundation.Date? = nil,
            dataStorageSizeInGBs: Swift.Double? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServers: [Swift.String]? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domain: Swift.String? = nil,
            exadataStorageInTBsLowestScaledValue: Swift.Double? = nil,
            hostname: Swift.String? = nil,
            isMtlsEnabledVmCluster: Swift.Bool? = nil,
            licenseModel: OdbClientTypes.LicenseModel? = nil,
            maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
            maxAcdsLowestScaledValue: Swift.Int? = nil,
            memoryPerOracleComputeUnitInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            nonProvisionableAutonomousContainerDatabases: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            provisionableAutonomousContainerDatabases: Swift.Int? = nil,
            provisionedAutonomousContainerDatabases: Swift.Int? = nil,
            provisionedCpus: Swift.Float? = nil,
            reclaimableCpus: Swift.Float? = nil,
            reservedCpus: Swift.Float? = nil,
            scanListenerPortNonTls: Swift.Int? = nil,
            scanListenerPortTls: Swift.Int? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            timeDatabaseSslCertificateExpires: Foundation.Date? = nil,
            timeOrdsCertificateExpires: Foundation.Date? = nil,
            timeZone: Swift.String? = nil,
            totalContainerDatabases: Swift.Int? = nil
        ) {
            self.autonomousDataStoragePercentage = autonomousDataStoragePercentage
            self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
            self.availableAutonomousDataStorageSizeInTBs = availableAutonomousDataStorageSizeInTBs
            self.availableContainerDatabases = availableContainerDatabases
            self.availableCpus = availableCpus
            self.cloudAutonomousVmClusterArn = cloudAutonomousVmClusterArn
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.cpuCoreCountPerNode = cpuCoreCountPerNode
            self.cpuPercentage = cpuPercentage
            self.createdAt = createdAt
            self.dataStorageSizeInGBs = dataStorageSizeInGBs
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.description = description
            self.displayName = displayName
            self.domain = domain
            self.exadataStorageInTBsLowestScaledValue = exadataStorageInTBsLowestScaledValue
            self.hostname = hostname
            self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
            self.licenseModel = licenseModel
            self.maintenanceWindow = maintenanceWindow
            self.maxAcdsLowestScaledValue = maxAcdsLowestScaledValue
            self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.nonProvisionableAutonomousContainerDatabases = nonProvisionableAutonomousContainerDatabases
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.provisionableAutonomousContainerDatabases = provisionableAutonomousContainerDatabases
            self.provisionedAutonomousContainerDatabases = provisionedAutonomousContainerDatabases
            self.provisionedCpus = provisionedCpus
            self.reclaimableCpus = reclaimableCpus
            self.reservedCpus = reservedCpus
            self.scanListenerPortNonTls = scanListenerPortNonTls
            self.scanListenerPortTls = scanListenerPortTls
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.timeDatabaseSslCertificateExpires = timeDatabaseSslCertificateExpires
            self.timeOrdsCertificateExpires = timeOrdsCertificateExpires
            self.timeZone = timeZone
            self.totalContainerDatabases = totalContainerDatabases
        }
    }
}

/// The operation tried to access a resource that doesn't exist. Make sure you provided the correct resource and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// You have exceeded the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unqiue identifier of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded the service quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that exceeded the service quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct CreateCloudAutonomousVmClusterInput: Swift.Sendable {
    /// The data disk group size to be allocated for Autonomous Databases, in terabytes (TB).
    /// This member is required.
    public var autonomousDataStorageSizeInTBs: Swift.Double?
    /// A client-provided token to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the Exadata infrastructure where the VM cluster will be created.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The number of CPU cores to be enabled per VM cluster node.
    /// This member is required.
    public var cpuCoreCountPerNode: Swift.Int?
    /// The list of database servers to be used for the Autonomous VM cluster.
    public var dbServers: [Swift.String]?
    /// A user-provided description of the Autonomous VM cluster.
    public var description: Swift.String?
    /// The display name for the Autonomous VM cluster. The name does not need to be unique.
    /// This member is required.
    public var displayName: Swift.String?
    /// Specifies whether to enable mutual TLS (mTLS) authentication for the Autonomous VM cluster.
    public var isMtlsEnabledVmCluster: Swift.Bool?
    /// The Oracle license model to apply to the Autonomous VM cluster.
    public var licenseModel: OdbClientTypes.LicenseModel?
    /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
    public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
    /// The amount of memory to be allocated per OCPU, in GB.
    /// This member is required.
    public var memoryPerOracleComputeUnitInGBs: Swift.Int?
    /// The unique identifier of the ODB network to be used for the VM cluster.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// The SCAN listener port for non-TLS (TCP) protocol.
    public var scanListenerPortNonTls: Swift.Int?
    /// The SCAN listener port for TLS (TCP) protocol.
    public var scanListenerPortTls: Swift.Int?
    /// Free-form tags for this resource. Each tag is a key-value pair with no predefined name, type, or namespace.
    public var tags: [Swift.String: Swift.String]?
    /// The time zone to use for the Autonomous VM cluster.
    public var timeZone: Swift.String?
    /// The total number of Autonomous CDBs that you can create in the Autonomous VM cluster.
    /// This member is required.
    public var totalContainerDatabases: Swift.Int?

    public init(
        autonomousDataStorageSizeInTBs: Swift.Double? = nil,
        clientToken: Swift.String? = nil,
        cloudExadataInfrastructureId: Swift.String? = nil,
        cpuCoreCountPerNode: Swift.Int? = nil,
        dbServers: [Swift.String]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        isMtlsEnabledVmCluster: Swift.Bool? = nil,
        licenseModel: OdbClientTypes.LicenseModel? = nil,
        maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
        memoryPerOracleComputeUnitInGBs: Swift.Int? = nil,
        odbNetworkId: Swift.String? = nil,
        scanListenerPortNonTls: Swift.Int? = nil,
        scanListenerPortTls: Swift.Int? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeZone: Swift.String? = nil,
        totalContainerDatabases: Swift.Int? = nil
    ) {
        self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
        self.clientToken = clientToken
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.cpuCoreCountPerNode = cpuCoreCountPerNode
        self.dbServers = dbServers
        self.description = description
        self.displayName = displayName
        self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
        self.licenseModel = licenseModel
        self.maintenanceWindow = maintenanceWindow
        self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
        self.odbNetworkId = odbNetworkId
        self.scanListenerPortNonTls = scanListenerPortNonTls
        self.scanListenerPortTls = scanListenerPortTls
        self.tags = tags
        self.timeZone = timeZone
        self.totalContainerDatabases = totalContainerDatabases
    }
}

public struct CreateCloudAutonomousVmClusterOutput: Swift.Sendable {
    /// The unique identifier of the created Autonomous VM cluster.
    /// This member is required.
    public var cloudAutonomousVmClusterId: Swift.String?
    /// The display name of the created Autonomous VM cluster.
    public var displayName: Swift.String?
    /// The current status of the Autonomous VM cluster creation process.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the current status of the Autonomous VM cluster creation process, if applicable.
    public var statusReason: Swift.String?

    public init(
        cloudAutonomousVmClusterId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
        self.displayName = displayName
        self.status = status
        self.statusReason = statusReason
    }
}

public struct DeleteCloudAutonomousVmClusterInput: Swift.Sendable {
    /// The unique identifier of the Autonomous VM cluster to delete.
    /// This member is required.
    public var cloudAutonomousVmClusterId: Swift.String?

    public init(
        cloudAutonomousVmClusterId: Swift.String? = nil
    ) {
        self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
    }
}

public struct DeleteCloudAutonomousVmClusterOutput: Swift.Sendable {

    public init() { }
}

public struct GetCloudAutonomousVmClusterInput: Swift.Sendable {
    /// The unique identifier of the Autonomous VM cluster to retrieve information about.
    /// This member is required.
    public var cloudAutonomousVmClusterId: Swift.String?

    public init(
        cloudAutonomousVmClusterId: Swift.String? = nil
    ) {
        self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
    }
}

public struct GetCloudAutonomousVmClusterOutput: Swift.Sendable {
    /// The details of the requested Autonomous VM cluster.
    public var cloudAutonomousVmCluster: OdbClientTypes.CloudAutonomousVmCluster?

    public init(
        cloudAutonomousVmCluster: OdbClientTypes.CloudAutonomousVmCluster? = nil
    ) {
        self.cloudAutonomousVmCluster = cloudAutonomousVmCluster
    }
}

public struct ListAutonomousVirtualMachinesInput: Swift.Sendable {
    /// The unique identifier of the Autonomous VM cluster whose virtual machines you're listing.
    /// This member is required.
    public var cloudAutonomousVmClusterId: Swift.String?
    /// The maximum number of items to return per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue listing from.
    public var nextToken: Swift.String?

    public init(
        cloudAutonomousVmClusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAutonomousVirtualMachinesOutput: Swift.Sendable {
    /// The list of Autonomous VMs in the specified Autonomous VM cluster.
    /// This member is required.
    public var autonomousVirtualMachines: [OdbClientTypes.AutonomousVirtualMachineSummary]?
    /// The pagination token from which to continue listing.
    public var nextToken: Swift.String?

    public init(
        autonomousVirtualMachines: [OdbClientTypes.AutonomousVirtualMachineSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.autonomousVirtualMachines = autonomousVirtualMachines
        self.nextToken = nextToken
    }
}

public struct ListCloudAutonomousVmClustersInput: Swift.Sendable {
    /// The unique identifier of the Cloud Exadata Infrastructure that hosts the Autonomous VM clusters to be listed.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The maximum number of items to return per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue listing from.
    public var nextToken: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCloudAutonomousVmClustersOutput: Swift.Sendable {
    /// The list of Autonomous VM clusters in the specified Cloud Exadata Infrastructure.
    /// This member is required.
    public var cloudAutonomousVmClusters: [OdbClientTypes.CloudAutonomousVmClusterSummary]?
    /// The pagination token to continue listing from.
    public var nextToken: Swift.String?

    public init(
        cloudAutonomousVmClusters: [OdbClientTypes.CloudAutonomousVmClusterSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudAutonomousVmClusters = cloudAutonomousVmClusters
        self.nextToken = nextToken
    }
}

extension OdbClientTypes {

    /// Resource details of an Autonomous VM cluster.
    public struct CloudAutonomousVmClusterResourceDetails: Swift.Sendable {
        /// The unique identifier of the Autonomous VM cluster.
        public var cloudAutonomousVmClusterId: Swift.String?
        /// The amount of unallocated Autonomous Database storage in the Autonomous VM cluster, in terabytes.
        public var unallocatedAdbStorageInTBs: Swift.Double?

        public init(
            cloudAutonomousVmClusterId: Swift.String? = nil,
            unallocatedAdbStorageInTBs: Swift.Double? = nil
        ) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.unallocatedAdbStorageInTBs = unallocatedAdbStorageInTBs
        }
    }
}

extension OdbClientTypes {

    /// A contact to receive notification from Oracle about maintenance updates for a specific Exadata infrastructure.
    public struct CustomerContact: Swift.Sendable {
        /// The email address of the contact.
        public var email: Swift.String?

        public init(
            email: Swift.String? = nil
        ) {
            self.email = email
        }
    }
}

extension OdbClientTypes.CustomerContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerContact(email: \"CONTENT_REDACTED\")"}
}

extension OdbClientTypes {

    /// Information about an Exadata infrastructure.
    public struct CloudExadataInfrastructure: Swift.Sendable {
        /// The number of storage servers requested for the Exadata infrastructure.
        public var activatedStorageCount: Swift.Int?
        /// The number of storage servers requested for the Exadata infrastructure.
        public var additionalStorageCount: Swift.Int?
        /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located.
        public var availabilityZone: Swift.String?
        /// The AZ ID of the AZ where the Exadata infrastructure is located.
        public var availabilityZoneId: Swift.String?
        /// The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.
        public var availableStorageSizeInGBs: Swift.Int?
        /// The Amazon Resource Name (ARN) for the Exadata infrastructure.
        public var cloudExadataInfrastructureArn: Swift.String?
        /// The unique identifier for the Exadata infrastructure.
        /// This member is required.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The number of database servers for the Exadata infrastructure.
        public var computeCount: Swift.Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The total number of CPU cores that are allocated to the Exadata infrastructure.
        public var cpuCount: Swift.Int?
        /// The date and time when the Exadata infrastructure was created.
        public var createdAt: Foundation.Date?
        /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
        public var customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]?
        /// The size of the Exadata infrastructure's data disk group, in terabytes (TB).
        public var dataStorageSizeInTBs: Swift.Double?
        /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public var databaseServerType: Swift.String?
        /// The size of the Exadata infrastructure's local node storage, in gigabytes (GB).
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The software version of the database servers (dom0) in the Exadata infrastructure.
        public var dbServerVersion: Swift.String?
        /// The user-friendly name for the Exadata infrastructure.
        public var displayName: Swift.String?
        /// The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.
        public var lastMaintenanceRunId: Swift.String?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
        /// The total number of CPU cores available on the Exadata infrastructure.
        public var maxCpuCount: Swift.Int?
        /// The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.
        public var maxDataStorageInTBs: Swift.Double?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.
        public var maxDbNodeStorageSizeInGBs: Swift.Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.
        public var maxMemoryInGBs: Swift.Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.
        public var memorySizeInGBs: Swift.Int?
        /// The monthly software version of the database servers installed on the Exadata infrastructure.
        public var monthlyDbServerVersion: Swift.String?
        /// The monthly software version of the storage servers installed on the Exadata infrastructure.
        public var monthlyStorageServerVersion: Swift.String?
        /// The OCID of the next maintenance run for the Exadata infrastructure.
        public var nextMaintenanceRunId: Swift.String?
        /// The name of the OCI resource anchor for the Exadata infrastructure.
        public var ociResourceAnchorName: Swift.String?
        /// The HTTPS link to the Exadata infrastructure in OCI.
        public var ociUrl: Swift.String?
        /// The OCID of the Exadata infrastructure.
        public var ocid: Swift.String?
        /// The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The model name of the Exadata infrastructure.
        public var shape: Swift.String?
        /// The current status of the Exadata infrastructure.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure.
        public var statusReason: Swift.String?
        /// The number of storage servers that are activated for the Exadata infrastructure.
        public var storageCount: Swift.Int?
        /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public var storageServerType: Swift.String?
        /// The software version of the storage servers on the Exadata infrastructure.
        public var storageServerVersion: Swift.String?
        /// The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.
        public var totalStorageSizeInGBs: Swift.Int?

        public init(
            activatedStorageCount: Swift.Int? = nil,
            additionalStorageCount: Swift.Int? = nil,
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            availableStorageSizeInGBs: Swift.Int? = nil,
            cloudExadataInfrastructureArn: Swift.String? = nil,
            cloudExadataInfrastructureId: Swift.String? = nil,
            computeCount: Swift.Int? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            databaseServerType: Swift.String? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerVersion: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastMaintenanceRunId: Swift.String? = nil,
            maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
            maxCpuCount: Swift.Int? = nil,
            maxDataStorageInTBs: Swift.Double? = nil,
            maxDbNodeStorageSizeInGBs: Swift.Int? = nil,
            maxMemoryInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            monthlyDbServerVersion: Swift.String? = nil,
            monthlyStorageServerVersion: Swift.String? = nil,
            nextMaintenanceRunId: Swift.String? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            storageCount: Swift.Int? = nil,
            storageServerType: Swift.String? = nil,
            storageServerVersion: Swift.String? = nil,
            totalStorageSizeInGBs: Swift.Int? = nil
        ) {
            self.activatedStorageCount = activatedStorageCount
            self.additionalStorageCount = additionalStorageCount
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableStorageSizeInGBs = availableStorageSizeInGBs
            self.cloudExadataInfrastructureArn = cloudExadataInfrastructureArn
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeCount = computeCount
            self.computeModel = computeModel
            self.cpuCount = cpuCount
            self.createdAt = createdAt
            self.customerContactsToSendToOCI = customerContactsToSendToOCI
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.databaseServerType = databaseServerType
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerVersion = dbServerVersion
            self.displayName = displayName
            self.lastMaintenanceRunId = lastMaintenanceRunId
            self.maintenanceWindow = maintenanceWindow
            self.maxCpuCount = maxCpuCount
            self.maxDataStorageInTBs = maxDataStorageInTBs
            self.maxDbNodeStorageSizeInGBs = maxDbNodeStorageSizeInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.monthlyDbServerVersion = monthlyDbServerVersion
            self.monthlyStorageServerVersion = monthlyStorageServerVersion
            self.nextMaintenanceRunId = nextMaintenanceRunId
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.percentProgress = percentProgress
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.storageCount = storageCount
            self.storageServerType = storageServerType
            self.storageServerVersion = storageServerVersion
            self.totalStorageSizeInGBs = totalStorageSizeInGBs
        }
    }
}

extension OdbClientTypes {

    /// Information about an Exadata infrastructure.
    public struct CloudExadataInfrastructureSummary: Swift.Sendable {
        /// The number of storage servers requested for the Exadata infrastructure.
        public var activatedStorageCount: Swift.Int?
        /// The number of storage servers requested for the Exadata infrastructure.
        public var additionalStorageCount: Swift.Int?
        /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located.
        public var availabilityZone: Swift.String?
        /// The AZ ID of the AZ where the Exadata infrastructure is located.
        public var availabilityZoneId: Swift.String?
        /// The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.
        public var availableStorageSizeInGBs: Swift.Int?
        /// The Amazon Resource Name (ARN) for the Exadata infrastructure.
        public var cloudExadataInfrastructureArn: Swift.String?
        /// The unique identifier for the Exadata infrastructure.
        /// This member is required.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The number of database servers for the Exadata infrastructure.
        public var computeCount: Swift.Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The total number of CPU cores that are allocated to the Exadata infrastructure.
        public var cpuCount: Swift.Int?
        /// The date and time when the Exadata infrastructure was created.
        public var createdAt: Foundation.Date?
        /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
        public var customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]?
        /// The size of the Exadata infrastructure's data disk group, in terabytes (TB).
        public var dataStorageSizeInTBs: Swift.Double?
        /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public var databaseServerType: Swift.String?
        /// The size of the Exadata infrastructure's local node storage, in gigabytes (GB).
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The software version of the database servers on the Exadata infrastructure.
        public var dbServerVersion: Swift.String?
        /// The user-friendly name for the Exadata infrastructure.
        public var displayName: Swift.String?
        /// The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.
        public var lastMaintenanceRunId: Swift.String?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
        /// The total number of CPU cores available on the Exadata infrastructure.
        public var maxCpuCount: Swift.Int?
        /// The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.
        public var maxDataStorageInTBs: Swift.Double?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.
        public var maxDbNodeStorageSizeInGBs: Swift.Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.
        public var maxMemoryInGBs: Swift.Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.
        public var memorySizeInGBs: Swift.Int?
        /// The monthly software version of the database servers (dom0) installed on the Exadata infrastructure.
        public var monthlyDbServerVersion: Swift.String?
        /// The monthly software version of the storage servers installed on the Exadata infrastructure.
        public var monthlyStorageServerVersion: Swift.String?
        /// The OCID of the next maintenance run for the Exadata infrastructure.
        public var nextMaintenanceRunId: Swift.String?
        /// The name of the OCI resource anchor for the Exadata infrastructure.
        public var ociResourceAnchorName: Swift.String?
        /// The HTTPS link to the Exadata infrastructure in OCI.
        public var ociUrl: Swift.String?
        /// The OCID of the Exadata infrastructure.
        public var ocid: Swift.String?
        /// The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The model name of the Exadata infrastructure.
        public var shape: Swift.String?
        /// The current status of the Exadata infrastructure.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure.
        public var statusReason: Swift.String?
        /// The number of storage servers that are activated for the Exadata infrastructure.
        public var storageCount: Swift.Int?
        /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public var storageServerType: Swift.String?
        /// The software version of the storage servers on the Exadata infrastructure.
        public var storageServerVersion: Swift.String?
        /// The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.
        public var totalStorageSizeInGBs: Swift.Int?

        public init(
            activatedStorageCount: Swift.Int? = nil,
            additionalStorageCount: Swift.Int? = nil,
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            availableStorageSizeInGBs: Swift.Int? = nil,
            cloudExadataInfrastructureArn: Swift.String? = nil,
            cloudExadataInfrastructureId: Swift.String? = nil,
            computeCount: Swift.Int? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            databaseServerType: Swift.String? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerVersion: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastMaintenanceRunId: Swift.String? = nil,
            maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
            maxCpuCount: Swift.Int? = nil,
            maxDataStorageInTBs: Swift.Double? = nil,
            maxDbNodeStorageSizeInGBs: Swift.Int? = nil,
            maxMemoryInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            monthlyDbServerVersion: Swift.String? = nil,
            monthlyStorageServerVersion: Swift.String? = nil,
            nextMaintenanceRunId: Swift.String? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            storageCount: Swift.Int? = nil,
            storageServerType: Swift.String? = nil,
            storageServerVersion: Swift.String? = nil,
            totalStorageSizeInGBs: Swift.Int? = nil
        ) {
            self.activatedStorageCount = activatedStorageCount
            self.additionalStorageCount = additionalStorageCount
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableStorageSizeInGBs = availableStorageSizeInGBs
            self.cloudExadataInfrastructureArn = cloudExadataInfrastructureArn
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeCount = computeCount
            self.computeModel = computeModel
            self.cpuCount = cpuCount
            self.createdAt = createdAt
            self.customerContactsToSendToOCI = customerContactsToSendToOCI
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.databaseServerType = databaseServerType
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerVersion = dbServerVersion
            self.displayName = displayName
            self.lastMaintenanceRunId = lastMaintenanceRunId
            self.maintenanceWindow = maintenanceWindow
            self.maxCpuCount = maxCpuCount
            self.maxDataStorageInTBs = maxDataStorageInTBs
            self.maxDbNodeStorageSizeInGBs = maxDbNodeStorageSizeInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.monthlyDbServerVersion = monthlyDbServerVersion
            self.monthlyStorageServerVersion = monthlyStorageServerVersion
            self.nextMaintenanceRunId = nextMaintenanceRunId
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.percentProgress = percentProgress
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.storageCount = storageCount
            self.storageServerType = storageServerType
            self.storageServerVersion = storageServerVersion
            self.totalStorageSizeInGBs = totalStorageSizeInGBs
        }
    }
}

public struct CreateCloudExadataInfrastructureInput: Swift.Sendable {
    /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId. Example: us-east-1a
    public var availabilityZone: Swift.String?
    /// The AZ ID of the AZ where the Exadata infrastructure is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId. Example: use1-az1
    public var availabilityZoneId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
    public var clientToken: Swift.String?
    /// The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the ListDbSystemShapes operation.
    /// This member is required.
    public var computeCount: Swift.Int?
    /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
    public var customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]?
    /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
    public var databaseServerType: Swift.String?
    /// A user-friendly name for the Exadata infrastructure.
    /// This member is required.
    public var displayName: Swift.String?
    /// The maintenance window configuration for the Exadata Cloud infrastructure. This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.
    public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?
    /// The model name of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
    /// This member is required.
    public var shape: Swift.String?
    /// The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the ListDbSystemShapes operation.
    /// This member is required.
    public var storageCount: Swift.Int?
    /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
    public var storageServerType: Swift.String?
    /// The list of resource tags to apply to the Exadata infrastructure.
    public var tags: [Swift.String: Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        computeCount: Swift.Int? = nil,
        customerContactsToSendToOCI: [OdbClientTypes.CustomerContact]? = nil,
        databaseServerType: Swift.String? = nil,
        displayName: Swift.String? = nil,
        maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil,
        shape: Swift.String? = nil,
        storageCount: Swift.Int? = nil,
        storageServerType: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.clientToken = clientToken
        self.computeCount = computeCount
        self.customerContactsToSendToOCI = customerContactsToSendToOCI
        self.databaseServerType = databaseServerType
        self.displayName = displayName
        self.maintenanceWindow = maintenanceWindow
        self.shape = shape
        self.storageCount = storageCount
        self.storageServerType = storageServerType
        self.tags = tags
    }
}

public struct CreateCloudExadataInfrastructureOutput: Swift.Sendable {
    /// The unique identifier of the Exadata infrastructure.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The user-friendly name for the Exadata infrastructure.
    public var displayName: Swift.String?
    /// The current status of the Exadata infrastructure.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the Exadata infrastructure.
    public var statusReason: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.displayName = displayName
        self.status = status
        self.statusReason = statusReason
    }
}

public struct DeleteCloudExadataInfrastructureInput: Swift.Sendable {
    /// The unique identifier of the Exadata infrastructure to delete.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
    }
}

public struct DeleteCloudExadataInfrastructureOutput: Swift.Sendable {

    public init() { }
}

public struct GetCloudExadataInfrastructureInput: Swift.Sendable {
    /// The unique identifier of the Exadata infrastructure.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
    }
}

public struct GetCloudExadataInfrastructureOutput: Swift.Sendable {
    /// The Exadata infrastructure.
    public var cloudExadataInfrastructure: OdbClientTypes.CloudExadataInfrastructure?

    public init(
        cloudExadataInfrastructure: OdbClientTypes.CloudExadataInfrastructure? = nil
    ) {
        self.cloudExadataInfrastructure = cloudExadataInfrastructure
    }
}

public struct GetCloudExadataInfrastructureUnallocatedResourcesInput: Swift.Sendable {
    /// The unique identifier of the Cloud Exadata infrastructure for which to retrieve unallocated resources.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The database servers to include in the unallocated resources query.
    public var dbServers: [Swift.String]?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        dbServers: [Swift.String]? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.dbServers = dbServers
    }
}

extension OdbClientTypes {

    /// Information about unallocated resources in the Cloud Exadata infrastructure.
    public struct CloudExadataInfrastructureUnallocatedResources: Swift.Sendable {
        /// A list of Autonomous VM clusters associated with this Cloud Exadata Infrastructure.
        public var cloudAutonomousVmClusters: [OdbClientTypes.CloudAutonomousVmClusterResourceDetails]?
        /// The display name of the Cloud Exadata infrastructure.
        public var cloudExadataInfrastructureDisplayName: Swift.String?
        /// The unique identifier of the Cloud Exadata infrastructure.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The amount of unallocated Exadata storage available, in terabytes (TB).
        public var exadataStorageInTBs: Swift.Double?
        /// The amount of unallocated local storage available, in gigabytes (GB).
        public var localStorageInGBs: Swift.Int?
        /// The amount of unallocated memory available, in gigabytes (GB).
        public var memoryInGBs: Swift.Int?
        /// The number of unallocated Oracle CPU Units (OCPUs) available.
        public var ocpus: Swift.Int?

        public init(
            cloudAutonomousVmClusters: [OdbClientTypes.CloudAutonomousVmClusterResourceDetails]? = nil,
            cloudExadataInfrastructureDisplayName: Swift.String? = nil,
            cloudExadataInfrastructureId: Swift.String? = nil,
            exadataStorageInTBs: Swift.Double? = nil,
            localStorageInGBs: Swift.Int? = nil,
            memoryInGBs: Swift.Int? = nil,
            ocpus: Swift.Int? = nil
        ) {
            self.cloudAutonomousVmClusters = cloudAutonomousVmClusters
            self.cloudExadataInfrastructureDisplayName = cloudExadataInfrastructureDisplayName
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.exadataStorageInTBs = exadataStorageInTBs
            self.localStorageInGBs = localStorageInGBs
            self.memoryInGBs = memoryInGBs
            self.ocpus = ocpus
        }
    }
}

public struct GetCloudExadataInfrastructureUnallocatedResourcesOutput: Swift.Sendable {
    /// Details about the unallocated resources in the specified Cloud Exadata infrastructure.
    public var cloudExadataInfrastructureUnallocatedResources: OdbClientTypes.CloudExadataInfrastructureUnallocatedResources?

    public init(
        cloudExadataInfrastructureUnallocatedResources: OdbClientTypes.CloudExadataInfrastructureUnallocatedResources? = nil
    ) {
        self.cloudExadataInfrastructureUnallocatedResources = cloudExadataInfrastructureUnallocatedResources
    }
}

public struct GetDbServerInput: Swift.Sendable {
    /// The unique identifier of the Oracle Exadata infrastructure that contains the database server.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The unique identifier of the database server to retrieve information about.
    /// This member is required.
    public var dbServerId: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        dbServerId: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.dbServerId = dbServerId
    }
}

extension OdbClientTypes {

    public enum DbServerPatchingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case maintenanceInProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [DbServerPatchingStatus] {
            return [
                .complete,
                .failed,
                .maintenanceInProgress,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .maintenanceInProgress: return "MAINTENANCE_IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
    public struct DbServerPatchingDetails: Swift.Sendable {
        /// Estimated time, in minutes, to patch one database server.
        public var estimatedPatchDuration: Swift.Int?
        /// The status of the patching operation. Possible values are SCHEDULED, MAINTENANCE_IN_PROGRESS, FAILED, and COMPLETE.
        public var patchingStatus: OdbClientTypes.DbServerPatchingStatus?
        /// The time when the patching operation ended.
        public var timePatchingEnded: Swift.String?
        /// The time when the patching operation started.
        public var timePatchingStarted: Swift.String?

        public init(
            estimatedPatchDuration: Swift.Int? = nil,
            patchingStatus: OdbClientTypes.DbServerPatchingStatus? = nil,
            timePatchingEnded: Swift.String? = nil,
            timePatchingStarted: Swift.String? = nil
        ) {
            self.estimatedPatchDuration = estimatedPatchDuration
            self.patchingStatus = patchingStatus
            self.timePatchingEnded = timePatchingEnded
            self.timePatchingStarted = timePatchingStarted
        }
    }
}

extension OdbClientTypes {

    /// Information about a database server.
    public struct DbServer: Swift.Sendable {
        /// The list of unique identifiers for the Autonomous VMs associated with this database server.
        public var autonomousVirtualMachineIds: [Swift.String]?
        /// The list of identifiers for the Autonomous VM clusters associated with this database server.
        public var autonomousVmClusterIds: [Swift.String]?
        /// The compute model of the database server (ECPU or OCPU).
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The number of CPU cores enabled on the database server.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the database server was created.
        public var createdAt: Foundation.Date?
        /// The allocated local node storage in GBs on the database server.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The unique identifier for the database server.
        public var dbServerId: Swift.String?
        /// The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        public var dbServerPatchingDetails: OdbClientTypes.DbServerPatchingDetails?
        /// The user-friendly name of the database server.
        public var displayName: Swift.String?
        /// The ID of the Exadata infrastructure the database server belongs to.
        public var exadataInfrastructureId: Swift.String?
        /// The total number of CPU cores available.
        public var maxCpuCount: Swift.Int?
        /// The total local node storage available in GBs.
        public var maxDbNodeStorageInGBs: Swift.Int?
        /// The total memory available in GBs.
        public var maxMemoryInGBs: Swift.Int?
        /// The allocated memory in GBs on the database server.
        public var memorySizeInGBs: Swift.Int?
        /// The name of the OCI resource anchor for the database server.
        public var ociResourceAnchorName: Swift.String?
        /// The OCID of the database server.
        public var ocid: Swift.String?
        /// The shape of the database server. The shape determines the amount of CPU, storage, and memory resources available.
        public var shape: Swift.String?
        /// The current status of the database server.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the database server.
        public var statusReason: Swift.String?
        /// The OCID of the VM clusters that are associated with the database server.
        public var vmClusterIds: [Swift.String]?

        public init(
            autonomousVirtualMachineIds: [Swift.String]? = nil,
            autonomousVmClusterIds: [Swift.String]? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerId: Swift.String? = nil,
            dbServerPatchingDetails: OdbClientTypes.DbServerPatchingDetails? = nil,
            displayName: Swift.String? = nil,
            exadataInfrastructureId: Swift.String? = nil,
            maxCpuCount: Swift.Int? = nil,
            maxDbNodeStorageInGBs: Swift.Int? = nil,
            maxMemoryInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ocid: Swift.String? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            vmClusterIds: [Swift.String]? = nil
        ) {
            self.autonomousVirtualMachineIds = autonomousVirtualMachineIds
            self.autonomousVmClusterIds = autonomousVmClusterIds
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbServerPatchingDetails = dbServerPatchingDetails
            self.displayName = displayName
            self.exadataInfrastructureId = exadataInfrastructureId
            self.maxCpuCount = maxCpuCount
            self.maxDbNodeStorageInGBs = maxDbNodeStorageInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ocid = ocid
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.vmClusterIds = vmClusterIds
        }
    }
}

public struct GetDbServerOutput: Swift.Sendable {
    /// The details of the requested database server.
    public var dbServer: OdbClientTypes.DbServer?

    public init(
        dbServer: OdbClientTypes.DbServer? = nil
    ) {
        self.dbServer = dbServer
    }
}

public struct ListCloudExadataInfrastructuresInput: Swift.Sendable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCloudExadataInfrastructuresOutput: Swift.Sendable {
    /// The list of Exadata infrastructures along with their properties.
    /// This member is required.
    public var cloudExadataInfrastructures: [OdbClientTypes.CloudExadataInfrastructureSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        cloudExadataInfrastructures: [OdbClientTypes.CloudExadataInfrastructureSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructures = cloudExadataInfrastructures
        self.nextToken = nextToken
    }
}

public struct ListDbServersInput: Swift.Sendable {
    /// The unique identifier of the Oracle Exadata infrastructure.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OdbClientTypes {

    /// Information about a database server.
    public struct DbServerSummary: Swift.Sendable {
        /// A list of unique identifiers for the Autonomous VMs.
        public var autonomousVirtualMachineIds: [Swift.String]?
        /// A list of identifiers for the Autonomous VM clusters.
        public var autonomousVmClusterIds: [Swift.String]?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The number of CPU cores enabled on the database server.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the database server was created.
        public var createdAt: Foundation.Date?
        /// The amount of local node storage, in gigabytes (GB), that's allocated on the database server.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The unique identifier of the database server.
        public var dbServerId: Swift.String?
        /// The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        public var dbServerPatchingDetails: OdbClientTypes.DbServerPatchingDetails?
        /// The user-friendly name of the database server. The name doesn't need to be unique.
        public var displayName: Swift.String?
        /// The ID of the Exadata infrastructure that hosts the database server.
        public var exadataInfrastructureId: Swift.String?
        /// The total number of CPU cores available on the database server.
        public var maxCpuCount: Swift.Int?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the database server.
        public var maxDbNodeStorageInGBs: Swift.Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the database server.
        public var maxMemoryInGBs: Swift.Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the database server.
        public var memorySizeInGBs: Swift.Int?
        /// The name of the OCI resource anchor for the database server.
        public var ociResourceAnchorName: Swift.String?
        /// The OCID of the database server.
        public var ocid: Swift.String?
        /// The hardware system model of the Exadata infrastructure that the database server is hosted on. The shape determines the amount of CPU, storage, and memory resources available.
        public var shape: Swift.String?
        /// The current status of the database server.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the status of the database server.
        public var statusReason: Swift.String?
        /// The IDs of the VM clusters that are associated with the database server.
        public var vmClusterIds: [Swift.String]?

        public init(
            autonomousVirtualMachineIds: [Swift.String]? = nil,
            autonomousVmClusterIds: [Swift.String]? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerId: Swift.String? = nil,
            dbServerPatchingDetails: OdbClientTypes.DbServerPatchingDetails? = nil,
            displayName: Swift.String? = nil,
            exadataInfrastructureId: Swift.String? = nil,
            maxCpuCount: Swift.Int? = nil,
            maxDbNodeStorageInGBs: Swift.Int? = nil,
            maxMemoryInGBs: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ocid: Swift.String? = nil,
            shape: Swift.String? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            vmClusterIds: [Swift.String]? = nil
        ) {
            self.autonomousVirtualMachineIds = autonomousVirtualMachineIds
            self.autonomousVmClusterIds = autonomousVmClusterIds
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbServerPatchingDetails = dbServerPatchingDetails
            self.displayName = displayName
            self.exadataInfrastructureId = exadataInfrastructureId
            self.maxCpuCount = maxCpuCount
            self.maxDbNodeStorageInGBs = maxDbNodeStorageInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ocid = ocid
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.vmClusterIds = vmClusterIds
        }
    }
}

public struct ListDbServersOutput: Swift.Sendable {
    /// The list of database servers along with their properties.
    /// This member is required.
    public var dbServers: [OdbClientTypes.DbServerSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        dbServers: [OdbClientTypes.DbServerSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dbServers = dbServers
        self.nextToken = nextToken
    }
}

public struct UpdateCloudExadataInfrastructureInput: Swift.Sendable {
    /// The unique identifier of the Exadata infrastructure to update.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
    public var maintenanceWindow: OdbClientTypes.MaintenanceWindow?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        maintenanceWindow: OdbClientTypes.MaintenanceWindow? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.maintenanceWindow = maintenanceWindow
    }
}

public struct UpdateCloudExadataInfrastructureOutput: Swift.Sendable {
    /// The unique identifier of the updated Exadata infrastructure.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The user-friendly name of the updated Exadata infrastructure.
    public var displayName: Swift.String?
    /// The current status of the Exadata infrastructure after the update operation.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the Exadata infrastructure after the update operation.
    public var statusReason: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.displayName = displayName
        self.status = status
        self.statusReason = statusReason
    }
}

extension OdbClientTypes {

    /// Information about the data collection options enabled for a VM cluster.
    public struct DataCollectionOptions: Swift.Sendable {
        /// Indicates whether diagnostic collection is enabled for the VM cluster.
        public var isDiagnosticsEventsEnabled: Swift.Bool?
        /// Indicates whether health monitoring is enabled for the VM cluster.
        public var isHealthMonitoringEnabled: Swift.Bool?
        /// Indicates whether incident logs are enabled for the cloud VM cluster.
        public var isIncidentLogsEnabled: Swift.Bool?

        public init(
            isDiagnosticsEventsEnabled: Swift.Bool? = nil,
            isHealthMonitoringEnabled: Swift.Bool? = nil,
            isIncidentLogsEnabled: Swift.Bool? = nil
        ) {
            self.isDiagnosticsEventsEnabled = isDiagnosticsEventsEnabled
            self.isHealthMonitoringEnabled = isHealthMonitoringEnabled
            self.isIncidentLogsEnabled = isIncidentLogsEnabled
        }
    }
}

extension OdbClientTypes {

    public enum DiskRedundancy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [DiskRedundancy] {
            return [
                .high,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The IORM configuration settings for the database.
    public struct DbIormConfig: Swift.Sendable {
        /// The database name. For the default DbPlan, the dbName is default.
        public var dbName: Swift.String?
        /// The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        public var flashCacheLimit: Swift.String?
        /// The relative priority of this database.
        public var share: Swift.Int?

        public init(
            dbName: Swift.String? = nil,
            flashCacheLimit: Swift.String? = nil,
            share: Swift.Int? = nil
        ) {
            self.dbName = dbName
            self.flashCacheLimit = flashCacheLimit
            self.share = share
        }
    }
}

extension OdbClientTypes {

    public enum IormLifecycleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bootstrapping
        case disabled
        case enabled
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IormLifecycleState] {
            return [
                .bootstrapping,
                .disabled,
                .enabled,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bootstrapping: return "BOOTSTRAPPING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum Objective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case balanced
        case basic
        case highThroughput
        case lowLatency
        case sdkUnknown(Swift.String)

        public static var allCases: [Objective] {
            return [
                .auto,
                .balanced,
                .basic,
                .highThroughput,
                .lowLatency
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .balanced: return "BALANCED"
            case .basic: return "BASIC"
            case .highThroughput: return "HIGH_THROUGHPUT"
            case .lowLatency: return "LOW_LATENCY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The IORM settings of the Exadata DB system.
    public struct ExadataIormConfig: Swift.Sendable {
        /// An array of IORM settings for all the database in the Exadata DB system.
        public var dbPlans: [OdbClientTypes.DbIormConfig]?
        /// Additional information about the current lifecycleState.
        public var lifecycleDetails: Swift.String?
        /// The current state of IORM configuration for the Exadata DB system.
        public var lifecycleState: OdbClientTypes.IormLifecycleState?
        /// The current value for the IORM objective. The default is AUTO.
        public var objective: OdbClientTypes.Objective?

        public init(
            dbPlans: [OdbClientTypes.DbIormConfig]? = nil,
            lifecycleDetails: Swift.String? = nil,
            lifecycleState: OdbClientTypes.IormLifecycleState? = nil,
            objective: OdbClientTypes.Objective? = nil
        ) {
            self.dbPlans = dbPlans
            self.lifecycleDetails = lifecycleDetails
            self.lifecycleState = lifecycleState
            self.objective = objective
        }
    }
}

extension OdbClientTypes {

    /// Information about a VM cluster.
    public struct CloudVmCluster: Swift.Sendable {
        /// The unique identifier of the Exadata infrastructure that this VM cluster belongs to.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The Amazon Resource Name (ARN) of the VM cluster.
        public var cloudVmClusterArn: Swift.String?
        /// The unique identifier of the VM cluster.
        /// This member is required.
        public var cloudVmClusterId: Swift.String?
        /// The name of the Grid Infrastructure (GI) cluster.
        public var clusterName: Swift.String?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The number of CPU cores enabled on the VM cluster.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the VM cluster was created.
        public var createdAt: Foundation.Date?
        /// The set of diagnostic collection options enabled for the VM cluster.
        public var dataCollectionOptions: OdbClientTypes.DataCollectionOptions?
        /// The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.
        public var dataStorageSizeInTBs: Swift.Double?
        /// The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The list of database servers for the VM cluster.
        public var dbServers: [Swift.String]?
        /// The type of redundancy configured for the VM cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        public var diskRedundancy: OdbClientTypes.DiskRedundancy?
        /// The user-friendly name for the VM cluster.
        public var displayName: Swift.String?
        /// The domain of the VM cluster.
        public var domain: Swift.String?
        /// The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.
        public var giVersion: Swift.String?
        /// The host name for the VM cluster.
        public var hostname: Swift.String?
        /// The ExadataIormConfig cache details for the VM cluster.
        public var iormConfigCache: OdbClientTypes.ExadataIormConfig?
        /// Indicates whether database backups to local Exadata storage is enabled for the VM cluster.
        public var isLocalBackupEnabled: Swift.Bool?
        /// Indicates whether the VM cluster is configured with a sparse disk group.
        public var isSparseDiskgroupEnabled: Swift.Bool?
        /// The Oracle Cloud ID (OCID) of the last maintenance update history entry.
        public var lastUpdateHistoryEntryId: Swift.String?
        /// The Oracle license model applied to the VM cluster.
        public var licenseModel: OdbClientTypes.LicenseModel?
        /// The port number configured for the listener on the VM cluster.
        public var listenerPort: Swift.Int?
        /// The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.
        public var memorySizeInGBs: Swift.Int?
        /// The number of nodes in the VM cluster.
        public var nodeCount: Swift.Int?
        /// The name of the OCI resource anchor for the VM cluster.
        public var ociResourceAnchorName: Swift.String?
        /// The HTTPS link to the VM cluster in OCI.
        public var ociUrl: Swift.String?
        /// The OCID of the VM cluster.
        public var ocid: Swift.String?
        /// The unique identifier of the ODB network for the VM cluster.
        public var odbNetworkId: Swift.String?
        /// The amount of progress made on the current operation on the VM cluster, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.
        public var scanDnsName: Swift.String?
        /// The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.
        public var scanDnsRecordId: Swift.String?
        /// The OCID of the SCAN IP addresses that are associated with the VM cluster.
        public var scanIpIds: [Swift.String]?
        /// The hardware model name of the Exadata infrastructure that's running the VM cluster.
        public var shape: Swift.String?
        /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
        public var sshPublicKeys: [Swift.String]?
        /// The current status of the VM cluster.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the status of the VM cluster.
        public var statusReason: Swift.String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.
        public var storageSizeInGBs: Swift.Int?
        /// The operating system version of the image chosen for the VM cluster.
        public var systemVersion: Swift.String?
        /// The time zone of the VM cluster.
        public var timeZone: Swift.String?
        /// The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        public var vipIds: [Swift.String]?

        public init(
            cloudExadataInfrastructureId: Swift.String? = nil,
            cloudVmClusterArn: Swift.String? = nil,
            cloudVmClusterId: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dataCollectionOptions: OdbClientTypes.DataCollectionOptions? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServers: [Swift.String]? = nil,
            diskRedundancy: OdbClientTypes.DiskRedundancy? = nil,
            displayName: Swift.String? = nil,
            domain: Swift.String? = nil,
            giVersion: Swift.String? = nil,
            hostname: Swift.String? = nil,
            iormConfigCache: OdbClientTypes.ExadataIormConfig? = nil,
            isLocalBackupEnabled: Swift.Bool? = nil,
            isSparseDiskgroupEnabled: Swift.Bool? = nil,
            lastUpdateHistoryEntryId: Swift.String? = nil,
            licenseModel: OdbClientTypes.LicenseModel? = nil,
            listenerPort: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            scanDnsName: Swift.String? = nil,
            scanDnsRecordId: Swift.String? = nil,
            scanIpIds: [Swift.String]? = nil,
            shape: Swift.String? = nil,
            sshPublicKeys: [Swift.String]? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            storageSizeInGBs: Swift.Int? = nil,
            systemVersion: Swift.String? = nil,
            timeZone: Swift.String? = nil,
            vipIds: [Swift.String]? = nil
        ) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.cloudVmClusterArn = cloudVmClusterArn
            self.cloudVmClusterId = cloudVmClusterId
            self.clusterName = clusterName
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dataCollectionOptions = dataCollectionOptions
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.diskRedundancy = diskRedundancy
            self.displayName = displayName
            self.domain = domain
            self.giVersion = giVersion
            self.hostname = hostname
            self.iormConfigCache = iormConfigCache
            self.isLocalBackupEnabled = isLocalBackupEnabled
            self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
            self.lastUpdateHistoryEntryId = lastUpdateHistoryEntryId
            self.licenseModel = licenseModel
            self.listenerPort = listenerPort
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.scanDnsName = scanDnsName
            self.scanDnsRecordId = scanDnsRecordId
            self.scanIpIds = scanIpIds
            self.shape = shape
            self.sshPublicKeys = sshPublicKeys
            self.status = status
            self.statusReason = statusReason
            self.storageSizeInGBs = storageSizeInGBs
            self.systemVersion = systemVersion
            self.timeZone = timeZone
            self.vipIds = vipIds
        }
    }
}

extension OdbClientTypes.CloudVmCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudVmCluster(cloudExadataInfrastructureId: \(Swift.String(describing: cloudExadataInfrastructureId)), cloudVmClusterArn: \(Swift.String(describing: cloudVmClusterArn)), cloudVmClusterId: \(Swift.String(describing: cloudVmClusterId)), clusterName: \(Swift.String(describing: clusterName)), computeModel: \(Swift.String(describing: computeModel)), cpuCoreCount: \(Swift.String(describing: cpuCoreCount)), createdAt: \(Swift.String(describing: createdAt)), dataCollectionOptions: \(Swift.String(describing: dataCollectionOptions)), dataStorageSizeInTBs: \(Swift.String(describing: dataStorageSizeInTBs)), dbNodeStorageSizeInGBs: \(Swift.String(describing: dbNodeStorageSizeInGBs)), dbServers: \(Swift.String(describing: dbServers)), diskRedundancy: \(Swift.String(describing: diskRedundancy)), displayName: \(Swift.String(describing: displayName)), domain: \(Swift.String(describing: domain)), giVersion: \(Swift.String(describing: giVersion)), hostname: \(Swift.String(describing: hostname)), iormConfigCache: \(Swift.String(describing: iormConfigCache)), isLocalBackupEnabled: \(Swift.String(describing: isLocalBackupEnabled)), isSparseDiskgroupEnabled: \(Swift.String(describing: isSparseDiskgroupEnabled)), lastUpdateHistoryEntryId: \(Swift.String(describing: lastUpdateHistoryEntryId)), licenseModel: \(Swift.String(describing: licenseModel)), listenerPort: \(Swift.String(describing: listenerPort)), memorySizeInGBs: \(Swift.String(describing: memorySizeInGBs)), nodeCount: \(Swift.String(describing: nodeCount)), ociResourceAnchorName: \(Swift.String(describing: ociResourceAnchorName)), ociUrl: \(Swift.String(describing: ociUrl)), ocid: \(Swift.String(describing: ocid)), odbNetworkId: \(Swift.String(describing: odbNetworkId)), percentProgress: \(Swift.String(describing: percentProgress)), scanDnsName: \(Swift.String(describing: scanDnsName)), scanDnsRecordId: \(Swift.String(describing: scanDnsRecordId)), scanIpIds: \(Swift.String(describing: scanIpIds)), shape: \(Swift.String(describing: shape)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), storageSizeInGBs: \(Swift.String(describing: storageSizeInGBs)), systemVersion: \(Swift.String(describing: systemVersion)), timeZone: \(Swift.String(describing: timeZone)), vipIds: \(Swift.String(describing: vipIds)), sshPublicKeys: \"CONTENT_REDACTED\")"}
}

extension OdbClientTypes {

    /// Information about a VM cluster.
    public struct CloudVmClusterSummary: Swift.Sendable {
        /// The unique identifier of the Exadata infrastructure that this VM cluster belongs to.
        public var cloudExadataInfrastructureId: Swift.String?
        /// The Amazon Resource Name (ARN) of the VM cluster.
        public var cloudVmClusterArn: Swift.String?
        /// The unique identifier of the VM cluster.
        /// This member is required.
        public var cloudVmClusterId: Swift.String?
        /// The name of the Grid Infrastructure (GI) cluster.
        public var clusterName: Swift.String?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The number of CPU cores enabled on the VM cluster.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the VM cluster was created.
        public var createdAt: Foundation.Date?
        /// Information about the data collection options enabled for a VM cluster.
        public var dataCollectionOptions: OdbClientTypes.DataCollectionOptions?
        /// The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.
        public var dataStorageSizeInTBs: Swift.Double?
        /// The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The list of database servers for the VM cluster.
        public var dbServers: [Swift.String]?
        /// The type of redundancy configured for the VM cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        public var diskRedundancy: OdbClientTypes.DiskRedundancy?
        /// The user-friendly name for the VM cluster.
        public var displayName: Swift.String?
        /// The domain of the VM cluster.
        public var domain: Swift.String?
        /// The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.
        public var giVersion: Swift.String?
        /// The host name for the VM cluster.
        public var hostname: Swift.String?
        /// The IORM settings of the Exadata DB system.
        public var iormConfigCache: OdbClientTypes.ExadataIormConfig?
        /// Indicates whether database backups to local Exadata storage is enabled for the VM cluster.
        public var isLocalBackupEnabled: Swift.Bool?
        /// Indicates whether the VM cluster is configured with a sparse disk group.
        public var isSparseDiskgroupEnabled: Swift.Bool?
        /// The Oracle Cloud ID (OCID) of the last maintenance update history entry.
        public var lastUpdateHistoryEntryId: Swift.String?
        /// The Oracle license model applied to the VM cluster.
        public var licenseModel: OdbClientTypes.LicenseModel?
        /// The port number configured for the listener on the VM cluster.
        public var listenerPort: Swift.Int?
        /// The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.
        public var memorySizeInGBs: Swift.Int?
        /// The number of nodes in the VM cluster.
        public var nodeCount: Swift.Int?
        /// The name of the OCI resource anchor for the VM cluster.
        public var ociResourceAnchorName: Swift.String?
        /// The HTTPS link to the VM cluster in OCI.
        public var ociUrl: Swift.String?
        /// The OCID of the VM cluster.
        public var ocid: Swift.String?
        /// The unique identifier of the ODB network for the VM cluster.
        public var odbNetworkId: Swift.String?
        /// The amount of progress made on the current operation on the VM cluster, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.
        public var scanDnsName: Swift.String?
        /// The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.
        public var scanDnsRecordId: Swift.String?
        /// The OCID of the SCAN IP addresses that are associated with the VM cluster.
        public var scanIpIds: [Swift.String]?
        /// The hardware model name of the Exadata infrastructure that's running the VM cluster.
        public var shape: Swift.String?
        /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
        public var sshPublicKeys: [Swift.String]?
        /// The current status of the VM cluster.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the status of the VM cluster.
        public var statusReason: Swift.String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.
        public var storageSizeInGBs: Swift.Int?
        /// The operating system version of the image chosen for the VM cluster.
        public var systemVersion: Swift.String?
        /// The time zone of the VM cluster.
        public var timeZone: Swift.String?
        /// The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        public var vipIds: [Swift.String]?

        public init(
            cloudExadataInfrastructureId: Swift.String? = nil,
            cloudVmClusterArn: Swift.String? = nil,
            cloudVmClusterId: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dataCollectionOptions: OdbClientTypes.DataCollectionOptions? = nil,
            dataStorageSizeInTBs: Swift.Double? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServers: [Swift.String]? = nil,
            diskRedundancy: OdbClientTypes.DiskRedundancy? = nil,
            displayName: Swift.String? = nil,
            domain: Swift.String? = nil,
            giVersion: Swift.String? = nil,
            hostname: Swift.String? = nil,
            iormConfigCache: OdbClientTypes.ExadataIormConfig? = nil,
            isLocalBackupEnabled: Swift.Bool? = nil,
            isSparseDiskgroupEnabled: Swift.Bool? = nil,
            lastUpdateHistoryEntryId: Swift.String? = nil,
            licenseModel: OdbClientTypes.LicenseModel? = nil,
            listenerPort: Swift.Int? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            nodeCount: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociUrl: Swift.String? = nil,
            ocid: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            percentProgress: Swift.Float? = nil,
            scanDnsName: Swift.String? = nil,
            scanDnsRecordId: Swift.String? = nil,
            scanIpIds: [Swift.String]? = nil,
            shape: Swift.String? = nil,
            sshPublicKeys: [Swift.String]? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            storageSizeInGBs: Swift.Int? = nil,
            systemVersion: Swift.String? = nil,
            timeZone: Swift.String? = nil,
            vipIds: [Swift.String]? = nil
        ) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.cloudVmClusterArn = cloudVmClusterArn
            self.cloudVmClusterId = cloudVmClusterId
            self.clusterName = clusterName
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dataCollectionOptions = dataCollectionOptions
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.diskRedundancy = diskRedundancy
            self.displayName = displayName
            self.domain = domain
            self.giVersion = giVersion
            self.hostname = hostname
            self.iormConfigCache = iormConfigCache
            self.isLocalBackupEnabled = isLocalBackupEnabled
            self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
            self.lastUpdateHistoryEntryId = lastUpdateHistoryEntryId
            self.licenseModel = licenseModel
            self.listenerPort = listenerPort
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.ocid = ocid
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.scanDnsName = scanDnsName
            self.scanDnsRecordId = scanDnsRecordId
            self.scanIpIds = scanIpIds
            self.shape = shape
            self.sshPublicKeys = sshPublicKeys
            self.status = status
            self.statusReason = statusReason
            self.storageSizeInGBs = storageSizeInGBs
            self.systemVersion = systemVersion
            self.timeZone = timeZone
            self.vipIds = vipIds
        }
    }
}

extension OdbClientTypes.CloudVmClusterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudVmClusterSummary(cloudExadataInfrastructureId: \(Swift.String(describing: cloudExadataInfrastructureId)), cloudVmClusterArn: \(Swift.String(describing: cloudVmClusterArn)), cloudVmClusterId: \(Swift.String(describing: cloudVmClusterId)), clusterName: \(Swift.String(describing: clusterName)), computeModel: \(Swift.String(describing: computeModel)), cpuCoreCount: \(Swift.String(describing: cpuCoreCount)), createdAt: \(Swift.String(describing: createdAt)), dataCollectionOptions: \(Swift.String(describing: dataCollectionOptions)), dataStorageSizeInTBs: \(Swift.String(describing: dataStorageSizeInTBs)), dbNodeStorageSizeInGBs: \(Swift.String(describing: dbNodeStorageSizeInGBs)), dbServers: \(Swift.String(describing: dbServers)), diskRedundancy: \(Swift.String(describing: diskRedundancy)), displayName: \(Swift.String(describing: displayName)), domain: \(Swift.String(describing: domain)), giVersion: \(Swift.String(describing: giVersion)), hostname: \(Swift.String(describing: hostname)), iormConfigCache: \(Swift.String(describing: iormConfigCache)), isLocalBackupEnabled: \(Swift.String(describing: isLocalBackupEnabled)), isSparseDiskgroupEnabled: \(Swift.String(describing: isSparseDiskgroupEnabled)), lastUpdateHistoryEntryId: \(Swift.String(describing: lastUpdateHistoryEntryId)), licenseModel: \(Swift.String(describing: licenseModel)), listenerPort: \(Swift.String(describing: listenerPort)), memorySizeInGBs: \(Swift.String(describing: memorySizeInGBs)), nodeCount: \(Swift.String(describing: nodeCount)), ociResourceAnchorName: \(Swift.String(describing: ociResourceAnchorName)), ociUrl: \(Swift.String(describing: ociUrl)), ocid: \(Swift.String(describing: ocid)), odbNetworkId: \(Swift.String(describing: odbNetworkId)), percentProgress: \(Swift.String(describing: percentProgress)), scanDnsName: \(Swift.String(describing: scanDnsName)), scanDnsRecordId: \(Swift.String(describing: scanDnsRecordId)), scanIpIds: \(Swift.String(describing: scanIpIds)), shape: \(Swift.String(describing: shape)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), storageSizeInGBs: \(Swift.String(describing: storageSizeInGBs)), systemVersion: \(Swift.String(describing: systemVersion)), timeZone: \(Swift.String(describing: timeZone)), vipIds: \(Swift.String(describing: vipIds)), sshPublicKeys: \"CONTENT_REDACTED\")"}
}

public struct CreateCloudVmClusterInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
    public var clientToken: Swift.String?
    /// The unique identifier of the Exadata infrastructure for this VM cluster.
    /// This member is required.
    public var cloudExadataInfrastructureId: Swift.String?
    /// A name for the Grid Infrastructure cluster. The name isn't case sensitive.
    public var clusterName: Swift.String?
    /// The number of CPU cores to enable on the VM cluster.
    /// This member is required.
    public var cpuCoreCount: Swift.Int?
    /// The set of preferences for the various diagnostic collection options for the VM cluster.
    public var dataCollectionOptions: OdbClientTypes.DataCollectionOptions?
    /// The size of the data disk group, in terabytes (TBs), to allocate for the VM cluster.
    public var dataStorageSizeInTBs: Swift.Double?
    /// The amount of local node storage, in gigabytes (GBs), to allocate for the VM cluster.
    public var dbNodeStorageSizeInGBs: Swift.Int?
    /// The list of database servers for the VM cluster.
    public var dbServers: [Swift.String]?
    /// A user-friendly name for the VM cluster.
    /// This member is required.
    public var displayName: Swift.String?
    /// A valid software version of Oracle Grid Infrastructure (GI). To get the list of valid values, use the ListGiVersions operation and specify the shape of the Exadata infrastructure. Example: 19.0.0.0
    /// This member is required.
    public var giVersion: Swift.String?
    /// The host name for the VM cluster. Constraints:
    ///
    /// * Can't be "localhost" or "hostname".
    ///
    /// * Can't contain "-version".
    ///
    /// * The maximum length of the combined hostname and domain is 63 characters.
    ///
    /// * The hostname must be unique within the subnet.
    /// This member is required.
    public var hostname: Swift.String?
    /// Specifies whether to enable database backups to local Exadata storage for the VM cluster.
    public var isLocalBackupEnabled: Swift.Bool?
    /// Specifies whether to create a sparse disk group for the VM cluster.
    public var isSparseDiskgroupEnabled: Swift.Bool?
    /// The Oracle license model to apply to the VM cluster. Default: LICENSE_INCLUDED
    public var licenseModel: OdbClientTypes.LicenseModel?
    /// The amount of memory, in gigabytes (GBs), to allocate for the VM cluster.
    public var memorySizeInGBs: Swift.Int?
    /// The unique identifier of the ODB network for the VM cluster.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// The port number for TCP connections to the single client access name (SCAN) listener. Valid values: 10248999 with the following exceptions: 2484, 6100, 6200, 7060, 7070, 7085, and 7879 Default: 1521
    public var scanListenerPortTcp: Swift.Int?
    /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
    /// This member is required.
    public var sshPublicKeys: [Swift.String]?
    /// The version of the operating system of the image for the VM cluster.
    public var systemVersion: Swift.String?
    /// The list of resource tags to apply to the VM cluster.
    public var tags: [Swift.String: Swift.String]?
    /// The time zone for the VM cluster. For a list of valid values for time zone, you can check the options in the console. Default: UTC
    public var timeZone: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        cloudExadataInfrastructureId: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        cpuCoreCount: Swift.Int? = nil,
        dataCollectionOptions: OdbClientTypes.DataCollectionOptions? = nil,
        dataStorageSizeInTBs: Swift.Double? = nil,
        dbNodeStorageSizeInGBs: Swift.Int? = nil,
        dbServers: [Swift.String]? = nil,
        displayName: Swift.String? = nil,
        giVersion: Swift.String? = nil,
        hostname: Swift.String? = nil,
        isLocalBackupEnabled: Swift.Bool? = nil,
        isSparseDiskgroupEnabled: Swift.Bool? = nil,
        licenseModel: OdbClientTypes.LicenseModel? = nil,
        memorySizeInGBs: Swift.Int? = nil,
        odbNetworkId: Swift.String? = nil,
        scanListenerPortTcp: Swift.Int? = nil,
        sshPublicKeys: [Swift.String]? = nil,
        systemVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        timeZone: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.clusterName = clusterName
        self.cpuCoreCount = cpuCoreCount
        self.dataCollectionOptions = dataCollectionOptions
        self.dataStorageSizeInTBs = dataStorageSizeInTBs
        self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
        self.dbServers = dbServers
        self.displayName = displayName
        self.giVersion = giVersion
        self.hostname = hostname
        self.isLocalBackupEnabled = isLocalBackupEnabled
        self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
        self.licenseModel = licenseModel
        self.memorySizeInGBs = memorySizeInGBs
        self.odbNetworkId = odbNetworkId
        self.scanListenerPortTcp = scanListenerPortTcp
        self.sshPublicKeys = sshPublicKeys
        self.systemVersion = systemVersion
        self.tags = tags
        self.timeZone = timeZone
    }
}

public struct CreateCloudVmClusterOutput: Swift.Sendable {
    /// The unique identifier for the VM cluster.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The user-friendly name for the VM cluster.
    public var displayName: Swift.String?
    /// The current status of the VM cluster.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the VM cluster.
    public var statusReason: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.displayName = displayName
        self.status = status
        self.statusReason = statusReason
    }
}

public struct DeleteCloudVmClusterInput: Swift.Sendable {
    /// The unique identifier of the VM cluster to delete.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
    }
}

public struct DeleteCloudVmClusterOutput: Swift.Sendable {

    public init() { }
}

public struct GetCloudVmClusterInput: Swift.Sendable {
    /// The unique identifier of the VM cluster.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
    }
}

public struct GetCloudVmClusterOutput: Swift.Sendable {
    /// The VM cluster.
    public var cloudVmCluster: OdbClientTypes.CloudVmCluster?

    public init(
        cloudVmCluster: OdbClientTypes.CloudVmCluster? = nil
    ) {
        self.cloudVmCluster = cloudVmCluster
    }
}

public struct ListCloudVmClustersInput: Swift.Sendable {
    /// The unique identifier of the Oracle Exadata infrastructure.
    public var cloudExadataInfrastructureId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        cloudExadataInfrastructureId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCloudVmClustersOutput: Swift.Sendable {
    /// The list of VM clusters along with their properties.
    /// This member is required.
    public var cloudVmClusters: [OdbClientTypes.CloudVmClusterSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        cloudVmClusters: [OdbClientTypes.CloudVmClusterSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudVmClusters = cloudVmClusters
        self.nextToken = nextToken
    }
}

public struct CreateOdbNetworkInput: Swift.Sendable {
    /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId.
    public var availabilityZone: Swift.String?
    /// The AZ ID of the AZ where the ODB network is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId.
    public var availabilityZoneId: Swift.String?
    /// The CIDR range of the backup subnet for the ODB network. Constraints:
    ///
    /// * Must not overlap with the CIDR range of the client subnet.
    ///
    /// * Must not overlap with the CIDR ranges of the VPCs that are connected to the ODB network.
    ///
    /// * Must not use the following CIDR ranges that are reserved by OCI:
    ///
    /// * 100.106.0.0/16 and 100.107.0.0/16
    ///
    /// * 169.254.0.0/16
    ///
    /// * 224.0.0.0 - 239.255.255.255
    ///
    /// * 240.0.0.0 - 255.255.255.255
    public var backupSubnetCidr: Swift.String?
    /// The CIDR range of the client subnet for the ODB network. Constraints:
    ///
    /// * Must not overlap with the CIDR range of the backup subnet.
    ///
    /// * Must not overlap with the CIDR ranges of the VPCs that are connected to the ODB network.
    ///
    /// * Must not use the following CIDR ranges that are reserved by OCI:
    ///
    /// * 100.106.0.0/16 and 100.107.0.0/16
    ///
    /// * 169.254.0.0/16
    ///
    /// * 224.0.0.0 - 239.255.255.255
    ///
    /// * 240.0.0.0 - 255.255.255.255
    /// This member is required.
    public var clientSubnetCidr: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
    public var clientToken: Swift.String?
    /// The domain name to use for the resources in the ODB network.
    public var customDomainName: Swift.String?
    /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
    public var defaultDnsPrefix: Swift.String?
    /// A user-friendly name for the ODB network.
    /// This member is required.
    public var displayName: Swift.String?
    /// Specifies the configuration for Amazon S3 access from the ODB network.
    public var s3Access: OdbClientTypes.Access?
    /// Specifies the endpoint policy for Amazon S3 access from the ODB network.
    public var s3PolicyDocument: Swift.String?
    /// The list of resource tags to apply to the ODB network.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies the configuration for Zero-ETL access from the ODB network.
    public var zeroEtlAccess: OdbClientTypes.Access?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        backupSubnetCidr: Swift.String? = nil,
        clientSubnetCidr: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        defaultDnsPrefix: Swift.String? = nil,
        displayName: Swift.String? = nil,
        s3Access: OdbClientTypes.Access? = nil,
        s3PolicyDocument: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        zeroEtlAccess: OdbClientTypes.Access? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.backupSubnetCidr = backupSubnetCidr
        self.clientSubnetCidr = clientSubnetCidr
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.defaultDnsPrefix = defaultDnsPrefix
        self.displayName = displayName
        self.s3Access = s3Access
        self.s3PolicyDocument = s3PolicyDocument
        self.tags = tags
        self.zeroEtlAccess = zeroEtlAccess
    }
}

public struct CreateOdbNetworkOutput: Swift.Sendable {
    /// The user-friendly name of the ODB network.
    public var displayName: Swift.String?
    /// The unique identifier of the ODB network.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// The current status of the ODB network.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the ODB network.
    public var statusReason: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        odbNetworkId: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.displayName = displayName
        self.odbNetworkId = odbNetworkId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct CreateOdbPeeringConnectionInput: Swift.Sendable {
    /// The client token for the ODB peering connection request. Constraints:
    ///
    /// * Must be unique for each request.
    public var clientToken: Swift.String?
    /// The display name for the ODB peering connection.
    public var displayName: Swift.String?
    /// The unique identifier of the ODB network that initiates the peering connection.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// A list of CIDR blocks to add to the peering connection. These CIDR blocks define the IP address ranges that can communicate through the peering connection.
    public var peerNetworkCidrsToBeAdded: [Swift.String]?
    /// The unique identifier of the peer network. This can be either a VPC ID or another ODB network ID.
    /// This member is required.
    public var peerNetworkId: Swift.String?
    /// The tags to assign to the ODB peering connection.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        odbNetworkId: Swift.String? = nil,
        peerNetworkCidrsToBeAdded: [Swift.String]? = nil,
        peerNetworkId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.displayName = displayName
        self.odbNetworkId = odbNetworkId
        self.peerNetworkCidrsToBeAdded = peerNetworkCidrsToBeAdded
        self.peerNetworkId = peerNetworkId
        self.tags = tags
    }
}

public struct CreateOdbPeeringConnectionOutput: Swift.Sendable {
    /// The display name of the ODB peering connection.
    public var displayName: Swift.String?
    /// The unique identifier of the ODB peering connection.
    /// This member is required.
    public var odbPeeringConnectionId: Swift.String?
    /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
    public var status: OdbClientTypes.ResourceStatus?
    /// The reason for the current status of the ODB peering connection.
    public var statusReason: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        odbPeeringConnectionId: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.displayName = displayName
        self.odbPeeringConnectionId = odbPeeringConnectionId
        self.status = status
        self.statusReason = statusReason
    }
}

extension OdbClientTypes {

    public enum DbNodeMaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vmdbRebootMigration
        case sdkUnknown(Swift.String)

        public static var allCases: [DbNodeMaintenanceType] {
            return [
                .vmdbRebootMigration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vmdbRebootMigration: return "VMDB_REBOOT_MIGRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    public enum DbNodeResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case failed
        case provisioning
        case starting
        case stopped
        case stopping
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DbNodeResourceStatus] {
            return [
                .available,
                .failed,
                .provisioning,
                .starting,
                .stopped,
                .stopping,
                .terminated,
                .terminating,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .failed: return "FAILED"
            case .provisioning: return "PROVISIONING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// Information about a DB node.
    public struct DbNode: Swift.Sendable {
        /// Additional information about the planned maintenance.
        public var additionalDetails: Swift.String?
        /// The Oracle Cloud ID (OCID) of the backup IP address that's associated with the DB node.
        public var backupIpId: Swift.String?
        /// The OCID of the second backup VNIC.
        public var backupVnic2Id: Swift.String?
        /// The OCID of the backup VNIC.
        public var backupVnicId: Swift.String?
        /// Number of CPU cores enabled on the DB node.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the DB node was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the DB node.
        public var dbNodeArn: Swift.String?
        /// The unique identifier of the DB node.
        public var dbNodeId: Swift.String?
        /// The amount of local node storage, in gigabytes (GBs), that's allocated on the DB node.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The unique identifier of the Db server that is associated with the DB node.
        public var dbServerId: Swift.String?
        /// The OCID of the DB system.
        public var dbSystemId: Swift.String?
        /// The name of the fault domain the instance is contained in.
        public var faultDomain: Swift.String?
        /// The floating IP address assigned to the DB node.
        public var floatingIpAddress: Swift.String?
        /// The OCID of the host IP address that's associated with the DB node.
        public var hostIpId: Swift.String?
        /// The host name for the DB node.
        public var hostname: Swift.String?
        /// The type of database node maintenance. Either VMDB_REBOOT_MIGRATION or EXADBXS_REBOOT_MIGRATION.
        public var maintenanceType: OdbClientTypes.DbNodeMaintenanceType?
        /// The allocated memory in GBs on the DB node.
        public var memorySizeInGBs: Swift.Int?
        /// The name of the OCI resource anchor for the DB node.
        public var ociResourceAnchorName: Swift.String?
        /// The OCID of the DB node.
        public var ocid: Swift.String?
        /// The private IP address assigned to the DB node.
        public var privateIpAddress: Swift.String?
        /// The size (in GB) of the block storage volume allocation for the DB system.
        public var softwareStorageSizeInGB: Swift.Int?
        /// The current status of the DB node.
        public var status: OdbClientTypes.DbNodeResourceStatus?
        /// Additional information about the status of the DB node.
        public var statusReason: Swift.String?
        /// End date and time of maintenance window.
        public var timeMaintenanceWindowEnd: Swift.String?
        /// Start date and time of maintenance window.
        public var timeMaintenanceWindowStart: Swift.String?
        /// The total number of CPU cores reserved on the DB node.
        public var totalCpuCoreCount: Swift.Int?
        /// The OCID of the second VNIC.
        public var vnic2Id: Swift.String?
        /// The OCID of the VNIC.
        public var vnicId: Swift.String?

        public init(
            additionalDetails: Swift.String? = nil,
            backupIpId: Swift.String? = nil,
            backupVnic2Id: Swift.String? = nil,
            backupVnicId: Swift.String? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dbNodeArn: Swift.String? = nil,
            dbNodeId: Swift.String? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerId: Swift.String? = nil,
            dbSystemId: Swift.String? = nil,
            faultDomain: Swift.String? = nil,
            floatingIpAddress: Swift.String? = nil,
            hostIpId: Swift.String? = nil,
            hostname: Swift.String? = nil,
            maintenanceType: OdbClientTypes.DbNodeMaintenanceType? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ocid: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            softwareStorageSizeInGB: Swift.Int? = nil,
            status: OdbClientTypes.DbNodeResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            timeMaintenanceWindowEnd: Swift.String? = nil,
            timeMaintenanceWindowStart: Swift.String? = nil,
            totalCpuCoreCount: Swift.Int? = nil,
            vnic2Id: Swift.String? = nil,
            vnicId: Swift.String? = nil
        ) {
            self.additionalDetails = additionalDetails
            self.backupIpId = backupIpId
            self.backupVnic2Id = backupVnic2Id
            self.backupVnicId = backupVnicId
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeArn = dbNodeArn
            self.dbNodeId = dbNodeId
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbSystemId = dbSystemId
            self.faultDomain = faultDomain
            self.floatingIpAddress = floatingIpAddress
            self.hostIpId = hostIpId
            self.hostname = hostname
            self.maintenanceType = maintenanceType
            self.memorySizeInGBs = memorySizeInGBs
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ocid = ocid
            self.privateIpAddress = privateIpAddress
            self.softwareStorageSizeInGB = softwareStorageSizeInGB
            self.status = status
            self.statusReason = statusReason
            self.timeMaintenanceWindowEnd = timeMaintenanceWindowEnd
            self.timeMaintenanceWindowStart = timeMaintenanceWindowStart
            self.totalCpuCoreCount = totalCpuCoreCount
            self.vnic2Id = vnic2Id
            self.vnicId = vnicId
        }
    }
}

extension OdbClientTypes {

    /// Information about a DB node.
    public struct DbNodeSummary: Swift.Sendable {
        /// Additional information about the planned maintenance.
        public var additionalDetails: Swift.String?
        /// The Oracle Cloud ID (OCID) of the backup IP address that's associated with the DB node.
        public var backupIpId: Swift.String?
        /// The OCID of the second backup virtual network interface card (VNIC) for the DB node.
        public var backupVnic2Id: Swift.String?
        /// The OCID of the backup VNIC for the DB node.
        public var backupVnicId: Swift.String?
        /// The number of CPU cores enabled on the DB node.
        public var cpuCoreCount: Swift.Int?
        /// The date and time when the DB node was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the DB node.
        public var dbNodeArn: Swift.String?
        /// The unique identifier of the DB node.
        public var dbNodeId: Swift.String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated on the DB node.
        public var dbNodeStorageSizeInGBs: Swift.Int?
        /// The unique identifier of the database server that's associated with the DB node.
        public var dbServerId: Swift.String?
        /// The OCID of the DB system.
        public var dbSystemId: Swift.String?
        /// The name of the fault domain where the DB node is located.
        public var faultDomain: Swift.String?
        /// The OCID of the host IP address that's associated with the DB node.
        public var hostIpId: Swift.String?
        /// The host name for the DB node.
        public var hostname: Swift.String?
        /// The type of maintenance the DB node.
        public var maintenanceType: OdbClientTypes.DbNodeMaintenanceType?
        /// The amount of memory, in gigabytes (GB), that allocated on the DB node.
        public var memorySizeInGBs: Swift.Int?
        /// The name of the OCI resource anchor for the DB node.
        public var ociResourceAnchorName: Swift.String?
        /// The OCID of the DB node.
        public var ocid: Swift.String?
        /// The size of the block storage volume, in gigabytes (GB), that's allocated for the DB system. This attribute applies only for virtual machine DB systems.
        public var softwareStorageSizeInGB: Swift.Int?
        /// The current status of the DB node.
        public var status: OdbClientTypes.DbNodeResourceStatus?
        /// Additional information about the status of the DB node.
        public var statusReason: Swift.String?
        /// The end date and time of the maintenance window.
        public var timeMaintenanceWindowEnd: Swift.String?
        /// The start date and time of the maintenance window.
        public var timeMaintenanceWindowStart: Swift.String?
        /// The total number of CPU cores reserved on the DB node.
        public var totalCpuCoreCount: Swift.Int?
        /// The OCID of the second VNIC.
        public var vnic2Id: Swift.String?
        /// The OCID of the VNIC.
        public var vnicId: Swift.String?

        public init(
            additionalDetails: Swift.String? = nil,
            backupIpId: Swift.String? = nil,
            backupVnic2Id: Swift.String? = nil,
            backupVnicId: Swift.String? = nil,
            cpuCoreCount: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            dbNodeArn: Swift.String? = nil,
            dbNodeId: Swift.String? = nil,
            dbNodeStorageSizeInGBs: Swift.Int? = nil,
            dbServerId: Swift.String? = nil,
            dbSystemId: Swift.String? = nil,
            faultDomain: Swift.String? = nil,
            hostIpId: Swift.String? = nil,
            hostname: Swift.String? = nil,
            maintenanceType: OdbClientTypes.DbNodeMaintenanceType? = nil,
            memorySizeInGBs: Swift.Int? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ocid: Swift.String? = nil,
            softwareStorageSizeInGB: Swift.Int? = nil,
            status: OdbClientTypes.DbNodeResourceStatus? = nil,
            statusReason: Swift.String? = nil,
            timeMaintenanceWindowEnd: Swift.String? = nil,
            timeMaintenanceWindowStart: Swift.String? = nil,
            totalCpuCoreCount: Swift.Int? = nil,
            vnic2Id: Swift.String? = nil,
            vnicId: Swift.String? = nil
        ) {
            self.additionalDetails = additionalDetails
            self.backupIpId = backupIpId
            self.backupVnic2Id = backupVnic2Id
            self.backupVnicId = backupVnicId
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeArn = dbNodeArn
            self.dbNodeId = dbNodeId
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbSystemId = dbSystemId
            self.faultDomain = faultDomain
            self.hostIpId = hostIpId
            self.hostname = hostname
            self.maintenanceType = maintenanceType
            self.memorySizeInGBs = memorySizeInGBs
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ocid = ocid
            self.softwareStorageSizeInGB = softwareStorageSizeInGB
            self.status = status
            self.statusReason = statusReason
            self.timeMaintenanceWindowEnd = timeMaintenanceWindowEnd
            self.timeMaintenanceWindowStart = timeMaintenanceWindowStart
            self.totalCpuCoreCount = totalCpuCoreCount
            self.vnic2Id = vnic2Id
            self.vnicId = vnicId
        }
    }
}

public struct GetDbNodeInput: Swift.Sendable {
    /// The unique identifier of the VM cluster that contains the DB node.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The unique identifier of the DB node to retrieve information about.
    /// This member is required.
    public var dbNodeId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        dbNodeId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.dbNodeId = dbNodeId
    }
}

public struct GetDbNodeOutput: Swift.Sendable {
    /// Information about a DB node.
    public var dbNode: OdbClientTypes.DbNode?

    public init(
        dbNode: OdbClientTypes.DbNode? = nil
    ) {
        self.dbNode = dbNode
    }
}

public struct ListDbNodesInput: Swift.Sendable {
    /// The unique identifier of the VM cluster.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDbNodesOutput: Swift.Sendable {
    /// The list of DB nodes along with their properties.
    /// This member is required.
    public var dbNodes: [OdbClientTypes.DbNodeSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        dbNodes: [OdbClientTypes.DbNodeSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dbNodes = dbNodes
        self.nextToken = nextToken
    }
}

public struct RebootDbNodeInput: Swift.Sendable {
    /// The unique identifier of the VM cluster that contains the DB node to reboot.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The unique identifier of the DB node to reboot.
    /// This member is required.
    public var dbNodeId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        dbNodeId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.dbNodeId = dbNodeId
    }
}

public struct RebootDbNodeOutput: Swift.Sendable {
    /// The unique identifier of the DB node that was rebooted.
    /// This member is required.
    public var dbNodeId: Swift.String?
    /// The current status of the DB node after the reboot operation.
    public var status: OdbClientTypes.DbNodeResourceStatus?
    /// Additional information about the status of the DB node after the reboot operation.
    public var statusReason: Swift.String?

    public init(
        dbNodeId: Swift.String? = nil,
        status: OdbClientTypes.DbNodeResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.dbNodeId = dbNodeId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct StartDbNodeInput: Swift.Sendable {
    /// The unique identifier of the VM cluster that contains the DB node to start.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The unique identifier of the DB node to start.
    /// This member is required.
    public var dbNodeId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        dbNodeId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.dbNodeId = dbNodeId
    }
}

public struct StartDbNodeOutput: Swift.Sendable {
    /// The unique identifier of the DB node that was started.
    /// This member is required.
    public var dbNodeId: Swift.String?
    /// The current status of the DB node after the start operation.
    public var status: OdbClientTypes.DbNodeResourceStatus?
    /// Additional information about the status of the DB node after the start operation.
    public var statusReason: Swift.String?

    public init(
        dbNodeId: Swift.String? = nil,
        status: OdbClientTypes.DbNodeResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.dbNodeId = dbNodeId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct StopDbNodeInput: Swift.Sendable {
    /// The unique identifier of the VM cluster that contains the DB node to stop.
    /// This member is required.
    public var cloudVmClusterId: Swift.String?
    /// The unique identifier of the DB node to stop.
    /// This member is required.
    public var dbNodeId: Swift.String?

    public init(
        cloudVmClusterId: Swift.String? = nil,
        dbNodeId: Swift.String? = nil
    ) {
        self.cloudVmClusterId = cloudVmClusterId
        self.dbNodeId = dbNodeId
    }
}

public struct StopDbNodeOutput: Swift.Sendable {
    /// The unique identifier of the DB node that was stopped.
    /// This member is required.
    public var dbNodeId: Swift.String?
    /// The current status of the DB node after the stop operation.
    public var status: OdbClientTypes.DbNodeResourceStatus?
    /// Additional information about the status of the DB node after the stop operation.
    public var statusReason: Swift.String?

    public init(
        dbNodeId: Swift.String? = nil,
        status: OdbClientTypes.DbNodeResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.dbNodeId = dbNodeId
        self.status = status
        self.statusReason = statusReason
    }
}

extension OdbClientTypes {

    public enum ShapeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amd
        case ampereFlexA1
        case intel
        case intelFlexX9
        case sdkUnknown(Swift.String)

        public static var allCases: [ShapeType] {
            return [
                .amd,
                .ampereFlexA1,
                .intel,
                .intelFlexX9
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amd: return "AMD"
            case .ampereFlexA1: return "AMPERE_FLEX_A1"
            case .intel: return "INTEL"
            case .intelFlexX9: return "INTEL_FLEX_X9"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// Information about a hardware system model (shape) that's available for an Exadata infrastructure. The shape determines resources, such as CPU cores, memory, and storage, to allocate to the Exadata infrastructure.
    public struct DbSystemShapeSummary: Swift.Sendable {
        /// Indicates whether the hardware system model supports configurable database and server storage types.
        public var areServerTypesSupported: Swift.Bool?
        /// The maximum number of CPU cores that can be enabled for the shape.
        public var availableCoreCount: Swift.Int?
        /// The maximum number of CPU cores per DB node that can be enabled for the shape.
        public var availableCoreCountPerNode: Swift.Int?
        /// The maximum amount of data storage, in terabytes (TB), that can be enabled for the shape.
        public var availableDataStorageInTBs: Swift.Int?
        /// The maximum amount of data storage, in terabytes (TB), that's available per storage server for the shape.
        public var availableDataStoragePerServerInTBs: Swift.Int?
        /// The maximum amount of DB node storage, in gigabytes (GB), that's available per DB node for the shape.
        public var availableDbNodePerNodeInGBs: Swift.Int?
        /// The maximum amount of DB node storage, in gigabytes (GB), that can be enabled for the shape.
        public var availableDbNodeStorageInGBs: Swift.Int?
        /// The maximum amount of memory, in gigabytes (GB), that can be enabled for the shape.
        public var availableMemoryInGBs: Swift.Int?
        /// The maximum amount of memory, in gigabytes (GB), that's available per DB node for the shape.
        public var availableMemoryPerNodeInGBs: Swift.Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public var computeModel: OdbClientTypes.ComputeModel?
        /// The discrete number by which the CPU core count for the shape can be increased or decreased.
        public var coreCountIncrement: Swift.Int?
        /// The maximum number of Exadata storage servers that's available for the shape.
        public var maxStorageCount: Swift.Int?
        /// The maximum number of compute servers that is available for the shape.
        public var maximumNodeCount: Swift.Int?
        /// The minimum number of CPU cores that can be enabled per node for the shape.
        public var minCoreCountPerNode: Swift.Int?
        /// The minimum amount of data storage, in terabytes (TB), that must be allocated for the shape.
        public var minDataStorageInTBs: Swift.Int?
        /// The minimum amount of DB node storage, in gigabytes (GB), that must be allocated per DB node for the shape.
        public var minDbNodeStoragePerNodeInGBs: Swift.Int?
        /// The minimum amount of memory, in gigabytes (GB), that must be allocated per DB node for the shape.
        public var minMemoryPerNodeInGBs: Swift.Int?
        /// The minimum number of Exadata storage servers that are available for the shape.
        public var minStorageCount: Swift.Int?
        /// The minimum number of CPU cores that can be enabled for the shape.
        public var minimumCoreCount: Swift.Int?
        /// The minimum number of compute servers that are available for the shape.
        public var minimumNodeCount: Swift.Int?
        /// The name of the shape.
        public var name: Swift.String?
        /// The runtime minimum number of CPU cores that can be enabled for the shape.
        public var runtimeMinimumCoreCount: Swift.Int?
        /// The family of the shape.
        public var shapeFamily: Swift.String?
        /// The shape type. This property is determined by the CPU hardware.
        public var shapeType: OdbClientTypes.ShapeType?

        public init(
            areServerTypesSupported: Swift.Bool? = nil,
            availableCoreCount: Swift.Int? = nil,
            availableCoreCountPerNode: Swift.Int? = nil,
            availableDataStorageInTBs: Swift.Int? = nil,
            availableDataStoragePerServerInTBs: Swift.Int? = nil,
            availableDbNodePerNodeInGBs: Swift.Int? = nil,
            availableDbNodeStorageInGBs: Swift.Int? = nil,
            availableMemoryInGBs: Swift.Int? = nil,
            availableMemoryPerNodeInGBs: Swift.Int? = nil,
            computeModel: OdbClientTypes.ComputeModel? = nil,
            coreCountIncrement: Swift.Int? = nil,
            maxStorageCount: Swift.Int? = nil,
            maximumNodeCount: Swift.Int? = nil,
            minCoreCountPerNode: Swift.Int? = nil,
            minDataStorageInTBs: Swift.Int? = nil,
            minDbNodeStoragePerNodeInGBs: Swift.Int? = nil,
            minMemoryPerNodeInGBs: Swift.Int? = nil,
            minStorageCount: Swift.Int? = nil,
            minimumCoreCount: Swift.Int? = nil,
            minimumNodeCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            runtimeMinimumCoreCount: Swift.Int? = nil,
            shapeFamily: Swift.String? = nil,
            shapeType: OdbClientTypes.ShapeType? = nil
        ) {
            self.areServerTypesSupported = areServerTypesSupported
            self.availableCoreCount = availableCoreCount
            self.availableCoreCountPerNode = availableCoreCountPerNode
            self.availableDataStorageInTBs = availableDataStorageInTBs
            self.availableDataStoragePerServerInTBs = availableDataStoragePerServerInTBs
            self.availableDbNodePerNodeInGBs = availableDbNodePerNodeInGBs
            self.availableDbNodeStorageInGBs = availableDbNodeStorageInGBs
            self.availableMemoryInGBs = availableMemoryInGBs
            self.availableMemoryPerNodeInGBs = availableMemoryPerNodeInGBs
            self.computeModel = computeModel
            self.coreCountIncrement = coreCountIncrement
            self.maxStorageCount = maxStorageCount
            self.maximumNodeCount = maximumNodeCount
            self.minCoreCountPerNode = minCoreCountPerNode
            self.minDataStorageInTBs = minDataStorageInTBs
            self.minDbNodeStoragePerNodeInGBs = minDbNodeStoragePerNodeInGBs
            self.minMemoryPerNodeInGBs = minMemoryPerNodeInGBs
            self.minStorageCount = minStorageCount
            self.minimumCoreCount = minimumCoreCount
            self.minimumNodeCount = minimumNodeCount
            self.name = name
            self.runtimeMinimumCoreCount = runtimeMinimumCoreCount
            self.shapeFamily = shapeFamily
            self.shapeType = shapeType
        }
    }
}

public struct DeleteOdbNetworkInput: Swift.Sendable {
    /// Specifies whether to delete associated OCI networking resources along with the ODB network.
    /// This member is required.
    public var deleteAssociatedResources: Swift.Bool?
    /// The unique identifier of the ODB network to delete.
    /// This member is required.
    public var odbNetworkId: Swift.String?

    public init(
        deleteAssociatedResources: Swift.Bool? = nil,
        odbNetworkId: Swift.String? = nil
    ) {
        self.deleteAssociatedResources = deleteAssociatedResources
        self.odbNetworkId = odbNetworkId
    }
}

public struct DeleteOdbNetworkOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOdbPeeringConnectionInput: Swift.Sendable {
    /// The unique identifier of the ODB peering connection to delete.
    /// This member is required.
    public var odbPeeringConnectionId: Swift.String?

    public init(
        odbPeeringConnectionId: Swift.String? = nil
    ) {
        self.odbPeeringConnectionId = odbPeeringConnectionId
    }
}

public struct DeleteOdbPeeringConnectionOutput: Swift.Sendable {

    public init() { }
}

public struct GetOciOnboardingStatusInput: Swift.Sendable {

    public init() { }
}

extension OdbClientTypes {

    ///
    public enum OciOnboardingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case activeInHomeRegion
        case activeLimited
        case canceled
        case failed
        case notStarted
        case pendingCustomerAction
        case pendingInitialization
        case pendingLinkGeneration
        case publicOfferUnsupported
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [OciOnboardingStatus] {
            return [
                .activating,
                .active,
                .activeInHomeRegion,
                .activeLimited,
                .canceled,
                .failed,
                .notStarted,
                .pendingCustomerAction,
                .pendingInitialization,
                .pendingLinkGeneration,
                .publicOfferUnsupported,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .activeInHomeRegion: return "ACTIVE_IN_HOME_REGION"
            case .activeLimited: return "ACTIVE_LIMITED"
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .notStarted: return "NOT_STARTED"
            case .pendingCustomerAction: return "PENDING_CUSTOMER_ACTION"
            case .pendingInitialization: return "PENDING_INITIALIZATION"
            case .pendingLinkGeneration: return "PENDING_LINK_GENERATION"
            case .publicOfferUnsupported: return "PUBLIC_OFFER_UNSUPPORTED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetOciOnboardingStatusOutput: Swift.Sendable {
    /// The existing OCI tenancy activation link for your Amazon Web Services account.
    public var existingTenancyActivationLink: Swift.String?
    /// A new OCI tenancy activation link for your Amazon Web Services account.
    public var newTenancyActivationLink: Swift.String?
    ///
    public var status: OdbClientTypes.OciOnboardingStatus?

    public init(
        existingTenancyActivationLink: Swift.String? = nil,
        newTenancyActivationLink: Swift.String? = nil,
        status: OdbClientTypes.OciOnboardingStatus? = nil
    ) {
        self.existingTenancyActivationLink = existingTenancyActivationLink
        self.newTenancyActivationLink = newTenancyActivationLink
        self.status = status
    }
}

public struct GetOdbNetworkInput: Swift.Sendable {
    /// The unique identifier of the ODB network.
    /// This member is required.
    public var odbNetworkId: Swift.String?

    public init(
        odbNetworkId: Swift.String? = nil
    ) {
        self.odbNetworkId = odbNetworkId
    }
}

extension OdbClientTypes {

    public enum ManagedResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagedResourceStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The configuration for managed Amazon S3 backup access from the ODB network.
    public struct ManagedS3BackupAccess: Swift.Sendable {
        /// The IPv4 addresses for the managed Amazon S3 backup access.
        public var ipv4Addresses: [Swift.String]?
        /// The status of the managed Amazon S3 backup access. Valid Values: enabled | disabled
        public var status: OdbClientTypes.ManagedResourceStatus?

        public init(
            ipv4Addresses: [Swift.String]? = nil,
            status: OdbClientTypes.ManagedResourceStatus? = nil
        ) {
            self.ipv4Addresses = ipv4Addresses
            self.status = status
        }
    }
}

extension OdbClientTypes {

    /// The configuration for Amazon S3 access from the ODB network.
    public struct S3Access: Swift.Sendable {
        /// The domain name for the Amazon S3 access.
        public var domainName: Swift.String?
        /// The IPv4 addresses for the Amazon S3 access.
        public var ipv4Addresses: [Swift.String]?
        /// The endpoint policy for the Amazon S3 access.
        public var s3PolicyDocument: Swift.String?
        /// The status of the Amazon S3 access. Valid Values: enabled | disabled
        public var status: OdbClientTypes.ManagedResourceStatus?

        public init(
            domainName: Swift.String? = nil,
            ipv4Addresses: [Swift.String]? = nil,
            s3PolicyDocument: Swift.String? = nil,
            status: OdbClientTypes.ManagedResourceStatus? = nil
        ) {
            self.domainName = domainName
            self.ipv4Addresses = ipv4Addresses
            self.s3PolicyDocument = s3PolicyDocument
            self.status = status
        }
    }
}

extension OdbClientTypes {

    public enum VpcEndpointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case servicenetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointType] {
            return [
                .servicenetwork
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .servicenetwork: return "SERVICENETWORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OdbClientTypes {

    /// The configuration for a service network endpoint.
    public struct ServiceNetworkEndpoint: Swift.Sendable {
        /// The identifier of the VPC endpoint.
        public var vpcEndpointId: Swift.String?
        /// The type of the VPC endpoint. Valid Values: Interface | Gateway
        public var vpcEndpointType: OdbClientTypes.VpcEndpointType?

        public init(
            vpcEndpointId: Swift.String? = nil,
            vpcEndpointType: OdbClientTypes.VpcEndpointType? = nil
        ) {
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointType = vpcEndpointType
        }
    }
}

extension OdbClientTypes {

    /// The configuration for Zero-ETL access from the ODB network.
    public struct ZeroEtlAccess: Swift.Sendable {
        /// The CIDR block for the Zero-ETL access.
        public var cidr: Swift.String?
        /// The status of the Zero-ETL access. Valid Values: enabled | disabled
        public var status: OdbClientTypes.ManagedResourceStatus?

        public init(
            cidr: Swift.String? = nil,
            status: OdbClientTypes.ManagedResourceStatus? = nil
        ) {
            self.cidr = cidr
            self.status = status
        }
    }
}

extension OdbClientTypes {

    /// The managed services configuration for the ODB network.
    public struct ManagedServices: Swift.Sendable {
        /// The managed Amazon S3 backup access configuration.
        public var managedS3BackupAccess: OdbClientTypes.ManagedS3BackupAccess?
        /// The IPv4 CIDR blocks for the managed services.
        public var managedServicesIpv4Cidrs: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public var resourceGatewayArn: Swift.String?
        /// The Amazon S3 access configuration.
        public var s3Access: OdbClientTypes.S3Access?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The service network endpoint configuration.
        public var serviceNetworkEndpoint: OdbClientTypes.ServiceNetworkEndpoint?
        /// The Zero-ETL access configuration.
        public var zeroEtlAccess: OdbClientTypes.ZeroEtlAccess?

        public init(
            managedS3BackupAccess: OdbClientTypes.ManagedS3BackupAccess? = nil,
            managedServicesIpv4Cidrs: [Swift.String]? = nil,
            resourceGatewayArn: Swift.String? = nil,
            s3Access: OdbClientTypes.S3Access? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkEndpoint: OdbClientTypes.ServiceNetworkEndpoint? = nil,
            zeroEtlAccess: OdbClientTypes.ZeroEtlAccess? = nil
        ) {
            self.managedS3BackupAccess = managedS3BackupAccess
            self.managedServicesIpv4Cidrs = managedServicesIpv4Cidrs
            self.resourceGatewayArn = resourceGatewayArn
            self.s3Access = s3Access
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkEndpoint = serviceNetworkEndpoint
            self.zeroEtlAccess = zeroEtlAccess
        }
    }
}

extension OdbClientTypes {

    /// DNS configuration to forward DNS resolver endpoints to your OCI Private Zone.
    public struct OciDnsForwardingConfig: Swift.Sendable {
        /// Domain name to which DNS resolver forwards to.
        public var domainName: Swift.String?
        /// OCI DNS listener IP for custom DNS setup.
        public var ociDnsListenerIp: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            ociDnsListenerIp: Swift.String? = nil
        ) {
            self.domainName = domainName
            self.ociDnsListenerIp = ociDnsListenerIp
        }
    }
}

extension OdbClientTypes {

    /// Information about an ODB network.
    public struct OdbNetwork: Swift.Sendable {
        /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located.
        public var availabilityZone: Swift.String?
        /// The AZ ID of the AZ where the ODB network is located.
        public var availabilityZoneId: Swift.String?
        /// The CIDR range of the backup subnet in the ODB network.
        public var backupSubnetCidr: Swift.String?
        /// The CIDR range of the client subnet in the ODB network.
        public var clientSubnetCidr: Swift.String?
        /// The date and time when the ODB network was created.
        public var createdAt: Foundation.Date?
        /// The domain name for the resources in the ODB network.
        public var customDomainName: Swift.String?
        /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
        public var defaultDnsPrefix: Swift.String?
        /// The user-friendly name of the ODB network.
        public var displayName: Swift.String?
        /// The managed services configuration for the ODB network.
        public var managedServices: OdbClientTypes.ManagedServices?
        /// The DNS resolver endpoint in OCI for forwarding DNS queries for the ociPrivateZone domain.
        public var ociDnsForwardingConfigs: [OdbClientTypes.OciDnsForwardingConfig]?
        /// The unique identifier of the OCI network anchor for the ODB network.
        public var ociNetworkAnchorId: Swift.String?
        /// The URL of the OCI network anchor for the ODB network.
        public var ociNetworkAnchorUrl: Swift.String?
        /// The name of the OCI resource anchor that's associated with the ODB network.
        public var ociResourceAnchorName: Swift.String?
        /// The Oracle Cloud ID (OCID) for the Virtual Cloud Network (VCN) that's associated with the ODB network.
        public var ociVcnId: Swift.String?
        /// The URL for the VCN that's associated with the ODB network.
        public var ociVcnUrl: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB network.
        public var odbNetworkArn: Swift.String?
        /// The unique identifier of the ODB network.
        /// This member is required.
        public var odbNetworkId: Swift.String?
        /// The list of CIDR ranges from the peered VPC that are allowed access to the ODB network.
        public var peeredCidrs: [Swift.String]?
        /// The amount of progress made on the current operation on the ODB network, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The current status of the ODB network.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the ODB network.
        public var statusReason: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            backupSubnetCidr: Swift.String? = nil,
            clientSubnetCidr: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            defaultDnsPrefix: Swift.String? = nil,
            displayName: Swift.String? = nil,
            managedServices: OdbClientTypes.ManagedServices? = nil,
            ociDnsForwardingConfigs: [OdbClientTypes.OciDnsForwardingConfig]? = nil,
            ociNetworkAnchorId: Swift.String? = nil,
            ociNetworkAnchorUrl: Swift.String? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociVcnId: Swift.String? = nil,
            ociVcnUrl: Swift.String? = nil,
            odbNetworkArn: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            peeredCidrs: [Swift.String]? = nil,
            percentProgress: Swift.Float? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.backupSubnetCidr = backupSubnetCidr
            self.clientSubnetCidr = clientSubnetCidr
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.defaultDnsPrefix = defaultDnsPrefix
            self.displayName = displayName
            self.managedServices = managedServices
            self.ociDnsForwardingConfigs = ociDnsForwardingConfigs
            self.ociNetworkAnchorId = ociNetworkAnchorId
            self.ociNetworkAnchorUrl = ociNetworkAnchorUrl
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociVcnId = ociVcnId
            self.ociVcnUrl = ociVcnUrl
            self.odbNetworkArn = odbNetworkArn
            self.odbNetworkId = odbNetworkId
            self.peeredCidrs = peeredCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct GetOdbNetworkOutput: Swift.Sendable {
    /// The ODB network.
    public var odbNetwork: OdbClientTypes.OdbNetwork?

    public init(
        odbNetwork: OdbClientTypes.OdbNetwork? = nil
    ) {
        self.odbNetwork = odbNetwork
    }
}

public struct GetOdbPeeringConnectionInput: Swift.Sendable {
    /// The unique identifier of the ODB peering connection to retrieve information about.
    /// This member is required.
    public var odbPeeringConnectionId: Swift.String?

    public init(
        odbPeeringConnectionId: Swift.String? = nil
    ) {
        self.odbPeeringConnectionId = odbPeeringConnectionId
    }
}

extension OdbClientTypes {

    /// A peering connection between an ODB network and either another ODB network or a customer-owned VPC.
    public struct OdbPeeringConnection: Swift.Sendable {
        /// The timestamp when the ODB peering connection was created.
        public var createdAt: Foundation.Date?
        /// The display name of the ODB peering connection.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB network that initiated the peering connection.
        public var odbNetworkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB peering connection. Example: arn:aws:odb:us-east-1:123456789012:odb-peering-connection/odbpcx-abcdefgh12345678
        public var odbPeeringConnectionArn: Swift.String?
        /// The unique identifier of the ODB peering connection. A sample ID is odbpcx-abcdefgh12345678.
        /// This member is required.
        public var odbPeeringConnectionId: Swift.String?
        /// The type of the ODB peering connection. Valid Values: ODB-VPC | ODB-ODB
        public var odbPeeringConnectionType: Swift.String?
        /// The Amazon Resource Name (ARN) of the peer network.
        public var peerNetworkArn: Swift.String?
        /// The CIDR blocks associated with the peering connection. These CIDR blocks define the IP address ranges that can communicate through the peering connection.
        public var peerNetworkCidrs: [Swift.String]?
        /// The percentage progress of the ODB peering connection creation or deletion.
        public var percentProgress: Swift.Float?
        /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
        public var status: OdbClientTypes.ResourceStatus?
        /// The reason for the current status of the ODB peering connection.
        public var statusReason: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            odbNetworkArn: Swift.String? = nil,
            odbPeeringConnectionArn: Swift.String? = nil,
            odbPeeringConnectionId: Swift.String? = nil,
            odbPeeringConnectionType: Swift.String? = nil,
            peerNetworkArn: Swift.String? = nil,
            peerNetworkCidrs: [Swift.String]? = nil,
            percentProgress: Swift.Float? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.odbNetworkArn = odbNetworkArn
            self.odbPeeringConnectionArn = odbPeeringConnectionArn
            self.odbPeeringConnectionId = odbPeeringConnectionId
            self.odbPeeringConnectionType = odbPeeringConnectionType
            self.peerNetworkArn = peerNetworkArn
            self.peerNetworkCidrs = peerNetworkCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct GetOdbPeeringConnectionOutput: Swift.Sendable {
    /// A peering connection between an ODB network and either another ODB network or a customer-owned VPC.
    public var odbPeeringConnection: OdbClientTypes.OdbPeeringConnection?

    public init(
        odbPeeringConnection: OdbClientTypes.OdbPeeringConnection? = nil
    ) {
        self.odbPeeringConnection = odbPeeringConnection
    }
}

extension OdbClientTypes {

    /// Information about a specific version of Oracle Grid Infrastructure (GI) software that can be installed on a VM cluster.
    public struct GiVersionSummary: Swift.Sendable {
        /// The GI software version.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        ) {
            self.version = version
        }
    }
}

public struct InitializeServiceInput: Swift.Sendable {

    public init() { }
}

public struct InitializeServiceOutput: Swift.Sendable {

    public init() { }
}

public struct ListDbSystemShapesInput: Swift.Sendable {
    /// The logical name of the AZ, for example, us-east-1a. This name varies depending on the account.
    public var availabilityZone: Swift.String?
    /// The physical ID of the AZ, for example, use1-az4. This ID persists across accounts.
    public var availabilityZoneId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDbSystemShapesOutput: Swift.Sendable {
    /// The list of shapes and their properties.
    /// This member is required.
    public var dbSystemShapes: [OdbClientTypes.DbSystemShapeSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        dbSystemShapes: [OdbClientTypes.DbSystemShapeSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dbSystemShapes = dbSystemShapes
        self.nextToken = nextToken
    }
}

public struct ListGiVersionsInput: Swift.Sendable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?
    /// The shape to return GI versions for. For a list of valid shapes, use the ListDbSystemShapes operation..
    public var shape: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        shape: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shape = shape
    }
}

public struct ListGiVersionsOutput: Swift.Sendable {
    /// The list of GI versions and their properties.
    /// This member is required.
    public var giVersions: [OdbClientTypes.GiVersionSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        giVersions: [OdbClientTypes.GiVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.giVersions = giVersions
        self.nextToken = nextToken
    }
}

public struct ListOdbNetworksInput: Swift.Sendable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OdbClientTypes {

    /// Information about an ODB network.
    public struct OdbNetworkSummary: Swift.Sendable {
        /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located.
        public var availabilityZone: Swift.String?
        /// The AZ ID of the AZ where the ODB network is located.
        public var availabilityZoneId: Swift.String?
        /// The CIDR range of the backup subnet in the ODB network.
        public var backupSubnetCidr: Swift.String?
        /// The CIDR range of the client subnet in the ODB network.
        public var clientSubnetCidr: Swift.String?
        /// The date and time when the ODB network was created.
        public var createdAt: Foundation.Date?
        /// The domain name for the resources in the ODB network.
        public var customDomainName: Swift.String?
        /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
        public var defaultDnsPrefix: Swift.String?
        /// The user-friendly name of the ODB network.
        public var displayName: Swift.String?
        /// The managed services configuration for the ODB network.
        public var managedServices: OdbClientTypes.ManagedServices?
        /// The DNS resolver endpoint in OCI for forwarding DNS queries for the ociPrivateZone domain.
        public var ociDnsForwardingConfigs: [OdbClientTypes.OciDnsForwardingConfig]?
        /// The unique identifier of the OCI network anchor for the ODB network.
        public var ociNetworkAnchorId: Swift.String?
        /// The URL of the OCI network anchor for the ODB network.
        public var ociNetworkAnchorUrl: Swift.String?
        /// The name of the OCI resource anchor associated with the ODB network.
        public var ociResourceAnchorName: Swift.String?
        /// The Oracle Cloud ID (OCID) for the Virtual Cloud Network (VCN) associated with the ODB network.
        public var ociVcnId: Swift.String?
        /// The URL for the VCN that's associated with the ODB network.
        public var ociVcnUrl: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB network.
        public var odbNetworkArn: Swift.String?
        /// The unique identifier of the ODB network.
        /// This member is required.
        public var odbNetworkId: Swift.String?
        /// The list of CIDR ranges from the peered VPC that are allowed access to the ODB network.
        public var peeredCidrs: [Swift.String]?
        /// The amount of progress made on the current operation on the ODB network, expressed as a percentage.
        public var percentProgress: Swift.Float?
        /// The current status of the ODB network.
        public var status: OdbClientTypes.ResourceStatus?
        /// Additional information about the current status of the ODB network.
        public var statusReason: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            backupSubnetCidr: Swift.String? = nil,
            clientSubnetCidr: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            defaultDnsPrefix: Swift.String? = nil,
            displayName: Swift.String? = nil,
            managedServices: OdbClientTypes.ManagedServices? = nil,
            ociDnsForwardingConfigs: [OdbClientTypes.OciDnsForwardingConfig]? = nil,
            ociNetworkAnchorId: Swift.String? = nil,
            ociNetworkAnchorUrl: Swift.String? = nil,
            ociResourceAnchorName: Swift.String? = nil,
            ociVcnId: Swift.String? = nil,
            ociVcnUrl: Swift.String? = nil,
            odbNetworkArn: Swift.String? = nil,
            odbNetworkId: Swift.String? = nil,
            peeredCidrs: [Swift.String]? = nil,
            percentProgress: Swift.Float? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.backupSubnetCidr = backupSubnetCidr
            self.clientSubnetCidr = clientSubnetCidr
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.defaultDnsPrefix = defaultDnsPrefix
            self.displayName = displayName
            self.managedServices = managedServices
            self.ociDnsForwardingConfigs = ociDnsForwardingConfigs
            self.ociNetworkAnchorId = ociNetworkAnchorId
            self.ociNetworkAnchorUrl = ociNetworkAnchorUrl
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociVcnId = ociVcnId
            self.ociVcnUrl = ociVcnUrl
            self.odbNetworkArn = odbNetworkArn
            self.odbNetworkId = odbNetworkId
            self.peeredCidrs = peeredCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListOdbNetworksOutput: Swift.Sendable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// The list of ODB networks.
    /// This member is required.
    public var odbNetworks: [OdbClientTypes.OdbNetworkSummary]?

    public init(
        nextToken: Swift.String? = nil,
        odbNetworks: [OdbClientTypes.OdbNetworkSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.odbNetworks = odbNetworks
    }
}

public struct ListOdbPeeringConnectionsInput: Swift.Sendable {
    /// The maximum number of ODB peering connections to return in the response. Default: 20 Constraints:
    ///
    /// * Must be between 1 and 100.
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of ODB peering connections.
    public var nextToken: Swift.String?
    /// The identifier of the ODB network to list peering connections for. If not specified, lists all ODB peering connections in the account.
    public var odbNetworkId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        odbNetworkId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.odbNetworkId = odbNetworkId
    }
}

extension OdbClientTypes {

    /// A summary of an ODB peering connection.
    public struct OdbPeeringConnectionSummary: Swift.Sendable {
        /// The timestamp when the ODB peering connection was created.
        public var createdAt: Foundation.Date?
        /// The display name of the ODB peering connection.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB network that initiated the peering connection.
        public var odbNetworkArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the ODB peering connection.
        public var odbPeeringConnectionArn: Swift.String?
        /// The unique identifier of the ODB peering connection. A sample ID is odbpcx-abcdefgh12345678.
        /// This member is required.
        public var odbPeeringConnectionId: Swift.String?
        /// The type of the ODB peering connection. Valid Values: ODB-VPC | ODB-ODB
        public var odbPeeringConnectionType: Swift.String?
        /// The Amazon Resource Name (ARN) of the peer network.
        public var peerNetworkArn: Swift.String?
        /// The CIDR blocks associated with the peering connection. These CIDR blocks define the IP address ranges that can communicate through the peering connection.
        public var peerNetworkCidrs: [Swift.String]?
        /// The percentage progress of the ODB peering connection creation or deletion.
        public var percentProgress: Swift.Float?
        /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
        public var status: OdbClientTypes.ResourceStatus?
        /// The reason for the current status of the ODB peering connection.
        public var statusReason: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            odbNetworkArn: Swift.String? = nil,
            odbPeeringConnectionArn: Swift.String? = nil,
            odbPeeringConnectionId: Swift.String? = nil,
            odbPeeringConnectionType: Swift.String? = nil,
            peerNetworkArn: Swift.String? = nil,
            peerNetworkCidrs: [Swift.String]? = nil,
            percentProgress: Swift.Float? = nil,
            status: OdbClientTypes.ResourceStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.odbNetworkArn = odbNetworkArn
            self.odbPeeringConnectionArn = odbPeeringConnectionArn
            self.odbPeeringConnectionId = odbPeeringConnectionId
            self.odbPeeringConnectionType = odbPeeringConnectionType
            self.peerNetworkArn = peerNetworkArn
            self.peerNetworkCidrs = peerNetworkCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListOdbPeeringConnectionsOutput: Swift.Sendable {
    /// The pagination token for the next page of ODB peering connections.
    public var nextToken: Swift.String?
    /// The list of ODB peering connections.
    /// This member is required.
    public var odbPeeringConnections: [OdbClientTypes.OdbPeeringConnectionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        odbPeeringConnections: [OdbClientTypes.OdbPeeringConnectionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.odbPeeringConnections = odbPeeringConnections
    }
}

public struct ListSystemVersionsInput: Swift.Sendable {
    /// The software version of the Exadata Grid Infrastructure (GI).
    /// This member is required.
    public var giVersion: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?
    /// The Exadata hardware system model.
    /// This member is required.
    public var shape: Swift.String?

    public init(
        giVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        shape: Swift.String? = nil
    ) {
        self.giVersion = giVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.shape = shape
    }
}

extension OdbClientTypes {

    /// Information about the compatible system versions that can be used with a specific Exadata shape and Grid Infrastructure (GI) version.
    public struct SystemVersionSummary: Swift.Sendable {
        /// The version of GI software.
        public var giVersion: Swift.String?
        /// The Exadata hardware model.
        public var shape: Swift.String?
        /// The Exadata system versions that are compatible with the specified Exadata shape and GI version.
        public var systemVersions: [Swift.String]?

        public init(
            giVersion: Swift.String? = nil,
            shape: Swift.String? = nil,
            systemVersions: [Swift.String]? = nil
        ) {
            self.giVersion = giVersion
            self.shape = shape
            self.systemVersions = systemVersions
        }
    }
}

public struct ListSystemVersionsOutput: Swift.Sendable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// The list of system versions.
    /// This member is required.
    public var systemVersions: [OdbClientTypes.SystemVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        systemVersions: [OdbClientTypes.SystemVersionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.systemVersions = systemVersions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags applied to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct UpdateOdbNetworkInput: Swift.Sendable {
    /// The new user-friendly name of the ODB network.
    public var displayName: Swift.String?
    /// The unique identifier of the ODB network to update.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// The list of CIDR ranges from the peered VPC that allow access to the ODB network.
    public var peeredCidrsToBeAdded: [Swift.String]?
    /// The list of CIDR ranges from the peered VPC to remove from the ODB network.
    public var peeredCidrsToBeRemoved: [Swift.String]?
    /// Specifies the updated configuration for Amazon S3 access from the ODB network.
    public var s3Access: OdbClientTypes.Access?
    /// Specifies the updated endpoint policy for Amazon S3 access from the ODB network.
    public var s3PolicyDocument: Swift.String?
    /// Specifies the updated configuration for Zero-ETL access from the ODB network.
    public var zeroEtlAccess: OdbClientTypes.Access?

    public init(
        displayName: Swift.String? = nil,
        odbNetworkId: Swift.String? = nil,
        peeredCidrsToBeAdded: [Swift.String]? = nil,
        peeredCidrsToBeRemoved: [Swift.String]? = nil,
        s3Access: OdbClientTypes.Access? = nil,
        s3PolicyDocument: Swift.String? = nil,
        zeroEtlAccess: OdbClientTypes.Access? = nil
    ) {
        self.displayName = displayName
        self.odbNetworkId = odbNetworkId
        self.peeredCidrsToBeAdded = peeredCidrsToBeAdded
        self.peeredCidrsToBeRemoved = peeredCidrsToBeRemoved
        self.s3Access = s3Access
        self.s3PolicyDocument = s3PolicyDocument
        self.zeroEtlAccess = zeroEtlAccess
    }
}

public struct UpdateOdbNetworkOutput: Swift.Sendable {
    /// The user-friendly name of the ODB network.
    public var displayName: Swift.String?
    /// The unique identifier of the ODB network.
    /// This member is required.
    public var odbNetworkId: Swift.String?
    /// The current status of the ODB network.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the ODB network.
    public var statusReason: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        odbNetworkId: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.displayName = displayName
        self.odbNetworkId = odbNetworkId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct UpdateOdbPeeringConnectionInput: Swift.Sendable {
    /// A new display name for the peering connection.
    public var displayName: Swift.String?
    /// The identifier of the Oracle Database@Amazon Web Services peering connection to update.
    /// This member is required.
    public var odbPeeringConnectionId: Swift.String?
    /// A list of CIDR blocks to add to the peering connection. These CIDR blocks define the IP address ranges that can communicate through the peering connection. The CIDR blocks must not overlap with existing CIDR blocks in the Oracle Database@Amazon Web Services network.
    public var peerNetworkCidrsToBeAdded: [Swift.String]?
    /// A list of CIDR blocks to remove from the peering connection. The CIDR blocks must currently exist in the peering connection.
    public var peerNetworkCidrsToBeRemoved: [Swift.String]?

    public init(
        displayName: Swift.String? = nil,
        odbPeeringConnectionId: Swift.String? = nil,
        peerNetworkCidrsToBeAdded: [Swift.String]? = nil,
        peerNetworkCidrsToBeRemoved: [Swift.String]? = nil
    ) {
        self.displayName = displayName
        self.odbPeeringConnectionId = odbPeeringConnectionId
        self.peerNetworkCidrsToBeAdded = peerNetworkCidrsToBeAdded
        self.peerNetworkCidrsToBeRemoved = peerNetworkCidrsToBeRemoved
    }
}

public struct UpdateOdbPeeringConnectionOutput: Swift.Sendable {
    /// The display name of the peering connection.
    public var displayName: Swift.String?
    /// The identifier of the Oracle Database@Amazon Web Services peering connection that was updated.
    /// This member is required.
    public var odbPeeringConnectionId: Swift.String?
    /// The status of the peering connection update operation.
    public var status: OdbClientTypes.ResourceStatus?
    /// Additional information about the status of the peering connection update operation.
    public var statusReason: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        odbPeeringConnectionId: Swift.String? = nil,
        status: OdbClientTypes.ResourceStatus? = nil,
        statusReason: Swift.String? = nil
    ) {
        self.displayName = displayName
        self.odbPeeringConnectionId = odbPeeringConnectionId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The names (keys) of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AcceptMarketplaceRegistrationInput {

    static func urlPathProvider(_ value: AcceptMarketplaceRegistrationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCloudAutonomousVmClusterInput {

    static func urlPathProvider(_ value: CreateCloudAutonomousVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCloudExadataInfrastructureInput {

    static func urlPathProvider(_ value: CreateCloudExadataInfrastructureInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCloudVmClusterInput {

    static func urlPathProvider(_ value: CreateCloudVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOdbNetworkInput {

    static func urlPathProvider(_ value: CreateOdbNetworkInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOdbPeeringConnectionInput {

    static func urlPathProvider(_ value: CreateOdbPeeringConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCloudAutonomousVmClusterInput {

    static func urlPathProvider(_ value: DeleteCloudAutonomousVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCloudExadataInfrastructureInput {

    static func urlPathProvider(_ value: DeleteCloudExadataInfrastructureInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCloudVmClusterInput {

    static func urlPathProvider(_ value: DeleteCloudVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOdbNetworkInput {

    static func urlPathProvider(_ value: DeleteOdbNetworkInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOdbPeeringConnectionInput {

    static func urlPathProvider(_ value: DeleteOdbPeeringConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension GetCloudAutonomousVmClusterInput {

    static func urlPathProvider(_ value: GetCloudAutonomousVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension GetCloudExadataInfrastructureInput {

    static func urlPathProvider(_ value: GetCloudExadataInfrastructureInput) -> Swift.String? {
        return "/"
    }
}

extension GetCloudExadataInfrastructureUnallocatedResourcesInput {

    static func urlPathProvider(_ value: GetCloudExadataInfrastructureUnallocatedResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension GetCloudVmClusterInput {

    static func urlPathProvider(_ value: GetCloudVmClusterInput) -> Swift.String? {
        return "/"
    }
}

extension GetDbNodeInput {

    static func urlPathProvider(_ value: GetDbNodeInput) -> Swift.String? {
        return "/"
    }
}

extension GetDbServerInput {

    static func urlPathProvider(_ value: GetDbServerInput) -> Swift.String? {
        return "/"
    }
}

extension GetOciOnboardingStatusInput {

    static func urlPathProvider(_ value: GetOciOnboardingStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetOdbNetworkInput {

    static func urlPathProvider(_ value: GetOdbNetworkInput) -> Swift.String? {
        return "/"
    }
}

extension GetOdbPeeringConnectionInput {

    static func urlPathProvider(_ value: GetOdbPeeringConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension InitializeServiceInput {

    static func urlPathProvider(_ value: InitializeServiceInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutonomousVirtualMachinesInput {

    static func urlPathProvider(_ value: ListAutonomousVirtualMachinesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCloudAutonomousVmClustersInput {

    static func urlPathProvider(_ value: ListCloudAutonomousVmClustersInput) -> Swift.String? {
        return "/"
    }
}

extension ListCloudExadataInfrastructuresInput {

    static func urlPathProvider(_ value: ListCloudExadataInfrastructuresInput) -> Swift.String? {
        return "/"
    }
}

extension ListCloudVmClustersInput {

    static func urlPathProvider(_ value: ListCloudVmClustersInput) -> Swift.String? {
        return "/"
    }
}

extension ListDbNodesInput {

    static func urlPathProvider(_ value: ListDbNodesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDbServersInput {

    static func urlPathProvider(_ value: ListDbServersInput) -> Swift.String? {
        return "/"
    }
}

extension ListDbSystemShapesInput {

    static func urlPathProvider(_ value: ListDbSystemShapesInput) -> Swift.String? {
        return "/"
    }
}

extension ListGiVersionsInput {

    static func urlPathProvider(_ value: ListGiVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOdbNetworksInput {

    static func urlPathProvider(_ value: ListOdbNetworksInput) -> Swift.String? {
        return "/"
    }
}

extension ListOdbPeeringConnectionsInput {

    static func urlPathProvider(_ value: ListOdbPeeringConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSystemVersionsInput {

    static func urlPathProvider(_ value: ListSystemVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RebootDbNodeInput {

    static func urlPathProvider(_ value: RebootDbNodeInput) -> Swift.String? {
        return "/"
    }
}

extension StartDbNodeInput {

    static func urlPathProvider(_ value: StartDbNodeInput) -> Swift.String? {
        return "/"
    }
}

extension StopDbNodeInput {

    static func urlPathProvider(_ value: StopDbNodeInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCloudExadataInfrastructureInput {

    static func urlPathProvider(_ value: UpdateCloudExadataInfrastructureInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOdbNetworkInput {

    static func urlPathProvider(_ value: UpdateOdbNetworkInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOdbPeeringConnectionInput {

    static func urlPathProvider(_ value: UpdateOdbPeeringConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptMarketplaceRegistrationInput {

    static func write(value: AcceptMarketplaceRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["marketplaceRegistrationToken"].write(value.marketplaceRegistrationToken)
    }
}

extension CreateCloudAutonomousVmClusterInput {

    static func write(value: CreateCloudAutonomousVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autonomousDataStorageSizeInTBs"].write(value.autonomousDataStorageSizeInTBs)
        try writer["clientToken"].write(value.clientToken)
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["cpuCoreCountPerNode"].write(value.cpuCoreCountPerNode)
        try writer["dbServers"].writeList(value.dbServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["isMtlsEnabledVmCluster"].write(value.isMtlsEnabledVmCluster)
        try writer["licenseModel"].write(value.licenseModel)
        try writer["maintenanceWindow"].write(value.maintenanceWindow, with: OdbClientTypes.MaintenanceWindow.write(value:to:))
        try writer["memoryPerOracleComputeUnitInGBs"].write(value.memoryPerOracleComputeUnitInGBs)
        try writer["odbNetworkId"].write(value.odbNetworkId)
        try writer["scanListenerPortNonTls"].write(value.scanListenerPortNonTls)
        try writer["scanListenerPortTls"].write(value.scanListenerPortTls)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeZone"].write(value.timeZone)
        try writer["totalContainerDatabases"].write(value.totalContainerDatabases)
    }
}

extension CreateCloudExadataInfrastructureInput {

    static func write(value: CreateCloudExadataInfrastructureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["clientToken"].write(value.clientToken)
        try writer["computeCount"].write(value.computeCount)
        try writer["customerContactsToSendToOCI"].writeList(value.customerContactsToSendToOCI, memberWritingClosure: OdbClientTypes.CustomerContact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["databaseServerType"].write(value.databaseServerType)
        try writer["displayName"].write(value.displayName)
        try writer["maintenanceWindow"].write(value.maintenanceWindow, with: OdbClientTypes.MaintenanceWindow.write(value:to:))
        try writer["shape"].write(value.shape)
        try writer["storageCount"].write(value.storageCount)
        try writer["storageServerType"].write(value.storageServerType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCloudVmClusterInput {

    static func write(value: CreateCloudVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["clusterName"].write(value.clusterName)
        try writer["cpuCoreCount"].write(value.cpuCoreCount)
        try writer["dataCollectionOptions"].write(value.dataCollectionOptions, with: OdbClientTypes.DataCollectionOptions.write(value:to:))
        try writer["dataStorageSizeInTBs"].write(value.dataStorageSizeInTBs)
        try writer["dbNodeStorageSizeInGBs"].write(value.dbNodeStorageSizeInGBs)
        try writer["dbServers"].writeList(value.dbServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["displayName"].write(value.displayName)
        try writer["giVersion"].write(value.giVersion)
        try writer["hostname"].write(value.hostname)
        try writer["isLocalBackupEnabled"].write(value.isLocalBackupEnabled)
        try writer["isSparseDiskgroupEnabled"].write(value.isSparseDiskgroupEnabled)
        try writer["licenseModel"].write(value.licenseModel)
        try writer["memorySizeInGBs"].write(value.memorySizeInGBs)
        try writer["odbNetworkId"].write(value.odbNetworkId)
        try writer["scanListenerPortTcp"].write(value.scanListenerPortTcp)
        try writer["sshPublicKeys"].writeList(value.sshPublicKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["systemVersion"].write(value.systemVersion)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeZone"].write(value.timeZone)
    }
}

extension CreateOdbNetworkInput {

    static func write(value: CreateOdbNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["backupSubnetCidr"].write(value.backupSubnetCidr)
        try writer["clientSubnetCidr"].write(value.clientSubnetCidr)
        try writer["clientToken"].write(value.clientToken)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["defaultDnsPrefix"].write(value.defaultDnsPrefix)
        try writer["displayName"].write(value.displayName)
        try writer["s3Access"].write(value.s3Access)
        try writer["s3PolicyDocument"].write(value.s3PolicyDocument)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["zeroEtlAccess"].write(value.zeroEtlAccess)
    }
}

extension CreateOdbPeeringConnectionInput {

    static func write(value: CreateOdbPeeringConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["displayName"].write(value.displayName)
        try writer["odbNetworkId"].write(value.odbNetworkId)
        try writer["peerNetworkCidrsToBeAdded"].writeList(value.peerNetworkCidrsToBeAdded, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["peerNetworkId"].write(value.peerNetworkId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteCloudAutonomousVmClusterInput {

    static func write(value: DeleteCloudAutonomousVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudAutonomousVmClusterId"].write(value.cloudAutonomousVmClusterId)
    }
}

extension DeleteCloudExadataInfrastructureInput {

    static func write(value: DeleteCloudExadataInfrastructureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
    }
}

extension DeleteCloudVmClusterInput {

    static func write(value: DeleteCloudVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
    }
}

extension DeleteOdbNetworkInput {

    static func write(value: DeleteOdbNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteAssociatedResources"].write(value.deleteAssociatedResources)
        try writer["odbNetworkId"].write(value.odbNetworkId)
    }
}

extension DeleteOdbPeeringConnectionInput {

    static func write(value: DeleteOdbPeeringConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["odbPeeringConnectionId"].write(value.odbPeeringConnectionId)
    }
}

extension GetCloudAutonomousVmClusterInput {

    static func write(value: GetCloudAutonomousVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudAutonomousVmClusterId"].write(value.cloudAutonomousVmClusterId)
    }
}

extension GetCloudExadataInfrastructureInput {

    static func write(value: GetCloudExadataInfrastructureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
    }
}

extension GetCloudExadataInfrastructureUnallocatedResourcesInput {

    static func write(value: GetCloudExadataInfrastructureUnallocatedResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["dbServers"].writeList(value.dbServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetCloudVmClusterInput {

    static func write(value: GetCloudVmClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
    }
}

extension GetDbNodeInput {

    static func write(value: GetDbNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
        try writer["dbNodeId"].write(value.dbNodeId)
    }
}

extension GetDbServerInput {

    static func write(value: GetDbServerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["dbServerId"].write(value.dbServerId)
    }
}

extension GetOciOnboardingStatusInput {

    static func write(value: GetOciOnboardingStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetOdbNetworkInput {

    static func write(value: GetOdbNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["odbNetworkId"].write(value.odbNetworkId)
    }
}

extension GetOdbPeeringConnectionInput {

    static func write(value: GetOdbPeeringConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["odbPeeringConnectionId"].write(value.odbPeeringConnectionId)
    }
}

extension InitializeServiceInput {

    static func write(value: InitializeServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListAutonomousVirtualMachinesInput {

    static func write(value: ListAutonomousVirtualMachinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudAutonomousVmClusterId"].write(value.cloudAutonomousVmClusterId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCloudAutonomousVmClustersInput {

    static func write(value: ListCloudAutonomousVmClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCloudExadataInfrastructuresInput {

    static func write(value: ListCloudExadataInfrastructuresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCloudVmClustersInput {

    static func write(value: ListCloudVmClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDbNodesInput {

    static func write(value: ListDbNodesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDbServersInput {

    static func write(value: ListDbServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDbSystemShapesInput {

    static func write(value: ListDbSystemShapesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["availabilityZoneId"].write(value.availabilityZoneId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListGiVersionsInput {

    static func write(value: ListGiVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["shape"].write(value.shape)
    }
}

extension ListOdbNetworksInput {

    static func write(value: ListOdbNetworksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListOdbPeeringConnectionsInput {

    static func write(value: ListOdbPeeringConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["odbNetworkId"].write(value.odbNetworkId)
    }
}

extension ListSystemVersionsInput {

    static func write(value: ListSystemVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["giVersion"].write(value.giVersion)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["shape"].write(value.shape)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RebootDbNodeInput {

    static func write(value: RebootDbNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
        try writer["dbNodeId"].write(value.dbNodeId)
    }
}

extension StartDbNodeInput {

    static func write(value: StartDbNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
        try writer["dbNodeId"].write(value.dbNodeId)
    }
}

extension StopDbNodeInput {

    static func write(value: StopDbNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudVmClusterId"].write(value.cloudVmClusterId)
        try writer["dbNodeId"].write(value.dbNodeId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCloudExadataInfrastructureInput {

    static func write(value: UpdateCloudExadataInfrastructureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudExadataInfrastructureId"].write(value.cloudExadataInfrastructureId)
        try writer["maintenanceWindow"].write(value.maintenanceWindow, with: OdbClientTypes.MaintenanceWindow.write(value:to:))
    }
}

extension UpdateOdbNetworkInput {

    static func write(value: UpdateOdbNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["odbNetworkId"].write(value.odbNetworkId)
        try writer["peeredCidrsToBeAdded"].writeList(value.peeredCidrsToBeAdded, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["peeredCidrsToBeRemoved"].writeList(value.peeredCidrsToBeRemoved, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["s3Access"].write(value.s3Access)
        try writer["s3PolicyDocument"].write(value.s3PolicyDocument)
        try writer["zeroEtlAccess"].write(value.zeroEtlAccess)
    }
}

extension UpdateOdbPeeringConnectionInput {

    static func write(value: UpdateOdbPeeringConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["odbPeeringConnectionId"].write(value.odbPeeringConnectionId)
        try writer["peerNetworkCidrsToBeAdded"].writeList(value.peerNetworkCidrsToBeAdded, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["peerNetworkCidrsToBeRemoved"].writeList(value.peerNetworkCidrsToBeRemoved, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AcceptMarketplaceRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptMarketplaceRegistrationOutput {
        return AcceptMarketplaceRegistrationOutput()
    }
}

extension CreateCloudAutonomousVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudAutonomousVmClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudAutonomousVmClusterOutput()
        value.cloudAutonomousVmClusterId = try reader["cloudAutonomousVmClusterId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension CreateCloudExadataInfrastructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudExadataInfrastructureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudExadataInfrastructureOutput()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension CreateCloudVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudVmClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudVmClusterOutput()
        value.cloudVmClusterId = try reader["cloudVmClusterId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension CreateOdbNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOdbNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOdbNetworkOutput()
        value.displayName = try reader["displayName"].readIfPresent()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension CreateOdbPeeringConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOdbPeeringConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOdbPeeringConnectionOutput()
        value.displayName = try reader["displayName"].readIfPresent()
        value.odbPeeringConnectionId = try reader["odbPeeringConnectionId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension DeleteCloudAutonomousVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCloudAutonomousVmClusterOutput {
        return DeleteCloudAutonomousVmClusterOutput()
    }
}

extension DeleteCloudExadataInfrastructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCloudExadataInfrastructureOutput {
        return DeleteCloudExadataInfrastructureOutput()
    }
}

extension DeleteCloudVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCloudVmClusterOutput {
        return DeleteCloudVmClusterOutput()
    }
}

extension DeleteOdbNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOdbNetworkOutput {
        return DeleteOdbNetworkOutput()
    }
}

extension DeleteOdbPeeringConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOdbPeeringConnectionOutput {
        return DeleteOdbPeeringConnectionOutput()
    }
}

extension GetCloudAutonomousVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudAutonomousVmClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudAutonomousVmClusterOutput()
        value.cloudAutonomousVmCluster = try reader["cloudAutonomousVmCluster"].readIfPresent(with: OdbClientTypes.CloudAutonomousVmCluster.read(from:))
        return value
    }
}

extension GetCloudExadataInfrastructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudExadataInfrastructureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudExadataInfrastructureOutput()
        value.cloudExadataInfrastructure = try reader["cloudExadataInfrastructure"].readIfPresent(with: OdbClientTypes.CloudExadataInfrastructure.read(from:))
        return value
    }
}

extension GetCloudExadataInfrastructureUnallocatedResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudExadataInfrastructureUnallocatedResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudExadataInfrastructureUnallocatedResourcesOutput()
        value.cloudExadataInfrastructureUnallocatedResources = try reader["cloudExadataInfrastructureUnallocatedResources"].readIfPresent(with: OdbClientTypes.CloudExadataInfrastructureUnallocatedResources.read(from:))
        return value
    }
}

extension GetCloudVmClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudVmClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudVmClusterOutput()
        value.cloudVmCluster = try reader["cloudVmCluster"].readIfPresent(with: OdbClientTypes.CloudVmCluster.read(from:))
        return value
    }
}

extension GetDbNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDbNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDbNodeOutput()
        value.dbNode = try reader["dbNode"].readIfPresent(with: OdbClientTypes.DbNode.read(from:))
        return value
    }
}

extension GetDbServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDbServerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDbServerOutput()
        value.dbServer = try reader["dbServer"].readIfPresent(with: OdbClientTypes.DbServer.read(from:))
        return value
    }
}

extension GetOciOnboardingStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOciOnboardingStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOciOnboardingStatusOutput()
        value.existingTenancyActivationLink = try reader["existingTenancyActivationLink"].readIfPresent()
        value.newTenancyActivationLink = try reader["newTenancyActivationLink"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetOdbNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOdbNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOdbNetworkOutput()
        value.odbNetwork = try reader["odbNetwork"].readIfPresent(with: OdbClientTypes.OdbNetwork.read(from:))
        return value
    }
}

extension GetOdbPeeringConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOdbPeeringConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOdbPeeringConnectionOutput()
        value.odbPeeringConnection = try reader["odbPeeringConnection"].readIfPresent(with: OdbClientTypes.OdbPeeringConnection.read(from:))
        return value
    }
}

extension InitializeServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InitializeServiceOutput {
        return InitializeServiceOutput()
    }
}

extension ListAutonomousVirtualMachinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutonomousVirtualMachinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutonomousVirtualMachinesOutput()
        value.autonomousVirtualMachines = try reader["autonomousVirtualMachines"].readListIfPresent(memberReadingClosure: OdbClientTypes.AutonomousVirtualMachineSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCloudAutonomousVmClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCloudAutonomousVmClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCloudAutonomousVmClustersOutput()
        value.cloudAutonomousVmClusters = try reader["cloudAutonomousVmClusters"].readListIfPresent(memberReadingClosure: OdbClientTypes.CloudAutonomousVmClusterSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCloudExadataInfrastructuresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCloudExadataInfrastructuresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCloudExadataInfrastructuresOutput()
        value.cloudExadataInfrastructures = try reader["cloudExadataInfrastructures"].readListIfPresent(memberReadingClosure: OdbClientTypes.CloudExadataInfrastructureSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCloudVmClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCloudVmClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCloudVmClustersOutput()
        value.cloudVmClusters = try reader["cloudVmClusters"].readListIfPresent(memberReadingClosure: OdbClientTypes.CloudVmClusterSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDbNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDbNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDbNodesOutput()
        value.dbNodes = try reader["dbNodes"].readListIfPresent(memberReadingClosure: OdbClientTypes.DbNodeSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDbServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDbServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDbServersOutput()
        value.dbServers = try reader["dbServers"].readListIfPresent(memberReadingClosure: OdbClientTypes.DbServerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDbSystemShapesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDbSystemShapesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDbSystemShapesOutput()
        value.dbSystemShapes = try reader["dbSystemShapes"].readListIfPresent(memberReadingClosure: OdbClientTypes.DbSystemShapeSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGiVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGiVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGiVersionsOutput()
        value.giVersions = try reader["giVersions"].readListIfPresent(memberReadingClosure: OdbClientTypes.GiVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOdbNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOdbNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOdbNetworksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.odbNetworks = try reader["odbNetworks"].readListIfPresent(memberReadingClosure: OdbClientTypes.OdbNetworkSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListOdbPeeringConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOdbPeeringConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOdbPeeringConnectionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.odbPeeringConnections = try reader["odbPeeringConnections"].readListIfPresent(memberReadingClosure: OdbClientTypes.OdbPeeringConnectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSystemVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSystemVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSystemVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.systemVersions = try reader["systemVersions"].readListIfPresent(memberReadingClosure: OdbClientTypes.SystemVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RebootDbNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebootDbNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RebootDbNodeOutput()
        value.dbNodeId = try reader["dbNodeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension StartDbNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDbNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDbNodeOutput()
        value.dbNodeId = try reader["dbNodeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension StopDbNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopDbNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopDbNodeOutput()
        value.dbNodeId = try reader["dbNodeId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCloudExadataInfrastructureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCloudExadataInfrastructureOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCloudExadataInfrastructureOutput()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension UpdateOdbNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOdbNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOdbNetworkOutput()
        value.displayName = try reader["displayName"].readIfPresent()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension UpdateOdbPeeringConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOdbPeeringConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOdbPeeringConnectionOutput()
        value.displayName = try reader["displayName"].readIfPresent()
        value.odbPeeringConnectionId = try reader["odbPeeringConnectionId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

enum AcceptMarketplaceRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudAutonomousVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudExadataInfrastructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOdbNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOdbPeeringConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCloudAutonomousVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCloudExadataInfrastructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCloudVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOdbNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOdbPeeringConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudAutonomousVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudExadataInfrastructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudExadataInfrastructureUnallocatedResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudVmClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDbNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDbServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOciOnboardingStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOdbNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOdbPeeringConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InitializeServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutonomousVirtualMachinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCloudAutonomousVmClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCloudExadataInfrastructuresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCloudVmClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDbNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDbServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDbSystemShapesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGiVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOdbNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOdbPeeringConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSystemVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebootDbNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDbNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopDbNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCloudExadataInfrastructureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOdbNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOdbPeeringConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: OdbClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OdbClientTypes.CloudAutonomousVmCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudAutonomousVmCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudAutonomousVmCluster()
        value.cloudAutonomousVmClusterId = try reader["cloudAutonomousVmClusterId"].readIfPresent() ?? ""
        value.cloudAutonomousVmClusterArn = try reader["cloudAutonomousVmClusterArn"].readIfPresent()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent()
        value.autonomousDataStoragePercentage = try reader["autonomousDataStoragePercentage"].readIfPresent()
        value.autonomousDataStorageSizeInTBs = try reader["autonomousDataStorageSizeInTBs"].readIfPresent()
        value.availableAutonomousDataStorageSizeInTBs = try reader["availableAutonomousDataStorageSizeInTBs"].readIfPresent()
        value.availableContainerDatabases = try reader["availableContainerDatabases"].readIfPresent()
        value.availableCpus = try reader["availableCpus"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.cpuCoreCountPerNode = try reader["cpuCoreCountPerNode"].readIfPresent()
        value.cpuPercentage = try reader["cpuPercentage"].readIfPresent()
        value.dataStorageSizeInGBs = try reader["dataStorageSizeInGBs"].readIfPresent()
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServers = try reader["dbServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        value.exadataStorageInTBsLowestScaledValue = try reader["exadataStorageInTBsLowestScaledValue"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.isMtlsEnabledVmCluster = try reader["isMtlsEnabledVmCluster"].readIfPresent()
        value.licenseModel = try reader["licenseModel"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: OdbClientTypes.MaintenanceWindow.read(from:))
        value.maxAcdsLowestScaledValue = try reader["maxAcdsLowestScaledValue"].readIfPresent()
        value.memoryPerOracleComputeUnitInGBs = try reader["memoryPerOracleComputeUnitInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.nodeCount = try reader["nodeCount"].readIfPresent()
        value.nonProvisionableAutonomousContainerDatabases = try reader["nonProvisionableAutonomousContainerDatabases"].readIfPresent()
        value.provisionableAutonomousContainerDatabases = try reader["provisionableAutonomousContainerDatabases"].readIfPresent()
        value.provisionedAutonomousContainerDatabases = try reader["provisionedAutonomousContainerDatabases"].readIfPresent()
        value.provisionedCpus = try reader["provisionedCpus"].readIfPresent()
        value.reclaimableCpus = try reader["reclaimableCpus"].readIfPresent()
        value.reservedCpus = try reader["reservedCpus"].readIfPresent()
        value.scanListenerPortNonTls = try reader["scanListenerPortNonTls"].readIfPresent()
        value.scanListenerPortTls = try reader["scanListenerPortTls"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeDatabaseSslCertificateExpires = try reader["timeDatabaseSslCertificateExpires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeOrdsCertificateExpires = try reader["timeOrdsCertificateExpires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeZone = try reader["timeZone"].readIfPresent()
        value.totalContainerDatabases = try reader["totalContainerDatabases"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.MaintenanceWindow {

    static func write(value: OdbClientTypes.MaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customActionTimeoutInMins"].write(value.customActionTimeoutInMins)
        try writer["daysOfWeek"].writeList(value.daysOfWeek, memberWritingClosure: OdbClientTypes.DayOfWeek.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["hoursOfDay"].writeList(value.hoursOfDay, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["isCustomActionTimeoutEnabled"].write(value.isCustomActionTimeoutEnabled)
        try writer["leadTimeInWeeks"].write(value.leadTimeInWeeks)
        try writer["months"].writeList(value.months, memberWritingClosure: OdbClientTypes.Month.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["patchingMode"].write(value.patchingMode)
        try writer["preference"].write(value.preference)
        try writer["skipRu"].write(value.skipRu)
        try writer["weeksOfMonth"].writeList(value.weeksOfMonth, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.MaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.MaintenanceWindow()
        value.customActionTimeoutInMins = try reader["customActionTimeoutInMins"].readIfPresent()
        value.daysOfWeek = try reader["daysOfWeek"].readListIfPresent(memberReadingClosure: OdbClientTypes.DayOfWeek.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.hoursOfDay = try reader["hoursOfDay"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.isCustomActionTimeoutEnabled = try reader["isCustomActionTimeoutEnabled"].readIfPresent()
        value.leadTimeInWeeks = try reader["leadTimeInWeeks"].readIfPresent()
        value.months = try reader["months"].readListIfPresent(memberReadingClosure: OdbClientTypes.Month.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.patchingMode = try reader["patchingMode"].readIfPresent()
        value.preference = try reader["preference"].readIfPresent()
        value.skipRu = try reader["skipRu"].readIfPresent()
        value.weeksOfMonth = try reader["weeksOfMonth"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OdbClientTypes.Month {

    static func write(value: OdbClientTypes.Month?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.Month {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.Month()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DayOfWeek {

    static func write(value: OdbClientTypes.DayOfWeek?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DayOfWeek {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DayOfWeek()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudExadataInfrastructure {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudExadataInfrastructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudExadataInfrastructure()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudExadataInfrastructureArn = try reader["cloudExadataInfrastructureArn"].readIfPresent()
        value.activatedStorageCount = try reader["activatedStorageCount"].readIfPresent()
        value.additionalStorageCount = try reader["additionalStorageCount"].readIfPresent()
        value.availableStorageSizeInGBs = try reader["availableStorageSizeInGBs"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.computeCount = try reader["computeCount"].readIfPresent()
        value.cpuCount = try reader["cpuCount"].readIfPresent()
        value.customerContactsToSendToOCI = try reader["customerContactsToSendToOCI"].readListIfPresent(memberReadingClosure: OdbClientTypes.CustomerContact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerVersion = try reader["dbServerVersion"].readIfPresent()
        value.lastMaintenanceRunId = try reader["lastMaintenanceRunId"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: OdbClientTypes.MaintenanceWindow.read(from:))
        value.maxCpuCount = try reader["maxCpuCount"].readIfPresent()
        value.maxDataStorageInTBs = try reader["maxDataStorageInTBs"].readIfPresent()
        value.maxDbNodeStorageSizeInGBs = try reader["maxDbNodeStorageSizeInGBs"].readIfPresent()
        value.maxMemoryInGBs = try reader["maxMemoryInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.monthlyDbServerVersion = try reader["monthlyDbServerVersion"].readIfPresent()
        value.monthlyStorageServerVersion = try reader["monthlyStorageServerVersion"].readIfPresent()
        value.nextMaintenanceRunId = try reader["nextMaintenanceRunId"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.storageCount = try reader["storageCount"].readIfPresent()
        value.storageServerVersion = try reader["storageServerVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.totalStorageSizeInGBs = try reader["totalStorageSizeInGBs"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.databaseServerType = try reader["databaseServerType"].readIfPresent()
        value.storageServerType = try reader["storageServerType"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CustomerContact {

    static func write(value: OdbClientTypes.CustomerContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["email"].write(value.email)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CustomerContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CustomerContact()
        value.email = try reader["email"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudExadataInfrastructureUnallocatedResources {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudExadataInfrastructureUnallocatedResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudExadataInfrastructureUnallocatedResources()
        value.cloudAutonomousVmClusters = try reader["cloudAutonomousVmClusters"].readListIfPresent(memberReadingClosure: OdbClientTypes.CloudAutonomousVmClusterResourceDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cloudExadataInfrastructureDisplayName = try reader["cloudExadataInfrastructureDisplayName"].readIfPresent()
        value.exadataStorageInTBs = try reader["exadataStorageInTBs"].readIfPresent()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent()
        value.localStorageInGBs = try reader["localStorageInGBs"].readIfPresent()
        value.memoryInGBs = try reader["memoryInGBs"].readIfPresent()
        value.ocpus = try reader["ocpus"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudAutonomousVmClusterResourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudAutonomousVmClusterResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudAutonomousVmClusterResourceDetails()
        value.cloudAutonomousVmClusterId = try reader["cloudAutonomousVmClusterId"].readIfPresent()
        value.unallocatedAdbStorageInTBs = try reader["unallocatedAdbStorageInTBs"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudVmCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudVmCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudVmCluster()
        value.cloudVmClusterId = try reader["cloudVmClusterId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudVmClusterArn = try reader["cloudVmClusterArn"].readIfPresent()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dataCollectionOptions = try reader["dataCollectionOptions"].readIfPresent(with: OdbClientTypes.DataCollectionOptions.read(from:))
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServers = try reader["dbServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.diskRedundancy = try reader["diskRedundancy"].readIfPresent()
        value.giVersion = try reader["giVersion"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.iormConfigCache = try reader["iormConfigCache"].readIfPresent(with: OdbClientTypes.ExadataIormConfig.read(from:))
        value.isLocalBackupEnabled = try reader["isLocalBackupEnabled"].readIfPresent()
        value.isSparseDiskgroupEnabled = try reader["isSparseDiskgroupEnabled"].readIfPresent()
        value.lastUpdateHistoryEntryId = try reader["lastUpdateHistoryEntryId"].readIfPresent()
        value.licenseModel = try reader["licenseModel"].readIfPresent()
        value.listenerPort = try reader["listenerPort"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.nodeCount = try reader["nodeCount"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        value.scanDnsName = try reader["scanDnsName"].readIfPresent()
        value.scanDnsRecordId = try reader["scanDnsRecordId"].readIfPresent()
        value.scanIpIds = try reader["scanIpIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.shape = try reader["shape"].readIfPresent()
        value.sshPublicKeys = try reader["sshPublicKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageSizeInGBs = try reader["storageSizeInGBs"].readIfPresent()
        value.systemVersion = try reader["systemVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeZone = try reader["timeZone"].readIfPresent()
        value.vipIds = try reader["vipIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.ExadataIormConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ExadataIormConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ExadataIormConfig()
        value.dbPlans = try reader["dbPlans"].readListIfPresent(memberReadingClosure: OdbClientTypes.DbIormConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lifecycleDetails = try reader["lifecycleDetails"].readIfPresent()
        value.lifecycleState = try reader["lifecycleState"].readIfPresent()
        value.objective = try reader["objective"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DbIormConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbIormConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbIormConfig()
        value.dbName = try reader["dbName"].readIfPresent()
        value.flashCacheLimit = try reader["flashCacheLimit"].readIfPresent()
        value.share = try reader["share"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DataCollectionOptions {

    static func write(value: OdbClientTypes.DataCollectionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isDiagnosticsEventsEnabled"].write(value.isDiagnosticsEventsEnabled)
        try writer["isHealthMonitoringEnabled"].write(value.isHealthMonitoringEnabled)
        try writer["isIncidentLogsEnabled"].write(value.isIncidentLogsEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DataCollectionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DataCollectionOptions()
        value.isDiagnosticsEventsEnabled = try reader["isDiagnosticsEventsEnabled"].readIfPresent()
        value.isHealthMonitoringEnabled = try reader["isHealthMonitoringEnabled"].readIfPresent()
        value.isIncidentLogsEnabled = try reader["isIncidentLogsEnabled"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DbNode {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbNode()
        value.dbNodeId = try reader["dbNodeId"].readIfPresent()
        value.dbNodeArn = try reader["dbNodeArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.additionalDetails = try reader["additionalDetails"].readIfPresent()
        value.backupIpId = try reader["backupIpId"].readIfPresent()
        value.backupVnic2Id = try reader["backupVnic2Id"].readIfPresent()
        value.backupVnicId = try reader["backupVnicId"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerId = try reader["dbServerId"].readIfPresent()
        value.dbSystemId = try reader["dbSystemId"].readIfPresent()
        value.faultDomain = try reader["faultDomain"].readIfPresent()
        value.hostIpId = try reader["hostIpId"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.maintenanceType = try reader["maintenanceType"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.softwareStorageSizeInGB = try reader["softwareStorageSizeInGB"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeMaintenanceWindowEnd = try reader["timeMaintenanceWindowEnd"].readIfPresent()
        value.timeMaintenanceWindowStart = try reader["timeMaintenanceWindowStart"].readIfPresent()
        value.totalCpuCoreCount = try reader["totalCpuCoreCount"].readIfPresent()
        value.vnic2Id = try reader["vnic2Id"].readIfPresent()
        value.vnicId = try reader["vnicId"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        value.floatingIpAddress = try reader["floatingIpAddress"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DbServer {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbServer()
        value.dbServerId = try reader["dbServerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerPatchingDetails = try reader["dbServerPatchingDetails"].readIfPresent(with: OdbClientTypes.DbServerPatchingDetails.read(from:))
        value.displayName = try reader["displayName"].readIfPresent()
        value.exadataInfrastructureId = try reader["exadataInfrastructureId"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.maxCpuCount = try reader["maxCpuCount"].readIfPresent()
        value.maxDbNodeStorageInGBs = try reader["maxDbNodeStorageInGBs"].readIfPresent()
        value.maxMemoryInGBs = try reader["maxMemoryInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.vmClusterIds = try reader["vmClusterIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.computeModel = try reader["computeModel"].readIfPresent()
        value.autonomousVmClusterIds = try reader["autonomousVmClusterIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autonomousVirtualMachineIds = try reader["autonomousVirtualMachineIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OdbClientTypes.DbServerPatchingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbServerPatchingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbServerPatchingDetails()
        value.estimatedPatchDuration = try reader["estimatedPatchDuration"].readIfPresent()
        value.patchingStatus = try reader["patchingStatus"].readIfPresent()
        value.timePatchingEnded = try reader["timePatchingEnded"].readIfPresent()
        value.timePatchingStarted = try reader["timePatchingStarted"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.OdbNetwork {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.OdbNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.OdbNetwork()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.odbNetworkArn = try reader["odbNetworkArn"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.clientSubnetCidr = try reader["clientSubnetCidr"].readIfPresent()
        value.backupSubnetCidr = try reader["backupSubnetCidr"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.defaultDnsPrefix = try reader["defaultDnsPrefix"].readIfPresent()
        value.peeredCidrs = try reader["peeredCidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ociNetworkAnchorId = try reader["ociNetworkAnchorId"].readIfPresent()
        value.ociNetworkAnchorUrl = try reader["ociNetworkAnchorUrl"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociVcnId = try reader["ociVcnId"].readIfPresent()
        value.ociVcnUrl = try reader["ociVcnUrl"].readIfPresent()
        value.ociDnsForwardingConfigs = try reader["ociDnsForwardingConfigs"].readListIfPresent(memberReadingClosure: OdbClientTypes.OciDnsForwardingConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.managedServices = try reader["managedServices"].readIfPresent(with: OdbClientTypes.ManagedServices.read(from:))
        return value
    }
}

extension OdbClientTypes.ManagedServices {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ManagedServices {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ManagedServices()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.resourceGatewayArn = try reader["resourceGatewayArn"].readIfPresent()
        value.managedServicesIpv4Cidrs = try reader["managedServicesIpv4Cidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceNetworkEndpoint = try reader["serviceNetworkEndpoint"].readIfPresent(with: OdbClientTypes.ServiceNetworkEndpoint.read(from:))
        value.managedS3BackupAccess = try reader["managedS3BackupAccess"].readIfPresent(with: OdbClientTypes.ManagedS3BackupAccess.read(from:))
        value.zeroEtlAccess = try reader["zeroEtlAccess"].readIfPresent(with: OdbClientTypes.ZeroEtlAccess.read(from:))
        value.s3Access = try reader["s3Access"].readIfPresent(with: OdbClientTypes.S3Access.read(from:))
        return value
    }
}

extension OdbClientTypes.S3Access {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.S3Access {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.S3Access()
        value.status = try reader["status"].readIfPresent()
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.domainName = try reader["domainName"].readIfPresent()
        value.s3PolicyDocument = try reader["s3PolicyDocument"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.ZeroEtlAccess {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ZeroEtlAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ZeroEtlAccess()
        value.status = try reader["status"].readIfPresent()
        value.cidr = try reader["cidr"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.ManagedS3BackupAccess {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ManagedS3BackupAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ManagedS3BackupAccess()
        value.status = try reader["status"].readIfPresent()
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OdbClientTypes.ServiceNetworkEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ServiceNetworkEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ServiceNetworkEndpoint()
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcEndpointType = try reader["vpcEndpointType"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.OciDnsForwardingConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.OciDnsForwardingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.OciDnsForwardingConfig()
        value.domainName = try reader["domainName"].readIfPresent()
        value.ociDnsListenerIp = try reader["ociDnsListenerIp"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.OdbPeeringConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.OdbPeeringConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.OdbPeeringConnection()
        value.odbPeeringConnectionId = try reader["odbPeeringConnectionId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.odbPeeringConnectionArn = try reader["odbPeeringConnectionArn"].readIfPresent()
        value.odbNetworkArn = try reader["odbNetworkArn"].readIfPresent()
        value.peerNetworkArn = try reader["peerNetworkArn"].readIfPresent()
        value.odbPeeringConnectionType = try reader["odbPeeringConnectionType"].readIfPresent()
        value.peerNetworkCidrs = try reader["peerNetworkCidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.AutonomousVirtualMachineSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.AutonomousVirtualMachineSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.AutonomousVirtualMachineSummary()
        value.autonomousVirtualMachineId = try reader["autonomousVirtualMachineId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.vmName = try reader["vmName"].readIfPresent()
        value.dbServerId = try reader["dbServerId"].readIfPresent()
        value.dbServerDisplayName = try reader["dbServerDisplayName"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.clientIpAddress = try reader["clientIpAddress"].readIfPresent()
        value.cloudAutonomousVmClusterId = try reader["cloudAutonomousVmClusterId"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudAutonomousVmClusterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudAutonomousVmClusterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudAutonomousVmClusterSummary()
        value.cloudAutonomousVmClusterId = try reader["cloudAutonomousVmClusterId"].readIfPresent() ?? ""
        value.cloudAutonomousVmClusterArn = try reader["cloudAutonomousVmClusterArn"].readIfPresent()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent()
        value.autonomousDataStoragePercentage = try reader["autonomousDataStoragePercentage"].readIfPresent()
        value.autonomousDataStorageSizeInTBs = try reader["autonomousDataStorageSizeInTBs"].readIfPresent()
        value.availableAutonomousDataStorageSizeInTBs = try reader["availableAutonomousDataStorageSizeInTBs"].readIfPresent()
        value.availableContainerDatabases = try reader["availableContainerDatabases"].readIfPresent()
        value.availableCpus = try reader["availableCpus"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.cpuCoreCountPerNode = try reader["cpuCoreCountPerNode"].readIfPresent()
        value.cpuPercentage = try reader["cpuPercentage"].readIfPresent()
        value.dataStorageSizeInGBs = try reader["dataStorageSizeInGBs"].readIfPresent()
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServers = try reader["dbServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        value.exadataStorageInTBsLowestScaledValue = try reader["exadataStorageInTBsLowestScaledValue"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.isMtlsEnabledVmCluster = try reader["isMtlsEnabledVmCluster"].readIfPresent()
        value.licenseModel = try reader["licenseModel"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: OdbClientTypes.MaintenanceWindow.read(from:))
        value.maxAcdsLowestScaledValue = try reader["maxAcdsLowestScaledValue"].readIfPresent()
        value.memoryPerOracleComputeUnitInGBs = try reader["memoryPerOracleComputeUnitInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.nodeCount = try reader["nodeCount"].readIfPresent()
        value.nonProvisionableAutonomousContainerDatabases = try reader["nonProvisionableAutonomousContainerDatabases"].readIfPresent()
        value.provisionableAutonomousContainerDatabases = try reader["provisionableAutonomousContainerDatabases"].readIfPresent()
        value.provisionedAutonomousContainerDatabases = try reader["provisionedAutonomousContainerDatabases"].readIfPresent()
        value.provisionedCpus = try reader["provisionedCpus"].readIfPresent()
        value.reclaimableCpus = try reader["reclaimableCpus"].readIfPresent()
        value.reservedCpus = try reader["reservedCpus"].readIfPresent()
        value.scanListenerPortNonTls = try reader["scanListenerPortNonTls"].readIfPresent()
        value.scanListenerPortTls = try reader["scanListenerPortTls"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeDatabaseSslCertificateExpires = try reader["timeDatabaseSslCertificateExpires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeOrdsCertificateExpires = try reader["timeOrdsCertificateExpires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeZone = try reader["timeZone"].readIfPresent()
        value.totalContainerDatabases = try reader["totalContainerDatabases"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudExadataInfrastructureSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudExadataInfrastructureSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudExadataInfrastructureSummary()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudExadataInfrastructureArn = try reader["cloudExadataInfrastructureArn"].readIfPresent()
        value.activatedStorageCount = try reader["activatedStorageCount"].readIfPresent()
        value.additionalStorageCount = try reader["additionalStorageCount"].readIfPresent()
        value.availableStorageSizeInGBs = try reader["availableStorageSizeInGBs"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.computeCount = try reader["computeCount"].readIfPresent()
        value.cpuCount = try reader["cpuCount"].readIfPresent()
        value.customerContactsToSendToOCI = try reader["customerContactsToSendToOCI"].readListIfPresent(memberReadingClosure: OdbClientTypes.CustomerContact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerVersion = try reader["dbServerVersion"].readIfPresent()
        value.lastMaintenanceRunId = try reader["lastMaintenanceRunId"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: OdbClientTypes.MaintenanceWindow.read(from:))
        value.maxCpuCount = try reader["maxCpuCount"].readIfPresent()
        value.maxDataStorageInTBs = try reader["maxDataStorageInTBs"].readIfPresent()
        value.maxDbNodeStorageSizeInGBs = try reader["maxDbNodeStorageSizeInGBs"].readIfPresent()
        value.maxMemoryInGBs = try reader["maxMemoryInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.monthlyDbServerVersion = try reader["monthlyDbServerVersion"].readIfPresent()
        value.monthlyStorageServerVersion = try reader["monthlyStorageServerVersion"].readIfPresent()
        value.nextMaintenanceRunId = try reader["nextMaintenanceRunId"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.storageCount = try reader["storageCount"].readIfPresent()
        value.storageServerVersion = try reader["storageServerVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.totalStorageSizeInGBs = try reader["totalStorageSizeInGBs"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.databaseServerType = try reader["databaseServerType"].readIfPresent()
        value.storageServerType = try reader["storageServerType"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.CloudVmClusterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.CloudVmClusterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.CloudVmClusterSummary()
        value.cloudVmClusterId = try reader["cloudVmClusterId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cloudVmClusterArn = try reader["cloudVmClusterArn"].readIfPresent()
        value.cloudExadataInfrastructureId = try reader["cloudExadataInfrastructureId"].readIfPresent()
        value.clusterName = try reader["clusterName"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dataCollectionOptions = try reader["dataCollectionOptions"].readIfPresent(with: OdbClientTypes.DataCollectionOptions.read(from:))
        value.dataStorageSizeInTBs = try reader["dataStorageSizeInTBs"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServers = try reader["dbServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.diskRedundancy = try reader["diskRedundancy"].readIfPresent()
        value.giVersion = try reader["giVersion"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.iormConfigCache = try reader["iormConfigCache"].readIfPresent(with: OdbClientTypes.ExadataIormConfig.read(from:))
        value.isLocalBackupEnabled = try reader["isLocalBackupEnabled"].readIfPresent()
        value.isSparseDiskgroupEnabled = try reader["isSparseDiskgroupEnabled"].readIfPresent()
        value.lastUpdateHistoryEntryId = try reader["lastUpdateHistoryEntryId"].readIfPresent()
        value.licenseModel = try reader["licenseModel"].readIfPresent()
        value.listenerPort = try reader["listenerPort"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.nodeCount = try reader["nodeCount"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociUrl = try reader["ociUrl"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent()
        value.scanDnsName = try reader["scanDnsName"].readIfPresent()
        value.scanDnsRecordId = try reader["scanDnsRecordId"].readIfPresent()
        value.scanIpIds = try reader["scanIpIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.shape = try reader["shape"].readIfPresent()
        value.sshPublicKeys = try reader["sshPublicKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageSizeInGBs = try reader["storageSizeInGBs"].readIfPresent()
        value.systemVersion = try reader["systemVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeZone = try reader["timeZone"].readIfPresent()
        value.vipIds = try reader["vipIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent()
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DbNodeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbNodeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbNodeSummary()
        value.dbNodeId = try reader["dbNodeId"].readIfPresent()
        value.dbNodeArn = try reader["dbNodeArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.additionalDetails = try reader["additionalDetails"].readIfPresent()
        value.backupIpId = try reader["backupIpId"].readIfPresent()
        value.backupVnic2Id = try reader["backupVnic2Id"].readIfPresent()
        value.backupVnicId = try reader["backupVnicId"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerId = try reader["dbServerId"].readIfPresent()
        value.dbSystemId = try reader["dbSystemId"].readIfPresent()
        value.faultDomain = try reader["faultDomain"].readIfPresent()
        value.hostIpId = try reader["hostIpId"].readIfPresent()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.maintenanceType = try reader["maintenanceType"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.softwareStorageSizeInGB = try reader["softwareStorageSizeInGB"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.timeMaintenanceWindowEnd = try reader["timeMaintenanceWindowEnd"].readIfPresent()
        value.timeMaintenanceWindowStart = try reader["timeMaintenanceWindowStart"].readIfPresent()
        value.totalCpuCoreCount = try reader["totalCpuCoreCount"].readIfPresent()
        value.vnic2Id = try reader["vnic2Id"].readIfPresent()
        value.vnicId = try reader["vnicId"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.DbServerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbServerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbServerSummary()
        value.dbServerId = try reader["dbServerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.cpuCoreCount = try reader["cpuCoreCount"].readIfPresent()
        value.dbNodeStorageSizeInGBs = try reader["dbNodeStorageSizeInGBs"].readIfPresent()
        value.dbServerPatchingDetails = try reader["dbServerPatchingDetails"].readIfPresent(with: OdbClientTypes.DbServerPatchingDetails.read(from:))
        value.displayName = try reader["displayName"].readIfPresent()
        value.exadataInfrastructureId = try reader["exadataInfrastructureId"].readIfPresent()
        value.ocid = try reader["ocid"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.maxCpuCount = try reader["maxCpuCount"].readIfPresent()
        value.maxDbNodeStorageInGBs = try reader["maxDbNodeStorageInGBs"].readIfPresent()
        value.maxMemoryInGBs = try reader["maxMemoryInGBs"].readIfPresent()
        value.memorySizeInGBs = try reader["memorySizeInGBs"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.vmClusterIds = try reader["vmClusterIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.computeModel = try reader["computeModel"].readIfPresent()
        value.autonomousVmClusterIds = try reader["autonomousVmClusterIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autonomousVirtualMachineIds = try reader["autonomousVirtualMachineIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OdbClientTypes.DbSystemShapeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.DbSystemShapeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.DbSystemShapeSummary()
        value.availableCoreCount = try reader["availableCoreCount"].readIfPresent()
        value.availableCoreCountPerNode = try reader["availableCoreCountPerNode"].readIfPresent()
        value.availableDataStorageInTBs = try reader["availableDataStorageInTBs"].readIfPresent()
        value.availableDataStoragePerServerInTBs = try reader["availableDataStoragePerServerInTBs"].readIfPresent()
        value.availableDbNodePerNodeInGBs = try reader["availableDbNodePerNodeInGBs"].readIfPresent()
        value.availableDbNodeStorageInGBs = try reader["availableDbNodeStorageInGBs"].readIfPresent()
        value.availableMemoryInGBs = try reader["availableMemoryInGBs"].readIfPresent()
        value.availableMemoryPerNodeInGBs = try reader["availableMemoryPerNodeInGBs"].readIfPresent()
        value.coreCountIncrement = try reader["coreCountIncrement"].readIfPresent()
        value.maxStorageCount = try reader["maxStorageCount"].readIfPresent()
        value.maximumNodeCount = try reader["maximumNodeCount"].readIfPresent()
        value.minCoreCountPerNode = try reader["minCoreCountPerNode"].readIfPresent()
        value.minDataStorageInTBs = try reader["minDataStorageInTBs"].readIfPresent()
        value.minDbNodeStoragePerNodeInGBs = try reader["minDbNodeStoragePerNodeInGBs"].readIfPresent()
        value.minMemoryPerNodeInGBs = try reader["minMemoryPerNodeInGBs"].readIfPresent()
        value.minStorageCount = try reader["minStorageCount"].readIfPresent()
        value.minimumCoreCount = try reader["minimumCoreCount"].readIfPresent()
        value.minimumNodeCount = try reader["minimumNodeCount"].readIfPresent()
        value.runtimeMinimumCoreCount = try reader["runtimeMinimumCoreCount"].readIfPresent()
        value.shapeFamily = try reader["shapeFamily"].readIfPresent()
        value.shapeType = try reader["shapeType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.computeModel = try reader["computeModel"].readIfPresent()
        value.areServerTypesSupported = try reader["areServerTypesSupported"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.GiVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.GiVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.GiVersionSummary()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.OdbNetworkSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.OdbNetworkSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.OdbNetworkSummary()
        value.odbNetworkId = try reader["odbNetworkId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.odbNetworkArn = try reader["odbNetworkArn"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["availabilityZoneId"].readIfPresent()
        value.clientSubnetCidr = try reader["clientSubnetCidr"].readIfPresent()
        value.backupSubnetCidr = try reader["backupSubnetCidr"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.defaultDnsPrefix = try reader["defaultDnsPrefix"].readIfPresent()
        value.peeredCidrs = try reader["peeredCidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ociNetworkAnchorId = try reader["ociNetworkAnchorId"].readIfPresent()
        value.ociNetworkAnchorUrl = try reader["ociNetworkAnchorUrl"].readIfPresent()
        value.ociResourceAnchorName = try reader["ociResourceAnchorName"].readIfPresent()
        value.ociVcnId = try reader["ociVcnId"].readIfPresent()
        value.ociVcnUrl = try reader["ociVcnUrl"].readIfPresent()
        value.ociDnsForwardingConfigs = try reader["ociDnsForwardingConfigs"].readListIfPresent(memberReadingClosure: OdbClientTypes.OciDnsForwardingConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        value.managedServices = try reader["managedServices"].readIfPresent(with: OdbClientTypes.ManagedServices.read(from:))
        return value
    }
}

extension OdbClientTypes.OdbPeeringConnectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.OdbPeeringConnectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.OdbPeeringConnectionSummary()
        value.odbPeeringConnectionId = try reader["odbPeeringConnectionId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.odbPeeringConnectionArn = try reader["odbPeeringConnectionArn"].readIfPresent()
        value.odbNetworkArn = try reader["odbNetworkArn"].readIfPresent()
        value.peerNetworkArn = try reader["peerNetworkArn"].readIfPresent()
        value.odbPeeringConnectionType = try reader["odbPeeringConnectionType"].readIfPresent()
        value.peerNetworkCidrs = try reader["peerNetworkCidrs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.percentProgress = try reader["percentProgress"].readIfPresent()
        return value
    }
}

extension OdbClientTypes.SystemVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.SystemVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.SystemVersionSummary()
        value.giVersion = try reader["giVersion"].readIfPresent()
        value.shape = try reader["shape"].readIfPresent()
        value.systemVersions = try reader["systemVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OdbClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> OdbClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OdbClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum OdbClientTypes {}
