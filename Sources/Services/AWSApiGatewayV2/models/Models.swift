// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayV2ClientTypes.AccessLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "destinationArn"
        case format = "format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Settings for logging access in a stage.
    public struct AccessLogSettings: Swift.Equatable {
        /// The ARN of the CloudWatch Logs log group to receive access logs.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension ApiGatewayV2ClientTypes.Api: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiEndpoint = self.apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiGatewayManaged = self.apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKeySelectionExpression = self.apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = self.corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = self.disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = self.disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let importInfo = importInfo {
            var importInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importInfo)
            for __string0 in importInfo {
                try importInfoContainer.encode(__string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeSelectionExpression = self.routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for __string0 in warnings {
                try warningsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API.
    public struct Api: Swift.Equatable {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public var apiGatewayManaged: Swift.Bool?
        /// The API ID.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
        public var apiKeySelectionExpression: Swift.String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
        /// The timestamp when the API was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the API.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public var disableSchemaValidation: Swift.Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public var importInfo: [Swift.String]?
        /// The name of the API.
        /// This member is required.
        public var name: Swift.String?
        /// The API protocol.
        /// This member is required.
        public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        /// This member is required.
        public var routeSelectionExpression: Swift.String?
        /// A collection of tags associated with the API.
        public var tags: [Swift.String:Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init(
            apiEndpoint: Swift.String? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool? = nil,
            disableSchemaValidation: Swift.Bool? = nil,
            importInfo: [Swift.String]? = nil,
            name: Swift.String? = nil,
            protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
            routeSelectionExpression: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

extension ApiGatewayV2ClientTypes.ApiMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingId = self.apiMappingId {
            try encodeContainer.encode(apiMappingId, forKey: .apiMappingId)
        }
        if let apiMappingKey = self.apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API mapping.
    public struct ApiMapping: Swift.Equatable {
        /// The API identifier.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API mapping identifier.
        public var apiMappingId: Swift.String?
        /// The API mapping key.
        public var apiMappingKey: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            apiId: Swift.String? = nil,
            apiMappingId: Swift.String? = nil,
            apiMappingKey: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The authorization type. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case custom
        case jwt
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .custom,
                .jwt,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .custom: return "CUSTOM"
            case .jwt: return "JWT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Authorizer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = self.authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let authorizerPayloadFormatVersion = self.authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = self.authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = self.authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = self.enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for __string0 in identitySource {
                try identitySourceContainer.encode(__string0)
            }
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = self.jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an authorizer.
    public struct Authorizer: Swift.Equatable {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public var authorizerCredentialsArn: Swift.String?
        /// The authorizer identifier.
        public var authorizerId: Swift.String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
        public var authorizerPayloadFormatVersion: Swift.String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public var authorizerUri: Swift.String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
        public var enableSimpleResponses: Swift.Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public var identitySource: [Swift.String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
        /// The name of the authorizer.
        /// This member is required.
        public var name: Swift.String?

        public init(
            authorizerCredentialsArn: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            authorizerPayloadFormatVersion: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
            authorizerUri: Swift.String? = nil,
            enableSimpleResponses: Swift.Bool? = nil,
            identitySource: [Swift.String]? = nil,
            identityValidationExpression: Swift.String? = nil,
            jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
            name: Swift.String? = nil
        )
        {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jwt
        case request
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .jwt,
                .request,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jwt: return "JWT"
            case .request: return "REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a connection type.
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.
    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Cors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCredentials = "allowCredentials"
        case allowHeaders = "allowHeaders"
        case allowMethods = "allowMethods"
        case allowOrigins = "allowOrigins"
        case exposeHeaders = "exposeHeaders"
        case maxAge = "maxAge"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCredentials = self.allowCredentials {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for __string0 in allowHeaders {
                try allowHeadersContainer.encode(__string0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for stringwithlengthbetween1and640 in allowMethods {
                try allowMethodsContainer.encode(stringwithlengthbetween1and640)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for __string0 in allowOrigins {
                try allowOriginsContainer.encode(__string0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for __string0 in exposeHeaders {
                try exposeHeadersContainer.encode(__string0)
            }
        }
        if let maxAge = self.maxAge {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCredentials)
        allowCredentials = allowCredentialsDecoded
        let allowHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[Swift.String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [Swift.String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
        let allowMethodsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[Swift.String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [Swift.String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[Swift.String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [Swift.String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAge)
        maxAge = maxAgeDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public struct Cors: Swift.Equatable {
        /// Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
        public var allowCredentials: Swift.Bool?
        /// Represents a collection of allowed headers. Supported only for HTTP APIs.
        public var allowHeaders: [Swift.String]?
        /// Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
        public var allowMethods: [Swift.String]?
        /// Represents a collection of allowed origins. Supported only for HTTP APIs.
        public var allowOrigins: [Swift.String]?
        /// Represents a collection of exposed headers. Supported only for HTTP APIs.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension CreateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = self.apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = self.corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = self.disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = self.disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType.rawValue, forKey: .protocolType)
        }
        if let routeKey = self.routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = self.routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension CreateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

/// Creates a new Api resource to represent an API.
public struct CreateApiInput: Swift.Equatable {
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    /// This member is required.
    public var name: Swift.String?
    /// The API protocol.
    /// This member is required.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.protocolType = protocolType
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.target = target
        self.version = version
    }
}

struct CreateApiInputBody: Swift.Equatable {
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeKey: Swift.String?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let target: Swift.String?
    let version: Swift.String?
}

extension CreateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case protocolType = "protocolType"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case target = "target"
        case version = "version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CreateApiMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = self.apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension CreateApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

/// Creates a new ApiMapping resource to represent an API mapping.
public struct CreateApiMappingInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    /// This member is required.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct CreateApiMappingInputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension CreateApiMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateApiMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApiMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct CreateApiMappingOutput: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct CreateApiMappingOutputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension CreateApiMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum CreateApiMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct CreateApiOutput: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateApiOutputBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension CreateApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum CreateApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = self.authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = self.authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = self.authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = self.authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = self.enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for __string0 in identitySource {
                try identitySourceContainer.encode(__string0)
            }
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = self.jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

/// Creates a new Authorizer resource to represent an authorizer.
public struct CreateAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    /// This member is required.
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    /// This member is required.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerInputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension CreateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct CreateAuthorizerOutput: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct CreateAuthorizerOutputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension CreateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

/// Creates a new Deployment resource to represent a deployment.
public struct CreateDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.stageName = stageName
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let description: Swift.String?
    let stageName: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case stageName = "stageName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct CreateDeploymentOutput: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfiguration0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfiguration0)
            }
        }
        if let mutualTlsAuthentication = self.mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domainnames"
    }
}

/// Creates a new DomainName resource to represent a domain name.
public struct CreateDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct CreateDomainNameOutput: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct CreateDomainNameOutputBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = self.integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = self.integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = self.integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = self.integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = self.passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = self.payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationParameters0) in requestParameters {
                try requestParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templateMap0) in requestTemplates {
                try requestTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseParameters0) in responseParameters {
                var responseParameters0Container = responseParametersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, integrationParameters1) in responseParameters0 {
                    try responseParameters0Container.encode(integrationParameters1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = self.timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

extension CreateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

/// Creates a new Integration resource to represent an integration.
public struct CreateIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration.
    public var description: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    /// This member is required.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationMethod: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?
}

extension CreateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension CreateIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct CreateIntegrationOutput: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct CreateIntegrationOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension CreateIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum CreateIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = self.integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationParameters0) in responseParameters {
                try responseParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templateMap0) in responseTemplates {
                try responseTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

extension CreateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

/// Creates a new IntegrationResponse resource to represent an integration response.
public struct CreateIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response key.
    /// This member is required.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseInputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension CreateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension CreateIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct CreateIntegrationResponseOutput: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct CreateIntegrationResponseOutputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension CreateIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

enum CreateIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

/// Creates a new Model.
public struct CreateModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.name = name
        self.schema = schema
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct CreateModelOutput: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension CreateModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum CreateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = self.apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for stringwithlengthbetween1and640 in authorizationScopes {
                try authorizationScopesContainer.encode(stringwithlengthbetween1and640)
            }
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routeModels0) in requestModels {
                try requestModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeParameters0) in requestParameters {
                try requestParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeKey = self.routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = self.routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension CreateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

/// Creates a new Route resource to represent a route.
public struct CreateRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route key for the route.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteInputBody: Swift.Equatable {
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension CreateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension CreateRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct CreateRouteOutput: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct CreateRouteOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension CreateRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

enum CreateRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRouteResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routeModels0) in responseModels {
                try responseModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeParameters0) in responseParameters {
                try responseParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = self.routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

extension CreateRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

/// Creates a new RouteResponse resource to represent a route response.
public struct CreateRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response key.
    /// This member is required.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseInputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseKey: Swift.String?
}

extension CreateRouteResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension CreateRouteResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRouteResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct CreateRouteResponseOutput: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct CreateRouteResponseOutputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension CreateRouteResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

enum CreateRouteResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let autoDeploy = self.autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = self.defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routeSettingsMap0) in routeSettings {
                try routeSettingsContainer.encode(routeSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stageVariablesMap0) in stageVariables {
                try stageVariablesContainer.encode(stageVariablesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

/// Creates a new Stage resource to represent a stage.
public struct CreateStageInput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier of the API stage.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct CreateStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct CreateStageOutputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __string0 in subnetIds {
                try subnetIdsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/vpclinks"
    }
}

/// Creates a VPC link
public struct CreateVpcLinkInput: Swift.Equatable {
    /// The name of the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct CreateVpcLinkOutput: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct CreateVpcLinkOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension CreateVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

enum CreateVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAccessLogSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/accesslogsettings"
    }
}

public struct DeleteAccessLogSettingsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteAccessLogSettingsInputBody: Swift.Equatable {
}

extension DeleteAccessLogSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessLogSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessLogSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessLogSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct DeleteApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiInputBody: Swift.Equatable {
}

extension DeleteApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

public struct DeleteApiMappingInput: Swift.Equatable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct DeleteApiMappingInputBody: Swift.Equatable {
}

extension DeleteApiMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApiMappingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApiMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApiOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

public struct DeleteAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct DeleteAuthorizerInputBody: Swift.Equatable {
}

extension DeleteAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAuthorizerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCorsConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/cors"
    }
}

public struct DeleteCorsConfigurationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteCorsConfigurationInputBody: Swift.Equatable {
}

extension DeleteCorsConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCorsConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCorsConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCorsConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct DeleteDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
}

extension DeleteDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeploymentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct DeleteDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainNameOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct DeleteIntegrationInputBody: Swift.Equatable {
}

extension DeleteIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

public struct DeleteIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct DeleteIntegrationResponseInputBody: Swift.Equatable {
}

extension DeleteIntegrationResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIntegrationResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

public struct DeleteModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

public struct DeleteRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct DeleteRouteInputBody: Swift.Equatable {
}

extension DeleteRouteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRouteOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteRequestParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let requestParameterKey = requestParameterKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/requestparameters/\(requestParameterKey.urlPercentEncoding())"
    }
}

public struct DeleteRouteRequestParameterInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route request parameter key.
    /// This member is required.
    public var requestParameterKey: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        requestParameterKey: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.requestParameterKey = requestParameterKey
        self.routeId = routeId
    }
}

struct DeleteRouteRequestParameterInputBody: Swift.Equatable {
}

extension DeleteRouteRequestParameterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteRequestParameterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRouteRequestParameterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRouteRequestParameterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

public struct DeleteRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct DeleteRouteResponseInputBody: Swift.Equatable {
}

extension DeleteRouteResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRouteResponseOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRouteResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRouteSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let routeKey = routeKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/routesettings/\(routeKey.urlPercentEncoding())"
    }
}

public struct DeleteRouteSettingsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route key.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeKey = routeKey
        self.stageName = stageName
    }
}

struct DeleteRouteSettingsInputBody: Swift.Equatable {
}

extension DeleteRouteSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRouteSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRouteSettingsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRouteSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

public struct DeleteStageInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStageOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

public struct DeleteVpcLinkInput: Swift.Equatable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Swift.Equatable {
}

extension DeleteVpcLinkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVpcLinkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApiGatewayV2ClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoDeployed = self.autoDeployed {
            try encodeContainer.encode(autoDeployed, forKey: .autoDeployed)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus.rawValue, forKey: .deploymentStatus)
        }
        if let deploymentStatusMessage = self.deploymentStatusMessage {
            try encodeContainer.encode(deploymentStatusMessage, forKey: .deploymentStatusMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// An immutable representation of an API that can be called by users. A Deployment must be associated with a Stage for it to be callable over the internet.
    public struct Deployment: Swift.Equatable {
        /// Specifies whether a deployment was automatically released.
        public var autoDeployed: Swift.Bool?
        /// The date and time when the Deployment resource was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for the deployment.
        public var deploymentId: Swift.String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public var deploymentStatusMessage: Swift.String?
        /// The description for the deployment.
        public var description: Swift.String?

        public init(
            autoDeployed: Swift.Bool? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a deployment status.
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deployed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .deployed,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.DomainName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiMappingSelectionExpression = self.apiMappingSelectionExpression {
            try encodeContainer.encode(apiMappingSelectionExpression, forKey: .apiMappingSelectionExpression)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfiguration0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfiguration0)
            }
        }
        if let mutualTlsAuthentication = self.mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a domain name.
    public struct DomainName: Swift.Equatable {
        /// The API mapping selection expression.
        public var apiMappingSelectionExpression: Swift.String?
        /// The name of the DomainName resource.
        /// This member is required.
        public var domainName: Swift.String?
        /// The domain name configurations.
        public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public var tags: [Swift.String:Swift.String]?

        public init(
            apiMappingSelectionExpression: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
            mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }
    }

}

extension ApiGatewayV2ClientTypes.DomainNameConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayDomainName = "apiGatewayDomainName"
        case certificateArn = "certificateArn"
        case certificateName = "certificateName"
        case certificateUploadDate = "certificateUploadDate"
        case domainNameStatus = "domainNameStatus"
        case domainNameStatusMessage = "domainNameStatusMessage"
        case endpointType = "endpointType"
        case hostedZoneId = "hostedZoneId"
        case ownershipVerificationCertificateArn = "ownershipVerificationCertificateArn"
        case securityPolicy = "securityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayDomainName = self.apiGatewayDomainName {
            try encodeContainer.encode(apiGatewayDomainName, forKey: .apiGatewayDomainName)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = self.certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = self.certificateUploadDate {
            try encodeContainer.encodeTimestamp(certificateUploadDate, format: .dateTime, forKey: .certificateUploadDate)
        }
        if let domainNameStatus = self.domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = self.domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if let ownershipVerificationCertificateArn = self.ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let securityPolicy = self.securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiGatewayDomainName)
        apiGatewayDomainName = apiGatewayDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateUploadDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The domain name configuration.
    public struct DomainNameConfiguration: Swift.Equatable {
        /// A domain name for the API.
        public var apiGatewayDomainName: Swift.String?
        /// An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: ClientRuntime.Date?
        /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the domain name migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint type.
        public var endpointType: ApiGatewayV2ClientTypes.EndpointType?
        /// The Amazon Route 53 Hosted Zone ID of the endpoint.
        public var hostedZoneId: Swift.String?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy?

        public init(
            apiGatewayDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: ClientRuntime.Date? = nil,
            domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointType: ApiGatewayV2ClientTypes.EndpointType? = nil,
            hostedZoneId: Swift.String? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy? = nil
        )
        {
            self.apiGatewayDomainName = apiGatewayDomainName
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointType = endpointType
            self.hostedZoneId = hostedZoneId
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.securityPolicy = securityPolicy
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an endpoint type.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ExportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let stageName = stageName {
                let stageNameQueryItem = ClientRuntime.URLQueryItem(name: "stageName".urlPercentEncoding(), value: Swift.String(stageName).urlPercentEncoding())
                items.append(stageNameQueryItem)
            }
            if let includeExtensions = includeExtensions {
                let includeExtensionsQueryItem = ClientRuntime.URLQueryItem(name: "includeExtensions".urlPercentEncoding(), value: Swift.String(includeExtensions).urlPercentEncoding())
                items.append(includeExtensionsQueryItem)
            }
            if let exportVersion = exportVersion {
                let exportVersionQueryItem = ClientRuntime.URLQueryItem(name: "exportVersion".urlPercentEncoding(), value: Swift.String(exportVersion).urlPercentEncoding())
                items.append(exportVersionQueryItem)
            }
            guard let outputType = outputType else {
                let message = "Creating a URL Query Item failed. outputType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let outputTypeQueryItem = ClientRuntime.URLQueryItem(name: "outputType".urlPercentEncoding(), value: Swift.String(outputType).urlPercentEncoding())
            items.append(outputTypeQueryItem)
            return items
        }
    }
}

extension ExportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let specification = specification else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/exports/\(specification.urlPercentEncoding())"
    }
}

public struct ExportApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.
    public var exportVersion: Swift.String?
    /// Specifies whether to include [API Gateway extensions](https://docs.aws.amazon.com//apigateway/latest/developerguide/api-gateway-swagger-extensions.html) in the exported API definition. API Gateway extensions are included by default.
    public var includeExtensions: Swift.Bool?
    /// The output type of the exported definition file. Valid values are JSON and YAML.
    /// This member is required.
    public var outputType: Swift.String?
    /// The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.
    /// This member is required.
    public var specification: Swift.String?
    /// The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        exportVersion: Swift.String? = nil,
        includeExtensions: Swift.Bool? = nil,
        outputType: Swift.String? = nil,
        specification: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.exportVersion = exportVersion
        self.includeExtensions = includeExtensions
        self.outputType = outputType
        self.specification = specification
        self.stageName = stageName
    }
}

struct ExportApiInputBody: Swift.Equatable {
}

extension ExportApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        switch httpResponse.body {
        case .data(let data):
            self.body = data
        case .stream(let stream):
            self.body = try stream.readToEnd()
        case .none:
            self.body = nil
        }
    }
}

public struct ExportApiOutput: Swift.Equatable {
    /// Represents an exported definition of an API in a particular output format, for example, YAML. The API is serialized to the requested specification, for example, OpenAPI 3.0.
    public var body: ClientRuntime.Data?

    public init(
        body: ClientRuntime.Data? = nil
    )
    {
        self.body = body
    }
}

struct ExportApiOutputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ExportApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

enum ExportApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

public struct GetApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiInputBody: Swift.Equatable {
}

extension GetApiInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

public struct GetApiMappingInput: Swift.Equatable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

struct GetApiMappingInputBody: Swift.Equatable {
}

extension GetApiMappingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct GetApiMappingOutput: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct GetApiMappingOutputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension GetApiMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum GetApiMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetApiMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

public struct GetApiMappingsInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApiMappingsInputBody: Swift.Equatable {
}

extension GetApiMappingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApiMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApiMappingsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ApiMapping]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.ApiMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApiMappingsOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.ApiMapping]?
    let nextToken: Swift.String?
}

extension GetApiMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.ApiMapping?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.ApiMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.ApiMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetApiMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct GetApiOutput: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetApiOutputBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension GetApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum GetApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

public struct GetApisInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetApisInputBody: Swift.Equatable {
}

extension GetApisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApisOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetApisOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Api]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Api]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetApisOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Api]?
    let nextToken: Swift.String?
}

extension GetApisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Api?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Api]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Api]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetApisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

public struct GetAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

struct GetAuthorizerInputBody: Swift.Equatable {
}

extension GetAuthorizerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct GetAuthorizerOutput: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct GetAuthorizerOutputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension GetAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum GetAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAuthorizersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetAuthorizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

public struct GetAuthorizersInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetAuthorizersInputBody: Swift.Equatable {
}

extension GetAuthorizersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetAuthorizersOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Authorizer]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Authorizer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetAuthorizersOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Authorizer]?
    let nextToken: Swift.String?
}

extension GetAuthorizersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Authorizer?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetAuthorizersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

public struct GetDeploymentsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDeploymentsInputBody: Swift.Equatable {
}

extension GetDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDeploymentsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Deployment]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDeploymentsOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Deployment]?
    let nextToken: Swift.String?
}

extension GetDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Deployment?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

public struct GetDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct GetDomainNameOutput: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct GetDomainNameOutputBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension GetDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/domainnames"
    }
}

public struct GetDomainNamesInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDomainNamesInputBody: Swift.Equatable {
}

extension GetDomainNamesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainNamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetDomainNamesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.DomainName]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.DomainName]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetDomainNamesOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.DomainName]?
    let nextToken: Swift.String?
}

extension GetDomainNamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainName?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDomainNamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

public struct GetIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

struct GetIntegrationInputBody: Swift.Equatable {
}

extension GetIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct GetIntegrationOutput: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct GetIntegrationOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension GetIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum GetIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

public struct GetIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

struct GetIntegrationResponseInputBody: Swift.Equatable {
}

extension GetIntegrationResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct GetIntegrationResponseOutput: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct GetIntegrationResponseOutputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension GetIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

enum GetIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetIntegrationResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

public struct GetIntegrationResponsesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesInputBody: Swift.Equatable {
}

extension GetIntegrationResponsesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponsesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationResponsesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationResponsesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.IntegrationResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationResponsesOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    let nextToken: Swift.String?
}

extension GetIntegrationResponsesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.IntegrationResponse?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.IntegrationResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.IntegrationResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetIntegrationResponsesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIntegrationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetIntegrationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

public struct GetIntegrationsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetIntegrationsInputBody: Swift.Equatable {
}

extension GetIntegrationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIntegrationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetIntegrationsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Integration]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Integration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetIntegrationsOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Integration]?
    let nextToken: Swift.String?
}

extension GetIntegrationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Integration?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Integration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Integration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetIntegrationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

public struct GetModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelInputBody: Swift.Equatable {
}

extension GetModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct GetModelOutput: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension GetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum GetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())/template"
    }
}

public struct GetModelTemplateInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

struct GetModelTemplateInputBody: Swift.Equatable {
}

extension GetModelTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

public struct GetModelTemplateOutput: Swift.Equatable {
    /// The template value.
    public var value: Swift.String?

    public init(
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputBody: Swift.Equatable {
    let value: Swift.String?
}

extension GetModelTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

enum GetModelTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

public struct GetModelsInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Swift.Equatable {
}

extension GetModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Model]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetModelsOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Model]?
    let nextToken: Swift.String?
}

extension GetModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Model?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

public struct GetRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

struct GetRouteInputBody: Swift.Equatable {
}

extension GetRouteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct GetRouteOutput: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct GetRouteOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension GetRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

enum GetRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

public struct GetRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

struct GetRouteResponseInputBody: Swift.Equatable {
}

extension GetRouteResponseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRouteResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct GetRouteResponseOutput: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct GetRouteResponseOutputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension GetRouteResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

enum GetRouteResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRouteResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRouteResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

public struct GetRouteResponsesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeId = routeId
    }
}

struct GetRouteResponsesInputBody: Swift.Equatable {
}

extension GetRouteResponsesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRouteResponsesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRouteResponsesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRouteResponsesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.RouteResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.RouteResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRouteResponsesOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.RouteResponse]?
    let nextToken: Swift.String?
}

extension GetRouteResponsesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.RouteResponse?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.RouteResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.RouteResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetRouteResponsesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRoutesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetRoutesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

public struct GetRoutesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetRoutesInputBody: Swift.Equatable {
}

extension GetRoutesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRoutesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoutesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetRoutesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Route]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Route]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetRoutesOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Route]?
    let nextToken: Swift.String?
}

extension GetRoutesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Route?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Route]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Route]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetRoutesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

public struct GetStageInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct GetStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct GetStageOutputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

public struct GetStagesInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetStagesInputBody: Swift.Equatable {
}

extension GetStagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetStagesOutput: Swift.Equatable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Stage]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Stage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetStagesOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.Stage]?
    let nextToken: Swift.String?
}

extension GetStagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.Stage?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.Stage]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.Stage]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetStagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetTagsInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Swift.Equatable {
}

extension GetTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct GetTagsOutput: Swift.Equatable {
    /// Represents a collection of tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension GetTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

public struct GetVpcLinkInput: Swift.Equatable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Swift.Equatable {
}

extension GetVpcLinkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct GetVpcLinkOutput: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct GetVpcLinkOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension GetVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

enum GetVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVpcLinksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetVpcLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/vpclinks"
    }
}

public struct GetVpcLinksInput: Swift.Equatable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetVpcLinksInputBody: Swift.Equatable {
}

extension GetVpcLinksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVpcLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetVpcLinksOutput: Swift.Equatable {
    /// A collection of VPC links.
    public var items: [ApiGatewayV2ClientTypes.VpcLink]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.VpcLink]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetVpcLinksOutputBody: Swift.Equatable {
    let items: [ApiGatewayV2ClientTypes.VpcLink]?
    let nextToken: Swift.String?
}

extension GetVpcLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "items"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.VpcLink?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayV2ClientTypes.VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayV2ClientTypes.VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetVpcLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension ImportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            if let basepath = basepath {
                let basepathQueryItem = ClientRuntime.URLQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
                items.append(basepathQueryItem)
            }
            return items
        }
    }
}

extension ImportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v2/apis"
    }
}

///
public struct ImportApiInput: Swift.Equatable {
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ImportApiInputBody: Swift.Equatable {
    let body: Swift.String?
}

extension ImportApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ImportApiOutput: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportApiOutputBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension ImportApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum ImportApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApiGatewayV2ClientTypes.Integration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayManaged = self.apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationId = self.integrationId {
            try encodeContainer.encode(integrationId, forKey: .integrationId)
        }
        if let integrationMethod = self.integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationResponseSelectionExpression = self.integrationResponseSelectionExpression {
            try encodeContainer.encode(integrationResponseSelectionExpression, forKey: .integrationResponseSelectionExpression)
        }
        if let integrationSubtype = self.integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = self.integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = self.integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = self.passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = self.payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationParameters0) in requestParameters {
                try requestParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templateMap0) in requestTemplates {
                try requestTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseParameters0) in responseParameters {
                var responseParameters0Container = responseParametersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, integrationParameters1) in responseParameters0 {
                    try responseParameters0Container.encode(integrationParameters1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = self.timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration.
    public struct Integration: Swift.Equatable {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public var apiGatewayManaged: Swift.Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public var credentialsArn: Swift.String?
        /// Represents the description of an integration.
        public var description: Swift.String?
        /// Represents the identifier of an integration.
        public var integrationId: Swift.String?
        /// Specifies the integration's HTTP method type.
        public var integrationMethod: Swift.String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
        public var integrationResponseSelectionExpression: Swift.String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
        public var integrationSubtype: Swift.String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
        public var integrationUri: Swift.String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
        public var payloadFormatVersion: Swift.String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var requestParameters: [Swift.String:Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public var requestTemplates: [Swift.String:Swift.String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public var templateSelectionExpression: Swift.String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public var timeoutInMillis: Swift.Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            connectionId: Swift.String? = nil,
            connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            credentialsArn: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationId: Swift.String? = nil,
            integrationMethod: Swift.String? = nil,
            integrationResponseSelectionExpression: Swift.String? = nil,
            integrationSubtype: Swift.String? = nil,
            integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
            integrationUri: Swift.String? = nil,
            passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
            payloadFormatVersion: Swift.String? = nil,
            requestParameters: [Swift.String:Swift.String]? = nil,
            requestTemplates: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
            templateSelectionExpression: Swift.String? = nil,
            timeoutInMillis: Swift.Int? = nil,
            tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }
    }

}

extension ApiGatewayV2ClientTypes.IntegrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseId = self.integrationResponseId {
            try encodeContainer.encode(integrationResponseId, forKey: .integrationResponseId)
        }
        if let integrationResponseKey = self.integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationParameters0) in responseParameters {
                try responseParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templateMap0) in responseTemplates {
                try responseTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration response.
    public struct IntegrationResponse: Swift.Equatable {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// The integration response ID.
        public var integrationResponseId: Swift.String?
        /// The integration response key.
        /// This member is required.
        public var integrationResponseKey: Swift.String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String:Swift.String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// The template selection expressions for the integration response.
        public var templateSelectionExpression: Swift.String?

        public init(
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            integrationResponseId: Swift.String? = nil,
            integrationResponseKey: Swift.String? = nil,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            templateSelectionExpression: Swift.String? = nil
        )
        {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an API method integration type.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.JWTConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audience = "audience"
        case issuer = "issuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audience = audience {
            var audienceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audience)
            for __string0 in audience {
                try audienceContainer.encode(__string0)
            }
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audienceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .audience)
        var audienceDecoded0:[Swift.String]? = nil
        if let audienceContainer = audienceContainer {
            audienceDecoded0 = [Swift.String]()
            for string0 in audienceContainer {
                if let string0 = string0 {
                    audienceDecoded0?.append(string0)
                }
            }
        }
        audience = audienceDecoded0
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public struct JWTConfiguration: Swift.Equatable {
        /// A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See [RFC 7519](https://tools.ietf.org/html/rfc7519#section-4.1.3). Supported only for HTTP APIs.
        public var audience: [Swift.String]?
        /// The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.{region}.amazonaws.com/{userPoolId} . Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var issuer: Swift.String?

        public init(
            audience: [Swift.String]? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.audience = audience
            self.issuer = issuer
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The logging level.
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a data model for an API. Supported only for WebSocket APIs. See [Create Models and Mapping Templates for Request and Response Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html).
    public struct Model: Swift.Equatable {
        /// The content-type for the model, for example, "application/json".
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The model identifier.
        public var modelId: Swift.String?
        /// The name of the model. Must be alphanumeric.
        /// This member is required.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public var schema: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }
    }

}

extension ApiGatewayV2ClientTypes.MutualTlsAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
        case truststoreWarnings = "truststoreWarnings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = self.truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = self.truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for __string0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[Swift.String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [Swift.String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthentication: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

extension ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri = "truststoreUri"
        case truststoreVersion = "truststoreVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = self.truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = self.truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthenticationInput: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request was not found. See the message field for more information.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
        /// The resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ApiGatewayV2ClientTypes.ParameterConstraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Validation constraints imposed on parameters of a request (path, query string, headers).
    public struct ParameterConstraints: Swift.Equatable {
        /// Whether or not the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            `required`: Swift.Bool? = nil
        )
        {
            self.`required` = `required`
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.
    public enum PassthroughBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case never
        case whenNoMatch
        case whenNoTemplates
        case sdkUnknown(Swift.String)

        public static var allCases: [PassthroughBehavior] {
            return [
                .never,
                .whenNoMatch,
                .whenNoTemplates,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .never: return "NEVER"
            case .whenNoMatch: return "WHEN_NO_MATCH"
            case .whenNoTemplates: return "WHEN_NO_TEMPLATES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PassthroughBehavior(rawValue: rawValue) ?? PassthroughBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a protocol type.
    public enum ProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .http,
                .websocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtocolType(rawValue: rawValue) ?? ProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension ReimportApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension ReimportApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let failOnWarnings = failOnWarnings {
                let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
                items.append(failOnWarningsQueryItem)
            }
            if let basepath = basepath {
                let basepathQueryItem = ClientRuntime.URLQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
                items.append(basepathQueryItem)
            }
            return items
        }
    }
}

extension ReimportApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

///
public struct ReimportApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        apiId: Swift.String? = nil,
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

struct ReimportApiInputBody: Swift.Equatable {
    let body: Swift.String?
}

extension ReimportApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "body"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ReimportApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReimportApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct ReimportApiOutput: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ReimportApiOutputBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension ReimportApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum ReimportApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResetAuthorizersCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

public struct ResetAuthorizersCacheInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

struct ResetAuthorizersCacheInputBody: Swift.Equatable {
}

extension ResetAuthorizersCacheInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ResetAuthorizersCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetAuthorizersCacheOutput: Swift.Equatable {

    public init() { }
}

enum ResetAuthorizersCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApiGatewayV2ClientTypes.Route: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiGatewayManaged = self.apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let apiKeyRequired = self.apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for stringwithlengthbetween1and640 in authorizationScopes {
                try authorizationScopesContainer.encode(stringwithlengthbetween1and640)
            }
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routeModels0) in requestModels {
                try requestModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeParameters0) in requestParameters {
                try requestParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeId = self.routeId {
            try encodeContainer.encode(routeId, forKey: .routeId)
        }
        if let routeKey = self.routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = self.routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a route.
    public struct Route: Swift.Equatable {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public var authorizerId: Swift.String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// The operation name for the route.
        public var operationName: Swift.String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public var requestModels: [Swift.String:Swift.String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// The route ID.
        public var routeId: Swift.String?
        /// The route key for the route.
        /// This member is required.
        public var routeKey: Swift.String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public var routeResponseSelectionExpression: Swift.String?
        /// The target for the route.
        public var target: Swift.String?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
            authorizerId: Swift.String? = nil,
            modelSelectionExpression: Swift.String? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String:Swift.String]? = nil,
            requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeId: Swift.String? = nil,
            routeKey: Swift.String? = nil,
            routeResponseSelectionExpression: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }
    }

}

extension ApiGatewayV2ClientTypes.RouteResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routeModels0) in responseModels {
                try responseModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeParameters0) in responseParameters {
                try responseParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseId = self.routeResponseId {
            try encodeContainer.encode(routeResponseId, forKey: .routeResponseId)
        }
        if let routeResponseKey = self.routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a route response.
    public struct RouteResponse: Swift.Equatable {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// Represents the response models of a route response.
        public var responseModels: [Swift.String:Swift.String]?
        /// Represents the response parameters of a route response.
        public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// Represents the identifier of a route response.
        public var routeResponseId: Swift.String?
        /// Represents the route response key of a route response.
        /// This member is required.
        public var routeResponseKey: Swift.String?

        public init(
            modelSelectionExpression: Swift.String? = nil,
            responseModels: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeResponseId: Swift.String? = nil,
            routeResponseKey: Swift.String? = nil
        )
        {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }
    }

}

extension ApiGatewayV2ClientTypes.RouteSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTraceEnabled = "dataTraceEnabled"
        case detailedMetricsEnabled = "detailedMetricsEnabled"
        case loggingLevel = "loggingLevel"
        case throttlingBurstLimit = "throttlingBurstLimit"
        case throttlingRateLimit = "throttlingRateLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTraceEnabled = self.dataTraceEnabled {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let detailedMetricsEnabled = self.detailedMetricsEnabled {
            try encodeContainer.encode(detailedMetricsEnabled, forKey: .detailedMetricsEnabled)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel.rawValue, forKey: .loggingLevel)
        }
        if let throttlingBurstLimit = self.throttlingBurstLimit {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if let throttlingRateLimit = self.throttlingRateLimit {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTraceEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let detailedMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .detailedMetricsEnabled)
        detailedMetricsEnabled = detailedMetricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.LoggingLevel.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let throttlingBurstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a collection of route settings.
    public struct RouteSettings: Swift.Equatable {
        /// Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool?
        /// Specifies whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool?
        /// Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel?
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int?
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double?

        public init(
            dataTraceEnabled: Swift.Bool? = nil,
            detailedMetricsEnabled: Swift.Bool? = nil,
            loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil
        )
        {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let apiGatewayManaged = self.apiGatewayManaged {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if let autoDeploy = self.autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let defaultRouteSettings = self.defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastDeploymentStatusMessage = self.lastDeploymentStatusMessage {
            try encodeContainer.encode(lastDeploymentStatusMessage, forKey: .lastDeploymentStatusMessage)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .dateTime, forKey: .lastUpdatedDate)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routeSettingsMap0) in routeSettings {
                try routeSettingsContainer.encode(routeSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stageVariablesMap0) in stageVariables {
                try stageVariablesContainer.encode(stageVariablesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API stage.
    public struct Stage: Swift.Equatable {
        /// Settings for logging access in this stage.
        public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public var autoDeploy: Swift.Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: ClientRuntime.Date?
        /// Default route settings for the stage.
        public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// The timestamp when the stage was last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// Route settings for the stage, by routeKey.
        public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
        /// The name of the stage.
        /// This member is required.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var stageVariables: [Swift.String:Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            autoDeploy: Swift.Bool? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Creates a new Tag resource to represent a tag.
public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApiGatewayV2ClientTypes.TlsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = self.serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfig: Swift.Equatable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

extension ApiGatewayV2ClientTypes.TlsConfigInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverNameToVerify = "serverNameToVerify"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverNameToVerify = self.serverNameToVerify {
            try encodeContainer.encode(serverNameToVerify, forKey: .serverNameToVerify)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameToVerifyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverNameToVerify)
        serverNameToVerify = serverNameToVerifyDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfigInput: Swift.Equatable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limitType = output.limitType
            self.properties.message = output.message
        } else {
            self.properties.limitType = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A limit has been exceeded. See the accompanying error message for details.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit type.
        public internal(set) var limitType: Swift.String? = nil
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.limitType = limitType
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let limitType: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySelectionExpression = self.apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = self.corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disableExecuteApiEndpoint = self.disableExecuteApiEndpoint {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let disableSchemaValidation = self.disableSchemaValidation {
            try encodeContainer.encode(disableSchemaValidation, forKey: .disableSchemaValidation)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routeKey = self.routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeSelectionExpression = self.routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension UpdateApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

/// Updates an Api.
public struct UpdateApiInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    public var name: Swift.String?
    /// This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.target = target
        self.version = version
    }
}

struct UpdateApiInputBody: Swift.Equatable {
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let name: Swift.String?
    let routeKey: Swift.String?
    let routeSelectionExpression: Swift.String?
    let target: Swift.String?
    let version: Swift.String?
}

extension UpdateApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case name = "name"
        case routeKey = "routeKey"
        case routeSelectionExpression = "routeSelectionExpression"
        case target = "target"
        case version = "version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension UpdateApiMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiMappingKey = self.apiMappingKey {
            try encodeContainer.encode(apiMappingKey, forKey: .apiMappingKey)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension UpdateApiMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let apiMappingId = apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

/// Updates an ApiMapping.
public struct UpdateApiMappingInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

struct UpdateApiMappingInputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension UpdateApiMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateApiMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApiMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiId = output.apiId
            self.apiMappingId = output.apiMappingId
            self.apiMappingKey = output.apiMappingKey
            self.stage = output.stage
        } else {
            self.apiId = nil
            self.apiMappingId = nil
            self.apiMappingKey = nil
            self.stage = nil
        }
    }
}

public struct UpdateApiMappingOutput: Swift.Equatable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

struct UpdateApiMappingOutputBody: Swift.Equatable {
    let apiId: Swift.String?
    let apiMappingId: Swift.String?
    let apiMappingKey: Swift.String?
    let stage: Swift.String?
}

extension UpdateApiMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId = "apiId"
        case apiMappingId = "apiMappingId"
        case apiMappingKey = "apiMappingKey"
        case stage = "stage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiMappingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingId)
        apiMappingId = apiMappingIdDecoded
        let apiMappingKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingKey)
        apiMappingKey = apiMappingKeyDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

enum UpdateApiMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApiOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApiOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiEndpoint = output.apiEndpoint
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiId = output.apiId
            self.apiKeySelectionExpression = output.apiKeySelectionExpression
            self.corsConfiguration = output.corsConfiguration
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.disableSchemaValidation = output.disableSchemaValidation
            self.importInfo = output.importInfo
            self.name = output.name
            self.protocolType = output.protocolType
            self.routeSelectionExpression = output.routeSelectionExpression
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiEndpoint = nil
            self.apiGatewayManaged = nil
            self.apiId = nil
            self.apiKeySelectionExpression = nil
            self.corsConfiguration = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = nil
            self.disableSchemaValidation = nil
            self.importInfo = nil
            self.name = nil
            self.protocolType = nil
            self.routeSelectionExpression = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

public struct UpdateApiOutput: Swift.Equatable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateApiOutputBody: Swift.Equatable {
    let apiEndpoint: Swift.String?
    let apiGatewayManaged: Swift.Bool?
    let apiId: Swift.String?
    let apiKeySelectionExpression: Swift.String?
    let corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
    let disableSchemaValidation: Swift.Bool?
    let disableExecuteApiEndpoint: Swift.Bool?
    let importInfo: [Swift.String]?
    let name: Swift.String?
    let protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    let routeSelectionExpression: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let version: Swift.String?
    let warnings: [Swift.String]?
}

extension UpdateApiOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "apiEndpoint"
        case apiGatewayManaged = "apiGatewayManaged"
        case apiId = "apiId"
        case apiKeySelectionExpression = "apiKeySelectionExpression"
        case corsConfiguration = "corsConfiguration"
        case createdDate = "createdDate"
        case description = "description"
        case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
        case disableSchemaValidation = "disableSchemaValidation"
        case importInfo = "importInfo"
        case name = "name"
        case protocolType = "protocolType"
        case routeSelectionExpression = "routeSelectionExpression"
        case tags = "tags"
        case version = "version"
        case warnings = "warnings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.Cors.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableSchemaValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSchemaValidation)
        disableSchemaValidation = disableSchemaValidationDecoded
        let disableExecuteApiEndpointDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
        let importInfoContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importInfo)
        var importInfoDecoded0:[Swift.String]? = nil
        if let importInfoContainer = importInfoContainer {
            importInfoDecoded0 = [Swift.String]()
            for string0 in importInfoContainer {
                if let string0 = string0 {
                    importInfoDecoded0?.append(string0)
                }
            }
        }
        importInfo = importInfoDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ProtocolType.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

enum UpdateApiOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizerCredentialsArn = self.authorizerCredentialsArn {
            try encodeContainer.encode(authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
        }
        if let authorizerPayloadFormatVersion = self.authorizerPayloadFormatVersion {
            try encodeContainer.encode(authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
        }
        if let authorizerResultTtlInSeconds = self.authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerType = self.authorizerType {
            try encodeContainer.encode(authorizerType.rawValue, forKey: .authorizerType)
        }
        if let authorizerUri = self.authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let enableSimpleResponses = self.enableSimpleResponses {
            try encodeContainer.encode(enableSimpleResponses, forKey: .enableSimpleResponses)
        }
        if let identitySource = identitySource {
            var identitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identitySource)
            for __string0 in identitySource {
                try identitySourceContainer.encode(__string0)
            }
        }
        if let identityValidationExpression = self.identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let jwtConfiguration = self.jwtConfiguration {
            try encodeContainer.encode(jwtConfiguration, forKey: .jwtConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Updates an Authorizer.
public struct UpdateAuthorizerInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerInputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension UpdateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateAuthorizerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAuthorizerOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizerCredentialsArn = output.authorizerCredentialsArn
            self.authorizerId = output.authorizerId
            self.authorizerPayloadFormatVersion = output.authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerType = output.authorizerType
            self.authorizerUri = output.authorizerUri
            self.enableSimpleResponses = output.enableSimpleResponses
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.jwtConfiguration = output.jwtConfiguration
            self.name = output.name
        } else {
            self.authorizerCredentialsArn = nil
            self.authorizerId = nil
            self.authorizerPayloadFormatVersion = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerType = nil
            self.authorizerUri = nil
            self.enableSimpleResponses = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.jwtConfiguration = nil
            self.name = nil
        }
    }
}

public struct UpdateAuthorizerOutput: Swift.Equatable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

struct UpdateAuthorizerOutputBody: Swift.Equatable {
    let authorizerCredentialsArn: Swift.String?
    let authorizerId: Swift.String?
    let authorizerPayloadFormatVersion: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
    let authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    let authorizerUri: Swift.String?
    let enableSimpleResponses: Swift.Bool?
    let identitySource: [Swift.String]?
    let identityValidationExpression: Swift.String?
    let jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    let name: Swift.String?
}

extension UpdateAuthorizerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizerCredentialsArn = "authorizerCredentialsArn"
        case authorizerId = "authorizerId"
        case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
        case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
        case authorizerType = "authorizerType"
        case authorizerUri = "authorizerUri"
        case enableSimpleResponses = "enableSimpleResponses"
        case identitySource = "identitySource"
        case identityValidationExpression = "identityValidationExpression"
        case jwtConfiguration = "jwtConfiguration"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizerCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentialsArn)
        authorizerCredentialsArn = authorizerCredentialsArnDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let authorizerPayloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerPayloadFormatVersion)
        authorizerPayloadFormatVersion = authorizerPayloadFormatVersionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
        let authorizerTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizerType.self, forKey: .authorizerType)
        authorizerType = authorizerTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let enableSimpleResponsesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSimpleResponses)
        enableSimpleResponses = enableSimpleResponsesDecoded
        let identitySourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identitySource)
        var identitySourceDecoded0:[Swift.String]? = nil
        if let identitySourceContainer = identitySourceContainer {
            identitySourceDecoded0 = [Swift.String]()
            for string0 in identitySourceContainer {
                if let string0 = string0 {
                    identitySourceDecoded0?.append(string0)
                }
            }
        }
        identitySource = identitySourceDecoded0
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let jwtConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.JWTConfiguration.self, forKey: .jwtConfiguration)
        jwtConfiguration = jwtConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateAuthorizerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Updates a Deployment.
public struct UpdateDeploymentInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
        self.description = description
    }
}

struct UpdateDeploymentInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoDeployed = output.autoDeployed
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.deploymentStatus = output.deploymentStatus
            self.deploymentStatusMessage = output.deploymentStatusMessage
            self.description = output.description
        } else {
            self.autoDeployed = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.deploymentStatus = nil
            self.deploymentStatusMessage = nil
            self.description = nil
        }
    }
}

public struct UpdateDeploymentOutput: Swift.Equatable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

struct UpdateDeploymentOutputBody: Swift.Equatable {
    let autoDeployed: Swift.Bool?
    let createdDate: ClientRuntime.Date?
    let deploymentId: Swift.String?
    let deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    let deploymentStatusMessage: Swift.String?
    let description: Swift.String?
}

extension UpdateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoDeployed = "autoDeployed"
        case createdDate = "createdDate"
        case deploymentId = "deploymentId"
        case deploymentStatus = "deploymentStatus"
        case deploymentStatusMessage = "deploymentStatusMessage"
        case description = "description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoDeployedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeployed)
        autoDeployed = autoDeployedDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.DeploymentStatus.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatusMessage)
        deploymentStatusMessage = deploymentStatusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainNameConfigurations = domainNameConfigurations {
            var domainNameConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNameConfigurations)
            for domainnameconfiguration0 in domainNameConfigurations {
                try domainNameConfigurationsContainer.encode(domainnameconfiguration0)
            }
        }
        if let mutualTlsAuthentication = self.mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// Updates a DomainName.
public struct UpdateDomainNameInput: Swift.Equatable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
    }
}

extension UpdateDomainNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainNameOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiMappingSelectionExpression = output.apiMappingSelectionExpression
            self.domainName = output.domainName
            self.domainNameConfigurations = output.domainNameConfigurations
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.tags = output.tags
        } else {
            self.apiMappingSelectionExpression = nil
            self.domainName = nil
            self.domainNameConfigurations = nil
            self.mutualTlsAuthentication = nil
            self.tags = nil
        }
    }
}

public struct UpdateDomainNameOutput: Swift.Equatable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String:Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

struct UpdateDomainNameOutputBody: Swift.Equatable {
    let apiMappingSelectionExpression: Swift.String?
    let domainName: Swift.String?
    let domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    let mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateDomainNameOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiMappingSelectionExpression = "apiMappingSelectionExpression"
        case domainName = "domainName"
        case domainNameConfigurations = "domainNameConfigurations"
        case mutualTlsAuthentication = "mutualTlsAuthentication"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiMappingSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiMappingSelectionExpression)
        apiMappingSelectionExpression = apiMappingSelectionExpressionDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainNameConfigurationsContainer = try containerValues.decodeIfPresent([ApiGatewayV2ClientTypes.DomainNameConfiguration?].self, forKey: .domainNameConfigurations)
        var domainNameConfigurationsDecoded0:[ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil
        if let domainNameConfigurationsContainer = domainNameConfigurationsContainer {
            domainNameConfigurationsDecoded0 = [ApiGatewayV2ClientTypes.DomainNameConfiguration]()
            for structure0 in domainNameConfigurationsContainer {
                if let structure0 = structure0 {
                    domainNameConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        domainNameConfigurations = domainNameConfigurationsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateDomainNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationMethod = self.integrationMethod {
            try encodeContainer.encode(integrationMethod, forKey: .integrationMethod)
        }
        if let integrationSubtype = self.integrationSubtype {
            try encodeContainer.encode(integrationSubtype, forKey: .integrationSubtype)
        }
        if let integrationType = self.integrationType {
            try encodeContainer.encode(integrationType.rawValue, forKey: .integrationType)
        }
        if let integrationUri = self.integrationUri {
            try encodeContainer.encode(integrationUri, forKey: .integrationUri)
        }
        if let passthroughBehavior = self.passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior.rawValue, forKey: .passthroughBehavior)
        }
        if let payloadFormatVersion = self.payloadFormatVersion {
            try encodeContainer.encode(payloadFormatVersion, forKey: .payloadFormatVersion)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, integrationParameters0) in requestParameters {
                try requestParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, templateMap0) in requestTemplates {
                try requestTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, responseParameters0) in responseParameters {
                var responseParameters0Container = responseParametersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, integrationParameters1) in responseParameters0 {
                    try responseParameters0Container.encode(integrationParameters1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
        if let timeoutInMillis = self.timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = self.tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
    }
}

extension UpdateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

/// Updates an Integration.
public struct UpdateIntegrationInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration
    public var description: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationInputBody: Swift.Equatable {
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationMethod: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?
}

extension UpdateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationMethod = "integrationMethod"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfigInput.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.credentialsArn = output.credentialsArn
            self.description = output.description
            self.integrationId = output.integrationId
            self.integrationMethod = output.integrationMethod
            self.integrationResponseSelectionExpression = output.integrationResponseSelectionExpression
            self.integrationSubtype = output.integrationSubtype
            self.integrationType = output.integrationType
            self.integrationUri = output.integrationUri
            self.passthroughBehavior = output.passthroughBehavior
            self.payloadFormatVersion = output.payloadFormatVersion
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.responseParameters = output.responseParameters
            self.templateSelectionExpression = output.templateSelectionExpression
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
        } else {
            self.apiGatewayManaged = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandlingStrategy = nil
            self.credentialsArn = nil
            self.description = nil
            self.integrationId = nil
            self.integrationMethod = nil
            self.integrationResponseSelectionExpression = nil
            self.integrationSubtype = nil
            self.integrationType = nil
            self.integrationUri = nil
            self.passthroughBehavior = nil
            self.payloadFormatVersion = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.responseParameters = nil
            self.templateSelectionExpression = nil
            self.timeoutInMillis = nil
            self.tlsConfig = nil
        }
    }
}

public struct UpdateIntegrationOutput: Swift.Equatable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:[Swift.String:Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

struct UpdateIntegrationOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let connectionId: Swift.String?
    let connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let credentialsArn: Swift.String?
    let description: Swift.String?
    let integrationId: Swift.String?
    let integrationMethod: Swift.String?
    let integrationResponseSelectionExpression: Swift.String?
    let integrationSubtype: Swift.String?
    let integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    let integrationUri: Swift.String?
    let passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    let payloadFormatVersion: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:[Swift.String:Swift.String]]?
    let templateSelectionExpression: Swift.String?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?
}

extension UpdateIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case connectionId = "connectionId"
        case connectionType = "connectionType"
        case contentHandlingStrategy = "contentHandlingStrategy"
        case credentialsArn = "credentialsArn"
        case description = "description"
        case integrationId = "integrationId"
        case integrationMethod = "integrationMethod"
        case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
        case integrationSubtype = "integrationSubtype"
        case integrationType = "integrationType"
        case integrationUri = "integrationUri"
        case passthroughBehavior = "passthroughBehavior"
        case payloadFormatVersion = "payloadFormatVersion"
        case requestParameters = "requestParameters"
        case requestTemplates = "requestTemplates"
        case responseParameters = "responseParameters"
        case templateSelectionExpression = "templateSelectionExpression"
        case timeoutInMillis = "timeoutInMillis"
        case tlsConfig = "tlsConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let integrationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationId)
        integrationId = integrationIdDecoded
        let integrationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationMethod)
        integrationMethod = integrationMethodDecoded
        let integrationResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseSelectionExpression)
        integrationResponseSelectionExpression = integrationResponseSelectionExpressionDecoded
        let integrationSubtypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationSubtype)
        integrationSubtype = integrationSubtypeDecoded
        let integrationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.IntegrationType.self, forKey: .integrationType)
        integrationType = integrationTypeDecoded
        let integrationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationUri)
        integrationUri = integrationUriDecoded
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.PassthroughBehavior.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let payloadFormatVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payloadFormatVersion)
        payloadFormatVersion = payloadFormatVersionDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in requestParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    requestParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in requestTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    requestTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, integrationparameters0) in responseParametersContainer {
                var integrationparameters0Decoded0: [Swift.String: Swift.String]? = nil
                if let integrationparameters0 = integrationparameters0 {
                    integrationparameters0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, stringwithlengthbetween1and5121) in integrationparameters0 {
                        if let stringwithlengthbetween1and5121 = stringwithlengthbetween1and5121 {
                            integrationparameters0Decoded0?[key1] = stringwithlengthbetween1and5121
                        }
                    }
                }
                responseParametersDecoded0?[key0] = integrationparameters0Decoded0
            }
        }
        responseParameters = responseParametersDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

enum UpdateIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandlingStrategy = self.contentHandlingStrategy {
            try encodeContainer.encode(contentHandlingStrategy.rawValue, forKey: .contentHandlingStrategy)
        }
        if let integrationResponseKey = self.integrationResponseKey {
            try encodeContainer.encode(integrationResponseKey, forKey: .integrationResponseKey)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, integrationParameters0) in responseParameters {
                try responseParametersContainer.encode(integrationParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, templateMap0) in responseTemplates {
                try responseTemplatesContainer.encode(templateMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateSelectionExpression = self.templateSelectionExpression {
            try encodeContainer.encode(templateSelectionExpression, forKey: .templateSelectionExpression)
        }
    }
}

extension UpdateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let integrationId = integrationId else {
            return nil
        }
        guard let integrationResponseId = integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

/// Updates an IntegrationResponses.
public struct UpdateIntegrationResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name} , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression} , where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseInputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension UpdateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

extension UpdateIntegrationResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIntegrationResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentHandlingStrategy = output.contentHandlingStrategy
            self.integrationResponseId = output.integrationResponseId
            self.integrationResponseKey = output.integrationResponseKey
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.templateSelectionExpression = output.templateSelectionExpression
        } else {
            self.contentHandlingStrategy = nil
            self.integrationResponseId = nil
            self.integrationResponseKey = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.templateSelectionExpression = nil
        }
    }
}

public struct UpdateIntegrationResponseOutput: Swift.Equatable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

struct UpdateIntegrationResponseOutputBody: Swift.Equatable {
    let contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    let integrationResponseId: Swift.String?
    let integrationResponseKey: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let templateSelectionExpression: Swift.String?
}

extension UpdateIntegrationResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandlingStrategy = "contentHandlingStrategy"
        case integrationResponseId = "integrationResponseId"
        case integrationResponseKey = "integrationResponseKey"
        case responseParameters = "responseParameters"
        case responseTemplates = "responseTemplates"
        case templateSelectionExpression = "templateSelectionExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentHandlingStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.ContentHandlingStrategy.self, forKey: .contentHandlingStrategy)
        contentHandlingStrategy = contentHandlingStrategyDecoded
        let integrationResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseId)
        integrationResponseId = integrationResponseIdDecoded
        let integrationResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationResponseKey)
        integrationResponseKey = integrationResponseKeyDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and5120) in responseParametersContainer {
                if let stringwithlengthbetween1and5120 = stringwithlengthbetween1and5120 {
                    responseParametersDecoded0?[key0] = stringwithlengthbetween1and5120
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and32k0) in responseTemplatesContainer {
                if let stringwithlengthbetween0and32k0 = stringwithlengthbetween0and32k0 {
                    responseTemplatesDecoded0?[key0] = stringwithlengthbetween0and32k0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let templateSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateSelectionExpression)
        templateSelectionExpression = templateSelectionExpressionDecoded
    }
}

enum UpdateIntegrationResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension UpdateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let modelId = modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

/// Updates a Model.
public struct UpdateModelInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the model.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case name = "name"
        case schema = "schema"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension UpdateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.modelId = output.modelId
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.modelId = nil
            self.name = nil
            self.schema = nil
        }
    }
}

public struct UpdateModelOutput: Swift.Equatable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputBody: Swift.Equatable {
    let contentType: Swift.String?
    let description: Swift.String?
    let modelId: Swift.String?
    let name: Swift.String?
    let schema: Swift.String?
}

extension UpdateModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "contentType"
        case description = "description"
        case modelId = "modelId"
        case name = "name"
        case schema = "schema"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum UpdateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRouteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = self.apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for stringwithlengthbetween1and640 in authorizationScopes {
                try authorizationScopesContainer.encode(stringwithlengthbetween1and640)
            }
        }
        if let authorizationType = self.authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let authorizerId = self.authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let operationName = self.operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, routeModels0) in requestModels {
                try requestModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, routeParameters0) in requestParameters {
                try requestParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeKey = self.routeKey {
            try encodeContainer.encode(routeKey, forKey: .routeKey)
        }
        if let routeResponseSelectionExpression = self.routeResponseSelectionExpression {
            try encodeContainer.encode(routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }
}

extension UpdateRouteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

/// Updates a Route.
public struct UpdateRouteInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteInputBody: Swift.Equatable {
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension UpdateRouteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension UpdateRouteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRouteOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiGatewayManaged = output.apiGatewayManaged
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.modelSelectionExpression = output.modelSelectionExpression
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.routeId = output.routeId
            self.routeKey = output.routeKey
            self.routeResponseSelectionExpression = output.routeResponseSelectionExpression
            self.target = output.target
        } else {
            self.apiGatewayManaged = nil
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.modelSelectionExpression = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.routeId = nil
            self.routeKey = nil
            self.routeResponseSelectionExpression = nil
            self.target = nil
        }
    }
}

public struct UpdateRouteOutput: Swift.Equatable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String:Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

struct UpdateRouteOutputBody: Swift.Equatable {
    let apiGatewayManaged: Swift.Bool?
    let apiKeyRequired: Swift.Bool?
    let authorizationScopes: [Swift.String]?
    let authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    let authorizerId: Swift.String?
    let modelSelectionExpression: Swift.String?
    let operationName: Swift.String?
    let requestModels: [Swift.String:Swift.String]?
    let requestParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeId: Swift.String?
    let routeKey: Swift.String?
    let routeResponseSelectionExpression: Swift.String?
    let target: Swift.String?
}

extension UpdateRouteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiGatewayManaged = "apiGatewayManaged"
        case apiKeyRequired = "apiKeyRequired"
        case authorizationScopes = "authorizationScopes"
        case authorizationType = "authorizationType"
        case authorizerId = "authorizerId"
        case modelSelectionExpression = "modelSelectionExpression"
        case operationName = "operationName"
        case requestModels = "requestModels"
        case requestParameters = "requestParameters"
        case routeId = "routeId"
        case routeKey = "routeKey"
        case routeResponseSelectionExpression = "routeResponseSelectionExpression"
        case target = "target"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in requestModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    requestModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in requestParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    requestParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let routeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeId)
        routeId = routeIdDecoded
        let routeKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeKey)
        routeKey = routeKeyDecoded
        let routeResponseSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseSelectionExpression)
        routeResponseSelectionExpression = routeResponseSelectionExpressionDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

enum UpdateRouteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRouteResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelSelectionExpression = self.modelSelectionExpression {
            try encodeContainer.encode(modelSelectionExpression, forKey: .modelSelectionExpression)
        }
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, routeModels0) in responseModels {
                try responseModelsContainer.encode(routeModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, routeParameters0) in responseParameters {
                try responseParametersContainer.encode(routeParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let routeResponseKey = self.routeResponseKey {
            try encodeContainer.encode(routeResponseKey, forKey: .routeResponseKey)
        }
    }
}

extension UpdateRouteResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let routeId = routeId else {
            return nil
        }
        guard let routeResponseId = routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

/// Updates a RouteResponse.
public struct UpdateRouteResponseInput: Swift.Equatable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?
    /// The route response key.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseInputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseKey: Swift.String?
}

extension UpdateRouteResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseKey = "routeResponseKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

extension UpdateRouteResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRouteResponseOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelSelectionExpression = output.modelSelectionExpression
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.routeResponseId = output.routeResponseId
            self.routeResponseKey = output.routeResponseKey
        } else {
            self.modelSelectionExpression = nil
            self.responseModels = nil
            self.responseParameters = nil
            self.routeResponseId = nil
            self.routeResponseKey = nil
        }
    }
}

public struct UpdateRouteResponseOutput: Swift.Equatable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String:Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

struct UpdateRouteResponseOutputBody: Swift.Equatable {
    let modelSelectionExpression: Swift.String?
    let responseModels: [Swift.String:Swift.String]?
    let responseParameters: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]?
    let routeResponseId: Swift.String?
    let routeResponseKey: Swift.String?
}

extension UpdateRouteResponseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelSelectionExpression = "modelSelectionExpression"
        case responseModels = "responseModels"
        case responseParameters = "responseParameters"
        case routeResponseId = "routeResponseId"
        case routeResponseKey = "routeResponseKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelSelectionExpression)
        modelSelectionExpression = modelSelectionExpressionDecoded
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and1280) in responseModelsContainer {
                if let stringwithlengthbetween1and1280 = stringwithlengthbetween1and1280 {
                    responseModelsDecoded0?[key0] = stringwithlengthbetween1and1280
                }
            }
        }
        responseModels = responseModelsDecoded0
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.ParameterConstraints]()
            for (key0, parameterconstraints0) in responseParametersContainer {
                if let parameterconstraints0 = parameterconstraints0 {
                    responseParametersDecoded0?[key0] = parameterconstraints0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let routeResponseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseId)
        routeResponseId = routeResponseIdDecoded
        let routeResponseKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeResponseKey)
        routeResponseKey = routeResponseKeyDecoded
    }
}

enum UpdateRouteResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if let autoDeploy = self.autoDeploy {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let defaultRouteSettings = self.defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routeSettings = routeSettings {
            var routeSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .routeSettings)
            for (dictKey0, routeSettingsMap0) in routeSettings {
                try routeSettingsContainer.encode(routeSettingsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, stageVariablesMap0) in stageVariables {
                try stageVariablesContainer.encode(stageVariablesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiId = apiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Updates a Stage.
public struct UpdateStageInput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageVariables: [Swift.String:Swift.String]?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case routeSettings = "routeSettings"
        case stageVariables = "stageVariables"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension UpdateStageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStageOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.apiGatewayManaged = output.apiGatewayManaged
            self.autoDeploy = output.autoDeploy
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.defaultRouteSettings = output.defaultRouteSettings
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.lastDeploymentStatusMessage = output.lastDeploymentStatusMessage
            self.lastUpdatedDate = output.lastUpdatedDate
            self.routeSettings = output.routeSettings
            self.stageName = output.stageName
            self.stageVariables = output.stageVariables
            self.tags = output.tags
        } else {
            self.accessLogSettings = nil
            self.apiGatewayManaged = nil
            self.autoDeploy = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.defaultRouteSettings = nil
            self.deploymentId = nil
            self.description = nil
            self.lastDeploymentStatusMessage = nil
            self.lastUpdatedDate = nil
            self.routeSettings = nil
            self.stageName = nil
            self.stageVariables = nil
            self.tags = nil
        }
    }
}

public struct UpdateStageOutput: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String:Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

struct UpdateStageOutputBody: Swift.Equatable {
    let accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    let apiGatewayManaged: Swift.Bool?
    let autoDeploy: Swift.Bool?
    let clientCertificateId: Swift.String?
    let createdDate: ClientRuntime.Date?
    let defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let lastDeploymentStatusMessage: Swift.String?
    let lastUpdatedDate: ClientRuntime.Date?
    let routeSettings: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]?
    let stageName: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateStageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "accessLogSettings"
        case apiGatewayManaged = "apiGatewayManaged"
        case autoDeploy = "autoDeploy"
        case clientCertificateId = "clientCertificateId"
        case createdDate = "createdDate"
        case defaultRouteSettings = "defaultRouteSettings"
        case deploymentId = "deploymentId"
        case description = "description"
        case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
        case lastUpdatedDate = "lastUpdatedDate"
        case routeSettings = "routeSettings"
        case stageName = "stageName"
        case stageVariables = "stageVariables"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged)
        apiGatewayManaged = apiGatewayManagedDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy)
        autoDeploy = autoDeployDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayV2ClientTypes.RouteSettings?].self, forKey: .routeSettings)
        var routeSettingsDecoded0: [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]? = nil
        if let routeSettingsContainer = routeSettingsContainer {
            routeSettingsDecoded0 = [Swift.String:ApiGatewayV2ClientTypes.RouteSettings]()
            for (key0, routesettings0) in routeSettingsContainer {
                if let routesettings0 = routesettings0 {
                    routeSettingsDecoded0?[key0] = routesettings0
                }
            }
        }
        routeSettings = routeSettingsDecoded0
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween0and20480) in stageVariablesContainer {
                if let stringwithlengthbetween0and20480 = stringwithlengthbetween0and20480 {
                    stageVariablesDecoded0?[key0] = stringwithlengthbetween0and20480
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateStageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Updates a VPC link.
public struct UpdateVpcLinkInput: Swift.Equatable {
    /// The name of the VPC link.
    public var name: Swift.String?
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        name: Swift.String? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.name = name
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateVpcLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVpcLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.name = output.name
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.vpcLinkId = output.vpcLinkId
            self.vpcLinkStatus = output.vpcLinkStatus
            self.vpcLinkStatusMessage = output.vpcLinkStatusMessage
            self.vpcLinkVersion = output.vpcLinkVersion
        } else {
            self.createdDate = nil
            self.name = nil
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.tags = nil
            self.vpcLinkId = nil
            self.vpcLinkStatus = nil
            self.vpcLinkStatusMessage = nil
            self.vpcLinkVersion = nil
        }
    }
}

public struct UpdateVpcLinkOutput: Swift.Equatable {
    /// The timestamp when the VPC link was created.
    public var createdDate: ClientRuntime.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

struct UpdateVpcLinkOutputBody: Swift.Equatable {
    let createdDate: ClientRuntime.Date?
    let name: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let vpcLinkId: Swift.String?
    let vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    let vpcLinkStatusMessage: Swift.String?
    let vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?
}

extension UpdateVpcLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

enum UpdateVpcLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApiGatewayV2ClientTypes.VpcLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "createdDate"
        case name = "name"
        case securityGroupIds = "securityGroupIds"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case vpcLinkId = "vpcLinkId"
        case vpcLinkStatus = "vpcLinkStatus"
        case vpcLinkStatusMessage = "vpcLinkStatusMessage"
        case vpcLinkVersion = "vpcLinkVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .dateTime, forKey: .createdDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __string0 in subnetIds {
                try subnetIdsContainer.encode(__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcLinkId = self.vpcLinkId {
            try encodeContainer.encode(vpcLinkId, forKey: .vpcLinkId)
        }
        if let vpcLinkStatus = self.vpcLinkStatus {
            try encodeContainer.encode(vpcLinkStatus.rawValue, forKey: .vpcLinkStatus)
        }
        if let vpcLinkStatusMessage = self.vpcLinkStatusMessage {
            try encodeContainer.encode(vpcLinkStatusMessage, forKey: .vpcLinkStatusMessage)
        }
        if let vpcLinkVersion = self.vpcLinkVersion {
            try encodeContainer.encode(vpcLinkVersion.rawValue, forKey: .vpcLinkVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdDate)
        createdDate = createdDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringwithlengthbetween1and16000) in tagsContainer {
                if let stringwithlengthbetween1and16000 = stringwithlengthbetween1and16000 {
                    tagsDecoded0?[key0] = stringwithlengthbetween1and16000
                }
            }
        }
        tags = tagsDecoded0
        let vpcLinkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkId)
        vpcLinkId = vpcLinkIdDecoded
        let vpcLinkStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkStatus.self, forKey: .vpcLinkStatus)
        vpcLinkStatus = vpcLinkStatusDecoded
        let vpcLinkStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcLinkStatusMessage)
        vpcLinkStatusMessage = vpcLinkStatusMessageDecoded
        let vpcLinkVersionDecoded = try containerValues.decodeIfPresent(ApiGatewayV2ClientTypes.VpcLinkVersion.self, forKey: .vpcLinkVersion)
        vpcLinkVersion = vpcLinkVersionDecoded
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a VPC link.
    public struct VpcLink: Swift.Equatable {
        /// The timestamp when the VPC link was created.
        public var createdDate: ClientRuntime.Date?
        /// The name of the VPC link.
        /// This member is required.
        public var name: Swift.String?
        /// A list of security group IDs for the VPC link.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs to include in the VPC link.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// Tags for the VPC link.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the VPC link.
        /// This member is required.
        public var vpcLinkId: Swift.String?
        /// The status of the VPC link.
        public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public var vpcLinkStatusMessage: Swift.String?
        /// The version of the VPC link.
        public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vpcLinkId: Swift.String? = nil,
            vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
            vpcLinkStatusMessage: Swift.String? = nil,
            vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
        )
        {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// The status of the VPC link.
    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// The version of the VPC link.
    public enum VpcLinkVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkVersion] {
            return [
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkVersion(rawValue: rawValue) ?? VpcLinkVersion.sdkUnknown(rawValue)
        }
    }
}
