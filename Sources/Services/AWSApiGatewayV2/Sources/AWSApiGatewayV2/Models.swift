//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAccessLogSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApiMappingOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApiOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAuthorizerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCorsConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDeploymentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDomainNameOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIntegrationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIntegrationResponseOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteModelOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePortalOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePortalProductOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePortalProductSharingPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProductPageOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProductRestEndpointPageOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRouteOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRouteRequestParameterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRouteResponseOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRouteSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRoutingRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStageOutput: Swift.Sendable {

    public init() { }
}

public struct DisablePortalOutput: Swift.Sendable {

    public init() { }
}

public struct ResetAuthorizersCacheOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public struct Cors: Swift.Sendable {
        /// Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
        public var allowCredentials: Swift.Bool?
        /// Represents a collection of allowed headers. Supported only for HTTP APIs.
        public var allowHeaders: [Swift.String]?
        /// Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
        public var allowMethods: [Swift.String]?
        /// Represents a collection of allowed origins. Supported only for HTTP APIs.
        public var allowOrigins: [Swift.String]?
        /// Represents a collection of exposed headers. Supported only for HTTP APIs.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        ) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The IP address types that can invoke your API or domain name.
    public enum IpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualstack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualstack,
                .ipv4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "dualstack"
            case .ipv4: return "ipv4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a protocol type.
    public enum ProtocolType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .http,
                .websocket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an API.
    public struct Api: Swift.Sendable {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public var apiGatewayManaged: Swift.Bool?
        /// The API ID.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
        public var apiKeySelectionExpression: Swift.String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
        /// The timestamp when the API was created.
        public var createdDate: Foundation.Date?
        /// The description of the API.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public var disableSchemaValidation: Swift.Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public var importInfo: [Swift.String]?
        /// The IP address types that can invoke the API.
        public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
        /// The name of the API.
        /// This member is required.
        public var name: Swift.String?
        /// The API protocol.
        /// This member is required.
        public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        /// This member is required.
        public var routeSelectionExpression: Swift.String?
        /// A collection of tags associated with the API.
        public var tags: [Swift.String: Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init(
            apiEndpoint: Swift.String? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool? = nil,
            disableSchemaValidation: Swift.Bool? = nil,
            importInfo: [Swift.String]? = nil,
            ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
            name: Swift.String? = nil,
            protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
            routeSelectionExpression: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        ) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an API mapping.
    public struct ApiMapping: Swift.Sendable {
        /// The API identifier.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API mapping identifier.
        public var apiMappingId: Swift.String?
        /// The API mapping key.
        public var apiMappingKey: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            apiId: Swift.String? = nil,
            apiMappingId: Swift.String? = nil,
            apiMappingKey: Swift.String? = nil,
            stage: Swift.String? = nil
        ) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public enum AuthorizerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jwt
        case request
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .jwt,
                .request
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jwt: return "JWT"
            case .request: return "REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public struct JWTConfiguration: Swift.Sendable {
        /// A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See [RFC 7519](https://tools.ietf.org/html/rfc7519#section-4.1.3). Supported only for HTTP APIs.
        public var audience: [Swift.String]?
        /// The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.{region}.amazonaws.com/{userPoolId} . Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var issuer: Swift.String?

        public init(
            audience: [Swift.String]? = nil,
            issuer: Swift.String? = nil
        ) {
            self.audience = audience
            self.issuer = issuer
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an authorizer.
    public struct Authorizer: Swift.Sendable {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public var authorizerCredentialsArn: Swift.String?
        /// The authorizer identifier.
        public var authorizerId: Swift.String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
        public var authorizerPayloadFormatVersion: Swift.String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public var authorizerUri: Swift.String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
        public var enableSimpleResponses: Swift.Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public var identitySource: [Swift.String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
        /// The name of the authorizer.
        /// This member is required.
        public var name: Swift.String?

        public init(
            authorizerCredentialsArn: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            authorizerPayloadFormatVersion: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
            authorizerUri: Swift.String? = nil,
            enableSimpleResponses: Swift.Bool? = nil,
            identitySource: [Swift.String]? = nil,
            identityValidationExpression: Swift.String? = nil,
            jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
            name: Swift.String? = nil
        ) {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a deployment status.
    public enum DeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .deployed,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// An immutable representation of an API that can be called by users. A Deployment must be associated with a Stage for it to be callable over the internet.
    public struct Deployment: Swift.Sendable {
        /// Specifies whether a deployment was automatically released.
        public var autoDeployed: Swift.Bool?
        /// The date and time when the Deployment resource was created.
        public var createdDate: Foundation.Date?
        /// The identifier for the deployment.
        public var deploymentId: Swift.String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public var deploymentStatusMessage: Swift.String?
        /// The description for the deployment.
        public var description: Swift.String?

        public init(
            autoDeployed: Swift.Bool? = nil,
            createdDate: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil
        ) {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public enum DomainNameStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an endpoint type.
    public enum EndpointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edge
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
    public enum SecurityPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The domain name configuration.
    public struct DomainNameConfiguration: Swift.Sendable {
        /// A domain name for the API.
        public var apiGatewayDomainName: Swift.String?
        /// An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: Foundation.Date?
        /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the domain name migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint type.
        public var endpointType: ApiGatewayV2ClientTypes.EndpointType?
        /// The Amazon Route 53 Hosted Zone ID of the endpoint.
        public var hostedZoneId: Swift.String?
        /// The IP address types that can invoke the domain name. Use ipv4 to allow only IPv4 addresses to invoke your domain name, or use dualstack to allow both IPv4 and IPv6 addresses to invoke your domain name.
        public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy?

        public init(
            apiGatewayDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: Foundation.Date? = nil,
            domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointType: ApiGatewayV2ClientTypes.EndpointType? = nil,
            hostedZoneId: Swift.String? = nil,
            ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy? = nil
        ) {
            self.apiGatewayDomainName = apiGatewayDomainName
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointType = endpointType
            self.hostedZoneId = hostedZoneId
            self.ipAddressType = ipAddressType
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.securityPolicy = securityPolicy
        }
    }
}

extension ApiGatewayV2ClientTypes {

    public struct MutualTlsAuthentication: Swift.Sendable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        ) {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }
}

extension ApiGatewayV2ClientTypes {

    public enum RoutingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiMappingOnly
        case routingRuleOnly
        case routingRuleThenApiMapping
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingMode] {
            return [
                .apiMappingOnly,
                .routingRuleOnly,
                .routingRuleThenApiMapping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiMappingOnly: return "API_MAPPING_ONLY"
            case .routingRuleOnly: return "ROUTING_RULE_ONLY"
            case .routingRuleThenApiMapping: return "ROUTING_RULE_THEN_API_MAPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a domain name.
    public struct DomainName: Swift.Sendable {
        /// The API mapping selection expression.
        public var apiMappingSelectionExpression: Swift.String?
        /// The name of the DomainName resource.
        /// This member is required.
        public var domainName: Swift.String?
        /// Represents an Amazon Resource Name (ARN).
        public var domainNameArn: Swift.String?
        /// The domain name configurations.
        public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
        /// The routing mode.
        public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?
        /// The collection of tags associated with a domain name.
        public var tags: [Swift.String: Swift.String]?

        public init(
            apiMappingSelectionExpression: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameArn: Swift.String? = nil,
            domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
            mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
            routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameArn = domainNameArn
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.routingMode = routingMode
            self.tags = tags
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a connection type.
    public enum ConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.
    public enum ContentHandlingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an API method integration type.
    public enum IntegrationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.
    public enum PassthroughBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case never
        case whenNoMatch
        case whenNoTemplates
        case sdkUnknown(Swift.String)

        public static var allCases: [PassthroughBehavior] {
            return [
                .never,
                .whenNoMatch,
                .whenNoTemplates
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .never: return "NEVER"
            case .whenNoMatch: return "WHEN_NO_MATCH"
            case .whenNoTemplates: return "WHEN_NO_TEMPLATES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfig: Swift.Sendable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        ) {
            self.serverNameToVerify = serverNameToVerify
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an integration.
    public struct Integration: Swift.Sendable {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public var apiGatewayManaged: Swift.Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public var credentialsArn: Swift.String?
        /// Represents the description of an integration.
        public var description: Swift.String?
        /// Represents the identifier of an integration.
        public var integrationId: Swift.String?
        /// Specifies the integration's HTTP method type.
        public var integrationMethod: Swift.String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
        public var integrationResponseSelectionExpression: Swift.String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
        public var integrationSubtype: Swift.String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
        public var integrationUri: Swift.String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
        public var payloadFormatVersion: Swift.String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var requestParameters: [Swift.String: Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public var requestTemplates: [Swift.String: Swift.String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public var templateSelectionExpression: Swift.String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public var timeoutInMillis: Swift.Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            connectionId: Swift.String? = nil,
            connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            credentialsArn: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationId: Swift.String? = nil,
            integrationMethod: Swift.String? = nil,
            integrationResponseSelectionExpression: Swift.String? = nil,
            integrationSubtype: Swift.String? = nil,
            integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
            integrationUri: Swift.String? = nil,
            passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
            payloadFormatVersion: Swift.String? = nil,
            requestParameters: [Swift.String: Swift.String]? = nil,
            requestTemplates: [Swift.String: Swift.String]? = nil,
            responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
            templateSelectionExpression: Swift.String? = nil,
            timeoutInMillis: Swift.Int? = nil,
            tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
        ) {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an integration response.
    public struct IntegrationResponse: Swift.Sendable {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// The integration response ID.
        public var integrationResponseId: Swift.String?
        /// The integration response key.
        /// This member is required.
        public var integrationResponseKey: Swift.String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String: Swift.String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String: Swift.String]?
        /// The template selection expressions for the integration response.
        public var templateSelectionExpression: Swift.String?

        public init(
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            integrationResponseId: Swift.String? = nil,
            integrationResponseKey: Swift.String? = nil,
            responseParameters: [Swift.String: Swift.String]? = nil,
            responseTemplates: [Swift.String: Swift.String]? = nil,
            templateSelectionExpression: Swift.String? = nil
        ) {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a data model for an API. Supported only for WebSocket APIs. See [Create Models and Mapping Templates for Request and Response Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html).
    public struct Model: Swift.Sendable {
        /// The content-type for the model, for example, "application/json".
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The model identifier.
        public var modelId: Swift.String?
        /// The name of the model. Must be alphanumeric.
        /// This member is required.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public var schema: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        ) {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a portal product.
    public struct PortalProductSummary: Swift.Sendable {
        /// The description.
        /// This member is required.
        public var description: Swift.String?
        /// The display name of a portal product.
        /// This member is required.
        public var displayName: Swift.String?
        /// The timestamp when the portal product was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// The ARN of a portal product.
        /// This member is required.
        public var portalProductArn: Swift.String?
        /// The portal product identifier.
        /// This member is required.
        public var portalProductId: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            portalProductArn: Swift.String? = nil,
            portalProductId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.description = description
            self.displayName = displayName
            self.lastModified = lastModified
            self.portalProductArn = portalProductArn
            self.portalProductId = portalProductId
            self.tags = tags
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The configuration for using Amazon Cognito user pools to control access to your portal.
    public struct CognitoConfig: Swift.Sendable {
        /// The app client ID.
        /// This member is required.
        public var appClientId: Swift.String?
        /// The user pool ARN.
        /// This member is required.
        public var userPoolArn: Swift.String?
        /// The user pool domain.
        /// This member is required.
        public var userPoolDomain: Swift.String?

        public init(
            appClientId: Swift.String? = nil,
            userPoolArn: Swift.String? = nil,
            userPoolDomain: Swift.String? = nil
        ) {
            self.appClientId = appClientId
            self.userPoolArn = userPoolArn
            self.userPoolDomain = userPoolDomain
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The none option.
    public struct None: Swift.Sendable {

        public init() { }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an authorization configuration for a portal.
    public struct Authorization: Swift.Sendable {
        /// The Amazon Cognito configuration.
        public var cognitoConfig: ApiGatewayV2ClientTypes.CognitoConfig?
        /// Provide no authorization for your portal. This makes your portal publicly accesible on the web.
        public var `none`: ApiGatewayV2ClientTypes.None?

        public init(
            cognitoConfig: ApiGatewayV2ClientTypes.CognitoConfig? = nil,
            `none`: ApiGatewayV2ClientTypes.None? = nil
        ) {
            self.cognitoConfig = cognitoConfig
            self.`none` = `none`
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an endpoint configuration.
    public struct EndpointConfigurationResponse: Swift.Sendable {
        /// The ARN of the ACM certificate.
        public var certificateArn: Swift.String?
        /// The domain name.
        public var domainName: Swift.String?
        /// The portal default domain name. This domain name is generated and managed by API Gateway.
        /// This member is required.
        public var portalDefaultDomainName: Swift.String?
        /// The portal domain hosted zone identifier.
        /// This member is required.
        public var portalDomainHostedZoneId: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            domainName: Swift.String? = nil,
            portalDefaultDomainName: Swift.String? = nil,
            portalDomainHostedZoneId: Swift.String? = nil
        ) {
            self.certificateArn = certificateArn
            self.domainName = domainName
            self.portalDefaultDomainName = portalDefaultDomainName
            self.portalDomainHostedZoneId = portalDomainHostedZoneId
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents custom colors for a published portal.
    public struct CustomColors: Swift.Sendable {
        /// Represents the accent color.
        /// This member is required.
        public var accentColor: Swift.String?
        /// Represents the background color.
        /// This member is required.
        public var backgroundColor: Swift.String?
        /// The errorValidationColor.
        /// This member is required.
        public var errorValidationColor: Swift.String?
        /// Represents the header color.
        /// This member is required.
        public var headerColor: Swift.String?
        /// Represents the navigation color.
        /// This member is required.
        public var navigationColor: Swift.String?
        /// Represents the text color.
        /// This member is required.
        public var textColor: Swift.String?

        public init(
            accentColor: Swift.String? = nil,
            backgroundColor: Swift.String? = nil,
            errorValidationColor: Swift.String? = nil,
            headerColor: Swift.String? = nil,
            navigationColor: Swift.String? = nil,
            textColor: Swift.String? = nil
        ) {
            self.accentColor = accentColor
            self.backgroundColor = backgroundColor
            self.errorValidationColor = errorValidationColor
            self.headerColor = headerColor
            self.navigationColor = navigationColor
            self.textColor = textColor
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Defines the theme for a portal.
    public struct PortalTheme: Swift.Sendable {
        /// Defines custom color values.
        /// This member is required.
        public var customColors: ApiGatewayV2ClientTypes.CustomColors?
        /// The timestamp when the logo was last uploaded.
        public var logoLastUploaded: Foundation.Date?

        public init(
            customColors: ApiGatewayV2ClientTypes.CustomColors? = nil,
            logoLastUploaded: Foundation.Date? = nil
        ) {
            self.customColors = customColors
            self.logoLastUploaded = logoLastUploaded
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Contains the content that is visible to portal consumers including the themes, display names, and description.
    public struct PortalContent: Swift.Sendable {
        /// A description of the portal.
        public var description: Swift.String?
        /// The display name for the portal.
        /// This member is required.
        public var displayName: Swift.String?
        /// The theme for the portal.
        /// This member is required.
        public var theme: ApiGatewayV2ClientTypes.PortalTheme?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            theme: ApiGatewayV2ClientTypes.PortalTheme? = nil
        ) {
            self.description = description
            self.displayName = displayName
            self.theme = theme
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents the preview status.
    public enum PreviewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case previewFailed
        case previewInProgress
        case previewReady
        case sdkUnknown(Swift.String)

        public static var allCases: [PreviewStatus] {
            return [
                .previewFailed,
                .previewInProgress,
                .previewReady
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .previewFailed: return "PREVIEW_FAILED"
            case .previewInProgress: return "PREVIEW_IN_PROGRESS"
            case .previewReady: return "PREVIEW_READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a StatusException.
    public struct StatusException: Swift.Sendable {
        /// The exception.
        public var exception: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            exception: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.exception = exception
            self.message = message
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Contains the preview status and preview URL.
    public struct Preview: Swift.Sendable {
        /// The status of the preview.
        /// This member is required.
        public var previewStatus: ApiGatewayV2ClientTypes.PreviewStatus?
        /// The URL of the preview.
        public var previewUrl: Swift.String?
        /// The status exception information.
        public var statusException: ApiGatewayV2ClientTypes.StatusException?

        public init(
            previewStatus: ApiGatewayV2ClientTypes.PreviewStatus? = nil,
            previewUrl: Swift.String? = nil,
            statusException: ApiGatewayV2ClientTypes.StatusException? = nil
        ) {
            self.previewStatus = previewStatus
            self.previewUrl = previewUrl
            self.statusException = statusException
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a publish status.
    public enum PublishStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case published
        case publishFailed
        case publishInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PublishStatus] {
            return [
                .disabled,
                .published,
                .publishFailed,
                .publishInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .published: return "PUBLISHED"
            case .publishFailed: return "PUBLISH_FAILED"
            case .publishInProgress: return "PUBLISH_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a portal summary.
    public struct PortalSummary: Swift.Sendable {
        /// The authorization of the portal.
        /// This member is required.
        public var authorization: ApiGatewayV2ClientTypes.Authorization?
        /// The endpoint configuration of the portal.
        /// This member is required.
        public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse?
        /// The ARNs of the portal products included in the portal.
        /// This member is required.
        public var includedPortalProductArns: [Swift.String]?
        /// The timestamp when the portal was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// The timestamp when the portal was last published.
        public var lastPublished: Foundation.Date?
        /// The description of the portal the last time it was published.
        public var lastPublishedDescription: Swift.String?
        /// The ARN of the portal.
        /// This member is required.
        public var portalArn: Swift.String?
        /// Contains the content that is visible to portal consumers including the themes, display names, and description.
        /// This member is required.
        public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
        /// The portal identifier.
        /// This member is required.
        public var portalId: Swift.String?
        /// Represents the preview endpoint and the any possible error messages during preview generation.
        public var preview: ApiGatewayV2ClientTypes.Preview?
        /// The publish status.
        public var publishStatus: ApiGatewayV2ClientTypes.PublishStatus?
        /// The CloudWatch RUM app monitor name.
        public var rumAppMonitorName: Swift.String?
        /// The status exception information.
        public var statusException: ApiGatewayV2ClientTypes.StatusException?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
            endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse? = nil,
            includedPortalProductArns: [Swift.String]? = nil,
            lastModified: Foundation.Date? = nil,
            lastPublished: Foundation.Date? = nil,
            lastPublishedDescription: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
            portalId: Swift.String? = nil,
            preview: ApiGatewayV2ClientTypes.Preview? = nil,
            publishStatus: ApiGatewayV2ClientTypes.PublishStatus? = nil,
            rumAppMonitorName: Swift.String? = nil,
            statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.authorization = authorization
            self.endpointConfiguration = endpointConfiguration
            self.includedPortalProductArns = includedPortalProductArns
            self.lastModified = lastModified
            self.lastPublished = lastPublished
            self.lastPublishedDescription = lastPublishedDescription
            self.portalArn = portalArn
            self.portalContent = portalContent
            self.portalId = portalId
            self.preview = preview
            self.publishStatus = publishStatus
            self.rumAppMonitorName = rumAppMonitorName
            self.statusException = statusException
            self.tags = tags
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a product page summary without listing any page content.
    public struct ProductPageSummaryNoBody: Swift.Sendable {
        /// The timestamp when the product page was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// The page title.
        /// This member is required.
        public var pageTitle: Swift.String?
        /// The ARN of the product page.
        /// This member is required.
        public var productPageArn: Swift.String?
        /// The product page identifier.
        /// This member is required.
        public var productPageId: Swift.String?

        public init(
            lastModified: Foundation.Date? = nil,
            pageTitle: Swift.String? = nil,
            productPageArn: Swift.String? = nil,
            productPageId: Swift.String? = nil
        ) {
            self.lastModified = lastModified
            self.pageTitle = pageTitle
            self.productPageArn = productPageArn
            self.productPageId = productPageId
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The identifier parts of a product REST endpoint.
    public struct IdentifierParts: Swift.Sendable {
        /// The method of the product REST endpoint.
        /// This member is required.
        public var method: Swift.String?
        /// The path of the product REST endpoint.
        /// This member is required.
        public var path: Swift.String?
        /// The REST API ID of the product REST endpoint.
        /// This member is required.
        public var restApiId: Swift.String?
        /// The stage of the product REST endpoint.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            method: Swift.String? = nil,
            path: Swift.String? = nil,
            restApiId: Swift.String? = nil,
            stage: Swift.String? = nil
        ) {
            self.method = method
            self.path = path
            self.restApiId = restApiId
            self.stage = stage
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The REST API endpoint identifier.
    public struct RestEndpointIdentifier: Swift.Sendable {
        /// The identifier parts of the REST endpoint identifier.
        public var identifierParts: ApiGatewayV2ClientTypes.IdentifierParts?

        public init(
            identifierParts: ApiGatewayV2ClientTypes.IdentifierParts? = nil
        ) {
            self.identifierParts = identifierParts
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The status.
    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .available,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents the try it state for a product REST endpoint page.
    public enum TryItState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TryItState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// A summary of a product REST endpoint page, without providing the page content.
    public struct ProductRestEndpointPageSummaryNoBody: Swift.Sendable {
        /// The endpoint of the product REST endpoint page.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The timestamp when the product REST endpoint page was last modified.
        /// This member is required.
        public var lastModified: Foundation.Date?
        /// The operation name of the product REST endpoint.
        public var operationName: Swift.String?
        /// The ARN of the product REST endpoint page.
        /// This member is required.
        public var productRestEndpointPageArn: Swift.String?
        /// The product REST endpoint page identifier.
        /// This member is required.
        public var productRestEndpointPageId: Swift.String?
        /// The REST endpoint identifier.
        /// This member is required.
        public var restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier?
        /// The status.
        /// This member is required.
        public var status: ApiGatewayV2ClientTypes.Status?
        /// The status exception information.
        public var statusException: ApiGatewayV2ClientTypes.StatusException?
        /// The try it state of a product REST endpoint page.
        /// This member is required.
        public var tryItState: ApiGatewayV2ClientTypes.TryItState?

        public init(
            endpoint: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            operationName: Swift.String? = nil,
            productRestEndpointPageArn: Swift.String? = nil,
            productRestEndpointPageId: Swift.String? = nil,
            restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier? = nil,
            status: ApiGatewayV2ClientTypes.Status? = nil,
            statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
            tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
        ) {
            self.endpoint = endpoint
            self.lastModified = lastModified
            self.operationName = operationName
            self.productRestEndpointPageArn = productRestEndpointPageArn
            self.productRestEndpointPageId = productRestEndpointPageId
            self.restEndpointIdentifier = restEndpointIdentifier
            self.status = status
            self.statusException = statusException
            self.tryItState = tryItState
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The authorization type. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public enum AuthorizationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case custom
        case jwt
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .custom,
                .jwt,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .custom: return "CUSTOM"
            case .jwt: return "JWT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Validation constraints imposed on parameters of a request (path, query string, headers).
    public struct ParameterConstraints: Swift.Sendable {
        /// Whether or not the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            `required`: Swift.Bool? = nil
        ) {
            self.`required` = `required`
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a route.
    public struct Route: Swift.Sendable {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public var authorizerId: Swift.String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// The operation name for the route.
        public var operationName: Swift.String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public var requestModels: [Swift.String: Swift.String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// The route ID.
        public var routeId: Swift.String?
        /// The route key for the route.
        /// This member is required.
        public var routeKey: Swift.String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public var routeResponseSelectionExpression: Swift.String?
        /// The target for the route.
        public var target: Swift.String?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
            authorizerId: Swift.String? = nil,
            modelSelectionExpression: Swift.String? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String: Swift.String]? = nil,
            requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeId: Swift.String? = nil,
            routeKey: Swift.String? = nil,
            routeResponseSelectionExpression: Swift.String? = nil,
            target: Swift.String? = nil
        ) {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a route response.
    public struct RouteResponse: Swift.Sendable {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// Represents the response models of a route response.
        public var responseModels: [Swift.String: Swift.String]?
        /// Represents the response parameters of a route response.
        public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// Represents the identifier of a route response.
        public var routeResponseId: Swift.String?
        /// Represents the route response key of a route response.
        /// This member is required.
        public var routeResponseKey: Swift.String?

        public init(
            modelSelectionExpression: Swift.String? = nil,
            responseModels: [Swift.String: Swift.String]? = nil,
            responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeResponseId: Swift.String? = nil,
            routeResponseKey: Swift.String? = nil
        ) {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an InvokeApi action.
    public struct RoutingRuleActionInvokeApi: Swift.Sendable {
        /// The identifier.
        /// This member is required.
        public var apiId: Swift.String?
        /// A string with a length between [1-128].
        /// This member is required.
        public var stage: Swift.String?
        /// The strip base path setting.
        public var stripBasePath: Swift.Bool?

        public init(
            apiId: Swift.String? = nil,
            stage: Swift.String? = nil,
            stripBasePath: Swift.Bool? = nil
        ) {
            self.apiId = apiId
            self.stage = stage
            self.stripBasePath = stripBasePath
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The routing rule action.
    public struct RoutingRuleAction: Swift.Sendable {
        /// Represents an InvokeApi action.
        /// This member is required.
        public var invokeApi: ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi?

        public init(
            invokeApi: ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi? = nil
        ) {
            self.invokeApi = invokeApi
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a MatchBasePaths condition.
    public struct RoutingRuleMatchBasePaths: Swift.Sendable {
        /// The string of the case sensitive base path to be matched.
        /// This member is required.
        public var anyOf: [Swift.String]?

        public init(
            anyOf: [Swift.String]? = nil
        ) {
            self.anyOf = anyOf
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a MatchHeaderValue.
    public struct RoutingRuleMatchHeaderValue: Swift.Sendable {
        /// After evaluating a selection expression, the result is compared against one or more selection keys to find a matching key. See [Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions) for a list of expressions and each expression's associated selection key type.
        /// This member is required.
        public var header: Swift.String?
        /// An expression used to extract information at runtime. See [Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions) for more information.
        /// This member is required.
        public var valueGlob: Swift.String?

        public init(
            header: Swift.String? = nil,
            valueGlob: Swift.String? = nil
        ) {
            self.header = header
            self.valueGlob = valueGlob
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a MatchHeaders condition.
    public struct RoutingRuleMatchHeaders: Swift.Sendable {
        /// The header name and header value glob to be matched. The matchHeaders condition is matched if any of the header name and header value globs are matched.
        /// This member is required.
        public var anyOf: [ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue]?

        public init(
            anyOf: [ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue]? = nil
        ) {
            self.anyOf = anyOf
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a routing rule condition.
    public struct RoutingRuleCondition: Swift.Sendable {
        /// The base path to be matched.
        public var matchBasePaths: ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths?
        /// The headers to be matched.
        public var matchHeaders: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders?

        public init(
            matchBasePaths: ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths? = nil,
            matchHeaders: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders? = nil
        ) {
            self.matchBasePaths = matchBasePaths
            self.matchHeaders = matchHeaders
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a routing rule.
    public struct RoutingRule: Swift.Sendable {
        /// The routing rule action.
        public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
        /// The routing rule condition.
        public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
        /// The routing rule priority.
        public var priority: Swift.Int?
        /// The routing rule ARN.
        public var routingRuleArn: Swift.String?
        /// The routing rule ID.
        public var routingRuleId: Swift.String?

        public init(
            actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
            conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
            priority: Swift.Int? = nil,
            routingRuleArn: Swift.String? = nil,
            routingRuleId: Swift.String? = nil
        ) {
            self.actions = actions
            self.conditions = conditions
            self.priority = priority
            self.routingRuleArn = routingRuleArn
            self.routingRuleId = routingRuleId
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Contains the section name and list of product REST endpoints for a product.
    public struct Section: Swift.Sendable {
        /// The ARNs of the product REST endpoint pages in a portal product.
        /// This member is required.
        public var productRestEndpointPageArns: [Swift.String]?
        /// The section name.
        /// This member is required.
        public var sectionName: Swift.String?

        public init(
            productRestEndpointPageArns: [Swift.String]? = nil,
            sectionName: Swift.String? = nil
        ) {
            self.productRestEndpointPageArns = productRestEndpointPageArns
            self.sectionName = sectionName
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Settings for logging access in a stage.
    public struct AccessLogSettings: Swift.Sendable {
        /// The ARN of the CloudWatch Logs log group to receive access logs.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        ) {
            self.destinationArn = destinationArn
            self.format = format
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The logging level.
    public enum LoggingLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a collection of route settings.
    public struct RouteSettings: Swift.Sendable {
        /// Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool?
        /// Specifies whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool?
        /// Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel?
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int?
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double?

        public init(
            dataTraceEnabled: Swift.Bool? = nil,
            detailedMetricsEnabled: Swift.Bool? = nil,
            loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil
        ) {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an API stage.
    public struct Stage: Swift.Sendable {
        /// Settings for logging access in this stage.
        public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public var autoDeploy: Swift.Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: Foundation.Date?
        /// Default route settings for the stage.
        public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// The timestamp when the stage was last updated.
        public var lastUpdatedDate: Foundation.Date?
        /// Route settings for the stage, by routeKey.
        public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
        /// The name of the stage.
        /// This member is required.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var stageVariables: [Swift.String: Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            autoDeploy: Swift.Bool? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        ) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The status of the VPC link.
    public enum VpcLinkStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The version of the VPC link.
    public enum VpcLinkVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkVersion] {
            return [
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a VPC link.
    public struct VpcLink: Swift.Sendable {
        /// The timestamp when the VPC link was created.
        public var createdDate: Foundation.Date?
        /// The name of the VPC link.
        /// This member is required.
        public var name: Swift.String?
        /// A list of security group IDs for the VPC link.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs to include in the VPC link.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// Tags for the VPC link.
        public var tags: [Swift.String: Swift.String]?
        /// The ID of the VPC link.
        /// This member is required.
        public var vpcLinkId: Swift.String?
        /// The status of the VPC link.
        public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public var vpcLinkStatusMessage: Swift.String?
        /// The version of the VPC link.
        public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

        public init(
            createdDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vpcLinkId: Swift.String? = nil,
            vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
            vpcLinkStatusMessage: Swift.String? = nil,
            vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
        ) {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }
    }
}

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents a domain name and certificate for a portal.
    public struct ACMManaged: Swift.Sendable {
        /// The certificate ARN.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// The domain name.
        /// This member is required.
        public var domainName: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            domainName: Swift.String? = nil
        ) {
            self.certificateArn = certificateArn
            self.domainName = domainName
        }
    }
}

/// The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The resource specified in the request was not found. See the message field for more information.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
        /// The resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// A limit has been exceeded. See the accompanying error message for details.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The limit type.
        public internal(set) var limitType: Swift.String? = nil
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.limitType = limitType
        self.properties.message = message
    }
}

/// Creates a new Api resource to represent an API.
public struct CreateApiInput: Swift.Sendable {
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    /// This member is required.
    public var name: Swift.String?
    /// The API protocol.
    /// This member is required.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    ) {
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.target = target
        self.version = version
    }
}

public struct CreateApiOutput: Swift.Sendable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    ) {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Creates a new ApiMapping resource to represent an API mapping.
public struct CreateApiMappingInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    /// This member is required.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

public struct CreateApiMappingOutput: Swift.Sendable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

/// Creates a new Authorizer resource to represent an authorizer.
public struct CreateAuthorizerInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    /// This member is required.
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    /// This member is required.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct CreateAuthorizerOutput: Swift.Sendable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

/// Creates a new Deployment resource to represent a deployment.
public struct CreateDeploymentInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.description = description
        self.stageName = stageName
    }
}

public struct CreateDeploymentOutput: Swift.Sendable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    ) {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

extension ApiGatewayV2ClientTypes {

    public struct MutualTlsAuthenticationInput: Swift.Sendable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        ) {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }
}

/// Creates a new DomainName resource to represent a domain name.
public struct CreateDomainNameInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    /// The routing mode.
    public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil,
        routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.routingMode = routingMode
        self.tags = tags
    }
}

public struct CreateDomainNameOutput: Swift.Sendable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// Represents an Amazon Resource Name (ARN).
    public var domainNameArn: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The routing mode.
    public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameArn: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameArn = domainNameArn
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.routingMode = routingMode
        self.tags = tags
    }
}

extension ApiGatewayV2ClientTypes {

    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfigInput: Swift.Sendable {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        ) {
            self.serverNameToVerify = serverNameToVerify
        }
    }
}

/// Creates a new Integration resource to represent an integration.
public struct CreateIntegrationInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration.
    public var description: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    /// This member is required.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    ) {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct CreateIntegrationOutput: Swift.Sendable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

/// Creates a new IntegrationResponse resource to represent an integration response.
public struct CreateIntegrationResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response key.
    /// This member is required.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct CreateIntegrationResponseOutput: Swift.Sendable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    ) {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

/// Creates a new Model.
public struct CreateModelInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.name = name
        self.schema = schema
    }
}

public struct CreateModelOutput: Swift.Sendable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    ) {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an endpoint configuration.
    public struct EndpointConfigurationRequest: Swift.Sendable {
        /// Represents a domain name and certificate for a portal.
        public var acmManaged: ApiGatewayV2ClientTypes.ACMManaged?
        /// Use the default portal domain name that is generated and managed by API Gateway.
        public var `none`: ApiGatewayV2ClientTypes.None?

        public init(
            acmManaged: ApiGatewayV2ClientTypes.ACMManaged? = nil,
            `none`: ApiGatewayV2ClientTypes.None? = nil
        ) {
            self.acmManaged = acmManaged
            self.`none` = `none`
        }
    }
}

/// The request body for the post operation.
public struct CreatePortalInput: Swift.Sendable {
    /// The authentication configuration for the portal.
    /// This member is required.
    public var authorization: ApiGatewayV2ClientTypes.Authorization?
    /// The domain configuration for the portal. Use a default domain provided by API Gateway or provide a fully-qualified domain name that you own.
    /// This member is required.
    public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationRequest?
    /// The ARNs of the portal products included in the portal.
    public var includedPortalProductArns: [Swift.String]?
    /// The URI for the portal logo image that is displayed in the portal header.
    public var logoUri: Swift.String?
    /// The content of the portal.
    /// This member is required.
    public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
    /// The name of the Amazon CloudWatch RUM app monitor for the portal.
    public var rumAppMonitorName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
        endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationRequest? = nil,
        includedPortalProductArns: [Swift.String]? = nil,
        logoUri: Swift.String? = nil,
        portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
        rumAppMonitorName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authorization = authorization
        self.endpointConfiguration = endpointConfiguration
        self.includedPortalProductArns = includedPortalProductArns
        self.logoUri = logoUri
        self.portalContent = portalContent
        self.rumAppMonitorName = rumAppMonitorName
        self.tags = tags
    }
}

public struct CreatePortalOutput: Swift.Sendable {
    /// The authorization for the portal. Supports Cognito-based user authentication or no authentication.
    public var authorization: ApiGatewayV2ClientTypes.Authorization?
    /// The endpoint configuration.
    public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse?
    /// The ARNs of the portal products included in the portal.
    public var includedPortalProductArns: [Swift.String]?
    /// The timestamp when the portal configuration was last modified.
    public var lastModified: Foundation.Date?
    /// The timestamp when the portal was last published.
    public var lastPublished: Foundation.Date?
    /// A user-written description of the changes made in the last published version of the portal.
    public var lastPublishedDescription: Swift.String?
    /// The ARN of the portal.
    public var portalArn: Swift.String?
    /// The name, description, and theme for the portal.
    public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
    /// The portal identifier.
    public var portalId: Swift.String?
    /// The current publishing status of the portal.
    public var publishStatus: ApiGatewayV2ClientTypes.PublishStatus?
    /// The name of the Amazon CloudWatch RUM app monitor.
    public var rumAppMonitorName: Swift.String?
    /// Error information for failed portal operations. Contains details about any issues encountered during portal creation or publishing.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
        endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse? = nil,
        includedPortalProductArns: [Swift.String]? = nil,
        lastModified: Foundation.Date? = nil,
        lastPublished: Foundation.Date? = nil,
        lastPublishedDescription: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
        portalId: Swift.String? = nil,
        publishStatus: ApiGatewayV2ClientTypes.PublishStatus? = nil,
        rumAppMonitorName: Swift.String? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authorization = authorization
        self.endpointConfiguration = endpointConfiguration
        self.includedPortalProductArns = includedPortalProductArns
        self.lastModified = lastModified
        self.lastPublished = lastPublished
        self.lastPublishedDescription = lastPublishedDescription
        self.portalArn = portalArn
        self.portalContent = portalContent
        self.portalId = portalId
        self.publishStatus = publishStatus
        self.rumAppMonitorName = rumAppMonitorName
        self.statusException = statusException
        self.tags = tags
    }
}

/// The request body for the post operation.
public struct CreatePortalProductInput: Swift.Sendable {
    /// A description of the portal product.
    public var description: Swift.String?
    /// The name of the portal product as it appears in a published portal.
    /// This member is required.
    public var displayName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.tags = tags
    }
}

extension ApiGatewayV2ClientTypes {

    /// The display order.
    public struct DisplayOrder: Swift.Sendable {
        /// Represents a list of sections which include section name and list of product REST endpoints for a product.
        public var contents: [ApiGatewayV2ClientTypes.Section]?
        /// The ARN of the overview page.
        public var overviewPageArn: Swift.String?
        /// The product page ARNs.
        public var productPageArns: [Swift.String]?

        public init(
            contents: [ApiGatewayV2ClientTypes.Section]? = nil,
            overviewPageArn: Swift.String? = nil,
            productPageArns: [Swift.String]? = nil
        ) {
            self.contents = contents
            self.overviewPageArn = overviewPageArn
            self.productPageArns = productPageArns
        }
    }
}

public struct CreatePortalProductOutput: Swift.Sendable {
    /// A description of the portal product.
    public var description: Swift.String?
    /// The display name for the portal product.
    public var displayName: Swift.String?
    /// The visual ordering of the product pages and product REST endpoint pages in a published portal.
    public var displayOrder: ApiGatewayV2ClientTypes.DisplayOrder?
    /// The timestamp when the portal product was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the portal product.
    public var portalProductArn: Swift.String?
    /// The portal product identifier.
    public var portalProductId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        displayOrder: ApiGatewayV2ClientTypes.DisplayOrder? = nil,
        lastModified: Foundation.Date? = nil,
        portalProductArn: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.displayOrder = displayOrder
        self.lastModified = lastModified
        self.portalProductArn = portalProductArn
        self.portalProductId = portalProductId
        self.tags = tags
    }
}

extension ApiGatewayV2ClientTypes {

    /// The content of the product page.
    public struct DisplayContent: Swift.Sendable {
        /// The body.
        /// This member is required.
        public var body: Swift.String?
        /// The title.
        /// This member is required.
        public var title: Swift.String?

        public init(
            body: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.body = body
            self.title = title
        }
    }
}

/// The request body for the post operation.
public struct CreateProductPageInput: Swift.Sendable {
    /// The content of the product page.
    /// This member is required.
    public var displayContent: ApiGatewayV2ClientTypes.DisplayContent?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        displayContent: ApiGatewayV2ClientTypes.DisplayContent? = nil,
        portalProductId: Swift.String? = nil
    ) {
        self.displayContent = displayContent
        self.portalProductId = portalProductId
    }
}

public struct CreateProductPageOutput: Swift.Sendable {
    /// The content of the product page.
    public var displayContent: ApiGatewayV2ClientTypes.DisplayContent?
    /// The timestamp when the product page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product page.
    public var productPageArn: Swift.String?
    /// The product page identifier.
    public var productPageId: Swift.String?

    public init(
        displayContent: ApiGatewayV2ClientTypes.DisplayContent? = nil,
        lastModified: Foundation.Date? = nil,
        productPageArn: Swift.String? = nil,
        productPageId: Swift.String? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productPageArn = productPageArn
        self.productPageId = productPageId
    }
}

extension ApiGatewayV2ClientTypes {

    /// Contains any values that override the default configuration generated from API Gateway.
    public struct DisplayContentOverrides: Swift.Sendable {
        /// By default, this is the documentation of your REST API from API Gateway. You can provide custom documentation to override this value.
        public var body: Swift.String?
        /// The URL for your REST API. By default, API Gateway uses the default execute API endpoint. You can provide a custom domain to override this value.
        public var endpoint: Swift.String?
        /// The operation name of the product REST endpoint.
        public var operationName: Swift.String?

        public init(
            body: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            operationName: Swift.String? = nil
        ) {
            self.body = body
            self.endpoint = endpoint
            self.operationName = operationName
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents the endpoint display content.
    public struct EndpointDisplayContent: Swift.Sendable {
        /// If your product REST endpoint contains no overrides, the none object is returned.
        public var `none`: ApiGatewayV2ClientTypes.None?
        /// The overrides for endpoint display content.
        public var overrides: ApiGatewayV2ClientTypes.DisplayContentOverrides?

        public init(
            `none`: ApiGatewayV2ClientTypes.None? = nil,
            overrides: ApiGatewayV2ClientTypes.DisplayContentOverrides? = nil
        ) {
            self.`none` = `none`
            self.overrides = overrides
        }
    }
}

/// The request body for the post operation.
public struct CreateProductRestEndpointPageInput: Swift.Sendable {
    /// The content of the product REST endpoint page.
    public var displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContent?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The REST endpoint identifier.
    /// This member is required.
    public var restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier?
    /// The try it state of the product REST endpoint page.
    public var tryItState: ApiGatewayV2ClientTypes.TryItState?

    public init(
        displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContent? = nil,
        portalProductId: Swift.String? = nil,
        restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier? = nil,
        tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
    ) {
        self.displayContent = displayContent
        self.portalProductId = portalProductId
        self.restEndpointIdentifier = restEndpointIdentifier
        self.tryItState = tryItState
    }
}

extension ApiGatewayV2ClientTypes {

    /// The product REST endpoint page.
    public struct EndpointDisplayContentResponse: Swift.Sendable {
        /// The API documentation.
        public var body: Swift.String?
        /// The URL to invoke your REST API.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The operation name.
        public var operationName: Swift.String?

        public init(
            body: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            operationName: Swift.String? = nil
        ) {
            self.body = body
            self.endpoint = endpoint
            self.operationName = operationName
        }
    }
}

public struct CreateProductRestEndpointPageOutput: Swift.Sendable {
    /// The display content.
    public var displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse?
    /// The timestamp when the product REST endpoint page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product REST endpoint page.
    public var productRestEndpointPageArn: Swift.String?
    /// The product REST endpoint page identifier.
    public var productRestEndpointPageId: Swift.String?
    /// The REST endpoint identifier.
    public var restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier?
    /// The status.
    public var status: ApiGatewayV2ClientTypes.Status?
    /// The status exception information.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The try it state.
    public var tryItState: ApiGatewayV2ClientTypes.TryItState?

    public init(
        displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse? = nil,
        lastModified: Foundation.Date? = nil,
        productRestEndpointPageArn: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil,
        restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier? = nil,
        status: ApiGatewayV2ClientTypes.Status? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productRestEndpointPageArn = productRestEndpointPageArn
        self.productRestEndpointPageId = productRestEndpointPageId
        self.restEndpointIdentifier = restEndpointIdentifier
        self.status = status
        self.statusException = statusException
        self.tryItState = tryItState
    }
}

/// Creates a new Route resource to represent a route.
public struct CreateRouteInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route key for the route.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct CreateRouteOutput: Swift.Sendable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

/// Creates a new RouteResponse resource to represent a route response.
public struct CreateRouteResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response key.
    /// This member is required.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseKey = routeResponseKey
    }
}

public struct CreateRouteResponseOutput: Swift.Sendable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    ) {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

public struct CreateRoutingRuleInput: Swift.Sendable {
    /// Represents a routing rule action. The only supported action is invokeApi.
    /// This member is required.
    public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
    /// Represents a condition. Conditions can contain up to two matchHeaders conditions and one matchBasePaths conditions. API Gateway evaluates header conditions and base path conditions together. You can only use AND between header and base path conditions.
    /// This member is required.
    public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name ID.
    public var domainNameId: Swift.String?
    /// Represents the priority of the routing rule.
    /// This member is required.
    public var priority: Swift.Int?

    public init(
        actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
        conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
        domainName: Swift.String? = nil,
        domainNameId: Swift.String? = nil,
        priority: Swift.Int? = nil
    ) {
        self.actions = actions
        self.conditions = conditions
        self.domainName = domainName
        self.domainNameId = domainNameId
        self.priority = priority
    }
}

public struct CreateRoutingRuleOutput: Swift.Sendable {
    /// Represents a routing rule action. The only supported action is invokeApi.
    public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
    /// Represents a condition. Conditions can contain up to two matchHeaders conditions and one matchBasePaths conditions. API Gateway evaluates header conditions and base path conditions together. You can only use AND between header and base path conditions.
    public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
    /// Represents the priority of the routing rule.
    public var priority: Swift.Int?
    /// The ARN of the domain name.
    public var routingRuleArn: Swift.String?
    /// The routing rule ID.
    public var routingRuleId: Swift.String?

    public init(
        actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
        conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
        priority: Swift.Int? = nil,
        routingRuleArn: Swift.String? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.actions = actions
        self.conditions = conditions
        self.priority = priority
        self.routingRuleArn = routingRuleArn
        self.routingRuleId = routingRuleId
    }
}

/// Creates a new Stage resource to represent a stage.
public struct CreateStageInput: Swift.Sendable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier of the API stage.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

public struct CreateStageOutput: Swift.Sendable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

/// Creates a VPC link
public struct CreateVpcLinkInput: Swift.Sendable {
    /// The name of the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

public struct CreateVpcLinkOutput: Swift.Sendable {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    ) {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

public struct DeleteAccessLogSettingsInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct DeleteApiInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    ) {
        self.apiId = apiId
    }
}

public struct DeleteApiMappingInput: Swift.Sendable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

public struct DeleteAuthorizerInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

public struct DeleteCorsConfigurationInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    ) {
        self.apiId = apiId
    }
}

public struct DeleteDeploymentInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

public struct DeleteDomainNameInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    ) {
        self.domainName = domainName
    }
}

public struct DeleteIntegrationInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

public struct DeleteIntegrationResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

public struct DeleteModelInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct DeletePortalInput: Swift.Sendable {
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    ) {
        self.portalId = portalId
    }
}

public struct DeletePortalProductInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
    }
}

public struct DeletePortalProductSharingPolicyInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
    }
}

public struct DeleteProductPageInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var productPageId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil,
        productPageId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
        self.productPageId = productPageId
    }
}

public struct DeleteProductRestEndpointPageInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The product REST endpoint identifier.
    /// This member is required.
    public var productRestEndpointPageId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
        self.productRestEndpointPageId = productRestEndpointPageId
    }
}

public struct DeleteRouteInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.routeId = routeId
    }
}

public struct DeleteRouteRequestParameterInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route request parameter key.
    /// This member is required.
    public var requestParameterKey: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        requestParameterKey: Swift.String? = nil,
        routeId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.requestParameterKey = requestParameterKey
        self.routeId = routeId
    }
}

public struct DeleteRouteResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

public struct DeleteRouteSettingsInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route key.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.routeKey = routeKey
        self.stageName = stageName
    }
}

public struct DeleteRoutingRuleInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name ID.
    public var domainNameId: Swift.String?
    /// The routing rule ID.
    /// This member is required.
    public var routingRuleId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        domainNameId: Swift.String? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.domainNameId = domainNameId
        self.routingRuleId = routingRuleId
    }
}

public struct DeleteStageInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct DeleteVpcLinkInput: Swift.Sendable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    ) {
        self.vpcLinkId = vpcLinkId
    }
}

public struct DeleteVpcLinkOutput: Swift.Sendable {

    public init() { }
}

public struct DisablePortalInput: Swift.Sendable {
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    ) {
        self.portalId = portalId
    }
}

public struct ExportApiInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.
    public var exportVersion: Swift.String?
    /// Specifies whether to include [API Gateway extensions](https://docs.aws.amazon.com//apigateway/latest/developerguide/api-gateway-swagger-extensions.html) in the exported API definition. API Gateway extensions are included by default.
    public var includeExtensions: Swift.Bool?
    /// The output type of the exported definition file. Valid values are JSON and YAML.
    /// This member is required.
    public var outputType: Swift.String?
    /// The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.
    /// This member is required.
    public var specification: Swift.String?
    /// The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        exportVersion: Swift.String? = nil,
        includeExtensions: Swift.Bool? = nil,
        outputType: Swift.String? = nil,
        specification: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.exportVersion = exportVersion
        self.includeExtensions = includeExtensions
        self.outputType = outputType
        self.specification = specification
        self.stageName = stageName
    }
}

public struct ExportApiOutput: Swift.Sendable {
    /// Represents an exported definition of an API in a particular output format, for example, YAML. The API is serialized to the requested specification, for example, OpenAPI 3.0.
    public var body: Foundation.Data?

    public init(
        body: Foundation.Data? = nil
    ) {
        self.body = body
    }
}

public struct GetApiInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    ) {
        self.apiId = apiId
    }
}

public struct GetApiOutput: Swift.Sendable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    ) {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

public struct GetApiMappingInput: Swift.Sendable {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    ) {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

public struct GetApiMappingOutput: Swift.Sendable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

public struct GetApiMappingsInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetApiMappingsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ApiMapping]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.ApiMapping]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetApisInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetApisOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Api]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Api]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetAuthorizerInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

public struct GetAuthorizerOutput: Swift.Sendable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct GetAuthorizersInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetAuthorizersOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Authorizer]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Authorizer]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetDeploymentInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

public struct GetDeploymentOutput: Swift.Sendable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    ) {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

public struct GetDeploymentsInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDeploymentsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Deployment]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetDomainNameInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    ) {
        self.domainName = domainName
    }
}

public struct GetDomainNameOutput: Swift.Sendable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The ARN of the DomainName resource.
    public var domainNameArn: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The routing mode.
    public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameArn: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameArn = domainNameArn
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.routingMode = routingMode
        self.tags = tags
    }
}

public struct GetDomainNamesInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDomainNamesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.DomainName]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.DomainName]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetIntegrationInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

public struct GetIntegrationOutput: Swift.Sendable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct GetIntegrationResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

public struct GetIntegrationResponseOutput: Swift.Sendable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    ) {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct GetIntegrationResponsesInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.integrationId = integrationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetIntegrationResponsesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.IntegrationResponse]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetIntegrationsInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetIntegrationsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Integration]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Integration]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetModelInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct GetModelOutput: Swift.Sendable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    ) {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

public struct GetModelsInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetModelsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Model]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetModelTemplateInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct GetModelTemplateOutput: Swift.Sendable {
    /// The template value.
    public var value: Swift.String?

    public init(
        value: Swift.String? = nil
    ) {
        self.value = value
    }
}

public struct GetPortalInput: Swift.Sendable {
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    ) {
        self.portalId = portalId
    }
}

public struct GetPortalOutput: Swift.Sendable {
    /// The authorization for the portal.
    public var authorization: ApiGatewayV2ClientTypes.Authorization?
    /// The endpoint configuration.
    public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse?
    /// The ARNs of the portal products included in the portal.
    public var includedPortalProductArns: [Swift.String]?
    /// The timestamp when the portal was last modified.
    public var lastModified: Foundation.Date?
    /// The timestamp when the portal was last published.
    public var lastPublished: Foundation.Date?
    /// The publish description used when the portal was last published.
    public var lastPublishedDescription: Swift.String?
    /// The ARN of the portal.
    public var portalArn: Swift.String?
    /// Contains the content that is visible to portal consumers including the themes, display names, and description.
    public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
    /// The portal identifier.
    public var portalId: Swift.String?
    /// Represents the preview endpoint and the any possible error messages during preview generation.
    public var preview: ApiGatewayV2ClientTypes.Preview?
    /// The publish status of a portal.
    public var publishStatus: ApiGatewayV2ClientTypes.PublishStatus?
    /// The CloudWatch RUM app monitor name.
    public var rumAppMonitorName: Swift.String?
    /// The status exception information.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
        endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse? = nil,
        includedPortalProductArns: [Swift.String]? = nil,
        lastModified: Foundation.Date? = nil,
        lastPublished: Foundation.Date? = nil,
        lastPublishedDescription: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
        portalId: Swift.String? = nil,
        preview: ApiGatewayV2ClientTypes.Preview? = nil,
        publishStatus: ApiGatewayV2ClientTypes.PublishStatus? = nil,
        rumAppMonitorName: Swift.String? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authorization = authorization
        self.endpointConfiguration = endpointConfiguration
        self.includedPortalProductArns = includedPortalProductArns
        self.lastModified = lastModified
        self.lastPublished = lastPublished
        self.lastPublishedDescription = lastPublishedDescription
        self.portalArn = portalArn
        self.portalContent = portalContent
        self.portalId = portalId
        self.preview = preview
        self.publishStatus = publishStatus
        self.rumAppMonitorName = rumAppMonitorName
        self.statusException = statusException
        self.tags = tags
    }
}

public struct GetPortalProductInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The account ID of the resource owner of the portal product.
    public var resourceOwnerAccountId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil,
        resourceOwnerAccountId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
        self.resourceOwnerAccountId = resourceOwnerAccountId
    }
}

public struct GetPortalProductOutput: Swift.Sendable {
    /// The description of a portal product.
    public var description: Swift.String?
    /// The display name.
    public var displayName: Swift.String?
    /// The display order.
    public var displayOrder: ApiGatewayV2ClientTypes.DisplayOrder?
    /// The timestamp when the portal product was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the portal product.
    public var portalProductArn: Swift.String?
    /// The portal product identifier.
    public var portalProductId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        displayOrder: ApiGatewayV2ClientTypes.DisplayOrder? = nil,
        lastModified: Foundation.Date? = nil,
        portalProductArn: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.displayOrder = displayOrder
        self.lastModified = lastModified
        self.portalProductArn = portalProductArn
        self.portalProductId = portalProductId
        self.tags = tags
    }
}

public struct GetPortalProductSharingPolicyInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
    }
}

public struct GetPortalProductSharingPolicyOutput: Swift.Sendable {
    /// The product sharing policy.
    public var policyDocument: Swift.String?
    /// The portal product identifier.
    public var portalProductId: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        portalProductId: Swift.String? = nil
    ) {
        self.policyDocument = policyDocument
        self.portalProductId = portalProductId
    }
}

public struct GetProductPageInput: Swift.Sendable {
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var productPageId: Swift.String?
    /// The account ID of the resource owner of the portal product.
    public var resourceOwnerAccountId: Swift.String?

    public init(
        portalProductId: Swift.String? = nil,
        productPageId: Swift.String? = nil,
        resourceOwnerAccountId: Swift.String? = nil
    ) {
        self.portalProductId = portalProductId
        self.productPageId = productPageId
        self.resourceOwnerAccountId = resourceOwnerAccountId
    }
}

public struct GetProductPageOutput: Swift.Sendable {
    /// The content of the product page.
    public var displayContent: ApiGatewayV2ClientTypes.DisplayContent?
    /// The timestamp when the product page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product page.
    public var productPageArn: Swift.String?
    /// The product page identifier.
    public var productPageId: Swift.String?

    public init(
        displayContent: ApiGatewayV2ClientTypes.DisplayContent? = nil,
        lastModified: Foundation.Date? = nil,
        productPageArn: Swift.String? = nil,
        productPageId: Swift.String? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productPageArn = productPageArn
        self.productPageId = productPageId
    }
}

public struct GetProductRestEndpointPageInput: Swift.Sendable {
    /// The query parameter to include raw display content.
    public var includeRawDisplayContent: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The product REST endpoint identifier.
    /// This member is required.
    public var productRestEndpointPageId: Swift.String?
    /// The account ID of the resource owner of the portal product.
    public var resourceOwnerAccountId: Swift.String?

    public init(
        includeRawDisplayContent: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil,
        resourceOwnerAccountId: Swift.String? = nil
    ) {
        self.includeRawDisplayContent = includeRawDisplayContent
        self.portalProductId = portalProductId
        self.productRestEndpointPageId = productRestEndpointPageId
        self.resourceOwnerAccountId = resourceOwnerAccountId
    }
}

public struct GetProductRestEndpointPageOutput: Swift.Sendable {
    /// The content of the product REST endpoint page.
    public var displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse?
    /// The timestamp when the product REST endpoint page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product REST endpoint page.
    public var productRestEndpointPageArn: Swift.String?
    /// The product REST endpoint page identifier.
    public var productRestEndpointPageId: Swift.String?
    /// The raw display content of the product REST endpoint page.
    public var rawDisplayContent: Swift.String?
    /// The REST endpoint identifier.
    public var restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier?
    /// The status of the product REST endpoint page.
    public var status: ApiGatewayV2ClientTypes.Status?
    /// The status exception information.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The try it state.
    public var tryItState: ApiGatewayV2ClientTypes.TryItState?

    public init(
        displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse? = nil,
        lastModified: Foundation.Date? = nil,
        productRestEndpointPageArn: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil,
        rawDisplayContent: Swift.String? = nil,
        restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier? = nil,
        status: ApiGatewayV2ClientTypes.Status? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productRestEndpointPageArn = productRestEndpointPageArn
        self.productRestEndpointPageId = productRestEndpointPageId
        self.rawDisplayContent = rawDisplayContent
        self.restEndpointIdentifier = restEndpointIdentifier
        self.status = status
        self.statusException = statusException
        self.tryItState = tryItState
    }
}

public struct GetRouteInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.routeId = routeId
    }
}

public struct GetRouteOutput: Swift.Sendable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct GetRouteResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

public struct GetRouteResponseOutput: Swift.Sendable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    ) {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

public struct GetRouteResponsesInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        routeId: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeId = routeId
    }
}

public struct GetRouteResponsesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.RouteResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.RouteResponse]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetRoutesInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetRoutesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Route]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Route]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetRoutingRuleInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name ID.
    public var domainNameId: Swift.String?
    /// The routing rule ID.
    /// This member is required.
    public var routingRuleId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        domainNameId: Swift.String? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.domainNameId = domainNameId
        self.routingRuleId = routingRuleId
    }
}

public struct GetRoutingRuleOutput: Swift.Sendable {
    /// The resulting action based on matching a routing rules condition. Only InvokeApi is supported.
    public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
    /// The conditions of the routing rule.
    public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
    /// The order in which API Gateway evaluates a rule. Priority is evaluated from the lowest value to the highest value.
    public var priority: Swift.Int?
    /// The routing rule ARN.
    public var routingRuleArn: Swift.String?
    /// The routing rule ID.
    public var routingRuleId: Swift.String?

    public init(
        actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
        conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
        priority: Swift.Int? = nil,
        routingRuleArn: Swift.String? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.actions = actions
        self.conditions = conditions
        self.priority = priority
        self.routingRuleArn = routingRuleArn
        self.routingRuleId = routingRuleId
    }
}

public struct GetStageInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct GetStageOutput: Swift.Sendable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

public struct GetStagesInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetStagesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Stage]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Stage]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetTagsInput: Swift.Sendable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct GetTagsOutput: Swift.Sendable {
    /// Represents a collection of tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct GetVpcLinkInput: Swift.Sendable {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    ) {
        self.vpcLinkId = vpcLinkId
    }
}

public struct GetVpcLinkOutput: Swift.Sendable {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    ) {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

public struct GetVpcLinksInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetVpcLinksOutput: Swift.Sendable {
    /// A collection of VPC links.
    public var items: [ApiGatewayV2ClientTypes.VpcLink]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.VpcLink]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

///
public struct ImportApiInput: Swift.Sendable {
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    ) {
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

public struct ImportApiOutput: Swift.Sendable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    ) {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

public struct ListPortalProductsInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The resource owner of the portal product.
    public var resourceOwner: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceOwner: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
    }
}

public struct ListPortalProductsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.PortalProductSummary]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.PortalProductSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListPortalsInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPortalsOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.PortalSummary]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.PortalSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListProductPagesInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The account ID of the resource owner of the portal product.
    public var resourceOwnerAccountId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        resourceOwnerAccountId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalProductId = portalProductId
        self.resourceOwnerAccountId = resourceOwnerAccountId
    }
}

public struct ListProductPagesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ProductPageSummaryNoBody]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.ProductPageSummaryNoBody]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListProductRestEndpointPagesInput: Swift.Sendable {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The account ID of the resource owner of the portal product.
    public var resourceOwnerAccountId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        resourceOwnerAccountId: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalProductId = portalProductId
        self.resourceOwnerAccountId = resourceOwnerAccountId
    }
}

public struct ListProductRestEndpointPagesOutput: Swift.Sendable {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListRoutingRulesInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name ID.
    public var domainNameId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.Int?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        domainNameId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domainName = domainName
        self.domainNameId = domainNameId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRoutingRulesOutput: Swift.Sendable {
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The routing rules.
    public var routingRules: [ApiGatewayV2ClientTypes.RoutingRule]?

    public init(
        nextToken: Swift.String? = nil,
        routingRules: [ApiGatewayV2ClientTypes.RoutingRule]? = nil
    ) {
        self.nextToken = nextToken
        self.routingRules = routingRules
    }
}

public struct PreviewPortalInput: Swift.Sendable {
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    ) {
        self.portalId = portalId
    }
}

public struct PreviewPortalOutput: Swift.Sendable {

    public init() { }
}

/// The request body for the post operation.
public struct PublishPortalInput: Swift.Sendable {
    /// The description of the portal. When the portal is published, this description becomes the last published description.
    public var description: Swift.String?
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        description: Swift.String? = nil,
        portalId: Swift.String? = nil
    ) {
        self.description = description
        self.portalId = portalId
    }
}

public struct PublishPortalOutput: Swift.Sendable {

    public init() { }
}

/// The request body for the put operation.
public struct PutPortalProductSharingPolicyInput: Swift.Sendable {
    /// The product sharing policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        portalProductId: Swift.String? = nil
    ) {
        self.policyDocument = policyDocument
        self.portalProductId = portalProductId
    }
}

public struct PutPortalProductSharingPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutRoutingRuleInput: Swift.Sendable {
    /// The routing rule action.
    /// This member is required.
    public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
    /// The routing rule condition.
    /// This member is required.
    public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name ID.
    public var domainNameId: Swift.String?
    /// The routing rule priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The routing rule ID.
    /// This member is required.
    public var routingRuleId: Swift.String?

    public init(
        actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
        conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
        domainName: Swift.String? = nil,
        domainNameId: Swift.String? = nil,
        priority: Swift.Int? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.actions = actions
        self.conditions = conditions
        self.domainName = domainName
        self.domainNameId = domainNameId
        self.priority = priority
        self.routingRuleId = routingRuleId
    }
}

public struct PutRoutingRuleOutput: Swift.Sendable {
    /// The routing rule action.
    public var actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]?
    /// The conditions of the routing rule.
    public var conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]?
    /// The routing rule priority.
    public var priority: Swift.Int?
    /// The routing rule ARN.
    public var routingRuleArn: Swift.String?
    /// The routing rule ID.
    public var routingRuleId: Swift.String?

    public init(
        actions: [ApiGatewayV2ClientTypes.RoutingRuleAction]? = nil,
        conditions: [ApiGatewayV2ClientTypes.RoutingRuleCondition]? = nil,
        priority: Swift.Int? = nil,
        routingRuleArn: Swift.String? = nil,
        routingRuleId: Swift.String? = nil
    ) {
        self.actions = actions
        self.conditions = conditions
        self.priority = priority
        self.routingRuleArn = routingRuleArn
        self.routingRuleId = routingRuleId
    }
}

///
public struct ReimportApiInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        apiId: Swift.String? = nil,
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    ) {
        self.apiId = apiId
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

public struct ReimportApiOutput: Swift.Sendable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    ) {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

public struct ResetAuthorizersCacheInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.stageName = stageName
    }
}

/// Creates a new Tag resource to represent a tag.
public struct TagResourceInput: Swift.Sendable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// Updates an Api.
public struct UpdateApiInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The IP address types that can invoke your API or domain name.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.ipAddressType = ipAddressType
        self.name = name
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.target = target
        self.version = version
    }
}

public struct UpdateApiOutput: Swift.Sendable {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The IP address types that can invoke the API.
    public var ipAddressType: ApiGatewayV2ClientTypes.IpAddressType?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        ipAddressType: ApiGatewayV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    ) {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.ipAddressType = ipAddressType
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Updates an ApiMapping.
public struct UpdateApiMappingInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

public struct UpdateApiMappingOutput: Swift.Sendable {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

/// Updates an Authorizer.
public struct UpdateAuthorizerInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct UpdateAuthorizerOutput: Swift.Sendable {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    ) {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

/// Updates a Deployment.
public struct UpdateDeploymentInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.deploymentId = deploymentId
        self.description = description
    }
}

public struct UpdateDeploymentOutput: Swift.Sendable {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    ) {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

/// Updates a DomainName.
public struct UpdateDomainNameInput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    /// The routing mode.
    public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil,
        routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil
    ) {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.routingMode = routingMode
    }
}

public struct UpdateDomainNameOutput: Swift.Sendable {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The ARN of the DomainName resource.
    public var domainNameArn: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The routing mode.
    public var routingMode: ApiGatewayV2ClientTypes.RoutingMode?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameArn: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        routingMode: ApiGatewayV2ClientTypes.RoutingMode? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameArn = domainNameArn
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.routingMode = routingMode
        self.tags = tags
    }
}

/// Updates an Integration.
public struct UpdateIntegrationInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration
    public var description: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    ) {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct UpdateIntegrationOutput: Swift.Sendable {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see [Working with AWS Lambda proxy integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html).
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

/// Updates an IntegrationResponses.
public struct UpdateIntegrationResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name} , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression} , where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct UpdateIntegrationResponseOutput: Swift.Sendable {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    ) {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

/// Updates a Model.
public struct UpdateModelInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the model.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

public struct UpdateModelOutput: Swift.Sendable {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    ) {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

/// The request body for the patch operation.
public struct UpdatePortalInput: Swift.Sendable {
    /// The authorization of the portal.
    public var authorization: ApiGatewayV2ClientTypes.Authorization?
    /// Represents an endpoint configuration.
    public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationRequest?
    /// The ARNs of the portal products included in the portal.
    public var includedPortalProductArns: [Swift.String]?
    /// The logo URI.
    public var logoUri: Swift.String?
    /// Contains the content that is visible to portal consumers including the themes, display names, and description.
    public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
    /// The portal identifier.
    /// This member is required.
    public var portalId: Swift.String?
    /// The CloudWatch RUM app monitor name.
    public var rumAppMonitorName: Swift.String?

    public init(
        authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
        endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationRequest? = nil,
        includedPortalProductArns: [Swift.String]? = nil,
        logoUri: Swift.String? = nil,
        portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
        portalId: Swift.String? = nil,
        rumAppMonitorName: Swift.String? = nil
    ) {
        self.authorization = authorization
        self.endpointConfiguration = endpointConfiguration
        self.includedPortalProductArns = includedPortalProductArns
        self.logoUri = logoUri
        self.portalContent = portalContent
        self.portalId = portalId
        self.rumAppMonitorName = rumAppMonitorName
    }
}

public struct UpdatePortalOutput: Swift.Sendable {
    /// The authorization for the portal.
    public var authorization: ApiGatewayV2ClientTypes.Authorization?
    /// The endpoint configuration.
    public var endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse?
    /// The ARNs of the portal products included in the portal.
    public var includedPortalProductArns: [Swift.String]?
    /// The timestamp when the portal was last modified.
    public var lastModified: Foundation.Date?
    /// The timestamp when the portal was last published.
    public var lastPublished: Foundation.Date?
    /// The description associated with the last time the portal was published.
    public var lastPublishedDescription: Swift.String?
    /// The ARN of the portal.
    public var portalArn: Swift.String?
    /// Contains the content that is visible to portal consumers including the themes, display names, and description.
    public var portalContent: ApiGatewayV2ClientTypes.PortalContent?
    /// The portal identifier.
    public var portalId: Swift.String?
    /// Represents the preview endpoint and the any possible error messages during preview generation.
    public var preview: ApiGatewayV2ClientTypes.Preview?
    /// The publishStatus.
    public var publishStatus: ApiGatewayV2ClientTypes.PublishStatus?
    /// The CloudWatch RUM app monitor name.
    public var rumAppMonitorName: Swift.String?
    /// The status exception information.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authorization: ApiGatewayV2ClientTypes.Authorization? = nil,
        endpointConfiguration: ApiGatewayV2ClientTypes.EndpointConfigurationResponse? = nil,
        includedPortalProductArns: [Swift.String]? = nil,
        lastModified: Foundation.Date? = nil,
        lastPublished: Foundation.Date? = nil,
        lastPublishedDescription: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalContent: ApiGatewayV2ClientTypes.PortalContent? = nil,
        portalId: Swift.String? = nil,
        preview: ApiGatewayV2ClientTypes.Preview? = nil,
        publishStatus: ApiGatewayV2ClientTypes.PublishStatus? = nil,
        rumAppMonitorName: Swift.String? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authorization = authorization
        self.endpointConfiguration = endpointConfiguration
        self.includedPortalProductArns = includedPortalProductArns
        self.lastModified = lastModified
        self.lastPublished = lastPublished
        self.lastPublishedDescription = lastPublishedDescription
        self.portalArn = portalArn
        self.portalContent = portalContent
        self.portalId = portalId
        self.preview = preview
        self.publishStatus = publishStatus
        self.rumAppMonitorName = rumAppMonitorName
        self.statusException = statusException
        self.tags = tags
    }
}

/// The request body for the patch operation.
public struct UpdatePortalProductInput: Swift.Sendable {
    /// The description.
    public var description: Swift.String?
    /// The displayName.
    public var displayName: Swift.String?
    /// The display order.
    public var displayOrder: ApiGatewayV2ClientTypes.DisplayOrder?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        displayOrder: ApiGatewayV2ClientTypes.DisplayOrder? = nil,
        portalProductId: Swift.String? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.displayOrder = displayOrder
        self.portalProductId = portalProductId
    }
}

public struct UpdatePortalProductOutput: Swift.Sendable {
    /// The description of the portal product.
    public var description: Swift.String?
    /// The display name of a portal product.
    public var displayName: Swift.String?
    /// The display order that the portal products will appear in a portal.
    public var displayOrder: ApiGatewayV2ClientTypes.DisplayOrder?
    /// The timestamp when the portal product was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the portal product.
    public var portalProductArn: Swift.String?
    /// The portal product identifier.
    public var portalProductId: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        displayOrder: ApiGatewayV2ClientTypes.DisplayOrder? = nil,
        lastModified: Foundation.Date? = nil,
        portalProductArn: Swift.String? = nil,
        portalProductId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.displayName = displayName
        self.displayOrder = displayOrder
        self.lastModified = lastModified
        self.portalProductArn = portalProductArn
        self.portalProductId = portalProductId
        self.tags = tags
    }
}

/// The request body for the patch operation.
public struct UpdateProductPageInput: Swift.Sendable {
    /// The content of the product page.
    public var displayContent: ApiGatewayV2ClientTypes.DisplayContent?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The portal product identifier.
    /// This member is required.
    public var productPageId: Swift.String?

    public init(
        displayContent: ApiGatewayV2ClientTypes.DisplayContent? = nil,
        portalProductId: Swift.String? = nil,
        productPageId: Swift.String? = nil
    ) {
        self.displayContent = displayContent
        self.portalProductId = portalProductId
        self.productPageId = productPageId
    }
}

public struct UpdateProductPageOutput: Swift.Sendable {
    /// The content of the product page.
    public var displayContent: ApiGatewayV2ClientTypes.DisplayContent?
    /// The timestamp when the product page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product page.
    public var productPageArn: Swift.String?
    /// The product page identifier.
    public var productPageId: Swift.String?

    public init(
        displayContent: ApiGatewayV2ClientTypes.DisplayContent? = nil,
        lastModified: Foundation.Date? = nil,
        productPageArn: Swift.String? = nil,
        productPageId: Swift.String? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productPageArn = productPageArn
        self.productPageId = productPageId
    }
}

/// The request body for the patch operation.
public struct UpdateProductRestEndpointPageInput: Swift.Sendable {
    /// The display content.
    public var displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContent?
    /// The portal product identifier.
    /// This member is required.
    public var portalProductId: Swift.String?
    /// The product REST endpoint identifier.
    /// This member is required.
    public var productRestEndpointPageId: Swift.String?
    /// The try it state of a product REST endpoint page.
    public var tryItState: ApiGatewayV2ClientTypes.TryItState?

    public init(
        displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContent? = nil,
        portalProductId: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil,
        tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
    ) {
        self.displayContent = displayContent
        self.portalProductId = portalProductId
        self.productRestEndpointPageId = productRestEndpointPageId
        self.tryItState = tryItState
    }
}

public struct UpdateProductRestEndpointPageOutput: Swift.Sendable {
    /// The content of the product REST endpoint page.
    public var displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse?
    /// The timestamp when the product REST endpoint page was last modified.
    public var lastModified: Foundation.Date?
    /// The ARN of the product REST endpoint page.
    public var productRestEndpointPageArn: Swift.String?
    /// The product REST endpoint page identifier.
    public var productRestEndpointPageId: Swift.String?
    /// The REST endpoint identifier.
    public var restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier?
    /// The status.
    public var status: ApiGatewayV2ClientTypes.Status?
    /// The status exception information.
    public var statusException: ApiGatewayV2ClientTypes.StatusException?
    /// The try it state of a product REST endpoint page.
    public var tryItState: ApiGatewayV2ClientTypes.TryItState?

    public init(
        displayContent: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse? = nil,
        lastModified: Foundation.Date? = nil,
        productRestEndpointPageArn: Swift.String? = nil,
        productRestEndpointPageId: Swift.String? = nil,
        restEndpointIdentifier: ApiGatewayV2ClientTypes.RestEndpointIdentifier? = nil,
        status: ApiGatewayV2ClientTypes.Status? = nil,
        statusException: ApiGatewayV2ClientTypes.StatusException? = nil,
        tryItState: ApiGatewayV2ClientTypes.TryItState? = nil
    ) {
        self.displayContent = displayContent
        self.lastModified = lastModified
        self.productRestEndpointPageArn = productRestEndpointPageArn
        self.productRestEndpointPageId = productRestEndpointPageId
        self.restEndpointIdentifier = restEndpointIdentifier
        self.status = status
        self.statusException = statusException
        self.tryItState = tryItState
    }
}

/// Updates a Route.
public struct UpdateRouteInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct UpdateRouteOutput: Swift.Sendable {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    ) {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

/// Updates a RouteResponse.
public struct UpdateRouteResponseInput: Swift.Sendable {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?
    /// The route response key.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    ) {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

public struct UpdateRouteResponseOutput: Swift.Sendable {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    ) {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

/// Updates a Stage.
public struct UpdateStageInput: Swift.Sendable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil
    ) {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

public struct UpdateStageOutput: Swift.Sendable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

/// Updates a VPC link.
public struct UpdateVpcLinkInput: Swift.Sendable {
    /// The name of the VPC link.
    public var name: Swift.String?
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        name: Swift.String? = nil,
        vpcLinkId: Swift.String? = nil
    ) {
        self.name = name
        self.vpcLinkId = vpcLinkId
    }
}

public struct UpdateVpcLinkOutput: Swift.Sendable {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    ) {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

extension CreateApiInput {

    static func urlPathProvider(_ value: CreateApiInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension CreateApiMappingInput {

    static func urlPathProvider(_ value: CreateApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

extension CreateAuthorizerInput {

    static func urlPathProvider(_ value: CreateAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

extension CreateDomainNameInput {

    static func urlPathProvider(_ value: CreateDomainNameInput) -> Swift.String? {
        return "/v2/domainnames"
    }
}

extension CreateIntegrationInput {

    static func urlPathProvider(_ value: CreateIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

extension CreateIntegrationResponseInput {

    static func urlPathProvider(_ value: CreateIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

extension CreateModelInput {

    static func urlPathProvider(_ value: CreateModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

extension CreatePortalInput {

    static func urlPathProvider(_ value: CreatePortalInput) -> Swift.String? {
        return "/v2/portals"
    }
}

extension CreatePortalProductInput {

    static func urlPathProvider(_ value: CreatePortalProductInput) -> Swift.String? {
        return "/v2/portalproducts"
    }
}

extension CreateProductPageInput {

    static func urlPathProvider(_ value: CreateProductPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productpages"
    }
}

extension CreateProductRestEndpointPageInput {

    static func urlPathProvider(_ value: CreateProductRestEndpointPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productrestendpointpages"
    }
}

extension CreateRouteInput {

    static func urlPathProvider(_ value: CreateRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

extension CreateRouteResponseInput {

    static func urlPathProvider(_ value: CreateRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

extension CreateRoutingRuleInput {

    static func urlPathProvider(_ value: CreateRoutingRuleInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/routingrules"
    }
}

extension CreateRoutingRuleInput {

    static func queryItemProvider(_ value: CreateRoutingRuleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainNameId = value.domainNameId {
            let domainNameIdQueryItem = Smithy.URIQueryItem(name: "domainNameId".urlPercentEncoding(), value: Swift.String(domainNameId).urlPercentEncoding())
            items.append(domainNameIdQueryItem)
        }
        return items
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

extension CreateVpcLinkInput {

    static func urlPathProvider(_ value: CreateVpcLinkInput) -> Swift.String? {
        return "/v2/vpclinks"
    }
}

extension DeleteAccessLogSettingsInput {

    static func urlPathProvider(_ value: DeleteAccessLogSettingsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/accesslogsettings"
    }
}

extension DeleteApiInput {

    static func urlPathProvider(_ value: DeleteApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension DeleteApiMappingInput {

    static func urlPathProvider(_ value: DeleteApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension DeleteAuthorizerInput {

    static func urlPathProvider(_ value: DeleteAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension DeleteCorsConfigurationInput {

    static func urlPathProvider(_ value: DeleteCorsConfigurationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/cors"
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension DeleteDomainNameInput {

    static func urlPathProvider(_ value: DeleteDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteIntegrationInput {

    static func urlPathProvider(_ value: DeleteIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension DeleteIntegrationResponseInput {

    static func urlPathProvider(_ value: DeleteIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension DeleteModelInput {

    static func urlPathProvider(_ value: DeleteModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension DeletePortalInput {

    static func urlPathProvider(_ value: DeletePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())"
    }
}

extension DeletePortalProductInput {

    static func urlPathProvider(_ value: DeletePortalProductInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())"
    }
}

extension DeletePortalProductSharingPolicyInput {

    static func urlPathProvider(_ value: DeletePortalProductSharingPolicyInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/sharingpolicy"
    }
}

extension DeleteProductPageInput {

    static func urlPathProvider(_ value: DeleteProductPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productPageId = value.productPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productpages/\(productPageId.urlPercentEncoding())"
    }
}

extension DeleteProductRestEndpointPageInput {

    static func urlPathProvider(_ value: DeleteProductRestEndpointPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productRestEndpointPageId = value.productRestEndpointPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productrestendpointpages/\(productRestEndpointPageId.urlPercentEncoding())"
    }
}

extension DeleteRouteInput {

    static func urlPathProvider(_ value: DeleteRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension DeleteRouteRequestParameterInput {

    static func urlPathProvider(_ value: DeleteRouteRequestParameterInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let requestParameterKey = value.requestParameterKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/requestparameters/\(requestParameterKey.urlPercentEncoding())"
    }
}

extension DeleteRouteResponseInput {

    static func urlPathProvider(_ value: DeleteRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension DeleteRouteSettingsInput {

    static func urlPathProvider(_ value: DeleteRouteSettingsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        guard let routeKey = value.routeKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/routesettings/\(routeKey.urlPercentEncoding())"
    }
}

extension DeleteRoutingRuleInput {

    static func urlPathProvider(_ value: DeleteRoutingRuleInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let routingRuleId = value.routingRuleId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/routingrules/\(routingRuleId.urlPercentEncoding())"
    }
}

extension DeleteRoutingRuleInput {

    static func queryItemProvider(_ value: DeleteRoutingRuleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainNameId = value.domainNameId {
            let domainNameIdQueryItem = Smithy.URIQueryItem(name: "domainNameId".urlPercentEncoding(), value: Swift.String(domainNameId).urlPercentEncoding())
            items.append(domainNameIdQueryItem)
        }
        return items
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension DeleteVpcLinkInput {

    static func urlPathProvider(_ value: DeleteVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension DisablePortalInput {

    static func urlPathProvider(_ value: DisablePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())/publish"
    }
}

extension ExportApiInput {

    static func urlPathProvider(_ value: ExportApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let specification = value.specification else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/exports/\(specification.urlPercentEncoding())"
    }
}

extension ExportApiInput {

    static func queryItemProvider(_ value: ExportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stageName = value.stageName {
            let stageNameQueryItem = Smithy.URIQueryItem(name: "stageName".urlPercentEncoding(), value: Swift.String(stageName).urlPercentEncoding())
            items.append(stageNameQueryItem)
        }
        if let includeExtensions = value.includeExtensions {
            let includeExtensionsQueryItem = Smithy.URIQueryItem(name: "includeExtensions".urlPercentEncoding(), value: Swift.String(includeExtensions).urlPercentEncoding())
            items.append(includeExtensionsQueryItem)
        }
        if let exportVersion = value.exportVersion {
            let exportVersionQueryItem = Smithy.URIQueryItem(name: "exportVersion".urlPercentEncoding(), value: Swift.String(exportVersion).urlPercentEncoding())
            items.append(exportVersionQueryItem)
        }
        guard let outputType = value.outputType else {
            let message = "Creating a URL Query Item failed. outputType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let outputTypeQueryItem = Smithy.URIQueryItem(name: "outputType".urlPercentEncoding(), value: Swift.String(outputType).urlPercentEncoding())
        items.append(outputTypeQueryItem)
        return items
    }
}

extension GetApiInput {

    static func urlPathProvider(_ value: GetApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension GetApiMappingInput {

    static func urlPathProvider(_ value: GetApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension GetApiMappingsInput {

    static func urlPathProvider(_ value: GetApiMappingsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

extension GetApiMappingsInput {

    static func queryItemProvider(_ value: GetApiMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetApisInput {

    static func urlPathProvider(_ value: GetApisInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension GetApisInput {

    static func queryItemProvider(_ value: GetApisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetAuthorizerInput {

    static func urlPathProvider(_ value: GetAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension GetAuthorizersInput {

    static func urlPathProvider(_ value: GetAuthorizersInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

extension GetAuthorizersInput {

    static func queryItemProvider(_ value: GetAuthorizersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension GetDeploymentsInput {

    static func urlPathProvider(_ value: GetDeploymentsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

extension GetDeploymentsInput {

    static func queryItemProvider(_ value: GetDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDomainNameInput {

    static func urlPathProvider(_ value: GetDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension GetDomainNamesInput {

    static func urlPathProvider(_ value: GetDomainNamesInput) -> Swift.String? {
        return "/v2/domainnames"
    }
}

extension GetDomainNamesInput {

    static func queryItemProvider(_ value: GetDomainNamesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationInput {

    static func urlPathProvider(_ value: GetIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension GetIntegrationResponseInput {

    static func urlPathProvider(_ value: GetIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension GetIntegrationResponsesInput {

    static func urlPathProvider(_ value: GetIntegrationResponsesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

extension GetIntegrationResponsesInput {

    static func queryItemProvider(_ value: GetIntegrationResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationsInput {

    static func urlPathProvider(_ value: GetIntegrationsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

extension GetIntegrationsInput {

    static func queryItemProvider(_ value: GetIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetModelInput {

    static func urlPathProvider(_ value: GetModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension GetModelsInput {

    static func urlPathProvider(_ value: GetModelsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

extension GetModelsInput {

    static func queryItemProvider(_ value: GetModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetModelTemplateInput {

    static func urlPathProvider(_ value: GetModelTemplateInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())/template"
    }
}

extension GetPortalInput {

    static func urlPathProvider(_ value: GetPortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())"
    }
}

extension GetPortalProductInput {

    static func urlPathProvider(_ value: GetPortalProductInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())"
    }
}

extension GetPortalProductInput {

    static func queryItemProvider(_ value: GetPortalProductInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceOwnerAccountId = value.resourceOwnerAccountId {
            let resourceOwnerAccountIdQueryItem = Smithy.URIQueryItem(name: "resourceOwnerAccountId".urlPercentEncoding(), value: Swift.String(resourceOwnerAccountId).urlPercentEncoding())
            items.append(resourceOwnerAccountIdQueryItem)
        }
        return items
    }
}

extension GetPortalProductSharingPolicyInput {

    static func urlPathProvider(_ value: GetPortalProductSharingPolicyInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/sharingpolicy"
    }
}

extension GetProductPageInput {

    static func urlPathProvider(_ value: GetProductPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productPageId = value.productPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productpages/\(productPageId.urlPercentEncoding())"
    }
}

extension GetProductPageInput {

    static func queryItemProvider(_ value: GetProductPageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceOwnerAccountId = value.resourceOwnerAccountId {
            let resourceOwnerAccountIdQueryItem = Smithy.URIQueryItem(name: "resourceOwnerAccountId".urlPercentEncoding(), value: Swift.String(resourceOwnerAccountId).urlPercentEncoding())
            items.append(resourceOwnerAccountIdQueryItem)
        }
        return items
    }
}

extension GetProductRestEndpointPageInput {

    static func urlPathProvider(_ value: GetProductRestEndpointPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productRestEndpointPageId = value.productRestEndpointPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productrestendpointpages/\(productRestEndpointPageId.urlPercentEncoding())"
    }
}

extension GetProductRestEndpointPageInput {

    static func queryItemProvider(_ value: GetProductRestEndpointPageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceOwnerAccountId = value.resourceOwnerAccountId {
            let resourceOwnerAccountIdQueryItem = Smithy.URIQueryItem(name: "resourceOwnerAccountId".urlPercentEncoding(), value: Swift.String(resourceOwnerAccountId).urlPercentEncoding())
            items.append(resourceOwnerAccountIdQueryItem)
        }
        if let includeRawDisplayContent = value.includeRawDisplayContent {
            let includeRawDisplayContentQueryItem = Smithy.URIQueryItem(name: "includeRawDisplayContent".urlPercentEncoding(), value: Swift.String(includeRawDisplayContent).urlPercentEncoding())
            items.append(includeRawDisplayContentQueryItem)
        }
        return items
    }
}

extension GetRouteInput {

    static func urlPathProvider(_ value: GetRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension GetRouteResponseInput {

    static func urlPathProvider(_ value: GetRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension GetRouteResponsesInput {

    static func urlPathProvider(_ value: GetRouteResponsesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

extension GetRouteResponsesInput {

    static func queryItemProvider(_ value: GetRouteResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetRoutesInput {

    static func urlPathProvider(_ value: GetRoutesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

extension GetRoutesInput {

    static func queryItemProvider(_ value: GetRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetRoutingRuleInput {

    static func urlPathProvider(_ value: GetRoutingRuleInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let routingRuleId = value.routingRuleId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/routingrules/\(routingRuleId.urlPercentEncoding())"
    }
}

extension GetRoutingRuleInput {

    static func queryItemProvider(_ value: GetRoutingRuleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainNameId = value.domainNameId {
            let domainNameIdQueryItem = Smithy.URIQueryItem(name: "domainNameId".urlPercentEncoding(), value: Swift.String(domainNameId).urlPercentEncoding())
            items.append(domainNameIdQueryItem)
        }
        return items
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension GetStagesInput {

    static func urlPathProvider(_ value: GetStagesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

extension GetStagesInput {

    static func queryItemProvider(_ value: GetStagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetTagsInput {

    static func urlPathProvider(_ value: GetTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetVpcLinkInput {

    static func urlPathProvider(_ value: GetVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension GetVpcLinksInput {

    static func urlPathProvider(_ value: GetVpcLinksInput) -> Swift.String? {
        return "/v2/vpclinks"
    }
}

extension GetVpcLinksInput {

    static func queryItemProvider(_ value: GetVpcLinksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ImportApiInput {

    static func urlPathProvider(_ value: ImportApiInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension ImportApiInput {

    static func queryItemProvider(_ value: ImportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = value.basepath {
            let basepathQueryItem = Smithy.URIQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ListPortalProductsInput {

    static func urlPathProvider(_ value: ListPortalProductsInput) -> Swift.String? {
        return "/v2/portalproducts"
    }
}

extension ListPortalProductsInput {

    static func queryItemProvider(_ value: ListPortalProductsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceOwner = value.resourceOwner {
            let resourceOwnerQueryItem = Smithy.URIQueryItem(name: "resourceOwner".urlPercentEncoding(), value: Swift.String(resourceOwner).urlPercentEncoding())
            items.append(resourceOwnerQueryItem)
        }
        return items
    }
}

extension ListPortalsInput {

    static func urlPathProvider(_ value: ListPortalsInput) -> Swift.String? {
        return "/v2/portals"
    }
}

extension ListPortalsInput {

    static func queryItemProvider(_ value: ListPortalsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProductPagesInput {

    static func urlPathProvider(_ value: ListProductPagesInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productpages"
    }
}

extension ListProductPagesInput {

    static func queryItemProvider(_ value: ListProductPagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let resourceOwnerAccountId = value.resourceOwnerAccountId {
            let resourceOwnerAccountIdQueryItem = Smithy.URIQueryItem(name: "resourceOwnerAccountId".urlPercentEncoding(), value: Swift.String(resourceOwnerAccountId).urlPercentEncoding())
            items.append(resourceOwnerAccountIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProductRestEndpointPagesInput {

    static func urlPathProvider(_ value: ListProductRestEndpointPagesInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productrestendpointpages"
    }
}

extension ListProductRestEndpointPagesInput {

    static func queryItemProvider(_ value: ListProductRestEndpointPagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let resourceOwnerAccountId = value.resourceOwnerAccountId {
            let resourceOwnerAccountIdQueryItem = Smithy.URIQueryItem(name: "resourceOwnerAccountId".urlPercentEncoding(), value: Swift.String(resourceOwnerAccountId).urlPercentEncoding())
            items.append(resourceOwnerAccountIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutingRulesInput {

    static func urlPathProvider(_ value: ListRoutingRulesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/routingrules"
    }
}

extension ListRoutingRulesInput {

    static func queryItemProvider(_ value: ListRoutingRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainNameId = value.domainNameId {
            let domainNameIdQueryItem = Smithy.URIQueryItem(name: "domainNameId".urlPercentEncoding(), value: Swift.String(domainNameId).urlPercentEncoding())
            items.append(domainNameIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PreviewPortalInput {

    static func urlPathProvider(_ value: PreviewPortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())/preview"
    }
}

extension PublishPortalInput {

    static func urlPathProvider(_ value: PublishPortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())/publish"
    }
}

extension PutPortalProductSharingPolicyInput {

    static func urlPathProvider(_ value: PutPortalProductSharingPolicyInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/sharingpolicy"
    }
}

extension PutRoutingRuleInput {

    static func urlPathProvider(_ value: PutRoutingRuleInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let routingRuleId = value.routingRuleId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/routingrules/\(routingRuleId.urlPercentEncoding())"
    }
}

extension PutRoutingRuleInput {

    static func queryItemProvider(_ value: PutRoutingRuleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainNameId = value.domainNameId {
            let domainNameIdQueryItem = Smithy.URIQueryItem(name: "domainNameId".urlPercentEncoding(), value: Swift.String(domainNameId).urlPercentEncoding())
            items.append(domainNameIdQueryItem)
        }
        return items
    }
}

extension ReimportApiInput {

    static func urlPathProvider(_ value: ReimportApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension ReimportApiInput {

    static func queryItemProvider(_ value: ReimportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = value.basepath {
            let basepathQueryItem = Smithy.URIQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ResetAuthorizersCacheInput {

    static func urlPathProvider(_ value: ResetAuthorizersCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApiInput {

    static func urlPathProvider(_ value: UpdateApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension UpdateApiMappingInput {

    static func urlPathProvider(_ value: UpdateApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension UpdateAuthorizerInput {

    static func urlPathProvider(_ value: UpdateAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension UpdateDeploymentInput {

    static func urlPathProvider(_ value: UpdateDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension UpdateDomainNameInput {

    static func urlPathProvider(_ value: UpdateDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateIntegrationInput {

    static func urlPathProvider(_ value: UpdateIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension UpdateIntegrationResponseInput {

    static func urlPathProvider(_ value: UpdateIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension UpdateModelInput {

    static func urlPathProvider(_ value: UpdateModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension UpdatePortalInput {

    static func urlPathProvider(_ value: UpdatePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/v2/portals/\(portalId.urlPercentEncoding())"
    }
}

extension UpdatePortalProductInput {

    static func urlPathProvider(_ value: UpdatePortalProductInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())"
    }
}

extension UpdateProductPageInput {

    static func urlPathProvider(_ value: UpdateProductPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productPageId = value.productPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productpages/\(productPageId.urlPercentEncoding())"
    }
}

extension UpdateProductRestEndpointPageInput {

    static func urlPathProvider(_ value: UpdateProductRestEndpointPageInput) -> Swift.String? {
        guard let portalProductId = value.portalProductId else {
            return nil
        }
        guard let productRestEndpointPageId = value.productRestEndpointPageId else {
            return nil
        }
        return "/v2/portalproducts/\(portalProductId.urlPercentEncoding())/productrestendpointpages/\(productRestEndpointPageId.urlPercentEncoding())"
    }
}

extension UpdateRouteInput {

    static func urlPathProvider(_ value: UpdateRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension UpdateRouteResponseInput {

    static func urlPathProvider(_ value: UpdateRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension UpdateVpcLinkInput {

    static func urlPathProvider(_ value: UpdateVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension CreateApiInput {

    static func write(value: CreateApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeySelectionExpression"].write(value.apiKeySelectionExpression)
        try writer["corsConfiguration"].write(value.corsConfiguration, with: ApiGatewayV2ClientTypes.Cors.write(value:to:))
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["disableExecuteApiEndpoint"].write(value.disableExecuteApiEndpoint)
        try writer["disableSchemaValidation"].write(value.disableSchemaValidation)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["name"].write(value.name)
        try writer["protocolType"].write(value.protocolType)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeSelectionExpression"].write(value.routeSelectionExpression)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["target"].write(value.target)
        try writer["version"].write(value.version)
    }
}

extension CreateApiMappingInput {

    static func write(value: CreateApiMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["apiMappingKey"].write(value.apiMappingKey)
        try writer["stage"].write(value.stage)
    }
}

extension CreateAuthorizerInput {

    static func write(value: CreateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerCredentialsArn"].write(value.authorizerCredentialsArn)
        try writer["authorizerPayloadFormatVersion"].write(value.authorizerPayloadFormatVersion)
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerType"].write(value.authorizerType)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["enableSimpleResponses"].write(value.enableSimpleResponses)
        try writer["identitySource"].writeList(value.identitySource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
        try writer["jwtConfiguration"].write(value.jwtConfiguration, with: ApiGatewayV2ClientTypes.JWTConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["stageName"].write(value.stageName)
    }
}

extension CreateDomainNameInput {

    static func write(value: CreateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["domainNameConfigurations"].writeList(value.domainNameConfigurations, memberWritingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mutualTlsAuthentication"].write(value.mutualTlsAuthentication, with: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.write(value:to:))
        try writer["routingMode"].write(value.routingMode)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIntegrationInput {

    static func write(value: CreateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionType"].write(value.connectionType)
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["integrationMethod"].write(value.integrationMethod)
        try writer["integrationSubtype"].write(value.integrationSubtype)
        try writer["integrationType"].write(value.integrationType)
        try writer["integrationUri"].write(value.integrationUri)
        try writer["passthroughBehavior"].write(value.passthroughBehavior)
        try writer["payloadFormatVersion"].write(value.payloadFormatVersion)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestTemplates"].writeMap(value.requestTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
        try writer["timeoutInMillis"].write(value.timeoutInMillis)
        try writer["tlsConfig"].write(value.tlsConfig, with: ApiGatewayV2ClientTypes.TlsConfigInput.write(value:to:))
    }
}

extension CreateIntegrationResponseInput {

    static func write(value: CreateIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["integrationResponseKey"].write(value.integrationResponseKey)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
    }
}

extension CreateModelInput {

    static func write(value: CreateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension CreatePortalInput {

    static func write(value: CreatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorization"].write(value.authorization, with: ApiGatewayV2ClientTypes.Authorization.write(value:to:))
        try writer["endpointConfiguration"].write(value.endpointConfiguration, with: ApiGatewayV2ClientTypes.EndpointConfigurationRequest.write(value:to:))
        try writer["includedPortalProductArns"].writeList(value.includedPortalProductArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["logoUri"].write(value.logoUri)
        try writer["portalContent"].write(value.portalContent, with: ApiGatewayV2ClientTypes.PortalContent.write(value:to:))
        try writer["rumAppMonitorName"].write(value.rumAppMonitorName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePortalProductInput {

    static func write(value: CreatePortalProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateProductPageInput {

    static func write(value: CreateProductPageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayContent"].write(value.displayContent, with: ApiGatewayV2ClientTypes.DisplayContent.write(value:to:))
    }
}

extension CreateProductRestEndpointPageInput {

    static func write(value: CreateProductRestEndpointPageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayContent"].write(value.displayContent, with: ApiGatewayV2ClientTypes.EndpointDisplayContent.write(value:to:))
        try writer["restEndpointIdentifier"].write(value.restEndpointIdentifier, with: ApiGatewayV2ClientTypes.RestEndpointIdentifier.write(value:to:))
        try writer["tryItState"].write(value.tryItState)
    }
}

extension CreateRouteInput {

    static func write(value: CreateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeyRequired"].write(value.apiKeyRequired)
        try writer["authorizationScopes"].writeList(value.authorizationScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizationType"].write(value.authorizationType)
        try writer["authorizerId"].write(value.authorizerId)
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["operationName"].write(value.operationName)
        try writer["requestModels"].writeMap(value.requestModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeResponseSelectionExpression"].write(value.routeResponseSelectionExpression)
        try writer["target"].write(value.target)
    }
}

extension CreateRouteResponseInput {

    static func write(value: CreateRouteResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["responseModels"].writeMap(value.responseModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeResponseKey"].write(value.routeResponseKey)
    }
}

extension CreateRoutingRuleInput {

    static func write(value: CreateRoutingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["conditions"].writeList(value.conditions, memberWritingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["priority"].write(value.priority)
    }
}

extension CreateStageInput {

    static func write(value: CreateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLogSettings"].write(value.accessLogSettings, with: ApiGatewayV2ClientTypes.AccessLogSettings.write(value:to:))
        try writer["autoDeploy"].write(value.autoDeploy)
        try writer["clientCertificateId"].write(value.clientCertificateId)
        try writer["defaultRouteSettings"].write(value.defaultRouteSettings, with: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:))
        try writer["deploymentId"].write(value.deploymentId)
        try writer["description"].write(value.description)
        try writer["routeSettings"].writeMap(value.routeSettings, valueWritingClosure: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["stageName"].write(value.stageName)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateVpcLinkInput {

    static func write(value: CreateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ImportApiInput {

    static func write(value: ImportApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension PublishPortalInput {

    static func write(value: PublishPortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension PutPortalProductSharingPolicyInput {

    static func write(value: PutPortalProductSharingPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyDocument"].write(value.policyDocument)
    }
}

extension PutRoutingRuleInput {

    static func write(value: PutRoutingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["conditions"].writeList(value.conditions, memberWritingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["priority"].write(value.priority)
    }
}

extension ReimportApiInput {

    static func write(value: ReimportApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApiInput {

    static func write(value: UpdateApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeySelectionExpression"].write(value.apiKeySelectionExpression)
        try writer["corsConfiguration"].write(value.corsConfiguration, with: ApiGatewayV2ClientTypes.Cors.write(value:to:))
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["disableExecuteApiEndpoint"].write(value.disableExecuteApiEndpoint)
        try writer["disableSchemaValidation"].write(value.disableSchemaValidation)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["name"].write(value.name)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeSelectionExpression"].write(value.routeSelectionExpression)
        try writer["target"].write(value.target)
        try writer["version"].write(value.version)
    }
}

extension UpdateApiMappingInput {

    static func write(value: UpdateApiMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["apiMappingKey"].write(value.apiMappingKey)
        try writer["stage"].write(value.stage)
    }
}

extension UpdateAuthorizerInput {

    static func write(value: UpdateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerCredentialsArn"].write(value.authorizerCredentialsArn)
        try writer["authorizerPayloadFormatVersion"].write(value.authorizerPayloadFormatVersion)
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerType"].write(value.authorizerType)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["enableSimpleResponses"].write(value.enableSimpleResponses)
        try writer["identitySource"].writeList(value.identitySource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
        try writer["jwtConfiguration"].write(value.jwtConfiguration, with: ApiGatewayV2ClientTypes.JWTConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateDeploymentInput {

    static func write(value: UpdateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateDomainNameInput {

    static func write(value: UpdateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainNameConfigurations"].writeList(value.domainNameConfigurations, memberWritingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mutualTlsAuthentication"].write(value.mutualTlsAuthentication, with: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.write(value:to:))
        try writer["routingMode"].write(value.routingMode)
    }
}

extension UpdateIntegrationInput {

    static func write(value: UpdateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionType"].write(value.connectionType)
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["integrationMethod"].write(value.integrationMethod)
        try writer["integrationSubtype"].write(value.integrationSubtype)
        try writer["integrationType"].write(value.integrationType)
        try writer["integrationUri"].write(value.integrationUri)
        try writer["passthroughBehavior"].write(value.passthroughBehavior)
        try writer["payloadFormatVersion"].write(value.payloadFormatVersion)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestTemplates"].writeMap(value.requestTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
        try writer["timeoutInMillis"].write(value.timeoutInMillis)
        try writer["tlsConfig"].write(value.tlsConfig, with: ApiGatewayV2ClientTypes.TlsConfigInput.write(value:to:))
    }
}

extension UpdateIntegrationResponseInput {

    static func write(value: UpdateIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["integrationResponseKey"].write(value.integrationResponseKey)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
    }
}

extension UpdateModelInput {

    static func write(value: UpdateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension UpdatePortalInput {

    static func write(value: UpdatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorization"].write(value.authorization, with: ApiGatewayV2ClientTypes.Authorization.write(value:to:))
        try writer["endpointConfiguration"].write(value.endpointConfiguration, with: ApiGatewayV2ClientTypes.EndpointConfigurationRequest.write(value:to:))
        try writer["includedPortalProductArns"].writeList(value.includedPortalProductArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["logoUri"].write(value.logoUri)
        try writer["portalContent"].write(value.portalContent, with: ApiGatewayV2ClientTypes.PortalContent.write(value:to:))
        try writer["rumAppMonitorName"].write(value.rumAppMonitorName)
    }
}

extension UpdatePortalProductInput {

    static func write(value: UpdatePortalProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["displayOrder"].write(value.displayOrder, with: ApiGatewayV2ClientTypes.DisplayOrder.write(value:to:))
    }
}

extension UpdateProductPageInput {

    static func write(value: UpdateProductPageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayContent"].write(value.displayContent, with: ApiGatewayV2ClientTypes.DisplayContent.write(value:to:))
    }
}

extension UpdateProductRestEndpointPageInput {

    static func write(value: UpdateProductRestEndpointPageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayContent"].write(value.displayContent, with: ApiGatewayV2ClientTypes.EndpointDisplayContent.write(value:to:))
        try writer["tryItState"].write(value.tryItState)
    }
}

extension UpdateRouteInput {

    static func write(value: UpdateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeyRequired"].write(value.apiKeyRequired)
        try writer["authorizationScopes"].writeList(value.authorizationScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizationType"].write(value.authorizationType)
        try writer["authorizerId"].write(value.authorizerId)
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["operationName"].write(value.operationName)
        try writer["requestModels"].writeMap(value.requestModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeResponseSelectionExpression"].write(value.routeResponseSelectionExpression)
        try writer["target"].write(value.target)
    }
}

extension UpdateRouteResponseInput {

    static func write(value: UpdateRouteResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["responseModels"].writeMap(value.responseModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeResponseKey"].write(value.routeResponseKey)
    }
}

extension UpdateStageInput {

    static func write(value: UpdateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLogSettings"].write(value.accessLogSettings, with: ApiGatewayV2ClientTypes.AccessLogSettings.write(value:to:))
        try writer["autoDeploy"].write(value.autoDeploy)
        try writer["clientCertificateId"].write(value.clientCertificateId)
        try writer["defaultRouteSettings"].write(value.defaultRouteSettings, with: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:))
        try writer["deploymentId"].write(value.deploymentId)
        try writer["description"].write(value.description)
        try writer["routeSettings"].writeMap(value.routeSettings, valueWritingClosure: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateVpcLinkInput {

    static func write(value: UpdateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension CreateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension CreateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CreateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameArn = try reader["domainNameArn"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.routingMode = try reader["routingMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension CreateIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension CreateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension CreatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortalOutput()
        value.authorization = try reader["authorization"].readIfPresent(with: ApiGatewayV2ClientTypes.Authorization.read(from:))
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointConfigurationResponse.read(from:))
        value.includedPortalProductArns = try reader["includedPortalProductArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublished = try reader["lastPublished"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublishedDescription = try reader["lastPublishedDescription"].readIfPresent()
        value.portalArn = try reader["portalArn"].readIfPresent()
        value.portalContent = try reader["portalContent"].readIfPresent(with: ApiGatewayV2ClientTypes.PortalContent.read(from:))
        value.portalId = try reader["portalId"].readIfPresent()
        value.publishStatus = try reader["publishStatus"].readIfPresent()
        value.rumAppMonitorName = try reader["rumAppMonitorName"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreatePortalProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortalProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortalProductOutput()
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.displayOrder = try reader["displayOrder"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayOrder.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.portalProductArn = try reader["portalProductArn"].readIfPresent()
        value.portalProductId = try reader["portalProductId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateProductPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProductPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProductPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayContent.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productPageArn = try reader["productPageArn"].readIfPresent()
        value.productPageId = try reader["productPageId"].readIfPresent()
        return value
    }
}

extension CreateProductRestEndpointPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProductRestEndpointPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProductRestEndpointPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productRestEndpointPageArn = try reader["productRestEndpointPageArn"].readIfPresent()
        value.productRestEndpointPageId = try reader["productRestEndpointPageId"].readIfPresent()
        value.restEndpointIdentifier = try reader["restEndpointIdentifier"].readIfPresent(with: ApiGatewayV2ClientTypes.RestEndpointIdentifier.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tryItState = try reader["tryItState"].readIfPresent()
        return value
    }
}

extension CreateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension CreateRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension CreateRoutingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoutingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoutingRuleOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent()
        value.routingRuleArn = try reader["routingRuleArn"].readIfPresent()
        value.routingRuleId = try reader["routingRuleId"].readIfPresent()
        return value
    }
}

extension CreateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension DeleteAccessLogSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessLogSettingsOutput {
        return DeleteAccessLogSettingsOutput()
    }
}

extension DeleteApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiOutput {
        return DeleteApiOutput()
    }
}

extension DeleteApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiMappingOutput {
        return DeleteApiMappingOutput()
    }
}

extension DeleteAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthorizerOutput {
        return DeleteAuthorizerOutput()
    }
}

extension DeleteCorsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCorsConfigurationOutput {
        return DeleteCorsConfigurationOutput()
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeploymentOutput {
        return DeleteDeploymentOutput()
    }
}

extension DeleteDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainNameOutput {
        return DeleteDomainNameOutput()
    }
}

extension DeleteIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationOutput {
        return DeleteIntegrationOutput()
    }
}

extension DeleteIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationResponseOutput {
        return DeleteIntegrationResponseOutput()
    }
}

extension DeleteModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelOutput {
        return DeleteModelOutput()
    }
}

extension DeletePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortalOutput {
        return DeletePortalOutput()
    }
}

extension DeletePortalProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortalProductOutput {
        return DeletePortalProductOutput()
    }
}

extension DeletePortalProductSharingPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortalProductSharingPolicyOutput {
        return DeletePortalProductSharingPolicyOutput()
    }
}

extension DeleteProductPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProductPageOutput {
        return DeleteProductPageOutput()
    }
}

extension DeleteProductRestEndpointPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProductRestEndpointPageOutput {
        return DeleteProductRestEndpointPageOutput()
    }
}

extension DeleteRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteOutput {
        return DeleteRouteOutput()
    }
}

extension DeleteRouteRequestParameterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteRequestParameterOutput {
        return DeleteRouteRequestParameterOutput()
    }
}

extension DeleteRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteResponseOutput {
        return DeleteRouteResponseOutput()
    }
}

extension DeleteRouteSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteSettingsOutput {
        return DeleteRouteSettingsOutput()
    }
}

extension DeleteRoutingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoutingRuleOutput {
        return DeleteRoutingRuleOutput()
    }
}

extension DeleteStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStageOutput {
        return DeleteStageOutput()
    }
}

extension DeleteVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcLinkOutput {
        return DeleteVpcLinkOutput()
    }
}

extension DisablePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisablePortalOutput {
        return DisablePortalOutput()
    }
}

extension ExportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportApiOutput {
        var value = ExportApiOutput()
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension GetApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension GetApiMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiMappingsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.ApiMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetApisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApisOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Api.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension GetAuthorizersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Authorizer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension GetDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameArn = try reader["domainNameArn"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.routingMode = try reader["routingMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNamesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainName.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension GetIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension GetIntegrationResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationResponsesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.IntegrationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Integration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension GetModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Model.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelTemplateOutput()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension GetPortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortalOutput()
        value.authorization = try reader["authorization"].readIfPresent(with: ApiGatewayV2ClientTypes.Authorization.read(from:))
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointConfigurationResponse.read(from:))
        value.includedPortalProductArns = try reader["includedPortalProductArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublished = try reader["lastPublished"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublishedDescription = try reader["lastPublishedDescription"].readIfPresent()
        value.portalArn = try reader["portalArn"].readIfPresent()
        value.portalContent = try reader["portalContent"].readIfPresent(with: ApiGatewayV2ClientTypes.PortalContent.read(from:))
        value.portalId = try reader["portalId"].readIfPresent()
        value.preview = try reader["preview"].readIfPresent(with: ApiGatewayV2ClientTypes.Preview.read(from:))
        value.publishStatus = try reader["publishStatus"].readIfPresent()
        value.rumAppMonitorName = try reader["rumAppMonitorName"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetPortalProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortalProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortalProductOutput()
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.displayOrder = try reader["displayOrder"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayOrder.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.portalProductArn = try reader["portalProductArn"].readIfPresent()
        value.portalProductId = try reader["portalProductId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetPortalProductSharingPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortalProductSharingPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortalProductSharingPolicyOutput()
        value.policyDocument = try reader["policyDocument"].readIfPresent()
        value.portalProductId = try reader["portalProductId"].readIfPresent()
        return value
    }
}

extension GetProductPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProductPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProductPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayContent.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productPageArn = try reader["productPageArn"].readIfPresent()
        value.productPageId = try reader["productPageId"].readIfPresent()
        return value
    }
}

extension GetProductRestEndpointPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProductRestEndpointPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProductRestEndpointPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productRestEndpointPageArn = try reader["productRestEndpointPageArn"].readIfPresent()
        value.productRestEndpointPageId = try reader["productRestEndpointPageId"].readIfPresent()
        value.rawDisplayContent = try reader["rawDisplayContent"].readIfPresent()
        value.restEndpointIdentifier = try reader["restEndpointIdentifier"].readIfPresent(with: ApiGatewayV2ClientTypes.RestEndpointIdentifier.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tryItState = try reader["tryItState"].readIfPresent()
        return value
    }
}

extension GetRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension GetRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension GetRouteResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteResponsesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RouteResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoutesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetRoutingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoutingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoutingRuleOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent()
        value.routingRuleArn = try reader["routingRuleArn"].readIfPresent()
        value.routingRuleId = try reader["routingRuleId"].readIfPresent()
        return value
    }
}

extension GetStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetStagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStagesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Stage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTagsOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension GetVpcLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.VpcLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ImportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPortalProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortalProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortalProductsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.PortalProductSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPortalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortalsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.PortalSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProductPagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProductPagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProductPagesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.ProductPageSummaryNoBody.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProductRestEndpointPagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProductRestEndpointPagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProductRestEndpointPagesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRoutingRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoutingRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoutingRulesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.routingRules = try reader["routingRules"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PreviewPortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PreviewPortalOutput {
        return PreviewPortalOutput()
    }
}

extension PublishPortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishPortalOutput {
        return PublishPortalOutput()
    }
}

extension PutPortalProductSharingPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPortalProductSharingPolicyOutput {
        return PutPortalProductSharingPolicyOutput()
    }
}

extension PutRoutingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRoutingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRoutingRuleOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent()
        value.routingRuleArn = try reader["routingRuleArn"].readIfPresent()
        value.routingRuleId = try reader["routingRuleId"].readIfPresent()
        return value
    }
}

extension ReimportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReimportApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReimportApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResetAuthorizersCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetAuthorizersCacheOutput {
        return ResetAuthorizersCacheOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension UpdateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension UpdateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameArn = try reader["domainNameArn"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.routingMode = try reader["routingMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension UpdateIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension UpdateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension UpdatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortalOutput()
        value.authorization = try reader["authorization"].readIfPresent(with: ApiGatewayV2ClientTypes.Authorization.read(from:))
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointConfigurationResponse.read(from:))
        value.includedPortalProductArns = try reader["includedPortalProductArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublished = try reader["lastPublished"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublishedDescription = try reader["lastPublishedDescription"].readIfPresent()
        value.portalArn = try reader["portalArn"].readIfPresent()
        value.portalContent = try reader["portalContent"].readIfPresent(with: ApiGatewayV2ClientTypes.PortalContent.read(from:))
        value.portalId = try reader["portalId"].readIfPresent()
        value.preview = try reader["preview"].readIfPresent(with: ApiGatewayV2ClientTypes.Preview.read(from:))
        value.publishStatus = try reader["publishStatus"].readIfPresent()
        value.rumAppMonitorName = try reader["rumAppMonitorName"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdatePortalProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortalProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortalProductOutput()
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.displayOrder = try reader["displayOrder"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayOrder.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.portalProductArn = try reader["portalProductArn"].readIfPresent()
        value.portalProductId = try reader["portalProductId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateProductPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProductPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProductPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.DisplayContent.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productPageArn = try reader["productPageArn"].readIfPresent()
        value.productPageId = try reader["productPageId"].readIfPresent()
        return value
    }
}

extension UpdateProductRestEndpointPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProductRestEndpointPageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProductRestEndpointPageOutput()
        value.displayContent = try reader["displayContent"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointDisplayContentResponse.read(from:))
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.productRestEndpointPageArn = try reader["productRestEndpointPageArn"].readIfPresent()
        value.productRestEndpointPageId = try reader["productRestEndpointPageId"].readIfPresent()
        value.restEndpointIdentifier = try reader["restEndpointIdentifier"].readIfPresent(with: ApiGatewayV2ClientTypes.RestEndpointIdentifier.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tryItState = try reader["tryItState"].readIfPresent()
        return value
    }
}

extension UpdateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension UpdateRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension UpdateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

enum CreateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortalProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProductPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProductRestEndpointPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoutingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessLogSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCorsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortalProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortalProductSharingPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProductPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProductRestEndpointPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteRequestParameterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoutingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisablePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortalProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortalProductSharingPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProductPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProductRestEndpointPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoutingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortalProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProductPagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProductRestEndpointPagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoutingRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PreviewPortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishPortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPortalProductSharingPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRoutingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReimportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetAuthorizersCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortalProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProductPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProductRestEndpointPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.limitType = try reader["limitType"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApiGatewayV2ClientTypes.Cors {

    static func write(value: ApiGatewayV2ClientTypes.Cors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowCredentials"].write(value.allowCredentials)
        try writer["allowHeaders"].writeList(value.allowHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowMethods"].writeList(value.allowMethods, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowOrigins"].writeList(value.allowOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["exposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxAge"].write(value.maxAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Cors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Cors()
        value.allowCredentials = try reader["allowCredentials"].readIfPresent()
        value.allowHeaders = try reader["allowHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowMethods = try reader["allowMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowOrigins = try reader["allowOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exposeHeaders = try reader["exposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxAge = try reader["maxAge"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.JWTConfiguration {

    static func write(value: ApiGatewayV2ClientTypes.JWTConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audience"].writeList(value.audience, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["issuer"].write(value.issuer)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.JWTConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.JWTConfiguration()
        value.audience = try reader["audience"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.issuer = try reader["issuer"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.DomainNameConfiguration {

    static func write(value: ApiGatewayV2ClientTypes.DomainNameConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiGatewayDomainName"].write(value.apiGatewayDomainName)
        try writer["certificateArn"].write(value.certificateArn)
        try writer["certificateName"].write(value.certificateName)
        try writer["certificateUploadDate"].writeTimestamp(value.certificateUploadDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["domainNameStatus"].write(value.domainNameStatus)
        try writer["domainNameStatusMessage"].write(value.domainNameStatusMessage)
        try writer["endpointType"].write(value.endpointType)
        try writer["hostedZoneId"].write(value.hostedZoneId)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["ownershipVerificationCertificateArn"].write(value.ownershipVerificationCertificateArn)
        try writer["securityPolicy"].write(value.securityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DomainNameConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DomainNameConfiguration()
        value.apiGatewayDomainName = try reader["apiGatewayDomainName"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.endpointType = try reader["endpointType"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.MutualTlsAuthentication {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.MutualTlsAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.MutualTlsAuthentication()
        value.truststoreUri = try reader["truststoreUri"].readIfPresent()
        value.truststoreVersion = try reader["truststoreVersion"].readIfPresent()
        value.truststoreWarnings = try reader["truststoreWarnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.TlsConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.TlsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.TlsConfig()
        value.serverNameToVerify = try reader["serverNameToVerify"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Authorization {

    static func write(value: ApiGatewayV2ClientTypes.Authorization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cognitoConfig"].write(value.cognitoConfig, with: ApiGatewayV2ClientTypes.CognitoConfig.write(value:to:))
        try writer["none"].write(value.`none`, with: ApiGatewayV2ClientTypes.None.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Authorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Authorization()
        value.cognitoConfig = try reader["cognitoConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.CognitoConfig.read(from:))
        value.`none` = try reader["none"].readIfPresent(with: ApiGatewayV2ClientTypes.None.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.None {

    static func write(value: ApiGatewayV2ClientTypes.None?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.None {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ApiGatewayV2ClientTypes.None()
    }
}

extension ApiGatewayV2ClientTypes.CognitoConfig {

    static func write(value: ApiGatewayV2ClientTypes.CognitoConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appClientId"].write(value.appClientId)
        try writer["userPoolArn"].write(value.userPoolArn)
        try writer["userPoolDomain"].write(value.userPoolDomain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.CognitoConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.CognitoConfig()
        value.appClientId = try reader["appClientId"].readIfPresent() ?? ""
        value.userPoolArn = try reader["userPoolArn"].readIfPresent() ?? ""
        value.userPoolDomain = try reader["userPoolDomain"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.EndpointConfigurationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.EndpointConfigurationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.EndpointConfigurationResponse()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.portalDefaultDomainName = try reader["portalDefaultDomainName"].readIfPresent() ?? ""
        value.portalDomainHostedZoneId = try reader["portalDomainHostedZoneId"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.PortalContent {

    static func write(value: ApiGatewayV2ClientTypes.PortalContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["theme"].write(value.theme, with: ApiGatewayV2ClientTypes.PortalTheme.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.PortalContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.PortalContent()
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.theme = try reader["theme"].readIfPresent(with: ApiGatewayV2ClientTypes.PortalTheme.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.PortalTheme {

    static func write(value: ApiGatewayV2ClientTypes.PortalTheme?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customColors"].write(value.customColors, with: ApiGatewayV2ClientTypes.CustomColors.write(value:to:))
        try writer["logoLastUploaded"].writeTimestamp(value.logoLastUploaded, format: SmithyTimestamps.TimestampFormat.dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.PortalTheme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.PortalTheme()
        value.customColors = try reader["customColors"].readIfPresent(with: ApiGatewayV2ClientTypes.CustomColors.read(from:))
        value.logoLastUploaded = try reader["logoLastUploaded"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ApiGatewayV2ClientTypes.CustomColors {

    static func write(value: ApiGatewayV2ClientTypes.CustomColors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accentColor"].write(value.accentColor)
        try writer["backgroundColor"].write(value.backgroundColor)
        try writer["errorValidationColor"].write(value.errorValidationColor)
        try writer["headerColor"].write(value.headerColor)
        try writer["navigationColor"].write(value.navigationColor)
        try writer["textColor"].write(value.textColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.CustomColors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.CustomColors()
        value.accentColor = try reader["accentColor"].readIfPresent() ?? ""
        value.backgroundColor = try reader["backgroundColor"].readIfPresent() ?? ""
        value.errorValidationColor = try reader["errorValidationColor"].readIfPresent() ?? ""
        value.headerColor = try reader["headerColor"].readIfPresent() ?? ""
        value.navigationColor = try reader["navigationColor"].readIfPresent() ?? ""
        value.textColor = try reader["textColor"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.StatusException {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.StatusException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.StatusException()
        value.exception = try reader["exception"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.DisplayOrder {

    static func write(value: ApiGatewayV2ClientTypes.DisplayOrder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contents"].writeList(value.contents, memberWritingClosure: ApiGatewayV2ClientTypes.Section.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["overviewPageArn"].write(value.overviewPageArn)
        try writer["productPageArns"].writeList(value.productPageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DisplayOrder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DisplayOrder()
        value.contents = try reader["contents"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Section.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.overviewPageArn = try reader["overviewPageArn"].readIfPresent()
        value.productPageArns = try reader["productPageArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.Section {

    static func write(value: ApiGatewayV2ClientTypes.Section?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["productRestEndpointPageArns"].writeList(value.productRestEndpointPageArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sectionName"].write(value.sectionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Section {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Section()
        value.productRestEndpointPageArns = try reader["productRestEndpointPageArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sectionName = try reader["sectionName"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.DisplayContent {

    static func write(value: ApiGatewayV2ClientTypes.DisplayContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DisplayContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DisplayContent()
        value.body = try reader["body"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.EndpointDisplayContentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.EndpointDisplayContentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.EndpointDisplayContentResponse()
        value.body = try reader["body"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.operationName = try reader["operationName"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RestEndpointIdentifier {

    static func write(value: ApiGatewayV2ClientTypes.RestEndpointIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifierParts"].write(value.identifierParts, with: ApiGatewayV2ClientTypes.IdentifierParts.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RestEndpointIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RestEndpointIdentifier()
        value.identifierParts = try reader["identifierParts"].readIfPresent(with: ApiGatewayV2ClientTypes.IdentifierParts.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.IdentifierParts {

    static func write(value: ApiGatewayV2ClientTypes.IdentifierParts?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["method"].write(value.method)
        try writer["path"].write(value.path)
        try writer["restApiId"].write(value.restApiId)
        try writer["stage"].write(value.stage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.IdentifierParts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.IdentifierParts()
        value.method = try reader["method"].readIfPresent() ?? ""
        value.path = try reader["path"].readIfPresent() ?? ""
        value.restApiId = try reader["restApiId"].readIfPresent() ?? ""
        value.stage = try reader["stage"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.ParameterConstraints {

    static func write(value: ApiGatewayV2ClientTypes.ParameterConstraints?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["required"].write(value.`required`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ParameterConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ParameterConstraints()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleAction {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invokeApi"].write(value.invokeApi, with: ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleAction()
        value.invokeApi = try reader["invokeApi"].readIfPresent(with: ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["stage"].write(value.stage)
        try writer["stripBasePath"].write(value.stripBasePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleActionInvokeApi()
        value.apiId = try reader["apiId"].readIfPresent() ?? ""
        value.stage = try reader["stage"].readIfPresent() ?? ""
        value.stripBasePath = try reader["stripBasePath"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleCondition {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchBasePaths"].write(value.matchBasePaths, with: ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths.write(value:to:))
        try writer["matchHeaders"].write(value.matchHeaders, with: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleCondition()
        value.matchBasePaths = try reader["matchBasePaths"].readIfPresent(with: ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths.read(from:))
        value.matchHeaders = try reader["matchHeaders"].readIfPresent(with: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["anyOf"].writeList(value.anyOf, memberWritingClosure: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleMatchHeaders()
        value.anyOf = try reader["anyOf"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["header"].write(value.header)
        try writer["valueGlob"].write(value.valueGlob)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleMatchHeaderValue()
        value.header = try reader["header"].readIfPresent() ?? ""
        value.valueGlob = try reader["valueGlob"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths {

    static func write(value: ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["anyOf"].writeList(value.anyOf, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRuleMatchBasePaths()
        value.anyOf = try reader["anyOf"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApiGatewayV2ClientTypes.AccessLogSettings {

    static func write(value: ApiGatewayV2ClientTypes.AccessLogSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationArn"].write(value.destinationArn)
        try writer["format"].write(value.format)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.AccessLogSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.AccessLogSettings()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RouteSettings {

    static func write(value: ApiGatewayV2ClientTypes.RouteSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTraceEnabled"].write(value.dataTraceEnabled)
        try writer["detailedMetricsEnabled"].write(value.detailedMetricsEnabled)
        try writer["loggingLevel"].write(value.loggingLevel)
        try writer["throttlingBurstLimit"].write(value.throttlingBurstLimit)
        try writer["throttlingRateLimit"].write(value.throttlingRateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RouteSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RouteSettings()
        value.dataTraceEnabled = try reader["dataTraceEnabled"].readIfPresent()
        value.detailedMetricsEnabled = try reader["detailedMetricsEnabled"].readIfPresent()
        value.loggingLevel = try reader["loggingLevel"].readIfPresent()
        value.throttlingBurstLimit = try reader["throttlingBurstLimit"].readIfPresent()
        value.throttlingRateLimit = try reader["throttlingRateLimit"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.ApiMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ApiMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ApiMapping()
        value.apiId = try reader["apiId"].readIfPresent() ?? ""
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Api {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Api {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Api()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.Authorizer {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Authorizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Authorizer()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Deployment()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.DomainName {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DomainName {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DomainName()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.domainNameArn = try reader["domainNameArn"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.routingMode = try reader["routingMode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.IntegrationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.IntegrationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.IntegrationResponse()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent() ?? ""
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Integration {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Integration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Integration()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.Model {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Model()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Preview {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Preview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Preview()
        value.previewStatus = try reader["previewStatus"].readIfPresent() ?? .sdkUnknown("")
        value.previewUrl = try reader["previewUrl"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.RouteResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RouteResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RouteResponse()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Route {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Route {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Route()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent() ?? ""
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Stage {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Stage()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent() ?? ""
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.VpcLink {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.VpcLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.VpcLink()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent() ?? ""
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.PortalProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.PortalProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.PortalProductSummary()
        value.description = try reader["description"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.portalProductArn = try reader["portalProductArn"].readIfPresent() ?? ""
        value.portalProductId = try reader["portalProductId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.PortalSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.PortalSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.PortalSummary()
        value.authorization = try reader["authorization"].readIfPresent(with: ApiGatewayV2ClientTypes.Authorization.read(from:))
        value.endpointConfiguration = try reader["endpointConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.EndpointConfigurationResponse.read(from:))
        value.includedPortalProductArns = try reader["includedPortalProductArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastPublished = try reader["lastPublished"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastPublishedDescription = try reader["lastPublishedDescription"].readIfPresent()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.portalContent = try reader["portalContent"].readIfPresent(with: ApiGatewayV2ClientTypes.PortalContent.read(from:))
        value.portalId = try reader["portalId"].readIfPresent() ?? ""
        value.preview = try reader["preview"].readIfPresent(with: ApiGatewayV2ClientTypes.Preview.read(from:))
        value.publishStatus = try reader["publishStatus"].readIfPresent()
        value.rumAppMonitorName = try reader["rumAppMonitorName"].readIfPresent()
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.ProductPageSummaryNoBody {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ProductPageSummaryNoBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ProductPageSummaryNoBody()
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.pageTitle = try reader["pageTitle"].readIfPresent() ?? ""
        value.productPageArn = try reader["productPageArn"].readIfPresent() ?? ""
        value.productPageId = try reader["productPageId"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ProductRestEndpointPageSummaryNoBody()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.operationName = try reader["operationName"].readIfPresent()
        value.productRestEndpointPageArn = try reader["productRestEndpointPageArn"].readIfPresent() ?? ""
        value.productRestEndpointPageId = try reader["productRestEndpointPageId"].readIfPresent() ?? ""
        value.restEndpointIdentifier = try reader["restEndpointIdentifier"].readIfPresent(with: ApiGatewayV2ClientTypes.RestEndpointIdentifier.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusException = try reader["statusException"].readIfPresent(with: ApiGatewayV2ClientTypes.StatusException.read(from:))
        value.tryItState = try reader["tryItState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ApiGatewayV2ClientTypes.RoutingRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RoutingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RoutingRule()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RoutingRuleCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent()
        value.routingRuleArn = try reader["routingRuleArn"].readIfPresent()
        value.routingRuleId = try reader["routingRuleId"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput {

    static func write(value: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["truststoreUri"].write(value.truststoreUri)
        try writer["truststoreVersion"].write(value.truststoreVersion)
    }
}

extension ApiGatewayV2ClientTypes.TlsConfigInput {

    static func write(value: ApiGatewayV2ClientTypes.TlsConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverNameToVerify"].write(value.serverNameToVerify)
    }
}

extension ApiGatewayV2ClientTypes.EndpointConfigurationRequest {

    static func write(value: ApiGatewayV2ClientTypes.EndpointConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acmManaged"].write(value.acmManaged, with: ApiGatewayV2ClientTypes.ACMManaged.write(value:to:))
        try writer["none"].write(value.`none`, with: ApiGatewayV2ClientTypes.None.write(value:to:))
    }
}

extension ApiGatewayV2ClientTypes.ACMManaged {

    static func write(value: ApiGatewayV2ClientTypes.ACMManaged?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["domainName"].write(value.domainName)
    }
}

extension ApiGatewayV2ClientTypes.EndpointDisplayContent {

    static func write(value: ApiGatewayV2ClientTypes.EndpointDisplayContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["none"].write(value.`none`, with: ApiGatewayV2ClientTypes.None.write(value:to:))
        try writer["overrides"].write(value.overrides, with: ApiGatewayV2ClientTypes.DisplayContentOverrides.write(value:to:))
    }
}

extension ApiGatewayV2ClientTypes.DisplayContentOverrides {

    static func write(value: ApiGatewayV2ClientTypes.DisplayContentOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["endpoint"].write(value.endpoint)
        try writer["operationName"].write(value.operationName)
    }
}

public enum ApiGatewayV2ClientTypes {}
