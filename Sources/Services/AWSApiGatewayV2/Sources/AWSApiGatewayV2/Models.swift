//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

public struct DeleteAccessLogSettingsOutput {

    public init() { }
}

public struct DeleteApiMappingOutput {

    public init() { }
}

public struct DeleteApiOutput {

    public init() { }
}

public struct DeleteAuthorizerOutput {

    public init() { }
}

public struct DeleteCorsConfigurationOutput {

    public init() { }
}

public struct DeleteDeploymentOutput {

    public init() { }
}

public struct DeleteDomainNameOutput {

    public init() { }
}

public struct DeleteIntegrationOutput {

    public init() { }
}

public struct DeleteIntegrationResponseOutput {

    public init() { }
}

public struct DeleteModelOutput {

    public init() { }
}

public struct DeleteRouteOutput {

    public init() { }
}

public struct DeleteRouteRequestParameterOutput {

    public init() { }
}

public struct DeleteRouteResponseOutput {

    public init() { }
}

public struct DeleteRouteSettingsOutput {

    public init() { }
}

public struct DeleteStageOutput {

    public init() { }
}

public struct ResetAuthorizersCacheOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public struct Cors {
        /// Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
        public var allowCredentials: Swift.Bool?
        /// Represents a collection of allowed headers. Supported only for HTTP APIs.
        public var allowHeaders: [Swift.String]?
        /// Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
        public var allowMethods: [Swift.String]?
        /// Represents a collection of allowed origins. Supported only for HTTP APIs.
        public var allowOrigins: [Swift.String]?
        /// Represents a collection of exposed headers. Supported only for HTTP APIs.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// Represents a protocol type.
    public enum ProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .http,
                .websocket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents an API.
    public struct Api {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public var apiGatewayManaged: Swift.Bool?
        /// The API ID.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
        public var apiKeySelectionExpression: Swift.String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
        /// The timestamp when the API was created.
        public var createdDate: Foundation.Date?
        /// The description of the API.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public var disableSchemaValidation: Swift.Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public var importInfo: [Swift.String]?
        /// The name of the API.
        /// This member is required.
        public var name: Swift.String?
        /// The API protocol.
        /// This member is required.
        public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        /// This member is required.
        public var routeSelectionExpression: Swift.String?
        /// A collection of tags associated with the API.
        public var tags: [Swift.String: Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init(
            apiEndpoint: Swift.String? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool? = nil,
            disableSchemaValidation: Swift.Bool? = nil,
            importInfo: [Swift.String]? = nil,
            name: Swift.String? = nil,
            protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
            routeSelectionExpression: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an API mapping.
    public struct ApiMapping {
        /// The API identifier.
        /// This member is required.
        public var apiId: Swift.String?
        /// The API mapping identifier.
        public var apiMappingId: Swift.String?
        /// The API mapping key.
        public var apiMappingKey: Swift.String?
        /// The API stage.
        /// This member is required.
        public var stage: Swift.String?

        public init(
            apiId: Swift.String? = nil,
            apiMappingId: Swift.String? = nil,
            apiMappingKey: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jwt
        case request
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .jwt,
                .request
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jwt: return "JWT"
            case .request: return "REQUEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public struct JWTConfiguration {
        /// A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See [RFC 7519](https://tools.ietf.org/html/rfc7519#section-4.1.3). Supported only for HTTP APIs.
        public var audience: [Swift.String]?
        /// The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.{region}.amazonaws.com/{userPoolId} . Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var issuer: Swift.String?

        public init(
            audience: [Swift.String]? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.audience = audience
            self.issuer = issuer
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an authorizer.
    public struct Authorizer {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public var authorizerCredentialsArn: Swift.String?
        /// The authorizer identifier.
        public var authorizerId: Swift.String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
        public var authorizerPayloadFormatVersion: Swift.String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public var authorizerUri: Swift.String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
        public var enableSimpleResponses: Swift.Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public var identitySource: [Swift.String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
        /// The name of the authorizer.
        /// This member is required.
        public var name: Swift.String?

        public init(
            authorizerCredentialsArn: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            authorizerPayloadFormatVersion: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
            authorizerUri: Swift.String? = nil,
            enableSimpleResponses: Swift.Bool? = nil,
            identitySource: [Swift.String]? = nil,
            identityValidationExpression: Swift.String? = nil,
            jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
            name: Swift.String? = nil
        )
        {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// Represents a deployment status.
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .deployed,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// An immutable representation of an API that can be called by users. A Deployment must be associated with a Stage for it to be callable over the internet.
    public struct Deployment {
        /// Specifies whether a deployment was automatically released.
        public var autoDeployed: Swift.Bool?
        /// The date and time when the Deployment resource was created.
        public var createdDate: Foundation.Date?
        /// The identifier for the deployment.
        public var deploymentId: Swift.String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public var deploymentStatusMessage: Swift.String?
        /// The description for the deployment.
        public var description: Swift.String?

        public init(
            autoDeployed: Swift.Bool? = nil,
            createdDate: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
            deploymentStatusMessage: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an endpoint type.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edge
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// The domain name configuration.
    public struct DomainNameConfiguration {
        /// A domain name for the API.
        public var apiGatewayDomainName: Swift.String?
        /// An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: Foundation.Date?
        /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the domain name migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint type.
        public var endpointType: ApiGatewayV2ClientTypes.EndpointType?
        /// The Amazon Route 53 Hosted Zone ID of the endpoint.
        public var hostedZoneId: Swift.String?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy?

        public init(
            apiGatewayDomainName: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: Foundation.Date? = nil,
            domainNameStatus: ApiGatewayV2ClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointType: ApiGatewayV2ClientTypes.EndpointType? = nil,
            hostedZoneId: Swift.String? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            securityPolicy: ApiGatewayV2ClientTypes.SecurityPolicy? = nil
        )
        {
            self.apiGatewayDomainName = apiGatewayDomainName
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointType = endpointType
            self.hostedZoneId = hostedZoneId
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.securityPolicy = securityPolicy
        }
    }

}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthentication {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a domain name.
    public struct DomainName {
        /// The API mapping selection expression.
        public var apiMappingSelectionExpression: Swift.String?
        /// The name of the DomainName resource.
        /// This member is required.
        public var domainName: Swift.String?
        /// The domain name configurations.
        public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public var tags: [Swift.String: Swift.String]?

        public init(
            apiMappingSelectionExpression: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
            mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// Represents a connection type.
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Specifies how to handle response payload content type conversions. Supported only for WebSocket APIs.
    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents an API method integration type.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// Represents passthrough behavior for an integration response. Supported only for WebSocket APIs.
    public enum PassthroughBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case never
        case whenNoMatch
        case whenNoTemplates
        case sdkUnknown(Swift.String)

        public static var allCases: [PassthroughBehavior] {
            return [
                .never,
                .whenNoMatch,
                .whenNoTemplates
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .never: return "NEVER"
            case .whenNoMatch: return "WHEN_NO_MATCH"
            case .whenNoTemplates: return "WHEN_NO_TEMPLATES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfig {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration.
    public struct Integration {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public var apiGatewayManaged: Swift.Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public var credentialsArn: Swift.String?
        /// Represents the description of an integration.
        public var description: Swift.String?
        /// Represents the identifier of an integration.
        public var integrationId: Swift.String?
        /// Specifies the integration's HTTP method type.
        public var integrationMethod: Swift.String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
        public var integrationResponseSelectionExpression: Swift.String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
        public var integrationSubtype: Swift.String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
        public var integrationUri: Swift.String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
        public var payloadFormatVersion: Swift.String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var requestParameters: [Swift.String: Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public var requestTemplates: [Swift.String: Swift.String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
        public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public var templateSelectionExpression: Swift.String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public var timeoutInMillis: Swift.Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            connectionId: Swift.String? = nil,
            connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            credentialsArn: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationId: Swift.String? = nil,
            integrationMethod: Swift.String? = nil,
            integrationResponseSelectionExpression: Swift.String? = nil,
            integrationSubtype: Swift.String? = nil,
            integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
            integrationUri: Swift.String? = nil,
            passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
            payloadFormatVersion: Swift.String? = nil,
            requestParameters: [Swift.String: Swift.String]? = nil,
            requestTemplates: [Swift.String: Swift.String]? = nil,
            responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
            templateSelectionExpression: Swift.String? = nil,
            timeoutInMillis: Swift.Int? = nil,
            tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an integration response.
    public struct IntegrationResponse {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
        /// The integration response ID.
        public var integrationResponseId: Swift.String?
        /// The integration response key.
        /// This member is required.
        public var integrationResponseKey: Swift.String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String: Swift.String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String: Swift.String]?
        /// The template selection expressions for the integration response.
        public var templateSelectionExpression: Swift.String?

        public init(
            contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
            integrationResponseId: Swift.String? = nil,
            integrationResponseKey: Swift.String? = nil,
            responseParameters: [Swift.String: Swift.String]? = nil,
            responseTemplates: [Swift.String: Swift.String]? = nil,
            templateSelectionExpression: Swift.String? = nil
        )
        {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a data model for an API. Supported only for WebSocket APIs. See [Create Models and Mapping Templates for Request and Response Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html).
    public struct Model {
        /// The content-type for the model, for example, "application/json".
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The model identifier.
        public var modelId: Swift.String?
        /// The name of the model. Must be alphanumeric.
        /// This member is required.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public var schema: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// The authorization type. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer. For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public enum AuthorizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case custom
        case jwt
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationType] {
            return [
                .awsIam,
                .custom,
                .jwt,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .custom: return "CUSTOM"
            case .jwt: return "JWT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Validation constraints imposed on parameters of a request (path, query string, headers).
    public struct ParameterConstraints {
        /// Whether or not the parameter is required.
        public var `required`: Swift.Bool?

        public init(
            `required`: Swift.Bool? = nil
        )
        {
            self.`required` = `required`
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a route.
    public struct Route {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public var authorizerId: Swift.String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// The operation name for the route.
        public var operationName: Swift.String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public var requestModels: [Swift.String: Swift.String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// The route ID.
        public var routeId: Swift.String?
        /// The route key for the route.
        /// This member is required.
        public var routeKey: Swift.String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public var routeResponseSelectionExpression: Swift.String?
        /// The target for the route.
        public var target: Swift.String?

        public init(
            apiGatewayManaged: Swift.Bool? = nil,
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
            authorizerId: Swift.String? = nil,
            modelSelectionExpression: Swift.String? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String: Swift.String]? = nil,
            requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeId: Swift.String? = nil,
            routeKey: Swift.String? = nil,
            routeResponseSelectionExpression: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents a route response.
    public struct RouteResponse {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public var modelSelectionExpression: Swift.String?
        /// Represents the response models of a route response.
        public var responseModels: [Swift.String: Swift.String]?
        /// Represents the response parameters of a route response.
        public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
        /// Represents the identifier of a route response.
        public var routeResponseId: Swift.String?
        /// Represents the route response key of a route response.
        /// This member is required.
        public var routeResponseKey: Swift.String?

        public init(
            modelSelectionExpression: Swift.String? = nil,
            responseModels: [Swift.String: Swift.String]? = nil,
            responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
            routeResponseId: Swift.String? = nil,
            routeResponseKey: Swift.String? = nil
        )
        {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Settings for logging access in a stage.
    public struct AccessLogSettings {
        /// The ARN of the CloudWatch Logs log group to receive access logs.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// The logging level.
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a collection of route settings.
    public struct RouteSettings {
        /// Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool?
        /// Specifies whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool?
        /// Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public var loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel?
        /// Specifies the throttling burst limit.
        public var throttlingBurstLimit: Swift.Int?
        /// Specifies the throttling rate limit.
        public var throttlingRateLimit: Swift.Double?

        public init(
            dataTraceEnabled: Swift.Bool? = nil,
            detailedMetricsEnabled: Swift.Bool? = nil,
            loggingLevel: ApiGatewayV2ClientTypes.LoggingLevel? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil
        )
        {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }

}

extension ApiGatewayV2ClientTypes {
    /// Represents an API stage.
    public struct Stage {
        /// Settings for logging access in this stage.
        public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public var apiGatewayManaged: Swift.Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public var autoDeploy: Swift.Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: Foundation.Date?
        /// Default route settings for the stage.
        public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// The timestamp when the stage was last updated.
        public var lastUpdatedDate: Foundation.Date?
        /// Route settings for the stage, by routeKey.
        public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
        /// The name of the stage.
        /// This member is required.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var stageVariables: [Swift.String: Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            autoDeploy: Swift.Bool? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }
    }

}

extension ApiGatewayV2ClientTypes {

    /// The status of the VPC link.
    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case failed
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {

    /// The version of the VPC link.
    public enum VpcLinkVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkVersion] {
            return [
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApiGatewayV2ClientTypes {
    /// Represents a VPC link.
    public struct VpcLink {
        /// The timestamp when the VPC link was created.
        public var createdDate: Foundation.Date?
        /// The name of the VPC link.
        /// This member is required.
        public var name: Swift.String?
        /// A list of security group IDs for the VPC link.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs to include in the VPC link.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// Tags for the VPC link.
        public var tags: [Swift.String: Swift.String]?
        /// The ID of the VPC link.
        /// This member is required.
        public var vpcLinkId: Swift.String?
        /// The status of the VPC link.
        public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public var vpcLinkStatusMessage: Swift.String?
        /// The version of the VPC link.
        public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

        public init(
            createdDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            vpcLinkId: Swift.String? = nil,
            vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
            vpcLinkStatusMessage: Swift.String? = nil,
            vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
        )
        {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }
    }

}

public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource specified in the request was not found. See the message field for more information.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
        /// The resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// A limit has been exceeded. See the accompanying error message for details.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit type.
        public internal(set) var limitType: Swift.String? = nil
        /// Describes the error encountered.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.limitType = limitType
        self.properties.message = message
    }
}

/// Creates a new Api resource to represent an API.
public struct CreateApiInput {
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    /// This member is required.
    public var name: Swift.String?
    /// The API protocol.
    /// This member is required.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?
    /// This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.protocolType = protocolType
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.target = target
        self.version = version
    }
}

public struct CreateApiOutput {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Creates a new ApiMapping resource to represent an API mapping.
public struct CreateApiMappingInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    /// This member is required.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

public struct CreateApiMappingOutput {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

/// Creates a new Authorizer resource to represent an authorizer.
public struct CreateAuthorizerInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    /// This member is required.
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    /// This member is required.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct CreateAuthorizerOutput {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

/// Creates a new Deployment resource to represent a deployment.
public struct CreateDeploymentInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The name of the Stage resource for the Deployment resource to create.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        description: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.stageName = stageName
    }
}

public struct CreateDeploymentOutput {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

extension ApiGatewayV2ClientTypes {
    public struct MutualTlsAuthenticationInput {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?

        public init(
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

/// Creates a new DomainName resource to represent a domain name.
public struct CreateDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

public struct CreateDomainNameOutput {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

extension ApiGatewayV2ClientTypes {
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public struct TlsConfigInput {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public var serverNameToVerify: Swift.String?

        public init(
            serverNameToVerify: Swift.String? = nil
        )
        {
            self.serverNameToVerify = serverNameToVerify
        }
    }

}

/// Creates a new Integration resource to represent an integration.
public struct CreateIntegrationInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration.
    public var description: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    /// This member is required.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct CreateIntegrationOutput {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

/// Creates a new IntegrationResponse resource to represent an integration response.
public struct CreateIntegrationResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response key.
    /// This member is required.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct CreateIntegrationResponseOutput {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

/// Creates a new Model.
public struct CreateModelInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.name = name
        self.schema = schema
    }
}

public struct CreateModelOutput {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

/// Creates a new Route resource to represent a route.
public struct CreateRouteInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route key for the route.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct CreateRouteOutput {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

/// Creates a new RouteResponse resource to represent a route response.
public struct CreateRouteResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response key.
    /// This member is required.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseKey = routeResponseKey
    }
}

public struct CreateRouteResponseOutput {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

/// Creates a new Stage resource to represent a stage.
public struct CreateStageInput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier of the API stage.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

public struct CreateStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

/// Creates a VPC link
public struct CreateVpcLinkInput {
    /// The name of the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A list of tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

public struct CreateVpcLinkOutput {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

public struct DeleteAccessLogSettingsInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct DeleteApiInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct DeleteApiMappingInput {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

public struct DeleteAuthorizerInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

public struct DeleteCorsConfigurationInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct DeleteDeploymentInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

public struct DeleteDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct DeleteIntegrationInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

public struct DeleteIntegrationResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

public struct DeleteModelInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct DeleteRouteInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

public struct DeleteRouteRequestParameterInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route request parameter key.
    /// This member is required.
    public var requestParameterKey: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        requestParameterKey: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.requestParameterKey = requestParameterKey
        self.routeId = routeId
    }
}

public struct DeleteRouteResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

public struct DeleteRouteSettingsInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route key.
    /// This member is required.
    public var routeKey: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeKey = routeKey
        self.stageName = stageName
    }
}

public struct DeleteStageInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct DeleteVpcLinkInput {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

public struct DeleteVpcLinkOutput {

    public init() { }
}

public struct ExportApiInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.
    public var exportVersion: Swift.String?
    /// Specifies whether to include [API Gateway extensions](https://docs.aws.amazon.com//apigateway/latest/developerguide/api-gateway-swagger-extensions.html) in the exported API definition. API Gateway extensions are included by default.
    public var includeExtensions: Swift.Bool?
    /// The output type of the exported definition file. Valid values are JSON and YAML.
    /// This member is required.
    public var outputType: Swift.String?
    /// The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.
    /// This member is required.
    public var specification: Swift.String?
    /// The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        exportVersion: Swift.String? = nil,
        includeExtensions: Swift.Bool? = nil,
        outputType: Swift.String? = nil,
        specification: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.exportVersion = exportVersion
        self.includeExtensions = includeExtensions
        self.outputType = outputType
        self.specification = specification
        self.stageName = stageName
    }
}

public struct ExportApiOutput {
    /// Represents an exported definition of an API in a particular output format, for example, YAML. The API is serialized to the requested specification, for example, OpenAPI 3.0.
    public var body: Foundation.Data?

    public init(
        body: Foundation.Data? = nil
    )
    {
        self.body = body
    }
}

public struct GetApiInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?

    public init(
        apiId: Swift.String? = nil
    )
    {
        self.apiId = apiId
    }
}

public struct GetApiOutput {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

public struct GetApiMappingInput {
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        apiMappingId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.apiMappingId = apiMappingId
        self.domainName = domainName
    }
}

public struct GetApiMappingOutput {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

public struct GetApiMappingsInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetApiMappingsOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.ApiMapping]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.ApiMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetApisInput {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetApisOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Api]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Api]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetAuthorizerInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerId = authorizerId
    }
}

public struct GetAuthorizerOutput {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct GetAuthorizersInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetAuthorizersOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Authorizer]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Authorizer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetDeploymentInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
    }
}

public struct GetDeploymentOutput {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

public struct GetDeploymentsInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDeploymentsOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Deployment]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

public struct GetDomainNameOutput {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

public struct GetDomainNamesInput {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetDomainNamesOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.DomainName]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.DomainName]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetIntegrationInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
    }
}

public struct GetIntegrationOutput {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct GetIntegrationResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
    }
}

public struct GetIntegrationResponseOutput {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct GetIntegrationResponsesInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.integrationId = integrationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetIntegrationResponsesOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.IntegrationResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.IntegrationResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetIntegrationsInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetIntegrationsOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Integration]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Integration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetModelInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct GetModelOutput {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

public struct GetModelsInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetModelsOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Model]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetModelTemplateInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelId = modelId
    }
}

public struct GetModelTemplateOutput {
    /// The template value.
    public var value: Swift.String?

    public init(
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

public struct GetRouteInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
    }
}

public struct GetRouteOutput {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct GetRouteResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.routeId = routeId
        self.routeResponseId = routeResponseId
    }
}

public struct GetRouteResponseOutput {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

public struct GetRouteResponsesInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        routeId: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routeId = routeId
    }
}

public struct GetRouteResponsesOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.RouteResponse]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.RouteResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetRoutesInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetRoutesOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Route]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Route]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetStageInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

public struct GetStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

public struct GetStagesInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetStagesOutput {
    /// The elements from this collection.
    public var items: [ApiGatewayV2ClientTypes.Stage]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.Stage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct GetTagsInput {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetTagsOutput {
    /// Represents a collection of tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct GetVpcLinkInput {
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

public struct GetVpcLinkOutput {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

public struct GetVpcLinksInput {
    /// The maximum number of elements to be returned for this resource.
    public var maxResults: Swift.String?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetVpcLinksOutput {
    /// A collection of VPC links.
    public var items: [ApiGatewayV2ClientTypes.VpcLink]?
    /// The next page of elements from this collection. Not valid for the last element of the collection.
    public var nextToken: Swift.String?

    public init(
        items: [ApiGatewayV2ClientTypes.VpcLink]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

///
public struct ImportApiInput {
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

public struct ImportApiOutput {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

///
public struct ReimportApiInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see [Set the OpenAPI basePath Property](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html). Supported only for HTTP APIs.
    public var basepath: Swift.String?
    /// The OpenAPI definition. Supported only for HTTP APIs.
    /// This member is required.
    public var body: Swift.String?
    /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
    public var failOnWarnings: Swift.Bool?

    public init(
        apiId: Swift.String? = nil,
        basepath: Swift.String? = nil,
        body: Swift.String? = nil,
        failOnWarnings: Swift.Bool? = nil
    )
    {
        self.apiId = apiId
        self.basepath = basepath
        self.body = body
        self.failOnWarnings = failOnWarnings
    }
}

public struct ReimportApiOutput {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

public struct ResetAuthorizersCacheInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.stageName = stageName
    }
}

/// Creates a new Tag resource to represent a tag.
public struct TagResourceInput {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The resource ARN for the tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// Updates an Api.
public struct UpdateApiInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.
    public var credentialsArn: Swift.String?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The name of the API.
    public var name: Swift.String?
    /// This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.
    public var routeKey: Swift.String?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.
    public var target: Swift.String?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        name: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.credentialsArn = credentialsArn
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.name = name
        self.routeKey = routeKey
        self.routeSelectionExpression = routeSelectionExpression
        self.target = target
        self.version = version
    }
}

public struct UpdateApiOutput {
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
    public var apiEndpoint: Swift.String?
    /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
    public var apiGatewayManaged: Swift.Bool?
    /// The API ID.
    public var apiId: Swift.String?
    /// An API key selection expression. Supported only for WebSocket APIs. See [API Key Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).
    public var apiKeySelectionExpression: Swift.String?
    /// A CORS configuration. Supported only for HTTP APIs.
    public var corsConfiguration: ApiGatewayV2ClientTypes.Cors?
    /// The timestamp when the API was created.
    public var createdDate: Foundation.Date?
    /// The description of the API.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool?
    /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
    public var disableSchemaValidation: Swift.Bool?
    /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
    public var importInfo: [Swift.String]?
    /// The name of the API.
    public var name: Swift.String?
    /// The API protocol.
    public var protocolType: ApiGatewayV2ClientTypes.ProtocolType?
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
    public var routeSelectionExpression: Swift.String?
    /// A collection of tags associated with the API.
    public var tags: [Swift.String: Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init(
        apiEndpoint: Swift.String? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        apiId: Swift.String? = nil,
        apiKeySelectionExpression: Swift.String? = nil,
        corsConfiguration: ApiGatewayV2ClientTypes.Cors? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool? = nil,
        disableSchemaValidation: Swift.Bool? = nil,
        importInfo: [Swift.String]? = nil,
        name: Swift.String? = nil,
        protocolType: ApiGatewayV2ClientTypes.ProtocolType? = nil,
        routeSelectionExpression: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiEndpoint = apiEndpoint
        self.apiGatewayManaged = apiGatewayManaged
        self.apiId = apiId
        self.apiKeySelectionExpression = apiKeySelectionExpression
        self.corsConfiguration = corsConfiguration
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.disableSchemaValidation = disableSchemaValidation
        self.importInfo = importInfo
        self.name = name
        self.protocolType = protocolType
        self.routeSelectionExpression = routeSelectionExpression
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

/// Updates an ApiMapping.
public struct UpdateApiMappingInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    /// This member is required.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.domainName = domainName
        self.stage = stage
    }
}

public struct UpdateApiMappingOutput {
    /// The API identifier.
    public var apiId: Swift.String?
    /// The API mapping identifier.
    public var apiMappingId: Swift.String?
    /// The API mapping key.
    public var apiMappingKey: Swift.String?
    /// The API stage.
    public var stage: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiMappingId: Swift.String? = nil,
        apiMappingKey: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiMappingId = apiMappingId
        self.apiMappingKey = apiMappingKey
        self.stage = stage
    }
}

/// Updates an Authorizer.
public struct UpdateAuthorizerInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// This parameter is not used.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

public struct UpdateAuthorizerOutput {
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
    public var authorizerCredentialsArn: Swift.String?
    /// The authorizer identifier.
    public var authorizerId: Swift.String?
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).
    public var authorizerPayloadFormatVersion: Swift.String?
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
    public var authorizerType: ApiGatewayV2ClientTypes.AuthorizerType?
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
    public var authorizerUri: Swift.String?
    /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)
    public var enableSimpleResponses: Swift.Bool?
    /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see [Working with AWS Lambda authorizers for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html). For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
    public var identitySource: [Swift.String]?
    /// The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
    public var jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration?
    /// The name of the authorizer.
    public var name: Swift.String?

    public init(
        authorizerCredentialsArn: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        authorizerPayloadFormatVersion: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerType: ApiGatewayV2ClientTypes.AuthorizerType? = nil,
        authorizerUri: Swift.String? = nil,
        enableSimpleResponses: Swift.Bool? = nil,
        identitySource: [Swift.String]? = nil,
        identityValidationExpression: Swift.String? = nil,
        jwtConfiguration: ApiGatewayV2ClientTypes.JWTConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.authorizerCredentialsArn = authorizerCredentialsArn
        self.authorizerId = authorizerId
        self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerType = authorizerType
        self.authorizerUri = authorizerUri
        self.enableSimpleResponses = enableSimpleResponses
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.jwtConfiguration = jwtConfiguration
        self.name = name
    }
}

/// Updates a Deployment.
public struct UpdateDeploymentInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The deployment ID.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description for the deployment resource.
    public var description: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.deploymentId = deploymentId
        self.description = description
    }
}

public struct UpdateDeploymentOutput {
    /// Specifies whether a deployment was automatically released.
    public var autoDeployed: Swift.Bool?
    /// The date and time when the Deployment resource was created.
    public var createdDate: Foundation.Date?
    /// The identifier for the deployment.
    public var deploymentId: Swift.String?
    /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
    public var deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus?
    /// May contain additional feedback on the status of an API deployment.
    public var deploymentStatusMessage: Swift.String?
    /// The description for the deployment.
    public var description: Swift.String?

    public init(
        autoDeployed: Swift.Bool? = nil,
        createdDate: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        deploymentStatus: ApiGatewayV2ClientTypes.DeploymentStatus? = nil,
        deploymentStatusMessage: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.autoDeployed = autoDeployed
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.deploymentStatus = deploymentStatus
        self.deploymentStatusMessage = deploymentStatusMessage
        self.description = description
    }
}

/// Updates a DomainName.
public struct UpdateDomainNameInput {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?

    public init(
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput? = nil
    )
    {
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
    }
}

public struct UpdateDomainNameOutput {
    /// The API mapping selection expression.
    public var apiMappingSelectionExpression: Swift.String?
    /// The name of the DomainName resource.
    public var domainName: Swift.String?
    /// The domain name configurations.
    public var domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]?
    /// The mutual TLS authentication configuration for a custom domain name.
    public var mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication?
    /// The collection of tags associated with a domain name.
    public var tags: [Swift.String: Swift.String]?

    public init(
        apiMappingSelectionExpression: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameConfigurations: [ApiGatewayV2ClientTypes.DomainNameConfiguration]? = nil,
        mutualTlsAuthentication: ApiGatewayV2ClientTypes.MutualTlsAuthentication? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.apiMappingSelectionExpression = apiMappingSelectionExpression
        self.domainName = domainName
        self.domainNameConfigurations = domainNameConfigurations
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.tags = tags
    }
}

/// Updates an Integration.
public struct UpdateIntegrationInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// The description of the integration
    public var description: Swift.String?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern <action>:<header|querystring|path>.<location> where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput?

    public init(
        apiId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfigInput? = nil
    )
    {
        self.apiId = apiId
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

public struct UpdateIntegrationOutput {
    /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
    public var apiGatewayManaged: Swift.Bool?
    /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayV2ClientTypes.ConnectionType?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
    public var credentialsArn: Swift.String?
    /// Represents the description of an integration.
    public var description: Swift.String?
    /// Represents the identifier of an integration.
    public var integrationId: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var integrationMethod: Swift.String?
    /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See [Integration Response Selection Expressions](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-integration-response-selection-expressions).
    public var integrationResponseSelectionExpression: Swift.String?
    /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see [Integration subtype reference](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services-reference.html).
    public var integrationSubtype: Swift.String?
    /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
    public var integrationType: ApiGatewayV2ClientTypes.IntegrationType?
    /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html). For private integrations, all resources must be owned by the same AWS account.
    public var integrationUri: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
    public var passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior?
    /// Specifies the format of the payload sent to an integration. Required for HTTP APIs.
    public var payloadFormatVersion: Swift.String?
    /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where {location} is querystring, path, or header; and {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Working with AWS service integrations for HTTP APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-aws-services.html). For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern <action>:<header|querystring|path>.<location>. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var requestParameters: [Swift.String: Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
    public var requestTemplates: [Swift.String: Swift.String]?
    /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern <action>:<header>.<location> or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see [Transforming API requests and responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-parameter-mapping.html).
    public var responseParameters: [Swift.String: [Swift.String: Swift.String]]?
    /// The template selection expression for the integration. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
    public var timeoutInMillis: Swift.Int?
    /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
    public var tlsConfig: ApiGatewayV2ClientTypes.TlsConfig?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayV2ClientTypes.ConnectionType? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        credentialsArn: Swift.String? = nil,
        description: Swift.String? = nil,
        integrationId: Swift.String? = nil,
        integrationMethod: Swift.String? = nil,
        integrationResponseSelectionExpression: Swift.String? = nil,
        integrationSubtype: Swift.String? = nil,
        integrationType: ApiGatewayV2ClientTypes.IntegrationType? = nil,
        integrationUri: Swift.String? = nil,
        passthroughBehavior: ApiGatewayV2ClientTypes.PassthroughBehavior? = nil,
        payloadFormatVersion: Swift.String? = nil,
        requestParameters: [Swift.String: Swift.String]? = nil,
        requestTemplates: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: [Swift.String: Swift.String]]? = nil,
        templateSelectionExpression: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayV2ClientTypes.TlsConfig? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandlingStrategy = contentHandlingStrategy
        self.credentialsArn = credentialsArn
        self.description = description
        self.integrationId = integrationId
        self.integrationMethod = integrationMethod
        self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
        self.integrationSubtype = integrationSubtype
        self.integrationType = integrationType
        self.integrationUri = integrationUri
        self.passthroughBehavior = passthroughBehavior
        self.payloadFormatVersion = payloadFormatVersion
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.responseParameters = responseParameters
        self.templateSelectionExpression = templateSelectionExpression
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
    }
}

/// Updates an IntegrationResponses.
public struct UpdateIntegrationResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration ID.
    /// This member is required.
    public var integrationId: Swift.String?
    /// The integration response ID.
    /// This member is required.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name} , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression} , where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expression for the integration response. Supported only for WebSocket APIs.
    public var templateSelectionExpression: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationId: Swift.String? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationId = integrationId
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

public struct UpdateIntegrationResponseOutput {
    /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
    public var contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy?
    /// The integration response ID.
    public var integrationResponseId: Swift.String?
    /// The integration response key.
    public var integrationResponseKey: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String: Swift.String]?
    /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String: Swift.String]?
    /// The template selection expressions for the integration response.
    public var templateSelectionExpression: Swift.String?

    public init(
        contentHandlingStrategy: ApiGatewayV2ClientTypes.ContentHandlingStrategy? = nil,
        integrationResponseId: Swift.String? = nil,
        integrationResponseKey: Swift.String? = nil,
        responseParameters: [Swift.String: Swift.String]? = nil,
        responseTemplates: [Swift.String: Swift.String]? = nil,
        templateSelectionExpression: Swift.String? = nil
    )
    {
        self.contentHandlingStrategy = contentHandlingStrategy
        self.integrationResponseId = integrationResponseId
        self.integrationResponseKey = integrationResponseKey
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.templateSelectionExpression = templateSelectionExpression
    }
}

/// Updates a Model.
public struct UpdateModelInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The name of the model.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

public struct UpdateModelOutput {
    /// The content-type for the model, for example, "application/json".
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The model identifier.
    public var modelId: Swift.String?
    /// The name of the model. Must be alphanumeric.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
    public var schema: Swift.String?

    public init(
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.modelId = modelId
        self.name = name
        self.schema = schema
    }
}

/// Updates a Route.
public struct UpdateRouteInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// The authorization scopes supported by this route.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

public struct UpdateRouteOutput {
    /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
    public var authorizationType: ApiGatewayV2ClientTypes.AuthorizationType?
    /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// The model selection expression for the route. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The operation name for the route.
    public var operationName: Swift.String?
    /// The request models for the route. Supported only for WebSocket APIs.
    public var requestModels: [Swift.String: Swift.String]?
    /// The request parameters for the route. Supported only for WebSocket APIs.
    public var requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    public var routeId: Swift.String?
    /// The route key for the route.
    public var routeKey: Swift.String?
    /// The route response selection expression for the route. Supported only for WebSocket APIs.
    public var routeResponseSelectionExpression: Swift.String?
    /// The target for the route.
    public var target: Swift.String?

    public init(
        apiGatewayManaged: Swift.Bool? = nil,
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: ApiGatewayV2ClientTypes.AuthorizationType? = nil,
        authorizerId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String: Swift.String]? = nil,
        requestParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeKey: Swift.String? = nil,
        routeResponseSelectionExpression: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.apiGatewayManaged = apiGatewayManaged
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.modelSelectionExpression = modelSelectionExpression
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.routeId = routeId
        self.routeKey = routeKey
        self.routeResponseSelectionExpression = routeResponseSelectionExpression
        self.target = target
    }
}

/// Updates a RouteResponse.
public struct UpdateRouteResponseInput {
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// The model selection expression for the route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// The response models for the route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// The route response parameters.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// The route ID.
    /// This member is required.
    public var routeId: Swift.String?
    /// The route response ID.
    /// This member is required.
    public var routeResponseId: Swift.String?
    /// The route response key.
    public var routeResponseKey: Swift.String?

    public init(
        apiId: Swift.String? = nil,
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeId: Swift.String? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.apiId = apiId
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeId = routeId
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

public struct UpdateRouteResponseOutput {
    /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
    public var modelSelectionExpression: Swift.String?
    /// Represents the response models of a route response.
    public var responseModels: [Swift.String: Swift.String]?
    /// Represents the response parameters of a route response.
    public var responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]?
    /// Represents the identifier of a route response.
    public var routeResponseId: Swift.String?
    /// Represents the route response key of a route response.
    public var routeResponseKey: Swift.String?

    public init(
        modelSelectionExpression: Swift.String? = nil,
        responseModels: [Swift.String: Swift.String]? = nil,
        responseParameters: [Swift.String: ApiGatewayV2ClientTypes.ParameterConstraints]? = nil,
        routeResponseId: Swift.String? = nil,
        routeResponseKey: Swift.String? = nil
    )
    {
        self.modelSelectionExpression = modelSelectionExpression
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.routeResponseId = routeResponseId
        self.routeResponseKey = routeResponseKey
    }
}

/// Updates a Stage.
public struct UpdateStageInput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// The API identifier.
    /// This member is required.
    public var apiId: Swift.String?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage.
    public var clientCertificateId: Swift.String?
    /// The default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description for the API stage.
    public var description: Swift.String?
    /// Route settings for the stage.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiId: Swift.String? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiId = apiId
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
    }
}

public struct UpdateStageOutput {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings?
    /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
    public var apiGatewayManaged: Swift.Bool?
    /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
    public var autoDeploy: Swift.Bool?
    /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: Foundation.Date?
    /// Default route settings for the stage.
    public var defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings?
    /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
    public var deploymentId: Swift.String?
    /// The description of the stage.
    public var description: Swift.String?
    /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
    public var lastDeploymentStatusMessage: Swift.String?
    /// The timestamp when the stage was last updated.
    public var lastUpdatedDate: Foundation.Date?
    /// Route settings for the stage, by routeKey.
    public var routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]?
    /// The name of the stage.
    public var stageName: Swift.String?
    /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var stageVariables: [Swift.String: Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessLogSettings: ApiGatewayV2ClientTypes.AccessLogSettings? = nil,
        apiGatewayManaged: Swift.Bool? = nil,
        autoDeploy: Swift.Bool? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        defaultRouteSettings: ApiGatewayV2ClientTypes.RouteSettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        lastDeploymentStatusMessage: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        routeSettings: [Swift.String: ApiGatewayV2ClientTypes.RouteSettings]? = nil,
        stageName: Swift.String? = nil,
        stageVariables: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.apiGatewayManaged = apiGatewayManaged
        self.autoDeploy = autoDeploy
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.defaultRouteSettings = defaultRouteSettings
        self.deploymentId = deploymentId
        self.description = description
        self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
        self.lastUpdatedDate = lastUpdatedDate
        self.routeSettings = routeSettings
        self.stageName = stageName
        self.stageVariables = stageVariables
        self.tags = tags
    }
}

/// Updates a VPC link.
public struct UpdateVpcLinkInput {
    /// The name of the VPC link.
    public var name: Swift.String?
    /// The ID of the VPC link.
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init(
        name: Swift.String? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.name = name
        self.vpcLinkId = vpcLinkId
    }
}

public struct UpdateVpcLinkOutput {
    /// The timestamp when the VPC link was created.
    public var createdDate: Foundation.Date?
    /// The name of the VPC link.
    public var name: Swift.String?
    /// A list of security group IDs for the VPC link.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs to include in the VPC link.
    public var subnetIds: [Swift.String]?
    /// Tags for the VPC link.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC link.
    public var vpcLinkId: Swift.String?
    /// The status of the VPC link.
    public var vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus?
    /// A message summarizing the cause of the status of the VPC link.
    public var vpcLinkStatusMessage: Swift.String?
    /// The version of the VPC link.
    public var vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion?

    public init(
        createdDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcLinkId: Swift.String? = nil,
        vpcLinkStatus: ApiGatewayV2ClientTypes.VpcLinkStatus? = nil,
        vpcLinkStatusMessage: Swift.String? = nil,
        vpcLinkVersion: ApiGatewayV2ClientTypes.VpcLinkVersion? = nil
    )
    {
        self.createdDate = createdDate
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcLinkId = vpcLinkId
        self.vpcLinkStatus = vpcLinkStatus
        self.vpcLinkStatusMessage = vpcLinkStatusMessage
        self.vpcLinkVersion = vpcLinkVersion
    }
}

extension CreateApiInput {

    static func urlPathProvider(_ value: CreateApiInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension CreateApiMappingInput {

    static func urlPathProvider(_ value: CreateApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

extension CreateAuthorizerInput {

    static func urlPathProvider(_ value: CreateAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

extension CreateDomainNameInput {

    static func urlPathProvider(_ value: CreateDomainNameInput) -> Swift.String? {
        return "/v2/domainnames"
    }
}

extension CreateIntegrationInput {

    static func urlPathProvider(_ value: CreateIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

extension CreateIntegrationResponseInput {

    static func urlPathProvider(_ value: CreateIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

extension CreateModelInput {

    static func urlPathProvider(_ value: CreateModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

extension CreateRouteInput {

    static func urlPathProvider(_ value: CreateRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

extension CreateRouteResponseInput {

    static func urlPathProvider(_ value: CreateRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

extension CreateVpcLinkInput {

    static func urlPathProvider(_ value: CreateVpcLinkInput) -> Swift.String? {
        return "/v2/vpclinks"
    }
}

extension DeleteAccessLogSettingsInput {

    static func urlPathProvider(_ value: DeleteAccessLogSettingsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/accesslogsettings"
    }
}

extension DeleteApiInput {

    static func urlPathProvider(_ value: DeleteApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension DeleteApiMappingInput {

    static func urlPathProvider(_ value: DeleteApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension DeleteAuthorizerInput {

    static func urlPathProvider(_ value: DeleteAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension DeleteCorsConfigurationInput {

    static func urlPathProvider(_ value: DeleteCorsConfigurationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/cors"
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension DeleteDomainNameInput {

    static func urlPathProvider(_ value: DeleteDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteIntegrationInput {

    static func urlPathProvider(_ value: DeleteIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension DeleteIntegrationResponseInput {

    static func urlPathProvider(_ value: DeleteIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension DeleteModelInput {

    static func urlPathProvider(_ value: DeleteModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension DeleteRouteInput {

    static func urlPathProvider(_ value: DeleteRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension DeleteRouteRequestParameterInput {

    static func urlPathProvider(_ value: DeleteRouteRequestParameterInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let requestParameterKey = value.requestParameterKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/requestparameters/\(requestParameterKey.urlPercentEncoding())"
    }
}

extension DeleteRouteResponseInput {

    static func urlPathProvider(_ value: DeleteRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension DeleteRouteSettingsInput {

    static func urlPathProvider(_ value: DeleteRouteSettingsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        guard let routeKey = value.routeKey else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/routesettings/\(routeKey.urlPercentEncoding())"
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension DeleteVpcLinkInput {

    static func urlPathProvider(_ value: DeleteVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension ExportApiInput {

    static func urlPathProvider(_ value: ExportApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let specification = value.specification else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/exports/\(specification.urlPercentEncoding())"
    }
}

extension ExportApiInput {

    static func queryItemProvider(_ value: ExportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let stageName = value.stageName {
            let stageNameQueryItem = Smithy.URIQueryItem(name: "stageName".urlPercentEncoding(), value: Swift.String(stageName).urlPercentEncoding())
            items.append(stageNameQueryItem)
        }
        if let includeExtensions = value.includeExtensions {
            let includeExtensionsQueryItem = Smithy.URIQueryItem(name: "includeExtensions".urlPercentEncoding(), value: Swift.String(includeExtensions).urlPercentEncoding())
            items.append(includeExtensionsQueryItem)
        }
        if let exportVersion = value.exportVersion {
            let exportVersionQueryItem = Smithy.URIQueryItem(name: "exportVersion".urlPercentEncoding(), value: Swift.String(exportVersion).urlPercentEncoding())
            items.append(exportVersionQueryItem)
        }
        guard let outputType = value.outputType else {
            let message = "Creating a URL Query Item failed. outputType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let outputTypeQueryItem = Smithy.URIQueryItem(name: "outputType".urlPercentEncoding(), value: Swift.String(outputType).urlPercentEncoding())
        items.append(outputTypeQueryItem)
        return items
    }
}

extension GetApiInput {

    static func urlPathProvider(_ value: GetApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension GetApiMappingInput {

    static func urlPathProvider(_ value: GetApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension GetApiMappingsInput {

    static func urlPathProvider(_ value: GetApiMappingsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings"
    }
}

extension GetApiMappingsInput {

    static func queryItemProvider(_ value: GetApiMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetApisInput {

    static func urlPathProvider(_ value: GetApisInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension GetApisInput {

    static func queryItemProvider(_ value: GetApisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetAuthorizerInput {

    static func urlPathProvider(_ value: GetAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension GetAuthorizersInput {

    static func urlPathProvider(_ value: GetAuthorizersInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers"
    }
}

extension GetAuthorizersInput {

    static func queryItemProvider(_ value: GetAuthorizersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension GetDeploymentsInput {

    static func urlPathProvider(_ value: GetDeploymentsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments"
    }
}

extension GetDeploymentsInput {

    static func queryItemProvider(_ value: GetDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDomainNameInput {

    static func urlPathProvider(_ value: GetDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension GetDomainNamesInput {

    static func urlPathProvider(_ value: GetDomainNamesInput) -> Swift.String? {
        return "/v2/domainnames"
    }
}

extension GetDomainNamesInput {

    static func queryItemProvider(_ value: GetDomainNamesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationInput {

    static func urlPathProvider(_ value: GetIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension GetIntegrationResponseInput {

    static func urlPathProvider(_ value: GetIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension GetIntegrationResponsesInput {

    static func urlPathProvider(_ value: GetIntegrationResponsesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses"
    }
}

extension GetIntegrationResponsesInput {

    static func queryItemProvider(_ value: GetIntegrationResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetIntegrationsInput {

    static func urlPathProvider(_ value: GetIntegrationsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations"
    }
}

extension GetIntegrationsInput {

    static func queryItemProvider(_ value: GetIntegrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetModelInput {

    static func urlPathProvider(_ value: GetModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension GetModelsInput {

    static func urlPathProvider(_ value: GetModelsInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models"
    }
}

extension GetModelsInput {

    static func queryItemProvider(_ value: GetModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetModelTemplateInput {

    static func urlPathProvider(_ value: GetModelTemplateInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())/template"
    }
}

extension GetRouteInput {

    static func urlPathProvider(_ value: GetRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension GetRouteResponseInput {

    static func urlPathProvider(_ value: GetRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension GetRouteResponsesInput {

    static func urlPathProvider(_ value: GetRouteResponsesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses"
    }
}

extension GetRouteResponsesInput {

    static func queryItemProvider(_ value: GetRouteResponsesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetRoutesInput {

    static func urlPathProvider(_ value: GetRoutesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes"
    }
}

extension GetRoutesInput {

    static func queryItemProvider(_ value: GetRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension GetStagesInput {

    static func urlPathProvider(_ value: GetStagesInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages"
    }
}

extension GetStagesInput {

    static func queryItemProvider(_ value: GetStagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetTagsInput {

    static func urlPathProvider(_ value: GetTagsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetVpcLinkInput {

    static func urlPathProvider(_ value: GetVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension GetVpcLinksInput {

    static func urlPathProvider(_ value: GetVpcLinksInput) -> Swift.String? {
        return "/v2/vpclinks"
    }
}

extension GetVpcLinksInput {

    static func queryItemProvider(_ value: GetVpcLinksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ImportApiInput {

    static func urlPathProvider(_ value: ImportApiInput) -> Swift.String? {
        return "/v2/apis"
    }
}

extension ImportApiInput {

    static func queryItemProvider(_ value: ImportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = value.basepath {
            let basepathQueryItem = Smithy.URIQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ReimportApiInput {

    static func urlPathProvider(_ value: ReimportApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension ReimportApiInput {

    static func queryItemProvider(_ value: ReimportApiInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let failOnWarnings = value.failOnWarnings {
            let failOnWarningsQueryItem = Smithy.URIQueryItem(name: "failOnWarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let basepath = value.basepath {
            let basepathQueryItem = Smithy.URIQueryItem(name: "basepath".urlPercentEncoding(), value: Swift.String(basepath).urlPercentEncoding())
            items.append(basepathQueryItem)
        }
        return items
    }
}

extension ResetAuthorizersCacheInput {

    static func urlPathProvider(_ value: ResetAuthorizersCacheInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v2/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApiInput {

    static func urlPathProvider(_ value: UpdateApiInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())"
    }
}

extension UpdateApiMappingInput {

    static func urlPathProvider(_ value: UpdateApiMappingInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let apiMappingId = value.apiMappingId else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())/apimappings/\(apiMappingId.urlPercentEncoding())"
    }
}

extension UpdateAuthorizerInput {

    static func urlPathProvider(_ value: UpdateAuthorizerInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let authorizerId = value.authorizerId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

extension UpdateDeploymentInput {

    static func urlPathProvider(_ value: UpdateDeploymentInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension UpdateDomainNameInput {

    static func urlPathProvider(_ value: UpdateDomainNameInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/v2/domainnames/\(domainName.urlPercentEncoding())"
    }
}

extension UpdateIntegrationInput {

    static func urlPathProvider(_ value: UpdateIntegrationInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())"
    }
}

extension UpdateIntegrationResponseInput {

    static func urlPathProvider(_ value: UpdateIntegrationResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let integrationId = value.integrationId else {
            return nil
        }
        guard let integrationResponseId = value.integrationResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/integrations/\(integrationId.urlPercentEncoding())/integrationresponses/\(integrationResponseId.urlPercentEncoding())"
    }
}

extension UpdateModelInput {

    static func urlPathProvider(_ value: UpdateModelInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let modelId = value.modelId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/models/\(modelId.urlPercentEncoding())"
    }
}

extension UpdateRouteInput {

    static func urlPathProvider(_ value: UpdateRouteInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())"
    }
}

extension UpdateRouteResponseInput {

    static func urlPathProvider(_ value: UpdateRouteResponseInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let routeId = value.routeId else {
            return nil
        }
        guard let routeResponseId = value.routeResponseId else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/routes/\(routeId.urlPercentEncoding())/routeresponses/\(routeResponseId.urlPercentEncoding())"
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        guard let apiId = value.apiId else {
            return nil
        }
        guard let stageName = value.stageName else {
            return nil
        }
        return "/v2/apis/\(apiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

extension UpdateVpcLinkInput {

    static func urlPathProvider(_ value: UpdateVpcLinkInput) -> Swift.String? {
        guard let vpcLinkId = value.vpcLinkId else {
            return nil
        }
        return "/v2/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

extension CreateApiInput {

    static func write(value: CreateApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeySelectionExpression"].write(value.apiKeySelectionExpression)
        try writer["corsConfiguration"].write(value.corsConfiguration, with: ApiGatewayV2ClientTypes.Cors.write(value:to:))
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["disableExecuteApiEndpoint"].write(value.disableExecuteApiEndpoint)
        try writer["disableSchemaValidation"].write(value.disableSchemaValidation)
        try writer["name"].write(value.name)
        try writer["protocolType"].write(value.protocolType)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeSelectionExpression"].write(value.routeSelectionExpression)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["target"].write(value.target)
        try writer["version"].write(value.version)
    }
}

extension CreateApiMappingInput {

    static func write(value: CreateApiMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["apiMappingKey"].write(value.apiMappingKey)
        try writer["stage"].write(value.stage)
    }
}

extension CreateAuthorizerInput {

    static func write(value: CreateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerCredentialsArn"].write(value.authorizerCredentialsArn)
        try writer["authorizerPayloadFormatVersion"].write(value.authorizerPayloadFormatVersion)
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerType"].write(value.authorizerType)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["enableSimpleResponses"].write(value.enableSimpleResponses)
        try writer["identitySource"].writeList(value.identitySource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
        try writer["jwtConfiguration"].write(value.jwtConfiguration, with: ApiGatewayV2ClientTypes.JWTConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["stageName"].write(value.stageName)
    }
}

extension CreateDomainNameInput {

    static func write(value: CreateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["domainNameConfigurations"].writeList(value.domainNameConfigurations, memberWritingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mutualTlsAuthentication"].write(value.mutualTlsAuthentication, with: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIntegrationInput {

    static func write(value: CreateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionType"].write(value.connectionType)
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["integrationMethod"].write(value.integrationMethod)
        try writer["integrationSubtype"].write(value.integrationSubtype)
        try writer["integrationType"].write(value.integrationType)
        try writer["integrationUri"].write(value.integrationUri)
        try writer["passthroughBehavior"].write(value.passthroughBehavior)
        try writer["payloadFormatVersion"].write(value.payloadFormatVersion)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestTemplates"].writeMap(value.requestTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
        try writer["timeoutInMillis"].write(value.timeoutInMillis)
        try writer["tlsConfig"].write(value.tlsConfig, with: ApiGatewayV2ClientTypes.TlsConfigInput.write(value:to:))
    }
}

extension CreateIntegrationResponseInput {

    static func write(value: CreateIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["integrationResponseKey"].write(value.integrationResponseKey)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
    }
}

extension CreateModelInput {

    static func write(value: CreateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension CreateRouteInput {

    static func write(value: CreateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeyRequired"].write(value.apiKeyRequired)
        try writer["authorizationScopes"].writeList(value.authorizationScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizationType"].write(value.authorizationType)
        try writer["authorizerId"].write(value.authorizerId)
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["operationName"].write(value.operationName)
        try writer["requestModels"].writeMap(value.requestModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeResponseSelectionExpression"].write(value.routeResponseSelectionExpression)
        try writer["target"].write(value.target)
    }
}

extension CreateRouteResponseInput {

    static func write(value: CreateRouteResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["responseModels"].writeMap(value.responseModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeResponseKey"].write(value.routeResponseKey)
    }
}

extension CreateStageInput {

    static func write(value: CreateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLogSettings"].write(value.accessLogSettings, with: ApiGatewayV2ClientTypes.AccessLogSettings.write(value:to:))
        try writer["autoDeploy"].write(value.autoDeploy)
        try writer["clientCertificateId"].write(value.clientCertificateId)
        try writer["defaultRouteSettings"].write(value.defaultRouteSettings, with: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:))
        try writer["deploymentId"].write(value.deploymentId)
        try writer["description"].write(value.description)
        try writer["routeSettings"].writeMap(value.routeSettings, valueWritingClosure: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["stageName"].write(value.stageName)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateVpcLinkInput {

    static func write(value: CreateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ImportApiInput {

    static func write(value: ImportApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension ReimportApiInput {

    static func write(value: ReimportApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApiInput {

    static func write(value: UpdateApiInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeySelectionExpression"].write(value.apiKeySelectionExpression)
        try writer["corsConfiguration"].write(value.corsConfiguration, with: ApiGatewayV2ClientTypes.Cors.write(value:to:))
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["disableExecuteApiEndpoint"].write(value.disableExecuteApiEndpoint)
        try writer["disableSchemaValidation"].write(value.disableSchemaValidation)
        try writer["name"].write(value.name)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeSelectionExpression"].write(value.routeSelectionExpression)
        try writer["target"].write(value.target)
        try writer["version"].write(value.version)
    }
}

extension UpdateApiMappingInput {

    static func write(value: UpdateApiMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiId"].write(value.apiId)
        try writer["apiMappingKey"].write(value.apiMappingKey)
        try writer["stage"].write(value.stage)
    }
}

extension UpdateAuthorizerInput {

    static func write(value: UpdateAuthorizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorizerCredentialsArn"].write(value.authorizerCredentialsArn)
        try writer["authorizerPayloadFormatVersion"].write(value.authorizerPayloadFormatVersion)
        try writer["authorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["authorizerType"].write(value.authorizerType)
        try writer["authorizerUri"].write(value.authorizerUri)
        try writer["enableSimpleResponses"].write(value.enableSimpleResponses)
        try writer["identitySource"].writeList(value.identitySource, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["identityValidationExpression"].write(value.identityValidationExpression)
        try writer["jwtConfiguration"].write(value.jwtConfiguration, with: ApiGatewayV2ClientTypes.JWTConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateDeploymentInput {

    static func write(value: UpdateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateDomainNameInput {

    static func write(value: UpdateDomainNameInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainNameConfigurations"].writeList(value.domainNameConfigurations, memberWritingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["mutualTlsAuthentication"].write(value.mutualTlsAuthentication, with: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput.write(value:to:))
    }
}

extension UpdateIntegrationInput {

    static func write(value: UpdateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionType"].write(value.connectionType)
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["credentialsArn"].write(value.credentialsArn)
        try writer["description"].write(value.description)
        try writer["integrationMethod"].write(value.integrationMethod)
        try writer["integrationSubtype"].write(value.integrationSubtype)
        try writer["integrationType"].write(value.integrationType)
        try writer["integrationUri"].write(value.integrationUri)
        try writer["passthroughBehavior"].write(value.passthroughBehavior)
        try writer["payloadFormatVersion"].write(value.payloadFormatVersion)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestTemplates"].writeMap(value.requestTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
        try writer["timeoutInMillis"].write(value.timeoutInMillis)
        try writer["tlsConfig"].write(value.tlsConfig, with: ApiGatewayV2ClientTypes.TlsConfigInput.write(value:to:))
    }
}

extension UpdateIntegrationResponseInput {

    static func write(value: UpdateIntegrationResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentHandlingStrategy"].write(value.contentHandlingStrategy)
        try writer["integrationResponseKey"].write(value.integrationResponseKey)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseTemplates"].writeMap(value.responseTemplates, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["templateSelectionExpression"].write(value.templateSelectionExpression)
    }
}

extension UpdateModelInput {

    static func write(value: UpdateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["schema"].write(value.schema)
    }
}

extension UpdateRouteInput {

    static func write(value: UpdateRouteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKeyRequired"].write(value.apiKeyRequired)
        try writer["authorizationScopes"].writeList(value.authorizationScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["authorizationType"].write(value.authorizationType)
        try writer["authorizerId"].write(value.authorizerId)
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["operationName"].write(value.operationName)
        try writer["requestModels"].writeMap(value.requestModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requestParameters"].writeMap(value.requestParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeKey"].write(value.routeKey)
        try writer["routeResponseSelectionExpression"].write(value.routeResponseSelectionExpression)
        try writer["target"].write(value.target)
    }
}

extension UpdateRouteResponseInput {

    static func write(value: UpdateRouteResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSelectionExpression"].write(value.modelSelectionExpression)
        try writer["responseModels"].writeMap(value.responseModels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["responseParameters"].writeMap(value.responseParameters, valueWritingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["routeResponseKey"].write(value.routeResponseKey)
    }
}

extension UpdateStageInput {

    static func write(value: UpdateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessLogSettings"].write(value.accessLogSettings, with: ApiGatewayV2ClientTypes.AccessLogSettings.write(value:to:))
        try writer["autoDeploy"].write(value.autoDeploy)
        try writer["clientCertificateId"].write(value.clientCertificateId)
        try writer["defaultRouteSettings"].write(value.defaultRouteSettings, with: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:))
        try writer["deploymentId"].write(value.deploymentId)
        try writer["description"].write(value.description)
        try writer["routeSettings"].writeMap(value.routeSettings, valueWritingClosure: ApiGatewayV2ClientTypes.RouteSettings.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["stageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateVpcLinkInput {

    static func write(value: UpdateVpcLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension CreateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension CreateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CreateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension CreateIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension CreateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension CreateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension CreateRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension CreateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CreateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension DeleteAccessLogSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessLogSettingsOutput {
        return DeleteAccessLogSettingsOutput()
    }
}

extension DeleteApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiOutput {
        return DeleteApiOutput()
    }
}

extension DeleteApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApiMappingOutput {
        return DeleteApiMappingOutput()
    }
}

extension DeleteAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthorizerOutput {
        return DeleteAuthorizerOutput()
    }
}

extension DeleteCorsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCorsConfigurationOutput {
        return DeleteCorsConfigurationOutput()
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeploymentOutput {
        return DeleteDeploymentOutput()
    }
}

extension DeleteDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainNameOutput {
        return DeleteDomainNameOutput()
    }
}

extension DeleteIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationOutput {
        return DeleteIntegrationOutput()
    }
}

extension DeleteIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIntegrationResponseOutput {
        return DeleteIntegrationResponseOutput()
    }
}

extension DeleteModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelOutput {
        return DeleteModelOutput()
    }
}

extension DeleteRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteOutput {
        return DeleteRouteOutput()
    }
}

extension DeleteRouteRequestParameterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteRequestParameterOutput {
        return DeleteRouteRequestParameterOutput()
    }
}

extension DeleteRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteResponseOutput {
        return DeleteRouteResponseOutput()
    }
}

extension DeleteRouteSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRouteSettingsOutput {
        return DeleteRouteSettingsOutput()
    }
}

extension DeleteStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStageOutput {
        return DeleteStageOutput()
    }
}

extension DeleteVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcLinkOutput {
        return DeleteVpcLinkOutput()
    }
}

extension ExportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportApiOutput {
        var value = ExportApiOutput()
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension GetApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension GetApiMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApiMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApiMappingsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.ApiMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetApisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApisOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Api.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension GetAuthorizersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthorizersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthorizersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Authorizer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension GetDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainNamesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainName.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension GetIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension GetIntegrationResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationResponsesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.IntegrationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetIntegrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIntegrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIntegrationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Integration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension GetModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Model.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelTemplateOutput()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension GetRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension GetRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension GetRouteResponsesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteResponsesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteResponsesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.RouteResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoutesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetStagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStagesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.Stage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTagsOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension GetVpcLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcLinksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.VpcLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ImportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ReimportApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReimportApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReimportApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResetAuthorizersCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetAuthorizersCacheOutput {
        return ResetAuthorizersCacheOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApiOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiOutput()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.protocolType = try reader["protocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateApiMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApiMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApiMappingOutput()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent()
        return value
    }
}

extension UpdateAuthorizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAuthorizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAuthorizerOutput()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeploymentOutput()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension UpdateDomainNameOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainNameOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainNameOutput()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension UpdateIntegrationResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIntegrationResponseOutput()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent()
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension UpdateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateModelOutput()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension UpdateRouteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteOutput()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent()
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension UpdateRouteResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRouteResponseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRouteResponseOutput()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent()
        return value
    }
}

extension UpdateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStageOutput()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent()
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension UpdateVpcLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcLinkOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent()
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

enum CreateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessLogSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCorsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteRequestParameterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRouteSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApiMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthorizersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIntegrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteResponsesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReimportApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetAuthorizersCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApiMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAuthorizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainNameOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRouteResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.limitType = try reader["limitType"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApiGatewayV2ClientTypes.Cors {

    static func write(value: ApiGatewayV2ClientTypes.Cors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowCredentials"].write(value.allowCredentials)
        try writer["allowHeaders"].writeList(value.allowHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowMethods"].writeList(value.allowMethods, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowOrigins"].writeList(value.allowOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["exposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxAge"].write(value.maxAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Cors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Cors()
        value.allowCredentials = try reader["allowCredentials"].readIfPresent()
        value.allowHeaders = try reader["allowHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowMethods = try reader["allowMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowOrigins = try reader["allowOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exposeHeaders = try reader["exposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxAge = try reader["maxAge"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.JWTConfiguration {

    static func write(value: ApiGatewayV2ClientTypes.JWTConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audience"].writeList(value.audience, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["issuer"].write(value.issuer)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.JWTConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.JWTConfiguration()
        value.audience = try reader["audience"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.issuer = try reader["issuer"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.DomainNameConfiguration {

    static func write(value: ApiGatewayV2ClientTypes.DomainNameConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiGatewayDomainName"].write(value.apiGatewayDomainName)
        try writer["certificateArn"].write(value.certificateArn)
        try writer["certificateName"].write(value.certificateName)
        try writer["certificateUploadDate"].writeTimestamp(value.certificateUploadDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["domainNameStatus"].write(value.domainNameStatus)
        try writer["domainNameStatusMessage"].write(value.domainNameStatusMessage)
        try writer["endpointType"].write(value.endpointType)
        try writer["hostedZoneId"].write(value.hostedZoneId)
        try writer["ownershipVerificationCertificateArn"].write(value.ownershipVerificationCertificateArn)
        try writer["securityPolicy"].write(value.securityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DomainNameConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DomainNameConfiguration()
        value.apiGatewayDomainName = try reader["apiGatewayDomainName"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.certificateName = try reader["certificateName"].readIfPresent()
        value.certificateUploadDate = try reader["certificateUploadDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.domainNameStatus = try reader["domainNameStatus"].readIfPresent()
        value.domainNameStatusMessage = try reader["domainNameStatusMessage"].readIfPresent()
        value.endpointType = try reader["endpointType"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        value.securityPolicy = try reader["securityPolicy"].readIfPresent()
        value.ownershipVerificationCertificateArn = try reader["ownershipVerificationCertificateArn"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.MutualTlsAuthentication {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.MutualTlsAuthentication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.MutualTlsAuthentication()
        value.truststoreUri = try reader["truststoreUri"].readIfPresent()
        value.truststoreVersion = try reader["truststoreVersion"].readIfPresent()
        value.truststoreWarnings = try reader["truststoreWarnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.TlsConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.TlsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.TlsConfig()
        value.serverNameToVerify = try reader["serverNameToVerify"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.ParameterConstraints {

    static func write(value: ApiGatewayV2ClientTypes.ParameterConstraints?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["required"].write(value.`required`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ParameterConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ParameterConstraints()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.AccessLogSettings {

    static func write(value: ApiGatewayV2ClientTypes.AccessLogSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationArn"].write(value.destinationArn)
        try writer["format"].write(value.format)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.AccessLogSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.AccessLogSettings()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RouteSettings {

    static func write(value: ApiGatewayV2ClientTypes.RouteSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTraceEnabled"].write(value.dataTraceEnabled)
        try writer["detailedMetricsEnabled"].write(value.detailedMetricsEnabled)
        try writer["loggingLevel"].write(value.loggingLevel)
        try writer["throttlingBurstLimit"].write(value.throttlingBurstLimit)
        try writer["throttlingRateLimit"].write(value.throttlingRateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RouteSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RouteSettings()
        value.dataTraceEnabled = try reader["dataTraceEnabled"].readIfPresent()
        value.detailedMetricsEnabled = try reader["detailedMetricsEnabled"].readIfPresent()
        value.loggingLevel = try reader["loggingLevel"].readIfPresent()
        value.throttlingBurstLimit = try reader["throttlingBurstLimit"].readIfPresent()
        value.throttlingRateLimit = try reader["throttlingRateLimit"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.ApiMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.ApiMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.ApiMapping()
        value.apiId = try reader["apiId"].readIfPresent() ?? ""
        value.apiMappingId = try reader["apiMappingId"].readIfPresent()
        value.apiMappingKey = try reader["apiMappingKey"].readIfPresent()
        value.stage = try reader["stage"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Api {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Api {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Api()
        value.apiEndpoint = try reader["apiEndpoint"].readIfPresent()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiId = try reader["apiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["apiKeySelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["corsConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.Cors.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.disableSchemaValidation = try reader["disableSchemaValidation"].readIfPresent()
        value.disableExecuteApiEndpoint = try reader["disableExecuteApiEndpoint"].readIfPresent()
        value.importInfo = try reader["importInfo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolType = try reader["protocolType"].readIfPresent() ?? .sdkUnknown("")
        value.routeSelectionExpression = try reader["routeSelectionExpression"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.version = try reader["version"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.Authorizer {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Authorizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Authorizer()
        value.authorizerCredentialsArn = try reader["authorizerCredentialsArn"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.authorizerPayloadFormatVersion = try reader["authorizerPayloadFormatVersion"].readIfPresent()
        value.authorizerResultTtlInSeconds = try reader["authorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerType = try reader["authorizerType"].readIfPresent()
        value.authorizerUri = try reader["authorizerUri"].readIfPresent()
        value.enableSimpleResponses = try reader["enableSimpleResponses"].readIfPresent()
        value.identitySource = try reader["identitySource"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.identityValidationExpression = try reader["identityValidationExpression"].readIfPresent()
        value.jwtConfiguration = try reader["jwtConfiguration"].readIfPresent(with: ApiGatewayV2ClientTypes.JWTConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Deployment()
        value.autoDeployed = try reader["autoDeployed"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.deploymentStatusMessage = try reader["deploymentStatusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.DomainName {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.DomainName {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.DomainName()
        value.apiMappingSelectionExpression = try reader["apiMappingSelectionExpression"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.domainNameConfigurations = try reader["domainNameConfigurations"].readListIfPresent(memberReadingClosure: ApiGatewayV2ClientTypes.DomainNameConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mutualTlsAuthentication = try reader["mutualTlsAuthentication"].readIfPresent(with: ApiGatewayV2ClientTypes.MutualTlsAuthentication.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.IntegrationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.IntegrationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.IntegrationResponse()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.integrationResponseId = try reader["integrationResponseId"].readIfPresent()
        value.integrationResponseKey = try reader["integrationResponseKey"].readIfPresent() ?? ""
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseTemplates = try reader["responseTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Integration {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Integration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Integration()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionType = try reader["connectionType"].readIfPresent()
        value.contentHandlingStrategy = try reader["contentHandlingStrategy"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.integrationId = try reader["integrationId"].readIfPresent()
        value.integrationMethod = try reader["integrationMethod"].readIfPresent()
        value.integrationResponseSelectionExpression = try reader["integrationResponseSelectionExpression"].readIfPresent()
        value.integrationSubtype = try reader["integrationSubtype"].readIfPresent()
        value.integrationType = try reader["integrationType"].readIfPresent()
        value.integrationUri = try reader["integrationUri"].readIfPresent()
        value.passthroughBehavior = try reader["passthroughBehavior"].readIfPresent()
        value.payloadFormatVersion = try reader["payloadFormatVersion"].readIfPresent()
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestTemplates = try reader["requestTemplates"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateSelectionExpression = try reader["templateSelectionExpression"].readIfPresent()
        value.timeoutInMillis = try reader["timeoutInMillis"].readIfPresent()
        value.tlsConfig = try reader["tlsConfig"].readIfPresent(with: ApiGatewayV2ClientTypes.TlsConfig.read(from:))
        return value
    }
}

extension ApiGatewayV2ClientTypes.Model {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Model()
        value.contentType = try reader["contentType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.RouteResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.RouteResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.RouteResponse()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.responseModels = try reader["responseModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.responseParameters = try reader["responseParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeResponseId = try reader["routeResponseId"].readIfPresent()
        value.routeResponseKey = try reader["routeResponseKey"].readIfPresent() ?? ""
        return value
    }
}

extension ApiGatewayV2ClientTypes.Route {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Route {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Route()
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.apiKeyRequired = try reader["apiKeyRequired"].readIfPresent()
        value.authorizationScopes = try reader["authorizationScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizationType = try reader["authorizationType"].readIfPresent()
        value.authorizerId = try reader["authorizerId"].readIfPresent()
        value.modelSelectionExpression = try reader["modelSelectionExpression"].readIfPresent()
        value.operationName = try reader["operationName"].readIfPresent()
        value.requestModels = try reader["requestModels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestParameters = try reader["requestParameters"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.ParameterConstraints.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.routeId = try reader["routeId"].readIfPresent()
        value.routeKey = try reader["routeKey"].readIfPresent() ?? ""
        value.routeResponseSelectionExpression = try reader["routeResponseSelectionExpression"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.Stage {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.Stage()
        value.accessLogSettings = try reader["accessLogSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.AccessLogSettings.read(from:))
        value.apiGatewayManaged = try reader["apiGatewayManaged"].readIfPresent()
        value.autoDeploy = try reader["autoDeploy"].readIfPresent()
        value.clientCertificateId = try reader["clientCertificateId"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultRouteSettings = try reader["defaultRouteSettings"].readIfPresent(with: ApiGatewayV2ClientTypes.RouteSettings.read(from:))
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["lastDeploymentStatusMessage"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.routeSettings = try reader["routeSettings"].readMapIfPresent(valueReadingClosure: ApiGatewayV2ClientTypes.RouteSettings.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.stageName = try reader["stageName"].readIfPresent() ?? ""
        value.stageVariables = try reader["stageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApiGatewayV2ClientTypes.VpcLink {

    static func read(from reader: SmithyJSON.Reader) throws -> ApiGatewayV2ClientTypes.VpcLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApiGatewayV2ClientTypes.VpcLink()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcLinkId = try reader["vpcLinkId"].readIfPresent() ?? ""
        value.vpcLinkStatus = try reader["vpcLinkStatus"].readIfPresent()
        value.vpcLinkStatusMessage = try reader["vpcLinkStatusMessage"].readIfPresent()
        value.vpcLinkVersion = try reader["vpcLinkVersion"].readIfPresent()
        return value
    }
}

extension ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput {

    static func write(value: ApiGatewayV2ClientTypes.MutualTlsAuthenticationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["truststoreUri"].write(value.truststoreUri)
        try writer["truststoreVersion"].write(value.truststoreVersion)
    }
}

extension ApiGatewayV2ClientTypes.TlsConfigInput {

    static func write(value: ApiGatewayV2ClientTypes.TlsConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverNameToVerify"].write(value.serverNameToVerify)
    }
}

public enum ApiGatewayV2ClientTypes {}
