//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see [Access Management](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM User Guide.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct AccountInsightHealth {
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
        public var openProactiveInsights: Swift.Int
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
        public var openReactiveInsights: Swift.Int

        public init(
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Returns the number of open reactive insights, the number of open proactive insights, and the number of metrics analyzed in your Amazon Web Services account. Use these numbers to gauge the health of operations in your Amazon Web Services account.
    public struct AccountHealth {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.AccountInsightHealth?

        public init(
            accountId: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.AccountInsightHealth? = nil
        )
        {
            self.accountId = accountId
            self.insight = insight
        }
    }

}

/// An exception that is thrown when a conflict occurs.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the Amazon Web Services resource in which a conflict occurred.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the Amazon Web Services resource in which a conflict occurred.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal failure in an Amazon service occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds after which the action that caused the internal server exception can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// A requested resource could not be found
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the Amazon Web Services resource that could not be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the Amazon Web Services resource that could not be found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request contains a value that exceeds a maximum quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to a request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded, causing the throttling exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds after which the action that caused the throttling exception can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code of the service that caused the throttling exception.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension DevOpsGuruClientTypes {
    /// The field associated with the validation exception.
    public struct ValidationExceptionField {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case invalidParameterCombination
        case other
        case parameterInconsistentWithServiceState
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .invalidParameterCombination,
                .other,
                .parameterInconsistentWithServiceState,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidParameterCombination: return "INVALID_PARAMETER_COMBINATION"
            case .other: return "OTHER"
            case .parameterInconsistentWithServiceState: return "PARAMETER_INCONSISTENT_WITH_SERVICE_STATE"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Contains information about data passed in to a field during a request that is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An array of fields that are associated with the validation exception.
        public internal(set) var fields: [DevOpsGuruClientTypes.ValidationExceptionField]? = nil
        /// A message that describes the validation exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the validation exception was thrown.
        public internal(set) var reason: DevOpsGuruClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [DevOpsGuruClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DevOpsGuruClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension DevOpsGuruClientTypes {

    public enum NotificationMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closedInsight
        case newAssociation
        case newInsight
        case newRecommendation
        case severityUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationMessageType] {
            return [
                .closedInsight,
                .newAssociation,
                .newInsight,
                .newRecommendation,
                .severityUpgraded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closedInsight: return "CLOSED_INSIGHT"
            case .newAssociation: return "NEW_ASSOCIATION"
            case .newInsight: return "NEW_INSIGHT"
            case .newRecommendation: return "NEW_RECOMMENDATION"
            case .severityUpgraded: return "SEVERITY_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {

    public enum InsightSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightSeverity] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// The filter configurations for the Amazon SNS notification topic you use with DevOps Guru. You can choose to specify which events or message types to receive notifications for. You can also choose to specify which severity levels to receive notifications for.
    public struct NotificationFilterConfig {
        /// The events that you want to receive notifications for. For example, you can choose to receive notifications only when the severity level is upgraded or a new insight is created.
        public var messageTypes: [DevOpsGuruClientTypes.NotificationMessageType]?
        /// The severity levels that you want to receive notifications for. For example, you can choose to receive notifications only for insights with HIGH and MEDIUM severity levels. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities).
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?

        public init(
            messageTypes: [DevOpsGuruClientTypes.NotificationMessageType]? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil
        )
        {
            self.messageTypes = messageTypes
            self.severities = severities
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Contains the Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMS–encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct SnsChannelConfig {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about notification channels you have configured with DevOps Guru. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    public struct NotificationChannelConfig {
        /// The filter configurations for the Amazon SNS notification topic you use with DevOps Guru. If you do not provide filter configurations, the default configurations are to receive notifications for all message types of High or Medium severity.
        public var filters: DevOpsGuruClientTypes.NotificationFilterConfig?
        /// Information about a notification channel configured in DevOps Guru to send notifications when insights are created. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMS–encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
        /// This member is required.
        public var sns: DevOpsGuruClientTypes.SnsChannelConfig?

        public init(
            filters: DevOpsGuruClientTypes.NotificationFilterConfig? = nil,
            sns: DevOpsGuruClientTypes.SnsChannelConfig? = nil
        )
        {
            self.filters = filters
            self.sns = sns
        }
    }

}

public struct AddNotificationChannelInput {
    /// A NotificationChannelConfig object that specifies what type of notification channel to add. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    /// This member is required.
    public var config: DevOpsGuruClientTypes.NotificationChannelConfig?

    public init(
        config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil
    )
    {
        self.config = config
    }
}

public struct AddNotificationChannelOutput {
    /// The ID of the added notification channel.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension DevOpsGuruClientTypes {

    public enum EventSourceOptInStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceOptInStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Information about your account's integration with Amazon CodeGuru Profiler. This returns whether DevOps Guru is configured to consume recommendations generated from Amazon CodeGuru Profiler.
    public struct AmazonCodeGuruProfilerIntegration {
        /// The status of the CodeGuru Profiler integration. Specifies if DevOps Guru is enabled to consume recommendations that are generated from Amazon CodeGuru Profiler.
        public var status: DevOpsGuruClientTypes.EventSourceOptInStatus?

        public init(
            status: DevOpsGuruClientTypes.EventSourceOptInStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum LogAnomalyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blockFormat
        case format
        case httpCode
        case keyword
        case keywordToken
        case newFieldName
        case numericalNan
        case numericalPoint
        case sdkUnknown(Swift.String)

        public static var allCases: [LogAnomalyType] {
            return [
                .blockFormat,
                .format,
                .httpCode,
                .keyword,
                .keywordToken,
                .newFieldName,
                .numericalNan,
                .numericalPoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blockFormat: return "BLOCK_FORMAT"
            case .format: return "FORMAT"
            case .httpCode: return "HTTP_CODE"
            case .keyword: return "KEYWORD"
            case .keywordToken: return "KEYWORD_TOKEN"
            case .newFieldName: return "NEW_FIELD_NAME"
            case .numericalNan: return "NUMERICAL_NAN"
            case .numericalPoint: return "NUMERICAL_POINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomalous log event found within a log group.
    public struct LogAnomalyClass {
        /// The explanation for why the log event is considered an anomaly.
        public var explanation: Swift.String?
        /// The token where the anomaly was detected. This may refer to an exception or another location, or it may be blank for log anomalies such as format anomalies.
        public var logAnomalyToken: Swift.String?
        /// The type of log anomaly that has been detected.
        public var logAnomalyType: DevOpsGuruClientTypes.LogAnomalyType?
        /// The ID of the log event.
        public var logEventId: Swift.String?
        /// The time of the first occurrence of the anomalous log event.
        public var logEventTimestamp: Foundation.Date?
        /// The name of the Amazon CloudWatch log stream that the anomalous log event belongs to. A log stream is a sequence of log events that share the same source.
        public var logStreamName: Swift.String?
        /// The number of log lines where this anomalous log event occurs.
        public var numberOfLogLinesOccurrences: Swift.Int

        public init(
            explanation: Swift.String? = nil,
            logAnomalyToken: Swift.String? = nil,
            logAnomalyType: DevOpsGuruClientTypes.LogAnomalyType? = nil,
            logEventId: Swift.String? = nil,
            logEventTimestamp: Foundation.Date? = nil,
            logStreamName: Swift.String? = nil,
            numberOfLogLinesOccurrences: Swift.Int = 0
        )
        {
            self.explanation = explanation
            self.logAnomalyToken = logAnomalyToken
            self.logAnomalyType = logAnomalyType
            self.logEventId = logEventId
            self.logEventTimestamp = logEventTimestamp
            self.logStreamName = logStreamName
            self.numberOfLogLinesOccurrences = numberOfLogLinesOccurrences
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A cluster of similar anomalous log events found within a log group.
    public struct LogAnomalyShowcase {
        /// A list of anomalous log events that may be related.
        public var logAnomalyClasses: [DevOpsGuruClientTypes.LogAnomalyClass]?

        public init(
            logAnomalyClasses: [DevOpsGuruClientTypes.LogAnomalyClass]? = nil
        )
        {
            self.logAnomalyClasses = logAnomalyClasses
        }
    }

}

extension DevOpsGuruClientTypes {
    /// An Amazon CloudWatch log group that contains log anomalies and is used to generate an insight.
    public struct AnomalousLogGroup {
        /// The time the anomalous log events stopped.
        public var impactEndTime: Foundation.Date?
        /// The time the anomalous log events began. The impact start time indicates the time of the first log anomaly event that occurs.
        public var impactStartTime: Foundation.Date?
        /// The log anomalies in the log group. Each log anomaly displayed represents a cluster of similar anomalous log events.
        public var logAnomalyShowcases: [DevOpsGuruClientTypes.LogAnomalyShowcase]?
        /// The name of the CloudWatch log group.
        public var logGroupName: Swift.String?
        /// The number of log lines that were scanned for anomalous log events.
        public var numberOfLogLinesScanned: Swift.Int

        public init(
            impactEndTime: Foundation.Date? = nil,
            impactStartTime: Foundation.Date? = nil,
            logAnomalyShowcases: [DevOpsGuruClientTypes.LogAnomalyShowcase]? = nil,
            logGroupName: Swift.String? = nil,
            numberOfLogLinesScanned: Swift.Int = 0
        )
        {
            self.impactEndTime = impactEndTime
            self.impactStartTime = impactStartTime
            self.logAnomalyShowcases = logAnomalyShowcases
            self.logGroupName = logGroupName
            self.numberOfLogLinesScanned = numberOfLogLinesScanned
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when DevOps Guru opens and then closes an anomaly. This is different from AnomalyTimeRange, which specifies the time range when DevOps Guru actually observes the anomalous behavior.
    public struct AnomalyReportedTimeRange {
        /// The time when an anomaly is closed.
        public var closeTime: Foundation.Date?
        /// The time when an anomaly is opened.
        /// This member is required.
        public var openTime: Foundation.Date?

        public init(
            closeTime: Foundation.Date? = nil,
            openTime: Foundation.Date? = nil
        )
        {
            self.closeTime = closeTime
            self.openTime = openTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resources in which DevOps Guru detected unusual behavior that resulted in the generation of an anomaly. When DevOps Guru detects multiple related anomalies, it creates and insight with details about the anomalous behavior and suggestions about how to correct the problem.
    public struct AnomalyResource {
        /// The name of the Amazon Web Services resource.
        public var name: Swift.String?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum AnomalySeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySeverity] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// The dimension of an Amazon CloudWatch metric that is used when DevOps Guru analyzes the resources in your account for operational problems and anomalous behavior. A dimension is a name/value pair that is part of the identity of a metric. A metric can have up to 10 dimensions. For more information, see [Dimensions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension) in the Amazon CloudWatch User Guide.
    public struct CloudWatchMetricsDimension {
        /// The name of the CloudWatch dimension.
        public var name: Swift.String?
        /// The value of the CloudWatch dimension.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum CloudWatchMetricDataStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case internalError
        case partialData
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricDataStatusCode] {
            return [
                .complete,
                .internalError,
                .partialData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .internalError: return "InternalError"
            case .partialData: return "PartialData"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// A pair that contains metric values at the respective timestamp.
    public struct TimestampMetricValuePair {
        /// Value of the anomalous metric data point at respective Timestamp.
        public var metricValue: Swift.Double?
        /// A Timestamp that specifies the time the event occurred.
        public var timestamp: Foundation.Date?

        public init(
            metricValue: Swift.Double? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.metricValue = metricValue
            self.timestamp = timestamp
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Contains information about the analyzed metrics that displayed anomalous behavior.
    public struct CloudWatchMetricsDataSummary {
        /// This is an enum of the status showing whether the metric value pair list has partial or complete data, or if there was an error.
        public var statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode?
        /// This is a list of Amazon CloudWatch metric values at given timestamp.
        public var timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]?

        public init(
            statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode? = nil,
            timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]? = nil
        )
        {
            self.statusCode = statusCode
            self.timestampMetricValuePairList = timestampMetricValuePairList
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum CloudWatchMetricsStat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case maximum
        case minimum
        case p50
        case p90
        case p99
        case sampleCount
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricsStat] {
            return [
                .average,
                .maximum,
                .minimum,
                .p50,
                .p90,
                .p99,
                .sampleCount,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "Average"
            case .maximum: return "Maximum"
            case .minimum: return "Minimum"
            case .p50: return "p50"
            case .p90: return "p90"
            case .p99: return "p99"
            case .sampleCount: return "SampleCount"
            case .sum: return "Sum"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric.
    public struct CloudWatchMetricsDetail {
        /// An array of CloudWatch dimensions associated with
        public var dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]?
        /// This object returns anomaly metric data.
        public var metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary?
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?
        /// The length of time associated with the CloudWatch metric in number of seconds.
        public var period: Swift.Int
        /// The type of statistic associated with the CloudWatch metric. For more information, see [Statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic) in the Amazon CloudWatch User Guide.
        public var stat: DevOpsGuruClientTypes.CloudWatchMetricsStat?
        /// The unit of measure used for the CloudWatch metric. For example, Bytes, Seconds, Count, and Percent.
        public var unit: Swift.String?

        public init(
            dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]? = nil,
            metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil,
            period: Swift.Int = 0,
            stat: DevOpsGuruClientTypes.CloudWatchMetricsStat? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metricDataSummary = metricDataSummary
            self.metricName = metricName
            self.namespace = namespace
            self.period = period
            self.stat = stat
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions: db.sql.id, db.sql.db_id, db.sql.statement, and db.sql.tokenized_id. Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricDimensionGroup {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host.id - The host ID of the connected client (all engines)
        ///
        /// * db.host.name - The host name of the connected client (all engines)
        ///
        /// * db.name - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.session_type.name - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql.id - The SQL ID generated by Performance Insights (all engines)
        ///
        /// * db.sql.db_id - The SQL ID generated by the database (all engines)
        ///
        /// * db.sql.statement - The SQL text that is being executed (all engines)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The SQL digest ID generated by Performance Insights (all engines)
        ///
        /// * db.sql_tokenized.db_id - SQL digest ID generated by the database (all engines)
        ///
        /// * db.sql_tokenized.statement - The SQL digest text (all engines)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines)
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines)
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines)
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Its valid values are:
        ///
        /// * db - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.application - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host - The host name of the connected client (all engines)
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql - The SQL that is currently executing (all engines)
        ///
        /// * db.sql_tokenized - The SQL digest (all engines)
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines)
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines)
        ///
        /// * db.user - The user logged in to the database (all engines)
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init(
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A single query to be processed. Use these parameters to query the Performance Insights GetResourceMetrics API to retrieve the metrics for an anomaly. For more information, see [GetResourceMetrics](https://docs.aws.amazon.com/performance-insights/latest/APIReference/API_GetResourceMetrics.html) in the Amazon RDS Performance Insights API Reference. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricQuery {
        /// One or more filters to apply to a Performance Insights GetResourceMetrics API query. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String: Swift.String]?
        /// The specification for how to aggregate the data points from a Performance Insights GetResourceMetrics API query. The Performance Insights query returns all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup?
        /// The name of the meteric used used when querying an Performance Insights GetResourceMetrics API for anomaly metrics. Valid values for Metric are:
        ///
        /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - the raw number of active sessions for the database engine.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        public var metric: Swift.String?

        public init(
            filter: [Swift.String: Swift.String]? = nil,
            groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a reference metric used to evaluate Performance Insights.
    public struct PerformanceInsightsReferenceMetric {
        /// A query to be processed on the metric.
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?

        public init(
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil
        )
        {
            self.metricQuery = metricQuery
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A reference value to compare Performance Insights metrics against to determine if the metrics demonstrate anomalous behavior.
    public struct PerformanceInsightsReferenceScalar {
        /// The reference value.
        public var value: Swift.Double?

        public init(
            value: Swift.Double? = nil
        )
        {
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Reference scalar values and other metrics that DevOps Guru displays on a graph in its console along with the actual metrics it analyzed. Compare these reference values to your actual metrics to help you understand anomalous behavior that DevOps Guru detected.
    public struct PerformanceInsightsReferenceComparisonValues {
        /// A metric that DevOps Guru compares to actual metric values. This reference metric is used to determine if an actual metric should be considered anomalous.
        public var referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric?
        /// A scalar value DevOps Guru for a metric that DevOps Guru compares to actual metric values. This reference value is used to determine if an actual metric value should be considered anomalous.
        public var referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar?

        public init(
            referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric? = nil,
            referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar? = nil
        )
        {
            self.referenceMetric = referenceMetric
            self.referenceScalar = referenceScalar
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Reference data used to evaluate Performance Insights to determine if its performance is anomalous or not.
    public struct PerformanceInsightsReferenceData {
        /// The specific reference values used to evaluate the Performance Insights. For more information, see [PerformanceInsightsReferenceComparisonValues](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceComparisonValues.html).
        public var comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues?
        /// The name of the reference data.
        public var name: Swift.String?

        public init(
            comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues? = nil,
            name: Swift.String? = nil
        )
        {
            self.comparisonValues = comparisonValues
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A statistic in a Performance Insights collection.
    public struct PerformanceInsightsStat {
        /// The statistic type.
        public var type: Swift.String?
        /// The value of the statistic.
        public var value: Swift.Double?

        public init(
            type: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Details about Performance Insights metrics. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricsDetail {
        /// The name used for a specific Performance Insights metric.
        public var metricDisplayName: Swift.String?
        /// A single query to be processed for the metric. For more information, see [PerformanceInsightsMetricQuery](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsMetricQuery.html).
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?
        /// For more information, see [PerformanceInsightsReferenceData](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceData.html).
        public var referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]?
        /// The metric statistics during the anomalous period detected by DevOps Guru;
        public var statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// Typical metric statistics that are not considered anomalous. When DevOps Guru analyzes metrics, it compares them to StatsAtBaseline to help determine if they are anomalous.
        public var statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// The unit of measure for a metric. For example, a session or a process.
        public var unit: Swift.String?

        public init(
            metricDisplayName: Swift.String? = nil,
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil,
            referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]? = nil,
            statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            unit: Swift.String? = nil
        )
        {
            self.metricDisplayName = metricDisplayName
            self.metricQuery = metricQuery
            self.referenceData = referenceData
            self.statsAtAnomaly = statsAtAnomaly
            self.statsAtBaseline = statsAtBaseline
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Details about the source of the anomalous operational data that triggered the anomaly.
    public struct AnomalySourceDetails {
        /// An array of CloudWatchMetricsDetail objects that contain information about analyzed CloudWatch metrics that show anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]?
        /// An array of PerformanceInsightsMetricsDetail objects that contain information about analyzed Performance Insights metrics that show anomalous behavior.
        public var performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]?

        public init(
            cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]? = nil,
            performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.performanceInsightsMetrics = performanceInsightsMetrics
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Metadata about the detection source that generates proactive anomalies. The anomaly is detected using analysis of the metric data  over a period of time
    public struct AnomalySourceMetadata {
        /// The source of the anomaly.
        public var source: Swift.String?
        /// The name of the anomaly's resource.
        public var sourceResourceName: Swift.String?
        /// The anomaly's resource type.
        public var sourceResourceType: Swift.String?

        public init(
            source: Swift.String? = nil,
            sourceResourceName: Swift.String? = nil,
            sourceResourceType: Swift.String? = nil
        )
        {
            self.source = source
            self.sourceResourceName = sourceResourceName
            self.sourceResourceType = sourceResourceType
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum AnomalyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyStatus] {
            return [
                .closed,
                .ongoing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
    public struct AnomalyTimeRange {
        /// The time when the anomalous behavior ended.
        public var endTime: Foundation.Date?
        /// The time when the anomalous behavior started.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum AnomalyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case causal
        case contextual
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyType] {
            return [
                .causal,
                .contextual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .causal: return "CAUSAL"
            case .contextual: return "CONTEXTUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteInsightInput {
    /// The ID of the insight.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteInsightOutput {

    public init() { }
}

public struct DescribeAccountHealthInput {

    public init() { }
}

public struct DescribeAccountHealthOutput {
    /// Number of resources that DevOps Guru is monitoring in your Amazon Web Services account.
    public var analyzedResourceCount: Swift.Int?
    /// An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init(
        analyzedResourceCount: Swift.Int? = nil,
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.analyzedResourceCount = analyzedResourceCount
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

public struct DescribeAccountOverviewInput {
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: Foundation.Date?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: Foundation.Date?

    public init(
        fromTime: Foundation.Date? = nil,
        toTime: Foundation.Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

public struct DescribeAccountOverviewOutput {
    /// The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in.
    /// This member is required.
    public var meanTimeToRecoverInMilliseconds: Swift.Int?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init(
        meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

public struct DescribeAnomalyInput {
    /// The ID of the member account.
    public var accountId: Swift.String?
    /// The ID of the anomaly.
    /// This member is required.
    public var id: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    public struct PredictionTimeRange {
        /// The time when the behavior in a proactive insight is expected to end.
        public var endTime: Foundation.Date?
        /// The time range during which a metric limit is expected to be exceeded. This applies to proactive insights only.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollection {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services tags. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public struct TagCollection {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct ResourceCollection {
        /// An array of the names of Amazon Web Services CloudFormation stacks. The stacks define Amazon Web Services resources that DevOps Guru analyzes. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection?
        /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollection]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection? = nil,
            tags: [DevOpsGuruClientTypes.TagCollection]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly. This object is returned by ListAnomalies.
    public struct ProactiveAnomaly {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// A description of the proactive anomaly.
        public var description: Swift.String?
        /// The ID of a proactive anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The metadata for the anomaly.
        public var sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata?
        /// The status of a proactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: Foundation.Date?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by ListAnomalies.
    public struct ReactiveAnomaly {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

public struct DescribeAnomalyOutput {
    /// A ProactiveAnomaly object that represents the requested anomaly.
    public var proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly?
    /// A ReactiveAnomaly object that represents the requested anomaly.
    public var reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly?

    public init(
        proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly? = nil,
        reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly? = nil
    )
    {
        self.proactiveAnomaly = proactiveAnomaly
        self.reactiveAnomaly = reactiveAnomaly
    }
}

public struct DescribeEventSourcesConfigInput {

    public init() { }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru as consumer with another AWS service, such as AWS CodeGuru Profiler via EventBridge.
    public struct EventSourcesConfig {
        /// Information about whether DevOps Guru is configured to consume recommendations which are generated from AWS CodeGuru Profiler.
        public var amazonCodeGuruProfiler: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration?

        public init(
            amazonCodeGuruProfiler: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration? = nil
        )
        {
            self.amazonCodeGuruProfiler = amazonCodeGuruProfiler
        }
    }

}

public struct DescribeEventSourcesConfigOutput {
    /// Lists the event sources in the configuration.
    public var eventSources: DevOpsGuruClientTypes.EventSourcesConfig?

    public init(
        eventSources: DevOpsGuruClientTypes.EventSourcesConfig? = nil
    )
    {
        self.eventSources = eventSources
    }
}

public struct DescribeFeedbackInput {
    /// The ID of the insight for which the feedback was provided.
    public var insightId: Swift.String?

    public init(
        insightId: Swift.String? = nil
    )
    {
        self.insightId = insightId
    }
}

extension DevOpsGuruClientTypes {

    public enum InsightFeedbackOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alertTooSensitive
        case dataIncorrect
        case dataNoisyAnomaly
        case recommendationUseful
        case validCollection
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightFeedbackOption] {
            return [
                .alertTooSensitive,
                .dataIncorrect,
                .dataNoisyAnomaly,
                .recommendationUseful,
                .validCollection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alertTooSensitive: return "ALERT_TOO_SENSITIVE"
            case .dataIncorrect: return "DATA_INCORRECT"
            case .dataNoisyAnomaly: return "DATA_NOISY_ANOMALY"
            case .recommendationUseful: return "RECOMMENDATION_USEFUL"
            case .validCollection: return "VALID_COLLECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Information about insight feedback received from a customer.
    public struct InsightFeedback {
        /// The feedback provided by the customer.
        public var feedback: DevOpsGuruClientTypes.InsightFeedbackOption?
        /// The insight feedback ID.
        public var id: Swift.String?

        public init(
            feedback: DevOpsGuruClientTypes.InsightFeedbackOption? = nil,
            id: Swift.String? = nil
        )
        {
            self.feedback = feedback
            self.id = id
        }
    }

}

public struct DescribeFeedbackOutput {
    /// Information about insight feedback received from a customer.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init(
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

public struct DescribeInsightInput {
    /// The ID of the member account in the organization.
    public var accountId: Swift.String?
    /// The ID of the insight.
    /// This member is required.
    public var id: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

extension DevOpsGuruClientTypes {
    /// A time ranged that specifies when the observed behavior in an insight started and ended.
    public struct InsightTimeRange {
        /// The time when the behavior described in an insight ended.
        public var endTime: Foundation.Date?
        /// The time when the behavior described in an insight started.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum InsightStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightStatus] {
            return [
                .closed,
                .ongoing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by ListInsights.
    public struct ProactiveInsight {
        /// Describes the proactive insight.
        public var description: Swift.String?
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by ListInsights.
    public struct ReactiveInsight {
        /// Describes the reactive insight.
        public var description: Swift.String?
        /// The ID of a reactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

public struct DescribeInsightOutput {
    /// A ProactiveInsight object that represents the requested insight.
    public var proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight?
    /// A ReactiveInsight object that represents the requested insight.
    public var reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight?

    public init(
        proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight? = nil,
        reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight? = nil
    )
    {
        self.proactiveInsight = proactiveInsight
        self.reactiveInsight = reactiveInsight
    }
}

public struct DescribeOrganizationHealthInput {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.organizationalUnitIds = organizationalUnitIds
    }
}

public struct DescribeOrganizationHealthOutput {
    /// An integer that specifies the number of metrics that have been analyzed in your organization.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init(
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

public struct DescribeOrganizationOverviewInput {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: Foundation.Date?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: Foundation.Date?

    public init(
        accountIds: [Swift.String]? = nil,
        fromTime: Foundation.Date? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        toTime: Foundation.Date? = nil
    )
    {
        self.accountIds = accountIds
        self.fromTime = fromTime
        self.organizationalUnitIds = organizationalUnitIds
        self.toTime = toTime
    }
}

public struct DescribeOrganizationOverviewOutput {
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init(
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

extension DevOpsGuruClientTypes {

    public enum OrganizationResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAccount
        case awsCloudFormation
        case awsService
        case awsTags
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceCollectionType] {
            return [
                .awsAccount,
                .awsCloudFormation,
                .awsService,
                .awsTags
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case .awsTags: return "AWS_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeOrganizationResourceCollectionHealthInput {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationResourceCollectionType = organizationResourceCollectionType
        self.organizationalUnitIds = organizationalUnitIds
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct InsightHealth {
        /// The Meant Time to Recover (MTTR) for the insight.
        public var meanTimeToRecoverInMilliseconds: Swift.Int?
        /// The number of open proactive insights.
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights.
        public var openReactiveInsights: Swift.Int

        public init(
            meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack.
    public struct CloudFormationHealth {
        /// Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services CloudFormation stack.
        public var analyzedResourceCount: Swift.Int?
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The name of the CloudFormation stack.
        public var stackName: Swift.String?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.stackName = stackName
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Contains the number of open proactive and reactive insights in an analyzed Amazon Web Services service.
    public struct ServiceInsightHealth {
        /// The number of open proactive insights in the Amazon Web Services service
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights in the Amazon Web Services service
        public var openReactiveInsights: Swift.Int

        public init(
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiGateway
        case applicationElb
        case autoScalingGroup
        case cloudFront
        case dynamoDb
        case ec2
        case ecs
        case eks
        case elasticBeanstalk
        case elastiCache
        case elb
        case es
        case kinesis
        case lambda
        case natGateway
        case networkElb
        case rds
        case redshift
        case route53
        case s3
        case sageMaker
        case sns
        case sqs
        case stepFunctions
        case swf
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .apiGateway,
                .applicationElb,
                .autoScalingGroup,
                .cloudFront,
                .dynamoDb,
                .ec2,
                .ecs,
                .eks,
                .elasticBeanstalk,
                .elastiCache,
                .elb,
                .es,
                .kinesis,
                .lambda,
                .natGateway,
                .networkElb,
                .rds,
                .redshift,
                .route53,
                .s3,
                .sageMaker,
                .sns,
                .sqs,
                .stepFunctions,
                .swf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .applicationElb: return "APPLICATION_ELB"
            case .autoScalingGroup: return "AUTO_SCALING_GROUP"
            case .cloudFront: return "CLOUD_FRONT"
            case .dynamoDb: return "DYNAMO_DB"
            case .ec2: return "EC2"
            case .ecs: return "ECS"
            case .eks: return "EKS"
            case .elasticBeanstalk: return "ELASTIC_BEANSTALK"
            case .elastiCache: return "ELASTI_CACHE"
            case .elb: return "ELB"
            case .es: return "ES"
            case .kinesis: return "KINESIS"
            case .lambda: return "LAMBDA"
            case .natGateway: return "NAT_GATEWAY"
            case .networkElb: return "NETWORK_ELB"
            case .rds: return "RDS"
            case .redshift: return "REDSHIFT"
            case .route53: return "ROUTE_53"
            case .s3: return "S3"
            case .sageMaker: return "SAGE_MAKER"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case .stepFunctions: return "STEP_FUNCTIONS"
            case .swf: return "SWF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Represents the health of an Amazon Web Services service.
    public struct ServiceHealth {
        /// Number of resources that DevOps Guru is monitoring in an analyzed Amazon Web Services service.
        public var analyzedResourceCount: Swift.Int?
        /// Represents the health of an Amazon Web Services service. This is a ServiceInsightHealth that contains the number of open proactive and reactive insights for this service.
        public var insight: DevOpsGuruClientTypes.ServiceInsightHealth?
        /// The name of the Amazon Web Services service.
        public var serviceName: DevOpsGuruClientTypes.ServiceName?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            insight: DevOpsGuruClientTypes.ServiceInsightHealth? = nil,
            serviceName: DevOpsGuruClientTypes.ServiceName? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.serviceName = serviceName
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services tag key.
    public struct TagHealth {
        /// Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services tag.
        public var analyzedResourceCount: Swift.Int?
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var appBoundaryKey: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services tag, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The value in an Amazon Web Services tag. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public var tagValue: Swift.String?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            appBoundaryKey: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.appBoundaryKey = appBoundaryKey
            self.insight = insight
            self.tagValue = tagValue
        }
    }

}

public struct DescribeOrganizationResourceCollectionHealthOutput {
    /// The name of the organization's account.
    public var account: [DevOpsGuruClientTypes.AccountHealth]?
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?
    /// Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public var tags: [DevOpsGuruClientTypes.TagHealth]?

    public init(
        account: [DevOpsGuruClientTypes.AccountHealth]? = nil,
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil,
        tags: [DevOpsGuruClientTypes.TagHealth]? = nil
    )
    {
        self.account = account
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
        self.tags = tags
    }
}

extension DevOpsGuruClientTypes {

    public enum ResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsCloudFormation
        case awsService
        case awsTags
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .awsCloudFormation,
                .awsService,
                .awsTags
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case .awsTags: return "AWS_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeResourceCollectionHealthInput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

public struct DescribeResourceCollectionHealthOutput {
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?
    /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public var tags: [DevOpsGuruClientTypes.TagHealth]?

    public init(
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil,
        tags: [DevOpsGuruClientTypes.TagHealth]? = nil
    )
    {
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
        self.tags = tags
    }
}

public struct DescribeServiceIntegrationInput {

    public init() { }
}

extension DevOpsGuruClientTypes {

    /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
    public enum OptInStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {

    public enum ServerSideEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOwnedKmsKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionType] {
            return [
                .awsOwnedKmsKey,
                .customerManagedKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKmsKey: return "AWS_OWNED_KMS_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the KMS encryption used with DevOps Guru.
    public struct KMSServerSideEncryptionIntegration {
        /// Describes the specified KMS key. To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix it with "alias/". If you specify a predefined Amazon Web Services alias (an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an Amazon Web Services managed key and returns its KeyId and Arn in the response. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example: Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public var kmsKeyId: Swift.String?
        /// Specifies if DevOps Guru is enabled for customer managed keys.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?
        /// The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        public var type: DevOpsGuruClientTypes.ServerSideEncryptionType?

        public init(
            kmsKeyId: Swift.String? = nil,
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil,
            type: DevOpsGuruClientTypes.ServerSideEncryptionType? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with CloudWatch log groups for log anomaly detection.
    public struct LogsAnomalyDetectionIntegration {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
    public struct OpsCenterIntegration {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public struct ServiceIntegrationConfig {
        /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        public var kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration?
        /// Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        public var logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration?
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration?

        public init(
            kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration? = nil,
            logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration? = nil,
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration? = nil
        )
        {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }
    }

}

public struct DescribeServiceIntegrationOutput {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public var serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig?

    public init(
        serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

public struct GetCostEstimationInput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {

    public enum CostEstimationServiceResourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationServiceResourceState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// An object that contains information about the estimated monthly cost to analyze an Amazon Web Services resource. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct ServiceResourceCost {
        /// The total estimated monthly cost to analyze the active resources for this resource.
        public var cost: Swift.Double
        /// The number of active resources analyzed for this service to create a monthly cost estimate.
        public var count: Swift.Int
        /// The state of the resource. The resource is ACTIVE if it produces metrics, events, or logs within an hour, otherwise it is INACTIVE. You pay for the number of active Amazon Web Services resource hours analyzed for each resource. Inactive resources are not charged.
        public var state: DevOpsGuruClientTypes.CostEstimationServiceResourceState?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?
        /// The price per hour to analyze the resources in the service. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
        public var unitCost: Swift.Double

        public init(
            cost: Swift.Double = 0.0,
            count: Swift.Int = 0,
            state: DevOpsGuruClientTypes.CostEstimationServiceResourceState? = nil,
            type: Swift.String? = nil,
            unitCost: Swift.Double = 0.0
        )
        {
            self.cost = cost
            self.count = count
            self.state = state
            self.type = type
            self.unitCost = unitCost
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services CloudFormation stack used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of stacks you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the stack. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCostEstimationResourceCollectionFilter {
        /// An array of CloudFormation stack names. Its size is fixed at 1 item.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a collection of Amazon Web Services resources that are identified by an Amazon Web Services tag. This collection of resources is used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of tags you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the tag. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct TagCostEstimationResourceCollectionFilter {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed to create a monthly DevOps Guru cost estimate. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct CostEstimationResourceCollectionFilter {
        /// An object that specifies the CloudFormation stack that defines the Amazon Web Services resources used to create a monthly estimate for DevOps Guru.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter?
        /// The Amazon Web Services tags used to filter the resource collection that is used for a cost estimate. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {

    public enum CostEstimationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationStatus] {
            return [
                .completed,
                .ongoing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// The time range of a cost estimation.
    public struct CostEstimationTimeRange {
        /// The end time of the cost estimation.
        public var endTime: Foundation.Date?
        /// The start time of the cost estimation.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct GetCostEstimationOutput {
    /// An array of ResourceCost objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.
    public var costs: [DevOpsGuruClientTypes.ServiceResourceCost]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    /// The status of creating this cost estimate. If it's still in progress, the status ONGOING is returned. If it is finished, the status COMPLETED is returned.
    public var status: DevOpsGuruClientTypes.CostEstimationStatus?
    /// The start and end time of the cost estimation.
    public var timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange?
    /// The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the Costs object in this response.
    public var totalCost: Swift.Double

    public init(
        costs: [DevOpsGuruClientTypes.ServiceResourceCost]? = nil,
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil,
        status: DevOpsGuruClientTypes.CostEstimationStatus? = nil,
        timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange? = nil,
        totalCost: Swift.Double = 0.0
    )
    {
        self.costs = costs
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
        self.status = status
        self.timeRange = timeRange
        self.totalCost = totalCost
    }
}

public struct GetResourceCollectionInput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of Amazon Web Services resource collections to return. The one valid value is CLOUD_FORMATION for Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollectionFilter {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services tags used to filter insights. This is used to return insights generated from only resources that contain the tags in the tag collection.
    public struct TagCollectionFilter {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed for anomalous behavior by DevOps Guru.
    public struct ResourceCollectionFilter {
        /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter?
        /// The Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

public struct GetResourceCollectionOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public var resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of the names of Amazon Web Services services.
    public struct ServiceCollection {
        /// An array of strings that each specifies the name of an Amazon Web Services service.
        public var serviceNames: [DevOpsGuruClientTypes.ServiceName]?

        public init(
            serviceNames: [DevOpsGuruClientTypes.ServiceName]? = nil
        )
        {
            self.serviceNames = serviceNames
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Specifies one or more service names that are used to list anomalies.
    public struct ListAnomaliesForInsightFilters {
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?

        public init(
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil
        )
        {
            self.serviceCollection = serviceCollection
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A time range used to specify when the behavior of an insight or anomaly started.
    public struct StartTimeRange {
        /// The start time of the time range.
        public var fromTime: Foundation.Date?
        /// The end time of the time range.
        public var toTime: Foundation.Date?

        public init(
            fromTime: Foundation.Date? = nil,
            toTime: Foundation.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

public struct ListAnomaliesForInsightInput {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// Specifies one or more service names that are used to list anomalies.
    public var filters: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters?
    /// The ID of the insight. The returned anomalies belong to this insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the requested anomalies started. All returned anomalies started during this time range.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?

    public init(
        accountId: Swift.String? = nil,
        filters: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters? = nil,
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil
    )
    {
        self.accountId = accountId
        self.filters = filters
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive anomaly. This object is returned by DescribeAnomaly.
    public struct ProactiveAnomalySummary {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// A description of the proactive anomaly.
        public var description: Swift.String?
        /// The ID of the anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The metadata of the source which detects proactive anomalies.
        public var sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: Foundation.Date?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by DescribeAnomaly.
    public struct ReactiveAnomalySummary {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the reactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

public struct ListAnomaliesForInsightOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ProactiveAnomalySummary objects that represent the requested anomalies
    public var proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]?
    /// An array of ReactiveAnomalySummary objects that represent the requested anomalies
    public var reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]? = nil,
        reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveAnomalies = proactiveAnomalies
        self.reactiveAnomalies = reactiveAnomalies
    }
}

public struct ListAnomalousLogGroupsInput {
    /// The ID of the insight containing the log groups.
    /// This member is required.
    public var insightId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAnomalousLogGroupsOutput {
    /// The list of Amazon CloudWatch log groups that are related to an insight.
    /// This member is required.
    public var anomalousLogGroups: [DevOpsGuruClientTypes.AnomalousLogGroup]?
    /// The ID of the insight containing the log groups.
    /// This member is required.
    public var insightId: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        anomalousLogGroups: [DevOpsGuruClientTypes.AnomalousLogGroup]? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalousLogGroups = anomalousLogGroups
        self.insightId = insightId
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {

    public enum EventDataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsCloudTrail
        case awsCodeDeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataSource] {
            return [
                .awsCloudTrail,
                .awsCodeDeploy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsCloudTrail: return "AWS_CLOUD_TRAIL"
            case .awsCodeDeploy: return "AWS_CODE_DEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {

    public enum EventClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configChange
        case deployment
        case infrastructure
        case schemaChange
        case securityChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventClass] {
            return [
                .configChange,
                .deployment,
                .infrastructure,
                .schemaChange,
                .securityChange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configChange: return "CONFIG_CHANGE"
            case .deployment: return "DEPLOYMENT"
            case .infrastructure: return "INFRASTRUCTURE"
            case .schemaChange: return "SCHEMA_CHANGE"
            case .securityChange: return "SECURITY_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which an Amazon Web Services event occurred. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventTimeRange {
        /// The time when the event started.
        /// This member is required.
        public var fromTime: Foundation.Date?
        /// The time when the event ended.
        /// This member is required.
        public var toTime: Foundation.Date?

        public init(
            fromTime: Foundation.Date? = nil,
            toTime: Foundation.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct ListEventsFilters {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, of the events you want returned.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the events you want to filter for, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the events you want to filter for.
        public var eventSource: Swift.String?
        /// A time range during which you want the filtered events to have occurred.
        public var eventTimeRange: DevOpsGuruClientTypes.EventTimeRange?
        /// An ID of an insight that is related to the events you want to filter for.
        public var insightId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?

        public init(
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            eventTimeRange: DevOpsGuruClientTypes.EventTimeRange? = nil,
            insightId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.eventTimeRange = eventTimeRange
            self.insightId = insightId
            self.resourceCollection = resourceCollection
        }
    }

}

public struct ListEventsInput {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// A ListEventsFilters object used to specify which events to return.
    /// This member is required.
    public var filters: DevOpsGuruClientTypes.ListEventsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        filters: DevOpsGuruClientTypes.ListEventsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resource that emitted an event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventResource {
        /// The Amazon Resource Name (ARN) of the resource that emitted an event.
        public var arn: Swift.String?
        /// The name of the resource that emitted an event.
        public var name: Swift.String?
        /// The type of resource that emitted an event.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// An Amazon Web Services resource event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct Event {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, where DevOps Guru analysis found the event.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the event. The class specifies what the event is related to, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the event.
        public var eventSource: Swift.String?
        /// The ID of the event.
        public var id: Swift.String?
        /// The name of the event.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// An EventResource object that contains information about the resource that emitted the event.
        public var resources: [DevOpsGuruClientTypes.EventResource]?
        /// A Timestamp that specifies the time the event occurred.
        public var time: Foundation.Date?

        public init(
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            resources: [DevOpsGuruClientTypes.EventResource]? = nil,
            time: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.resources = resources
            self.time = time
        }
    }

}

public struct ListEventsOutput {
    /// A list of the requested events.
    /// This member is required.
    public var events: [DevOpsGuruClientTypes.Event]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        events: [DevOpsGuruClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {

    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case proactive
        case reactive
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .proactive,
                .reactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .proactive: return "PROACTIVE"
            case .reactive: return "REACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have any status.
    public struct ListInsightsAnyStatusFilter {
        /// A time range used to specify when the behavior of the filtered insights started.
        /// This member is required.
        public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.startTimeRange = startTimeRange
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A range of time that specifies when anomalous behavior in an anomaly or insight ended.
    public struct EndTimeRange {
        /// The earliest end time in the time range.
        public var fromTime: Foundation.Date?
        /// The latest end time in the time range.
        public var toTime: Foundation.Date?

        public init(
            fromTime: Foundation.Date? = nil,
            toTime: Foundation.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status CLOSED.
    public struct ListInsightsClosedStatusFilter {
        /// A time range used to specify when the behavior of the filtered insights ended.
        /// This member is required.
        public var endTimeRange: DevOpsGuruClientTypes.EndTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            endTimeRange: DevOpsGuruClientTypes.EndTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.endTimeRange = endTimeRange
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status ONGOING.
    public struct ListInsightsOngoingStatusFilter {
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A filter used by ListInsights to specify which insights to return.
    public struct ListInsightsStatusFilter {
        /// A ListInsightsAnyStatusFilter that specifies insights of any status that are either REACTIVE or PROACTIVE.
        public var any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter?
        /// A ListInsightsClosedStatusFilter that specifies closed insights that are either REACTIVE or PROACTIVE.
        public var closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter?
        /// A ListInsightsAnyStatusFilter that specifies ongoing insights that are either REACTIVE or PROACTIVE.
        public var ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter?

        public init(
            any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter? = nil,
            closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter? = nil,
            ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter? = nil
        )
        {
            self.any = any
            self.closed = closed
            self.ongoing = ongoing
        }
    }

}

public struct ListInsightsInput {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A filter used to filter the returned insights by their status. You can specify one status filter.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveInsightSummary {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveInsightSummary {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of a reactive summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

public struct ListInsightsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned list of proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned list of reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

extension DevOpsGuruClientTypes {

    public enum ResourcePermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullPermission
        case missingPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourcePermission] {
            return [
                .fullPermission,
                .missingPermission
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullPermission: return "FULL_PERMISSION"
            case .missingPermission: return "MISSING_PERMISSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {

    public enum ResourceTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudfrontDistribution
        case dynamodbTable
        case ec2NatGateway
        case ecsCluster
        case ecsService
        case eksCluster
        case elasticacheCacheCluster
        case elasticsearchDomain
        case elasticBeanstalkEnvironment
        case elasticLoadBalancerLoadBalancer
        case elasticLoadBalancingV2LoadBalancer
        case elasticLoadBalancingV2TargetGroup
        case kinesisStream
        case lambdaFunction
        case logGroups
        case openSearchServiceDomain
        case rdsDbCluster
        case rdsDbInstance
        case redshiftCluster
        case route53HealthCheck
        case route53HostedZone
        case s3Bucket
        case sagemakerEndpoint
        case snsTopic
        case sqsQueue
        case stepFunctionsActivity
        case stepFunctionsStateMachine
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeFilter] {
            return [
                .cloudfrontDistribution,
                .dynamodbTable,
                .ec2NatGateway,
                .ecsCluster,
                .ecsService,
                .eksCluster,
                .elasticacheCacheCluster,
                .elasticsearchDomain,
                .elasticBeanstalkEnvironment,
                .elasticLoadBalancerLoadBalancer,
                .elasticLoadBalancingV2LoadBalancer,
                .elasticLoadBalancingV2TargetGroup,
                .kinesisStream,
                .lambdaFunction,
                .logGroups,
                .openSearchServiceDomain,
                .rdsDbCluster,
                .rdsDbInstance,
                .redshiftCluster,
                .route53HealthCheck,
                .route53HostedZone,
                .s3Bucket,
                .sagemakerEndpoint,
                .snsTopic,
                .sqsQueue,
                .stepFunctionsActivity,
                .stepFunctionsStateMachine
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
            case .dynamodbTable: return "DYNAMODB_TABLE"
            case .ec2NatGateway: return "EC2_NAT_GATEWAY"
            case .ecsCluster: return "ECS_CLUSTER"
            case .ecsService: return "ECS_SERVICE"
            case .eksCluster: return "EKS_CLUSTER"
            case .elasticacheCacheCluster: return "ELASTICACHE_CACHE_CLUSTER"
            case .elasticsearchDomain: return "ELASTICSEARCH_DOMAIN"
            case .elasticBeanstalkEnvironment: return "ELASTIC_BEANSTALK_ENVIRONMENT"
            case .elasticLoadBalancerLoadBalancer: return "ELASTIC_LOAD_BALANCER_LOAD_BALANCER"
            case .elasticLoadBalancingV2LoadBalancer: return "ELASTIC_LOAD_BALANCING_V2_LOAD_BALANCER"
            case .elasticLoadBalancingV2TargetGroup: return "ELASTIC_LOAD_BALANCING_V2_TARGET_GROUP"
            case .kinesisStream: return "KINESIS_STREAM"
            case .lambdaFunction: return "LAMBDA_FUNCTION"
            case .logGroups: return "LOG_GROUPS"
            case .openSearchServiceDomain: return "OPEN_SEARCH_SERVICE_DOMAIN"
            case .rdsDbCluster: return "RDS_DB_CLUSTER"
            case .rdsDbInstance: return "RDS_DB_INSTANCE"
            case .redshiftCluster: return "REDSHIFT_CLUSTER"
            case .route53HealthCheck: return "ROUTE53_HEALTH_CHECK"
            case .route53HostedZone: return "ROUTE53_HOSTED_ZONE"
            case .s3Bucket: return "S3_BUCKET"
            case .sagemakerEndpoint: return "SAGEMAKER_ENDPOINT"
            case .snsTopic: return "SNS_TOPIC"
            case .sqsQueue: return "SQS_QUEUE"
            case .stepFunctionsActivity: return "STEP_FUNCTIONS_ACTIVITY"
            case .stepFunctionsStateMachine: return "STEP_FUNCTIONS_STATE_MACHINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Filters to determine which monitored resources you want to retrieve. You can filter by resource type or resource permission status.
    public struct ListMonitoredResourcesFilters {
        /// The permission status of a resource.
        /// This member is required.
        public var resourcePermission: DevOpsGuruClientTypes.ResourcePermission?
        /// The type of resource that you wish to retrieve, such as log groups.
        /// This member is required.
        public var resourceTypeFilters: [DevOpsGuruClientTypes.ResourceTypeFilter]?

        public init(
            resourcePermission: DevOpsGuruClientTypes.ResourcePermission? = nil,
            resourceTypeFilters: [DevOpsGuruClientTypes.ResourceTypeFilter]? = nil
        )
        {
            self.resourcePermission = resourcePermission
            self.resourceTypeFilters = resourceTypeFilters
        }
    }

}

public struct ListMonitoredResourcesInput {
    /// Filters to determine which monitored resources you want to retrieve. You can filter by resource type or resource permission status.
    public var filters: DevOpsGuruClientTypes.ListMonitoredResourcesFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        filters: DevOpsGuruClientTypes.ListMonitoredResourcesFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the resource that is being monitored, including the name of the resource, the type of resource, and whether or not permission is given to DevOps Guru to access that resource.
    public struct MonitoredResourceIdentifier {
        /// The time at which DevOps Guru last updated this resource.
        public var lastUpdated: Foundation.Date?
        /// The name of the resource being monitored.
        public var monitoredResourceName: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The permission status of a resource.
        public var resourcePermission: DevOpsGuruClientTypes.ResourcePermission?
        /// The type of resource being monitored.
        public var type: Swift.String?

        public init(
            lastUpdated: Foundation.Date? = nil,
            monitoredResourceName: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            resourcePermission: DevOpsGuruClientTypes.ResourcePermission? = nil,
            type: Swift.String? = nil
        )
        {
            self.lastUpdated = lastUpdated
            self.monitoredResourceName = monitoredResourceName
            self.resourceCollection = resourceCollection
            self.resourcePermission = resourcePermission
            self.type = type
        }
    }

}

public struct ListMonitoredResourcesOutput {
    /// Information about the resource that is being monitored, including the name of the resource, the type of resource, and whether or not permission is given to DevOps Guru to access that resource.
    /// This member is required.
    public var monitoredResourceIdentifiers: [DevOpsGuruClientTypes.MonitoredResourceIdentifier]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        monitoredResourceIdentifiers: [DevOpsGuruClientTypes.MonitoredResourceIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitoredResourceIdentifiers = monitoredResourceIdentifiers
        self.nextToken = nextToken
    }
}

public struct ListNotificationChannelsInput {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a notification channel. A notification channel is used to notify you when DevOps Guru creates an insight. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS). If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMS–encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct NotificationChannel {
        /// A NotificationChannelConfig object that contains information about configured notification channels.
        public var config: DevOpsGuruClientTypes.NotificationChannelConfig?
        /// The ID of a notification channel.
        public var id: Swift.String?

        public init(
            config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil,
            id: Swift.String? = nil
        )
        {
            self.config = config
            self.id = id
        }
    }

}

public struct ListNotificationChannelsOutput {
    /// An array that contains the requested notification channels.
    public var channels: [DevOpsGuruClientTypes.NotificationChannel]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        channels: [DevOpsGuruClientTypes.NotificationChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

public struct ListOrganizationInsightsInput {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// A filter used by ListInsights to specify which insights to return.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationalUnitIds = organizationalUnitIds
        self.statusFilter = statusFilter
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveOrganizationInsightSummary {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveOrganizationInsightSummary {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

public struct ListOrganizationInsightsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

extension DevOpsGuruClientTypes {

    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case esEs
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .esEs,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "DE_DE"
            case .enGb: return "EN_GB"
            case .enUs: return "EN_US"
            case .esEs: return "ES_ES"
            case .frFr: return "FR_FR"
            case .itIt: return "IT_IT"
            case .jaJp: return "JA_JP"
            case .koKr: return "KO_KR"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListRecommendationsInput {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// The ID of the requested insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// A locale that specifies the language to use for recommendations.
    public var locale: DevOpsGuruClientTypes.Locale?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        insightId: Swift.String? = nil,
        locale: DevOpsGuruClientTypes.Locale? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.insightId = insightId
        self.locale = locale
        self.nextToken = nextToken
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a resource in which DevOps Guru detected anomalous behavior.
    public struct RecommendationRelatedAnomalyResource {
        /// The name of the resource.
        public var name: Swift.String?
        /// The type of the resource. Resource types take the same form that is used by Amazon Web Services CloudFormation resource type identifiers, service-provider::service-name::data-type-name. For example, AWS::RDS::DBCluster. For more information, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the Amazon Web Services CloudFormation User Guide.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric that is analyzed by DevOps Guru. It is one of many analyzed metrics that are used to generate insights.
    public struct RecommendationRelatedCloudWatchMetricsSourceDetail {
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Contains an array of RecommendationRelatedCloudWatchMetricsSourceDetail objects that contain the name and namespace of an Amazon CloudWatch metric.
    public struct RecommendationRelatedAnomalySourceDetail {
        /// An array of CloudWatchMetricsDetail objects that contains information about the analyzed metrics that displayed anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]?

        public init(
            cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly that is related to a recommendation.
    public struct RecommendationRelatedAnomaly {
        /// The ID of an anomaly that generated the insight with this recommendation.
        public var anomalyId: Swift.String?
        /// An array of objects that represent resources in which DevOps Guru detected anomalous behavior. Each object contains the name and type of the resource.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]?
        /// Information about where the anomalous behavior related the recommendation was found. For example, details in Amazon CloudWatch metrics.
        public var sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]?

        public init(
            anomalyId: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]? = nil,
            sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]? = nil
        )
        {
            self.anomalyId = anomalyId
            self.resources = resources
            self.sourceDetails = sourceDetails
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services resource that emitted and event that is related to a recommendation in an insight.
    public struct RecommendationRelatedEventResource {
        /// The name of the resource that emitted the event. This corresponds to the Name field in an EventResource object.
        public var name: Swift.String?
        /// The type of the resource that emitted the event. This corresponds to the Type field in an EventResource object.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about an event that is related to a recommendation.
    public struct RecommendationRelatedEvent {
        /// The name of the event. This corresponds to the Name field in an Event object.
        public var name: Swift.String?
        /// A ResourceCollection object that contains arrays of the names of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]?

        public init(
            name: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]? = nil
        )
        {
            self.name = name
            self.resources = resources
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Recommendation information to help you remediate detected anomalous behavior that generated an insight.
    public struct Recommendation {
        /// The category type of the recommendation.
        public var category: Swift.String?
        /// A description of the problem.
        public var description: Swift.String?
        /// A hyperlink to information to help you address the problem.
        public var link: Swift.String?
        /// The name of the recommendation.
        public var name: Swift.String?
        /// The reason DevOps Guru flagged the anomalous behavior as a problem.
        public var reason: Swift.String?
        /// Anomalies that are related to the problem. Use these Anomalies to learn more about what's happening and to help address the issue.
        public var relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]?
        /// Events that are related to the problem. Use these events to learn more about what's happening and to help address the issue.
        public var relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]?

        public init(
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            link: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil,
            relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]? = nil,
            relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]? = nil
        )
        {
            self.category = category
            self.description = description
            self.link = link
            self.name = name
            self.reason = reason
            self.relatedAnomalies = relatedAnomalies
            self.relatedEvents = relatedEvents
        }
    }

}

public struct ListRecommendationsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of the requested recommendations.
    public var recommendations: [DevOpsGuruClientTypes.Recommendation]?

    public init(
        nextToken: Swift.String? = nil,
        recommendations: [DevOpsGuruClientTypes.Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

public struct PutFeedbackInput {
    /// The feedback from customers is about the recommendations in this insight.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init(
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

public struct PutFeedbackOutput {

    public init() { }
}

public struct RemoveNotificationChannelInput {
    /// The ID of the notification channel to be removed.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct RemoveNotificationChannelOutput {

    public init() { }
}

extension DevOpsGuruClientTypes {
    /// Specifies values used to filter responses when searching for insights. You can use a ResourceCollection, ServiceCollection, array of severities, and an array of status values. Each filter type contains one or more values to search for. If you specify multiple filter types, the filter types are joined with an AND, and the request returns only results that match all of the specified filters.
    public struct SearchInsightsFilters {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init(
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

public struct SearchInsightsInput {
    /// A SearchInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The start of the time range passed in. Returned insights occurred after this time.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init(
        filters: DevOpsGuruClientTypes.SearchInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

public struct SearchInsightsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct SearchOrganizationInsightsFilters {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init(
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

public struct SearchOrganizationInsightsInput {
    /// The ID of the Amazon Web Services account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// A SearchOrganizationInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the behavior of an insight or anomaly started.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init(
        accountIds: [Swift.String]? = nil,
        filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

public struct SearchOrganizationInsightsOutput {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

public struct StartCostEstimationInput {
    /// The idempotency token used to identify each cost estimate request.
    public var clientToken: Swift.String?
    /// The collection of Amazon Web Services resources used to create a monthly DevOps Guru cost estimate.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?

    public init(
        clientToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceCollection = resourceCollection
    }
}

public struct StartCostEstimationOutput {

    public init() { }
}

public struct UpdateEventSourcesConfigInput {
    /// Configuration information about the integration of DevOps Guru as the Consumer via EventBridge with another AWS Service.
    public var eventSources: DevOpsGuruClientTypes.EventSourcesConfig?

    public init(
        eventSources: DevOpsGuruClientTypes.EventSourcesConfig? = nil
    )
    {
        self.eventSources = eventSources
    }
}

public struct UpdateEventSourcesConfigOutput {

    public init() { }
}

extension DevOpsGuruClientTypes {

    public enum UpdateResourceCollectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateResourceCollectionAction] {
            return [
                .add,
                .remove
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the names of Amazon Web Services CloudFormation stacks used to update a collection of stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct UpdateCloudFormationCollectionFilter {
        /// An array of the names of the Amazon Web Services CloudFormation stacks to update. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes {
    /// A new collection of Amazon Web Services resources that are defined by an Amazon Web Services tag or tag key/value pair.
    public struct UpdateTagCollectionFilter {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Contains information used to update a collection of Amazon Web Services resources.
    public struct UpdateResourceCollectionFilter {
        /// A collection of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter?
        /// The updated Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

public struct UpdateResourceCollectionInput {
    /// Specifies if the resource collection in the request is added or deleted to the resource collection.
    /// This member is required.
    public var action: DevOpsGuruClientTypes.UpdateResourceCollectionAction?
    /// Contains information used to update a collection of Amazon Web Services resources.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?

    public init(
        action: DevOpsGuruClientTypes.UpdateResourceCollectionAction? = nil,
        resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter? = nil
    )
    {
        self.action = action
        self.resourceCollection = resourceCollection
    }
}

public struct UpdateResourceCollectionOutput {

    public init() { }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
    public struct KMSServerSideEncryptionIntegrationConfig {
        /// Describes the specified KMS key. To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix it with "alias/". If you specify a predefined Amazon Web Services alias (an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an Amazon Web Services managed key and returns its KeyId and Arn in the response. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example: Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public var kmsKeyId: Swift.String?
        /// Specifies if DevOps Guru is enabled for KMS integration.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?
        /// The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        public var type: DevOpsGuruClientTypes.ServerSideEncryptionType?

        public init(
            kmsKeyId: Swift.String? = nil,
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil,
            type: DevOpsGuruClientTypes.ServerSideEncryptionType? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with CloudWatch log groups for log anomaly detection. You can use this to update the configuration.
    public struct LogsAnomalyDetectionIntegrationConfig {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight. You can use this to update the configuration.
    public struct OpsCenterIntegrationConfig {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Information about updating the integration status of an Amazon Web Services service, such as Amazon Web Services Systems Manager, with DevOps Guru.
    public struct UpdateServiceIntegrationConfig {
        /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        public var kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig?
        /// Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        public var logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig?
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight. You can use this to update the configuration.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig?

        public init(
            kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig? = nil,
            logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig? = nil,
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig? = nil
        )
        {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }
    }

}

public struct UpdateServiceIntegrationInput {
    /// An IntegratedServiceConfig object used to specify the integrated service you want to update, and whether you want to update it to enabled or disabled.
    /// This member is required.
    public var serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?

    public init(
        serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

public struct UpdateServiceIntegrationOutput {

    public init() { }
}

extension AddNotificationChannelInput {

    static func urlPathProvider(_ value: AddNotificationChannelInput) -> Swift.String? {
        return "/channels"
    }
}

extension DeleteInsightInput {

    static func urlPathProvider(_ value: DeleteInsightInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/insights/\(id.urlPercentEncoding())"
    }
}

extension DescribeAccountHealthInput {

    static func urlPathProvider(_ value: DescribeAccountHealthInput) -> Swift.String? {
        return "/accounts/health"
    }
}

extension DescribeAccountOverviewInput {

    static func urlPathProvider(_ value: DescribeAccountOverviewInput) -> Swift.String? {
        return "/accounts/overview"
    }
}

extension DescribeAnomalyInput {

    static func urlPathProvider(_ value: DescribeAnomalyInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/anomalies/\(id.urlPercentEncoding())"
    }
}

extension DescribeAnomalyInput {

    static func queryItemProvider(_ value: DescribeAnomalyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        return items
    }
}

extension DescribeEventSourcesConfigInput {

    static func urlPathProvider(_ value: DescribeEventSourcesConfigInput) -> Swift.String? {
        return "/event-sources"
    }
}

extension DescribeFeedbackInput {

    static func urlPathProvider(_ value: DescribeFeedbackInput) -> Swift.String? {
        return "/feedback"
    }
}

extension DescribeInsightInput {

    static func urlPathProvider(_ value: DescribeInsightInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/insights/\(id.urlPercentEncoding())"
    }
}

extension DescribeInsightInput {

    static func queryItemProvider(_ value: DescribeInsightInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        return items
    }
}

extension DescribeOrganizationHealthInput {

    static func urlPathProvider(_ value: DescribeOrganizationHealthInput) -> Swift.String? {
        return "/organization/health"
    }
}

extension DescribeOrganizationOverviewInput {

    static func urlPathProvider(_ value: DescribeOrganizationOverviewInput) -> Swift.String? {
        return "/organization/overview"
    }
}

extension DescribeOrganizationResourceCollectionHealthInput {

    static func urlPathProvider(_ value: DescribeOrganizationResourceCollectionHealthInput) -> Swift.String? {
        return "/organization/health/resource-collection"
    }
}

extension DescribeResourceCollectionHealthInput {

    static func urlPathProvider(_ value: DescribeResourceCollectionHealthInput) -> Swift.String? {
        guard let resourceCollectionType = value.resourceCollectionType else {
            return nil
        }
        return "/accounts/health/resource-collection/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

extension DescribeResourceCollectionHealthInput {

    static func queryItemProvider(_ value: DescribeResourceCollectionHealthInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension DescribeServiceIntegrationInput {

    static func urlPathProvider(_ value: DescribeServiceIntegrationInput) -> Swift.String? {
        return "/service-integrations"
    }
}

extension GetCostEstimationInput {

    static func urlPathProvider(_ value: GetCostEstimationInput) -> Swift.String? {
        return "/cost-estimation"
    }
}

extension GetCostEstimationInput {

    static func queryItemProvider(_ value: GetCostEstimationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetResourceCollectionInput {

    static func urlPathProvider(_ value: GetResourceCollectionInput) -> Swift.String? {
        guard let resourceCollectionType = value.resourceCollectionType else {
            return nil
        }
        return "/resource-collections/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

extension GetResourceCollectionInput {

    static func queryItemProvider(_ value: GetResourceCollectionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAnomaliesForInsightInput {

    static func urlPathProvider(_ value: ListAnomaliesForInsightInput) -> Swift.String? {
        guard let insightId = value.insightId else {
            return nil
        }
        return "/anomalies/insight/\(insightId.urlPercentEncoding())"
    }
}

extension ListAnomalousLogGroupsInput {

    static func urlPathProvider(_ value: ListAnomalousLogGroupsInput) -> Swift.String? {
        return "/list-log-anomalies"
    }
}

extension ListEventsInput {

    static func urlPathProvider(_ value: ListEventsInput) -> Swift.String? {
        return "/events"
    }
}

extension ListInsightsInput {

    static func urlPathProvider(_ value: ListInsightsInput) -> Swift.String? {
        return "/insights"
    }
}

extension ListMonitoredResourcesInput {

    static func urlPathProvider(_ value: ListMonitoredResourcesInput) -> Swift.String? {
        return "/monitoredResources"
    }
}

extension ListNotificationChannelsInput {

    static func urlPathProvider(_ value: ListNotificationChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListOrganizationInsightsInput {

    static func urlPathProvider(_ value: ListOrganizationInsightsInput) -> Swift.String? {
        return "/organization/insights"
    }
}

extension ListRecommendationsInput {

    static func urlPathProvider(_ value: ListRecommendationsInput) -> Swift.String? {
        return "/recommendations"
    }
}

extension PutFeedbackInput {

    static func urlPathProvider(_ value: PutFeedbackInput) -> Swift.String? {
        return "/feedback"
    }
}

extension RemoveNotificationChannelInput {

    static func urlPathProvider(_ value: RemoveNotificationChannelInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

extension SearchInsightsInput {

    static func urlPathProvider(_ value: SearchInsightsInput) -> Swift.String? {
        return "/insights/search"
    }
}

extension SearchOrganizationInsightsInput {

    static func urlPathProvider(_ value: SearchOrganizationInsightsInput) -> Swift.String? {
        return "/organization/insights/search"
    }
}

extension StartCostEstimationInput {

    static func urlPathProvider(_ value: StartCostEstimationInput) -> Swift.String? {
        return "/cost-estimation"
    }
}

extension UpdateEventSourcesConfigInput {

    static func urlPathProvider(_ value: UpdateEventSourcesConfigInput) -> Swift.String? {
        return "/event-sources"
    }
}

extension UpdateResourceCollectionInput {

    static func urlPathProvider(_ value: UpdateResourceCollectionInput) -> Swift.String? {
        return "/resource-collections"
    }
}

extension UpdateServiceIntegrationInput {

    static func urlPathProvider(_ value: UpdateServiceIntegrationInput) -> Swift.String? {
        return "/service-integrations"
    }
}

extension AddNotificationChannelInput {

    static func write(value: AddNotificationChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Config"].write(value.config, with: DevOpsGuruClientTypes.NotificationChannelConfig.write(value:to:))
    }
}

extension DescribeAccountOverviewInput {

    static func write(value: DescribeAccountOverviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromTime"].writeTimestamp(value.fromTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToTime"].writeTimestamp(value.toTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DescribeFeedbackInput {

    static func write(value: DescribeFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightId"].write(value.insightId)
    }
}

extension DescribeOrganizationHealthInput {

    static func write(value: DescribeOrganizationHealthInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationalUnitIds"].writeList(value.organizationalUnitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOrganizationOverviewInput {

    static func write(value: DescribeOrganizationOverviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FromTime"].writeTimestamp(value.fromTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["OrganizationalUnitIds"].writeList(value.organizationalUnitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ToTime"].writeTimestamp(value.toTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DescribeOrganizationResourceCollectionHealthInput {

    static func write(value: DescribeOrganizationResourceCollectionHealthInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationResourceCollectionType"].write(value.organizationResourceCollectionType)
        try writer["OrganizationalUnitIds"].writeList(value.organizationalUnitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListAnomaliesForInsightInput {

    static func write(value: ListAnomaliesForInsightInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTimeRange"].write(value.startTimeRange, with: DevOpsGuruClientTypes.StartTimeRange.write(value:to:))
    }
}

extension ListAnomalousLogGroupsInput {

    static func write(value: ListAnomalousLogGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightId"].write(value.insightId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListEventsInput {

    static func write(value: ListEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.ListEventsFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListInsightsInput {

    static func write(value: ListInsightsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StatusFilter"].write(value.statusFilter, with: DevOpsGuruClientTypes.ListInsightsStatusFilter.write(value:to:))
    }
}

extension ListMonitoredResourcesInput {

    static func write(value: ListMonitoredResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.ListMonitoredResourcesFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListNotificationChannelsInput {

    static func write(value: ListNotificationChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListOrganizationInsightsInput {

    static func write(value: ListOrganizationInsightsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationalUnitIds"].writeList(value.organizationalUnitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatusFilter"].write(value.statusFilter, with: DevOpsGuruClientTypes.ListInsightsStatusFilter.write(value:to:))
    }
}

extension ListRecommendationsInput {

    static func write(value: ListRecommendationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["InsightId"].write(value.insightId)
        try writer["Locale"].write(value.locale)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutFeedbackInput {

    static func write(value: PutFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightFeedback"].write(value.insightFeedback, with: DevOpsGuruClientTypes.InsightFeedback.write(value:to:))
    }
}

extension SearchInsightsInput {

    static func write(value: SearchInsightsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.SearchInsightsFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTimeRange"].write(value.startTimeRange, with: DevOpsGuruClientTypes.StartTimeRange.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension SearchOrganizationInsightsInput {

    static func write(value: SearchOrganizationInsightsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTimeRange"].write(value.startTimeRange, with: DevOpsGuruClientTypes.StartTimeRange.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension StartCostEstimationInput {

    static func write(value: StartCostEstimationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ResourceCollection"].write(value.resourceCollection, with: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.write(value:to:))
    }
}

extension UpdateEventSourcesConfigInput {

    static func write(value: UpdateEventSourcesConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventSources"].write(value.eventSources, with: DevOpsGuruClientTypes.EventSourcesConfig.write(value:to:))
    }
}

extension UpdateResourceCollectionInput {

    static func write(value: UpdateResourceCollectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["ResourceCollection"].write(value.resourceCollection, with: DevOpsGuruClientTypes.UpdateResourceCollectionFilter.write(value:to:))
    }
}

extension UpdateServiceIntegrationInput {

    static func write(value: UpdateServiceIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceIntegration"].write(value.serviceIntegration, with: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig.write(value:to:))
    }
}

extension AddNotificationChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddNotificationChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddNotificationChannelOutput()
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInsightOutput {
        return DeleteInsightOutput()
    }
}

extension DescribeAccountHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountHealthOutput()
        value.analyzedResourceCount = try reader["AnalyzedResourceCount"].readIfPresent()
        value.metricsAnalyzed = try reader["MetricsAnalyzed"].readIfPresent() ?? 0
        value.openProactiveInsights = try reader["OpenProactiveInsights"].readIfPresent() ?? 0
        value.openReactiveInsights = try reader["OpenReactiveInsights"].readIfPresent() ?? 0
        value.resourceHours = try reader["ResourceHours"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeAccountOverviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountOverviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountOverviewOutput()
        value.meanTimeToRecoverInMilliseconds = try reader["MeanTimeToRecoverInMilliseconds"].readIfPresent() ?? 0
        value.proactiveInsights = try reader["ProactiveInsights"].readIfPresent() ?? 0
        value.reactiveInsights = try reader["ReactiveInsights"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeAnomalyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnomalyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnomalyOutput()
        value.proactiveAnomaly = try reader["ProactiveAnomaly"].readIfPresent(with: DevOpsGuruClientTypes.ProactiveAnomaly.read(from:))
        value.reactiveAnomaly = try reader["ReactiveAnomaly"].readIfPresent(with: DevOpsGuruClientTypes.ReactiveAnomaly.read(from:))
        return value
    }
}

extension DescribeEventSourcesConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventSourcesConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventSourcesConfigOutput()
        value.eventSources = try reader["EventSources"].readIfPresent(with: DevOpsGuruClientTypes.EventSourcesConfig.read(from:))
        return value
    }
}

extension DescribeFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFeedbackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFeedbackOutput()
        value.insightFeedback = try reader["InsightFeedback"].readIfPresent(with: DevOpsGuruClientTypes.InsightFeedback.read(from:))
        return value
    }
}

extension DescribeInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInsightOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInsightOutput()
        value.proactiveInsight = try reader["ProactiveInsight"].readIfPresent(with: DevOpsGuruClientTypes.ProactiveInsight.read(from:))
        value.reactiveInsight = try reader["ReactiveInsight"].readIfPresent(with: DevOpsGuruClientTypes.ReactiveInsight.read(from:))
        return value
    }
}

extension DescribeOrganizationHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationHealthOutput()
        value.metricsAnalyzed = try reader["MetricsAnalyzed"].readIfPresent() ?? 0
        value.openProactiveInsights = try reader["OpenProactiveInsights"].readIfPresent() ?? 0
        value.openReactiveInsights = try reader["OpenReactiveInsights"].readIfPresent() ?? 0
        value.resourceHours = try reader["ResourceHours"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeOrganizationOverviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationOverviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationOverviewOutput()
        value.proactiveInsights = try reader["ProactiveInsights"].readIfPresent() ?? 0
        value.reactiveInsights = try reader["ReactiveInsights"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeOrganizationResourceCollectionHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationResourceCollectionHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationResourceCollectionHealthOutput()
        value.account = try reader["Account"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AccountHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cloudFormation = try reader["CloudFormation"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.CloudFormationHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.service = try reader["Service"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ServiceHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TagHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeResourceCollectionHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeResourceCollectionHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeResourceCollectionHealthOutput()
        value.cloudFormation = try reader["CloudFormation"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.CloudFormationHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.service = try reader["Service"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ServiceHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TagHealth.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeServiceIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceIntegrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceIntegrationOutput()
        value.serviceIntegration = try reader["ServiceIntegration"].readIfPresent(with: DevOpsGuruClientTypes.ServiceIntegrationConfig.read(from:))
        return value
    }
}

extension GetCostEstimationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCostEstimationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCostEstimationOutput()
        value.costs = try reader["Costs"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ServiceResourceCost.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.timeRange = try reader["TimeRange"].readIfPresent(with: DevOpsGuruClientTypes.CostEstimationTimeRange.read(from:))
        value.totalCost = try reader["TotalCost"].readIfPresent() ?? 0
        return value
    }
}

extension GetResourceCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceCollectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceCollectionOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollectionFilter.read(from:))
        return value
    }
}

extension ListAnomaliesForInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomaliesForInsightOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomaliesForInsightOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proactiveAnomalies = try reader["ProactiveAnomalies"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ProactiveAnomalySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactiveAnomalies = try reader["ReactiveAnomalies"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ReactiveAnomalySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAnomalousLogGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomalousLogGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomalousLogGroupsOutput()
        value.anomalousLogGroups = try reader["AnomalousLogGroups"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AnomalousLogGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.insightId = try reader["InsightId"].readIfPresent() ?? ""
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventsOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInsightsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proactiveInsights = try reader["ProactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ProactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactiveInsights = try reader["ReactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ReactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMonitoredResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitoredResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitoredResourcesOutput()
        value.monitoredResourceIdentifiers = try reader["MonitoredResourceIdentifiers"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.MonitoredResourceIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationChannelsOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.NotificationChannel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOrganizationInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrganizationInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationInsightsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proactiveInsights = try reader["ProactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactiveInsights = try reader["ReactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.recommendations = try reader["Recommendations"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.Recommendation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFeedbackOutput {
        return PutFeedbackOutput()
    }
}

extension RemoveNotificationChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveNotificationChannelOutput {
        return RemoveNotificationChannelOutput()
    }
}

extension SearchInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchInsightsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proactiveInsights = try reader["ProactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ProactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactiveInsights = try reader["ReactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ReactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchOrganizationInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchOrganizationInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchOrganizationInsightsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.proactiveInsights = try reader["ProactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ProactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reactiveInsights = try reader["ReactiveInsights"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ReactiveInsightSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartCostEstimationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCostEstimationOutput {
        return StartCostEstimationOutput()
    }
}

extension UpdateEventSourcesConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventSourcesConfigOutput {
        return UpdateEventSourcesConfigOutput()
    }
}

extension UpdateResourceCollectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceCollectionOutput {
        return UpdateResourceCollectionOutput()
    }
}

extension UpdateServiceIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceIntegrationOutput {
        return UpdateServiceIntegrationOutput()
    }
}

enum AddNotificationChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountOverviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnomalyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventSourcesConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationOverviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationResourceCollectionHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeResourceCollectionHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCostEstimationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomaliesForInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomalousLogGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitoredResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrganizationInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveNotificationChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchOrganizationInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCostEstimationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventSourcesConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceCollectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DevOpsGuruClientTypes.ProactiveAnomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ProactiveAnomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ProactiveAnomaly()
        value.id = try reader["Id"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.anomalyTimeRange = try reader["AnomalyTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyTimeRange.read(from:))
        value.anomalyReportedTimeRange = try reader["AnomalyReportedTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyReportedTimeRange.read(from:))
        value.predictionTimeRange = try reader["PredictionTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.PredictionTimeRange.read(from:))
        value.sourceDetails = try reader["SourceDetails"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceDetails.read(from:))
        value.associatedInsightId = try reader["AssociatedInsightId"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.limit = try reader["Limit"].readIfPresent()
        value.sourceMetadata = try reader["SourceMetadata"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceMetadata.read(from:))
        value.anomalyResources = try reader["AnomalyResources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AnomalyResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalyResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalyResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalyResource()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalySourceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalySourceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalySourceMetadata()
        value.source = try reader["Source"].readIfPresent()
        value.sourceResourceName = try reader["SourceResourceName"].readIfPresent()
        value.sourceResourceType = try reader["SourceResourceType"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ResourceCollection {

    static func write(value: DevOpsGuruClientTypes.ResourceCollection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudFormation"].write(value.cloudFormation, with: DevOpsGuruClientTypes.CloudFormationCollection.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DevOpsGuruClientTypes.TagCollection.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ResourceCollection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ResourceCollection()
        value.cloudFormation = try reader["CloudFormation"].readIfPresent(with: DevOpsGuruClientTypes.CloudFormationCollection.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TagCollection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.TagCollection {

    static func write(value: DevOpsGuruClientTypes.TagCollection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBoundaryKey"].write(value.appBoundaryKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.TagCollection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.TagCollection()
        value.appBoundaryKey = try reader["AppBoundaryKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DevOpsGuruClientTypes.CloudFormationCollection {

    static func write(value: DevOpsGuruClientTypes.CloudFormationCollection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackNames"].writeList(value.stackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudFormationCollection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudFormationCollection()
        value.stackNames = try reader["StackNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalySourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalySourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalySourceDetails()
        value.cloudWatchMetrics = try reader["CloudWatchMetrics"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.CloudWatchMetricsDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.performanceInsightsMetrics = try reader["PerformanceInsightsMetrics"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail()
        value.metricDisplayName = try reader["MetricDisplayName"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.metricQuery = try reader["MetricQuery"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.read(from:))
        value.referenceData = try reader["ReferenceData"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.PerformanceInsightsReferenceData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statsAtAnomaly = try reader["StatsAtAnomaly"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.PerformanceInsightsStat.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statsAtBaseline = try reader["StatsAtBaseline"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.PerformanceInsightsStat.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsStat {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsStat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsStat()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceData {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsReferenceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsReferenceData()
        value.name = try reader["Name"].readIfPresent()
        value.comparisonValues = try reader["ComparisonValues"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues()
        value.referenceScalar = try reader["ReferenceScalar"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar.read(from:))
        value.referenceMetric = try reader["ReferenceMetric"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric()
        value.metricQuery = try reader["MetricQuery"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricQuery {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsMetricQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsMetricQuery()
        value.metric = try reader["Metric"].readIfPresent()
        value.groupBy = try reader["GroupBy"].readIfPresent(with: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup.read(from:))
        value.filter = try reader["Filter"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup()
        value.group = try reader["Group"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.limit = try reader["Limit"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.CloudWatchMetricsDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudWatchMetricsDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudWatchMetricsDetail()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.CloudWatchMetricsDimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stat = try reader["Stat"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        value.period = try reader["Period"].readIfPresent() ?? 0
        value.metricDataSummary = try reader["MetricDataSummary"].readIfPresent(with: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.CloudWatchMetricsDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudWatchMetricsDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudWatchMetricsDataSummary()
        value.timestampMetricValuePairList = try reader["TimestampMetricValuePairList"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TimestampMetricValuePair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statusCode = try reader["StatusCode"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.TimestampMetricValuePair {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.TimestampMetricValuePair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.TimestampMetricValuePair()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricValue = try reader["MetricValue"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.CloudWatchMetricsDimension {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudWatchMetricsDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudWatchMetricsDimension()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.PredictionTimeRange {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.PredictionTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.PredictionTimeRange()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalyReportedTimeRange {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalyReportedTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalyReportedTimeRange()
        value.openTime = try reader["OpenTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.closeTime = try reader["CloseTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalyTimeRange {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalyTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalyTimeRange()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.ReactiveAnomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ReactiveAnomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ReactiveAnomaly()
        value.id = try reader["Id"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.anomalyTimeRange = try reader["AnomalyTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyTimeRange.read(from:))
        value.anomalyReportedTimeRange = try reader["AnomalyReportedTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyReportedTimeRange.read(from:))
        value.sourceDetails = try reader["SourceDetails"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceDetails.read(from:))
        value.associatedInsightId = try reader["AssociatedInsightId"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.causalAnomalyId = try reader["CausalAnomalyId"].readIfPresent()
        value.anomalyResources = try reader["AnomalyResources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AnomalyResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.EventSourcesConfig {

    static func write(value: DevOpsGuruClientTypes.EventSourcesConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonCodeGuruProfiler"].write(value.amazonCodeGuruProfiler, with: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.EventSourcesConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.EventSourcesConfig()
        value.amazonCodeGuruProfiler = try reader["AmazonCodeGuruProfiler"].readIfPresent(with: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration {

    static func write(value: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.InsightFeedback {

    static func write(value: DevOpsGuruClientTypes.InsightFeedback?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Feedback"].write(value.feedback)
        try writer["Id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.InsightFeedback {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.InsightFeedback()
        value.id = try reader["Id"].readIfPresent()
        value.feedback = try reader["Feedback"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ProactiveInsight {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ProactiveInsight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ProactiveInsight()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.predictionTimeRange = try reader["PredictionTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.PredictionTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.ssmOpsItemId = try reader["SsmOpsItemId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.InsightTimeRange {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.InsightTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.InsightTimeRange()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.ReactiveInsight {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ReactiveInsight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ReactiveInsight()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.ssmOpsItemId = try reader["SsmOpsItemId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.CloudFormationHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudFormationHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudFormationHealth()
        value.stackName = try reader["StackName"].readIfPresent()
        value.insight = try reader["Insight"].readIfPresent(with: DevOpsGuruClientTypes.InsightHealth.read(from:))
        value.analyzedResourceCount = try reader["AnalyzedResourceCount"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.InsightHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.InsightHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.InsightHealth()
        value.openProactiveInsights = try reader["OpenProactiveInsights"].readIfPresent() ?? 0
        value.openReactiveInsights = try reader["OpenReactiveInsights"].readIfPresent() ?? 0
        value.meanTimeToRecoverInMilliseconds = try reader["MeanTimeToRecoverInMilliseconds"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ServiceHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ServiceHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ServiceHealth()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.insight = try reader["Insight"].readIfPresent(with: DevOpsGuruClientTypes.ServiceInsightHealth.read(from:))
        value.analyzedResourceCount = try reader["AnalyzedResourceCount"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ServiceInsightHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ServiceInsightHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ServiceInsightHealth()
        value.openProactiveInsights = try reader["OpenProactiveInsights"].readIfPresent() ?? 0
        value.openReactiveInsights = try reader["OpenReactiveInsights"].readIfPresent() ?? 0
        return value
    }
}

extension DevOpsGuruClientTypes.AccountHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AccountHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AccountHealth()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.insight = try reader["Insight"].readIfPresent(with: DevOpsGuruClientTypes.AccountInsightHealth.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.AccountInsightHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AccountInsightHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AccountInsightHealth()
        value.openProactiveInsights = try reader["OpenProactiveInsights"].readIfPresent() ?? 0
        value.openReactiveInsights = try reader["OpenReactiveInsights"].readIfPresent() ?? 0
        return value
    }
}

extension DevOpsGuruClientTypes.TagHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.TagHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.TagHealth()
        value.appBoundaryKey = try reader["AppBoundaryKey"].readIfPresent()
        value.tagValue = try reader["TagValue"].readIfPresent()
        value.insight = try reader["Insight"].readIfPresent(with: DevOpsGuruClientTypes.InsightHealth.read(from:))
        value.analyzedResourceCount = try reader["AnalyzedResourceCount"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ServiceIntegrationConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ServiceIntegrationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ServiceIntegrationConfig()
        value.opsCenter = try reader["OpsCenter"].readIfPresent(with: DevOpsGuruClientTypes.OpsCenterIntegration.read(from:))
        value.logsAnomalyDetection = try reader["LogsAnomalyDetection"].readIfPresent(with: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration.read(from:))
        value.kmsServerSideEncryption = try reader["KMSServerSideEncryption"].readIfPresent(with: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration()
        value.kmsKeyId = try reader["KMSKeyId"].readIfPresent()
        value.optInStatus = try reader["OptInStatus"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration()
        value.optInStatus = try reader["OptInStatus"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.OpsCenterIntegration {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.OpsCenterIntegration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.OpsCenterIntegration()
        value.optInStatus = try reader["OptInStatus"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudFormation"].write(value.cloudFormation, with: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter()
        value.cloudFormation = try reader["CloudFormation"].readIfPresent(with: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBoundaryKey"].write(value.appBoundaryKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter()
        value.appBoundaryKey = try reader["AppBoundaryKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackNames"].writeList(value.stackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter()
        value.stackNames = try reader["StackNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.ServiceResourceCost {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ServiceResourceCost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ServiceResourceCost()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.count = try reader["Count"].readIfPresent() ?? 0
        value.unitCost = try reader["UnitCost"].readIfPresent() ?? 0
        value.cost = try reader["Cost"].readIfPresent() ?? 0
        return value
    }
}

extension DevOpsGuruClientTypes.CostEstimationTimeRange {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CostEstimationTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CostEstimationTimeRange()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.ResourceCollectionFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ResourceCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ResourceCollectionFilter()
        value.cloudFormation = try reader["CloudFormation"].readIfPresent(with: DevOpsGuruClientTypes.CloudFormationCollectionFilter.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.TagCollectionFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.TagCollectionFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.TagCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.TagCollectionFilter()
        value.appBoundaryKey = try reader["AppBoundaryKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DevOpsGuruClientTypes.CloudFormationCollectionFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.CloudFormationCollectionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.CloudFormationCollectionFilter()
        value.stackNames = try reader["StackNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.ProactiveAnomalySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ProactiveAnomalySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ProactiveAnomalySummary()
        value.id = try reader["Id"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.anomalyTimeRange = try reader["AnomalyTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyTimeRange.read(from:))
        value.anomalyReportedTimeRange = try reader["AnomalyReportedTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyReportedTimeRange.read(from:))
        value.predictionTimeRange = try reader["PredictionTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.PredictionTimeRange.read(from:))
        value.sourceDetails = try reader["SourceDetails"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceDetails.read(from:))
        value.associatedInsightId = try reader["AssociatedInsightId"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.limit = try reader["Limit"].readIfPresent()
        value.sourceMetadata = try reader["SourceMetadata"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceMetadata.read(from:))
        value.anomalyResources = try reader["AnomalyResources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AnomalyResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ReactiveAnomalySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ReactiveAnomalySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ReactiveAnomalySummary()
        value.id = try reader["Id"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.anomalyTimeRange = try reader["AnomalyTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyTimeRange.read(from:))
        value.anomalyReportedTimeRange = try reader["AnomalyReportedTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.AnomalyReportedTimeRange.read(from:))
        value.sourceDetails = try reader["SourceDetails"].readIfPresent(with: DevOpsGuruClientTypes.AnomalySourceDetails.read(from:))
        value.associatedInsightId = try reader["AssociatedInsightId"].readIfPresent()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.causalAnomalyId = try reader["CausalAnomalyId"].readIfPresent()
        value.anomalyResources = try reader["AnomalyResources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.AnomalyResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.AnomalousLogGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.AnomalousLogGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.AnomalousLogGroup()
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        value.impactStartTime = try reader["ImpactStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.impactEndTime = try reader["ImpactEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numberOfLogLinesScanned = try reader["NumberOfLogLinesScanned"].readIfPresent() ?? 0
        value.logAnomalyShowcases = try reader["LogAnomalyShowcases"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.LogAnomalyShowcase.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.LogAnomalyShowcase {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.LogAnomalyShowcase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.LogAnomalyShowcase()
        value.logAnomalyClasses = try reader["LogAnomalyClasses"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.LogAnomalyClass.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.LogAnomalyClass {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.LogAnomalyClass {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.LogAnomalyClass()
        value.logStreamName = try reader["LogStreamName"].readIfPresent()
        value.logAnomalyType = try reader["LogAnomalyType"].readIfPresent()
        value.logAnomalyToken = try reader["LogAnomalyToken"].readIfPresent()
        value.logEventId = try reader["LogEventId"].readIfPresent()
        value.explanation = try reader["Explanation"].readIfPresent()
        value.numberOfLogLinesOccurrences = try reader["NumberOfLogLinesOccurrences"].readIfPresent() ?? 0
        value.logEventTimestamp = try reader["LogEventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DevOpsGuruClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.Event()
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.time = try reader["Time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventSource = try reader["EventSource"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.dataSource = try reader["DataSource"].readIfPresent()
        value.eventClass = try reader["EventClass"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.EventResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.EventResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.EventResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.EventResource()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ProactiveInsightSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ProactiveInsightSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ProactiveInsightSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.predictionTimeRange = try reader["PredictionTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.PredictionTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.serviceCollection = try reader["ServiceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ServiceCollection.read(from:))
        value.associatedResourceArns = try reader["AssociatedResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.ServiceCollection {

    static func write(value: DevOpsGuruClientTypes.ServiceCollection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceNames"].writeList(value.serviceNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.ServiceName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ServiceCollection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ServiceCollection()
        value.serviceNames = try reader["ServiceNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<DevOpsGuruClientTypes.ServiceName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.ReactiveInsightSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ReactiveInsightSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ReactiveInsightSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.serviceCollection = try reader["ServiceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ServiceCollection.read(from:))
        value.associatedResourceArns = try reader["AssociatedResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.MonitoredResourceIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.MonitoredResourceIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.MonitoredResourceIdentifier()
        value.monitoredResourceName = try reader["MonitoredResourceName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.resourcePermission = try reader["ResourcePermission"].readIfPresent()
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.NotificationChannel {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.NotificationChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.NotificationChannel()
        value.id = try reader["Id"].readIfPresent()
        value.config = try reader["Config"].readIfPresent(with: DevOpsGuruClientTypes.NotificationChannelConfig.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.NotificationChannelConfig {

    static func write(value: DevOpsGuruClientTypes.NotificationChannelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: DevOpsGuruClientTypes.NotificationFilterConfig.write(value:to:))
        try writer["Sns"].write(value.sns, with: DevOpsGuruClientTypes.SnsChannelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.NotificationChannelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.NotificationChannelConfig()
        value.sns = try reader["Sns"].readIfPresent(with: DevOpsGuruClientTypes.SnsChannelConfig.read(from:))
        value.filters = try reader["Filters"].readIfPresent(with: DevOpsGuruClientTypes.NotificationFilterConfig.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.NotificationFilterConfig {

    static func write(value: DevOpsGuruClientTypes.NotificationFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageTypes"].writeList(value.messageTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.NotificationMessageType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severities"].writeList(value.severities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.InsightSeverity>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.NotificationFilterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.NotificationFilterConfig()
        value.severities = try reader["Severities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<DevOpsGuruClientTypes.InsightSeverity>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.messageTypes = try reader["MessageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<DevOpsGuruClientTypes.NotificationMessageType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.SnsChannelConfig {

    static func write(value: DevOpsGuruClientTypes.SnsChannelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TopicArn"].write(value.topicArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.SnsChannelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.SnsChannelConfig()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary()
        value.id = try reader["Id"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.organizationalUnitId = try reader["OrganizationalUnitId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.predictionTimeRange = try reader["PredictionTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.PredictionTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.serviceCollection = try reader["ServiceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ServiceCollection.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary()
        value.id = try reader["Id"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.organizationalUnitId = try reader["OrganizationalUnitId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.insightTimeRange = try reader["InsightTimeRange"].readIfPresent(with: DevOpsGuruClientTypes.InsightTimeRange.read(from:))
        value.resourceCollection = try reader["ResourceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ResourceCollection.read(from:))
        value.serviceCollection = try reader["ServiceCollection"].readIfPresent(with: DevOpsGuruClientTypes.ServiceCollection.read(from:))
        return value
    }
}

extension DevOpsGuruClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.Recommendation()
        value.description = try reader["Description"].readIfPresent()
        value.link = try reader["Link"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.relatedEvents = try reader["RelatedEvents"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedAnomalies = try reader["RelatedAnomalies"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedAnomaly.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.category = try reader["Category"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedAnomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedAnomaly()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceDetails = try reader["SourceDetails"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.anomalyId = try reader["AnomalyId"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail()
        value.cloudWatchMetrics = try reader["CloudWatchMetrics"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedEvent()
        value.name = try reader["Name"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: DevOpsGuruClientTypes.RecommendationRelatedEventResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DevOpsGuruClientTypes.RecommendationRelatedEventResource {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.RecommendationRelatedEventResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.RecommendationRelatedEventResource()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DevOpsGuruClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> DevOpsGuruClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DevOpsGuruClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension DevOpsGuruClientTypes.StartTimeRange {

    static func write(value: DevOpsGuruClientTypes.StartTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromTime"].writeTimestamp(value.fromTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToTime"].writeTimestamp(value.toTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DevOpsGuruClientTypes.ListAnomaliesForInsightFilters {

    static func write(value: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceCollection"].write(value.serviceCollection, with: DevOpsGuruClientTypes.ServiceCollection.write(value:to:))
    }
}

extension DevOpsGuruClientTypes.ListEventsFilters {

    static func write(value: DevOpsGuruClientTypes.ListEventsFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSource"].write(value.dataSource)
        try writer["EventClass"].write(value.eventClass)
        try writer["EventSource"].write(value.eventSource)
        try writer["EventTimeRange"].write(value.eventTimeRange, with: DevOpsGuruClientTypes.EventTimeRange.write(value:to:))
        try writer["InsightId"].write(value.insightId)
        try writer["ResourceCollection"].write(value.resourceCollection, with: DevOpsGuruClientTypes.ResourceCollection.write(value:to:))
    }
}

extension DevOpsGuruClientTypes.EventTimeRange {

    static func write(value: DevOpsGuruClientTypes.EventTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromTime"].writeTimestamp(value.fromTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToTime"].writeTimestamp(value.toTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DevOpsGuruClientTypes.ListInsightsStatusFilter {

    static func write(value: DevOpsGuruClientTypes.ListInsightsStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Any"].write(value.any, with: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter.write(value:to:))
        try writer["Closed"].write(value.closed, with: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter.write(value:to:))
        try writer["Ongoing"].write(value.ongoing, with: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter.write(value:to:))
    }
}

extension DevOpsGuruClientTypes.ListInsightsAnyStatusFilter {

    static func write(value: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartTimeRange"].write(value.startTimeRange, with: DevOpsGuruClientTypes.StartTimeRange.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension DevOpsGuruClientTypes.ListInsightsClosedStatusFilter {

    static func write(value: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTimeRange"].write(value.endTimeRange, with: DevOpsGuruClientTypes.EndTimeRange.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension DevOpsGuruClientTypes.EndTimeRange {

    static func write(value: DevOpsGuruClientTypes.EndTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromTime"].writeTimestamp(value.fromTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToTime"].writeTimestamp(value.toTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter {

    static func write(value: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }
}

extension DevOpsGuruClientTypes.ListMonitoredResourcesFilters {

    static func write(value: DevOpsGuruClientTypes.ListMonitoredResourcesFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourcePermission"].write(value.resourcePermission)
        try writer["ResourceTypeFilters"].writeList(value.resourceTypeFilters, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.ResourceTypeFilter>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.SearchInsightsFilters {

    static func write(value: DevOpsGuruClientTypes.SearchInsightsFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceCollection"].write(value.resourceCollection, with: DevOpsGuruClientTypes.ResourceCollection.write(value:to:))
        try writer["ServiceCollection"].write(value.serviceCollection, with: DevOpsGuruClientTypes.ServiceCollection.write(value:to:))
        try writer["Severities"].writeList(value.severities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.InsightSeverity>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Statuses"].writeList(value.statuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.InsightStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.SearchOrganizationInsightsFilters {

    static func write(value: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceCollection"].write(value.resourceCollection, with: DevOpsGuruClientTypes.ResourceCollection.write(value:to:))
        try writer["ServiceCollection"].write(value.serviceCollection, with: DevOpsGuruClientTypes.ServiceCollection.write(value:to:))
        try writer["Severities"].writeList(value.severities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.InsightSeverity>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Statuses"].writeList(value.statuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DevOpsGuruClientTypes.InsightStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.UpdateResourceCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudFormation"].write(value.cloudFormation, with: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DevOpsGuruClientTypes.UpdateTagCollectionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.UpdateTagCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.UpdateTagCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppBoundaryKey"].write(value.appBoundaryKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter {

    static func write(value: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackNames"].writeList(value.stackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DevOpsGuruClientTypes.UpdateServiceIntegrationConfig {

    static func write(value: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSServerSideEncryption"].write(value.kmsServerSideEncryption, with: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig.write(value:to:))
        try writer["LogsAnomalyDetection"].write(value.logsAnomalyDetection, with: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig.write(value:to:))
        try writer["OpsCenter"].write(value.opsCenter, with: DevOpsGuruClientTypes.OpsCenterIntegrationConfig.write(value:to:))
    }
}

extension DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig {

    static func write(value: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSKeyId"].write(value.kmsKeyId)
        try writer["OptInStatus"].write(value.optInStatus)
        try writer["Type"].write(value.type)
    }
}

extension DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig {

    static func write(value: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptInStatus"].write(value.optInStatus)
    }
}

extension DevOpsGuruClientTypes.OpsCenterIntegrationConfig {

    static func write(value: DevOpsGuruClientTypes.OpsCenterIntegrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptInStatus"].write(value.optInStatus)
    }
}

public enum DevOpsGuruClientTypes {}
