// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see [Access Management](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM User Guide.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes.AccountHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insight = "Insight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let insight = self.insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AccountInsightHealth.self, forKey: .insight)
        insight = insightDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Returns the number of open reactive insights, the number of open proactive insights, and the number of metrics analyzed in your Amazon Web Services account. Use these numbers to gauge the health of operations in your Amazon Web Services account.
    public struct AccountHealth: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.AccountInsightHealth?

        public init(
            accountId: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.AccountInsightHealth? = nil
        )
        {
            self.accountId = accountId
            self.insight = insight
        }
    }

}

extension DevOpsGuruClientTypes.AccountInsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openProactiveInsights) ?? 0
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openReactiveInsights) ?? 0
        openReactiveInsights = openReactiveInsightsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct AccountInsightHealth: Swift.Equatable {
        /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
        public var openProactiveInsights: Swift.Int
        /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
        public var openReactiveInsights: Swift.Int

        public init(
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension AddNotificationChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = self.config {
            try encodeContainer.encode(config, forKey: .config)
        }
    }
}

extension AddNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct AddNotificationChannelInput: Swift.Equatable {
    /// A NotificationChannelConfig object that specifies what type of notification channel to add. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    /// This member is required.
    public var config: DevOpsGuruClientTypes.NotificationChannelConfig?

    public init(
        config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil
    )
    {
        self.config = config
    }
}

struct AddNotificationChannelInputBody: Swift.Equatable {
    let config: DevOpsGuruClientTypes.NotificationChannelConfig?
}

extension AddNotificationChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension AddNotificationChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddNotificationChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct AddNotificationChannelOutput: Swift.Equatable {
    /// The ID of the added notification channel.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct AddNotificationChannelOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension AddNotificationChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum AddNotificationChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventSourceOptInStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about your account's integration with Amazon CodeGuru Profiler. This returns whether DevOps Guru is configured to consume recommendations generated from Amazon CodeGuru Profiler.
    public struct AmazonCodeGuruProfilerIntegration: Swift.Equatable {
        /// The status of the CodeGuru Profiler integration. Specifies if DevOps Guru is enabled to consume recommendations that are generated from Amazon CodeGuru Profiler.
        public var status: DevOpsGuruClientTypes.EventSourceOptInStatus?

        public init(
            status: DevOpsGuruClientTypes.EventSourceOptInStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.AnomalousLogGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case impactEndTime = "ImpactEndTime"
        case impactStartTime = "ImpactStartTime"
        case logAnomalyShowcases = "LogAnomalyShowcases"
        case logGroupName = "LogGroupName"
        case numberOfLogLinesScanned = "NumberOfLogLinesScanned"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let impactEndTime = self.impactEndTime {
            try encodeContainer.encodeTimestamp(impactEndTime, format: .epochSeconds, forKey: .impactEndTime)
        }
        if let impactStartTime = self.impactStartTime {
            try encodeContainer.encodeTimestamp(impactStartTime, format: .epochSeconds, forKey: .impactStartTime)
        }
        if let logAnomalyShowcases = logAnomalyShowcases {
            var logAnomalyShowcasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logAnomalyShowcases)
            for loganomalyshowcase0 in logAnomalyShowcases {
                try logAnomalyShowcasesContainer.encode(loganomalyshowcase0)
            }
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if numberOfLogLinesScanned != 0 {
            try encodeContainer.encode(numberOfLogLinesScanned, forKey: .numberOfLogLinesScanned)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let impactStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .impactStartTime)
        impactStartTime = impactStartTimeDecoded
        let impactEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .impactEndTime)
        impactEndTime = impactEndTimeDecoded
        let numberOfLogLinesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfLogLinesScanned) ?? 0
        numberOfLogLinesScanned = numberOfLogLinesScannedDecoded
        let logAnomalyShowcasesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.LogAnomalyShowcase?].self, forKey: .logAnomalyShowcases)
        var logAnomalyShowcasesDecoded0:[DevOpsGuruClientTypes.LogAnomalyShowcase]? = nil
        if let logAnomalyShowcasesContainer = logAnomalyShowcasesContainer {
            logAnomalyShowcasesDecoded0 = [DevOpsGuruClientTypes.LogAnomalyShowcase]()
            for structure0 in logAnomalyShowcasesContainer {
                if let structure0 = structure0 {
                    logAnomalyShowcasesDecoded0?.append(structure0)
                }
            }
        }
        logAnomalyShowcases = logAnomalyShowcasesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// An Amazon CloudWatch log group that contains log anomalies and is used to generate an insight.
    public struct AnomalousLogGroup: Swift.Equatable {
        /// The time the anomalous log events stopped.
        public var impactEndTime: ClientRuntime.Date?
        /// The time the anomalous log events began. The impact start time indicates the time of the first log anomaly event that occurs.
        public var impactStartTime: ClientRuntime.Date?
        /// The log anomalies in the log group. Each log anomaly displayed represents a cluster of similar anomalous log events.
        public var logAnomalyShowcases: [DevOpsGuruClientTypes.LogAnomalyShowcase]?
        /// The name of the CloudWatch log group.
        public var logGroupName: Swift.String?
        /// The number of log lines that were scanned for anomalous log events.
        public var numberOfLogLinesScanned: Swift.Int

        public init(
            impactEndTime: ClientRuntime.Date? = nil,
            impactStartTime: ClientRuntime.Date? = nil,
            logAnomalyShowcases: [DevOpsGuruClientTypes.LogAnomalyShowcase]? = nil,
            logGroupName: Swift.String? = nil,
            numberOfLogLinesScanned: Swift.Int = 0
        )
        {
            self.impactEndTime = impactEndTime
            self.impactStartTime = impactStartTime
            self.logAnomalyShowcases = logAnomalyShowcases
            self.logGroupName = logGroupName
            self.numberOfLogLinesScanned = numberOfLogLinesScanned
        }
    }

}

extension DevOpsGuruClientTypes.AnomalyReportedTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case closeTime = "CloseTime"
        case openTime = "OpenTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let closeTime = self.closeTime {
            try encodeContainer.encodeTimestamp(closeTime, format: .epochSeconds, forKey: .closeTime)
        }
        if let openTime = self.openTime {
            try encodeContainer.encodeTimestamp(openTime, format: .epochSeconds, forKey: .openTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .openTime)
        openTime = openTimeDecoded
        let closeTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .closeTime)
        closeTime = closeTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when DevOps Guru opens and then closes an anomaly. This is different from AnomalyTimeRange, which specifies the time range when DevOps Guru actually observes the anomalous behavior.
    public struct AnomalyReportedTimeRange: Swift.Equatable {
        /// The time when an anomaly is closed.
        public var closeTime: ClientRuntime.Date?
        /// The time when an anomaly is opened.
        /// This member is required.
        public var openTime: ClientRuntime.Date?

        public init(
            closeTime: ClientRuntime.Date? = nil,
            openTime: ClientRuntime.Date? = nil
        )
        {
            self.closeTime = closeTime
            self.openTime = openTime
        }
    }

}

extension DevOpsGuruClientTypes.AnomalyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resources in which DevOps Guru detected unusual behavior that resulted in the generation of an anomaly. When DevOps Guru detects multiple related anomalies, it creates and insight with details about the anomalous behavior and suggestions about how to correct the problem.
    public struct AnomalyResource: Swift.Equatable {
        /// The name of the Amazon Web Services resource.
        public var name: Swift.String?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalySeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySeverity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalySeverity(rawValue: rawValue) ?? AnomalySeverity.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.AnomalySourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
        case performanceInsightsMetrics = "PerformanceInsightsMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for cloudwatchmetricsdetail0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(cloudwatchmetricsdetail0)
            }
        }
        if let performanceInsightsMetrics = performanceInsightsMetrics {
            var performanceInsightsMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .performanceInsightsMetrics)
            for performanceinsightsmetricsdetail0 in performanceInsightsMetrics {
                try performanceInsightsMetricsContainer.encode(performanceinsightsmetricsdetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudWatchMetricsDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[DevOpsGuruClientTypes.CloudWatchMetricsDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [DevOpsGuruClientTypes.CloudWatchMetricsDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
        let performanceInsightsMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail?].self, forKey: .performanceInsightsMetrics)
        var performanceInsightsMetricsDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]? = nil
        if let performanceInsightsMetricsContainer = performanceInsightsMetricsContainer {
            performanceInsightsMetricsDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]()
            for structure0 in performanceInsightsMetricsContainer {
                if let structure0 = structure0 {
                    performanceInsightsMetricsDecoded0?.append(structure0)
                }
            }
        }
        performanceInsightsMetrics = performanceInsightsMetricsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about the source of the anomalous operational data that triggered the anomaly.
    public struct AnomalySourceDetails: Swift.Equatable {
        /// An array of CloudWatchMetricsDetail objects that contain information about analyzed CloudWatch metrics that show anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]?
        /// An array of PerformanceInsightsMetricsDetail objects that contain information about analyzed Performance Insights metrics that show anomalous behavior.
        public var performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]?

        public init(
            cloudWatchMetrics: [DevOpsGuruClientTypes.CloudWatchMetricsDetail]? = nil,
            performanceInsightsMetrics: [DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
            self.performanceInsightsMetrics = performanceInsightsMetrics
        }
    }

}

extension DevOpsGuruClientTypes.AnomalySourceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case sourceResourceName = "SourceResourceName"
        case sourceResourceType = "SourceResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceResourceName = self.sourceResourceName {
            try encodeContainer.encode(sourceResourceName, forKey: .sourceResourceName)
        }
        if let sourceResourceType = self.sourceResourceType {
            try encodeContainer.encode(sourceResourceType, forKey: .sourceResourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceName)
        sourceResourceName = sourceResourceNameDecoded
        let sourceResourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceResourceType)
        sourceResourceType = sourceResourceTypeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Metadata about the detection source that generates proactive anomalies. The anomaly is detected using analysis of the metric dataâ€¨ over a period of time
    public struct AnomalySourceMetadata: Swift.Equatable {
        /// The source of the anomaly.
        public var source: Swift.String?
        /// The name of the anomaly's resource.
        public var sourceResourceName: Swift.String?
        /// The anomaly's resource type.
        public var sourceResourceType: Swift.String?

        public init(
            source: Swift.String? = nil,
            sourceResourceName: Swift.String? = nil,
            sourceResourceType: Swift.String? = nil
        )
        {
            self.source = source
            self.sourceResourceName = sourceResourceName
            self.sourceResourceType = sourceResourceType
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyStatus] {
            return [
                .closed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyStatus(rawValue: rawValue) ?? AnomalyStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.AnomalyTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
    public struct AnomalyTimeRange: Swift.Equatable {
        /// The time when the anomalous behavior ended.
        public var endTime: ClientRuntime.Date?
        /// The time when the anomalous behavior started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum AnomalyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case causal
        case contextual
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyType] {
            return [
                .causal,
                .contextual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .causal: return "CAUSAL"
            case .contextual: return "CONTEXTUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyType(rawValue: rawValue) ?? AnomalyType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CloudFormationCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stackname0 in stackNames {
                try stackNamesContainer.encode(stackname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollection: Swift.Equatable {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stackname0 in stackNames {
                try stackNamesContainer.encode(stackname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCollectionFilter: Swift.Equatable {
        /// An array of CloudFormation stack names.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stackname0 in stackNames {
                try stackNamesContainer.encode(stackname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services CloudFormation stack used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of stacks you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the stack. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct CloudFormationCostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An array of CloudFormation stack names. Its size is fixed at 1 item.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension DevOpsGuruClientTypes.CloudFormationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResourceCount = "AnalyzedResourceCount"
        case insight = "Insight"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzedResourceCount = self.analyzedResourceCount {
            try encodeContainer.encode(analyzedResourceCount, forKey: .analyzedResourceCount)
        }
        if let insight = self.insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightHealth.self, forKey: .insight)
        insight = insightDecoded
        let analyzedResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .analyzedResourceCount)
        analyzedResourceCount = analyzedResourceCountDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack.
    public struct CloudFormationHealth: Swift.Equatable {
        /// Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services CloudFormation stack.
        public var analyzedResourceCount: Swift.Int?
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services CloudFormation stack, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The name of the CloudFormation stack.
        public var stackName: Swift.String?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.stackName = stackName
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CloudWatchMetricDataStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case internalError
        case partialData
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricDataStatusCode] {
            return [
                .complete,
                .internalError,
                .partialData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .internalError: return "InternalError"
            case .partialData: return "PartialData"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchMetricDataStatusCode(rawValue: rawValue) ?? CloudWatchMetricDataStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CloudWatchMetricsDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode = "StatusCode"
        case timestampMetricValuePairList = "TimestampMetricValuePairList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let timestampMetricValuePairList = timestampMetricValuePairList {
            var timestampMetricValuePairListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestampMetricValuePairList)
            for timestampmetricvaluepair0 in timestampMetricValuePairList {
                try timestampMetricValuePairListContainer.encode(timestampmetricvaluepair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampMetricValuePairListContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TimestampMetricValuePair?].self, forKey: .timestampMetricValuePairList)
        var timestampMetricValuePairListDecoded0:[DevOpsGuruClientTypes.TimestampMetricValuePair]? = nil
        if let timestampMetricValuePairListContainer = timestampMetricValuePairListContainer {
            timestampMetricValuePairListDecoded0 = [DevOpsGuruClientTypes.TimestampMetricValuePair]()
            for structure0 in timestampMetricValuePairListContainer {
                if let structure0 = structure0 {
                    timestampMetricValuePairListDecoded0?.append(structure0)
                }
            }
        }
        timestampMetricValuePairList = timestampMetricValuePairListDecoded0
        let statusCodeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains information about the analyzed metrics that displayed anomalous behavior.
    public struct CloudWatchMetricsDataSummary: Swift.Equatable {
        /// This is an enum of the status showing whether the metric value pair list has partial or complete data, or if there was an error.
        public var statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode?
        /// This is a list of Amazon CloudWatch metric values at given timestamp.
        public var timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]?

        public init(
            statusCode: DevOpsGuruClientTypes.CloudWatchMetricDataStatusCode? = nil,
            timestampMetricValuePairList: [DevOpsGuruClientTypes.TimestampMetricValuePair]? = nil
        )
        {
            self.statusCode = statusCode
            self.timestampMetricValuePairList = timestampMetricValuePairList
        }
    }

}

extension DevOpsGuruClientTypes.CloudWatchMetricsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case metricDataSummary = "MetricDataSummary"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case period = "Period"
        case stat = "Stat"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for cloudwatchmetricsdimension0 in dimensions {
                try dimensionsContainer.encode(cloudwatchmetricsdimension0)
            }
        }
        if let metricDataSummary = self.metricDataSummary {
            try encodeContainer.encode(metricDataSummary, forKey: .metricDataSummary)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let stat = self.stat {
            try encodeContainer.encode(stat.rawValue, forKey: .stat)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudWatchMetricsDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[DevOpsGuruClientTypes.CloudWatchMetricsDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [DevOpsGuruClientTypes.CloudWatchMetricsDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let statDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricsStat.self, forKey: .stat)
        stat = statDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period) ?? 0
        period = periodDecoded
        let metricDataSummaryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudWatchMetricsDataSummary.self, forKey: .metricDataSummary)
        metricDataSummary = metricDataSummaryDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric.
    public struct CloudWatchMetricsDetail: Swift.Equatable {
        /// An array of CloudWatch dimensions associated with
        public var dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]?
        /// This object returns anomaly metric data.
        public var metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary?
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?
        /// The length of time associated with the CloudWatch metric in number of seconds.
        public var period: Swift.Int
        /// The type of statistic associated with the CloudWatch metric. For more information, see [Statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic) in the Amazon CloudWatch User Guide.
        public var stat: DevOpsGuruClientTypes.CloudWatchMetricsStat?
        /// The unit of measure used for the CloudWatch metric. For example, Bytes, Seconds, Count, and Percent.
        public var unit: Swift.String?

        public init(
            dimensions: [DevOpsGuruClientTypes.CloudWatchMetricsDimension]? = nil,
            metricDataSummary: DevOpsGuruClientTypes.CloudWatchMetricsDataSummary? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil,
            period: Swift.Int = 0,
            stat: DevOpsGuruClientTypes.CloudWatchMetricsStat? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metricDataSummary = metricDataSummary
            self.metricName = metricName
            self.namespace = namespace
            self.period = period
            self.stat = stat
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes.CloudWatchMetricsDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The dimension of an Amazon CloudWatch metric that is used when DevOps Guru analyzes the resources in your account for operational problems and anomalous behavior. A dimension is a name/value pair that is part of the identity of a metric. A metric can have up to 10 dimensions. For more information, see [Dimensions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension) in the Amazon CloudWatch User Guide.
    public struct CloudWatchMetricsDimension: Swift.Equatable {
        /// The name of the CloudWatch dimension.
        public var name: Swift.String?
        /// The value of the CloudWatch dimension.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CloudWatchMetricsStat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case maximum
        case minimum
        case p50
        case p90
        case p99
        case sampleCount
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchMetricsStat] {
            return [
                .average,
                .maximum,
                .minimum,
                .p50,
                .p90,
                .p99,
                .sampleCount,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "Average"
            case .maximum: return "Maximum"
            case .minimum: return "Minimum"
            case .p50: return "p50"
            case .p90: return "p90"
            case .p99: return "p99"
            case .sampleCount: return "SampleCount"
            case .sum: return "Sum"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchMetricsStat(rawValue: rawValue) ?? CloudWatchMetricsStat.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception that is thrown when a conflict occurs.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the Amazon Web Services resource in which a conflict occurred.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the Amazon Web Services resource in which a conflict occurred.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = self.cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcostestimationresourcecollectionfilter0 in tags {
                try tagsContainer.encode(tagcostestimationresourcecollectionfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed to create a monthly DevOps Guru cost estimate. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct CostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An object that specifies the CloudFormation stack that defines the Amazon Web Services resources used to create a monthly estimate for DevOps Guru.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter?
        /// The Amazon Web Services tags used to filter the resource collection that is used for a cost estimate. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCostEstimationResourceCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum CostEstimationServiceResourceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationServiceResourceState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostEstimationServiceResourceState(rawValue: rawValue) ?? CostEstimationServiceResourceState.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum CostEstimationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostEstimationStatus] {
            return [
                .completed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostEstimationStatus(rawValue: rawValue) ?? CostEstimationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.CostEstimationTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range of a cost estimation.
    public struct CostEstimationTimeRange: Swift.Equatable {
        /// The end time of the cost estimation.
        public var endTime: ClientRuntime.Date?
        /// The start time of the cost estimation.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DeleteInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/insights/\(id.urlPercentEncoding())"
    }
}

public struct DeleteInsightInput: Swift.Equatable {
    /// The ID of the insight.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteInsightInputBody: Swift.Equatable {
}

extension DeleteInsightInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInsightOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInsightOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInsightOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts/health"
    }
}

public struct DescribeAccountHealthInput: Swift.Equatable {

    public init() { }
}

struct DescribeAccountHealthInputBody: Swift.Equatable {
}

extension DescribeAccountHealthInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.analyzedResourceCount = output.analyzedResourceCount
            self.metricsAnalyzed = output.metricsAnalyzed
            self.openProactiveInsights = output.openProactiveInsights
            self.openReactiveInsights = output.openReactiveInsights
            self.resourceHours = output.resourceHours
        } else {
            self.analyzedResourceCount = nil
            self.metricsAnalyzed = 0
            self.openProactiveInsights = 0
            self.openReactiveInsights = 0
            self.resourceHours = nil
        }
    }
}

public struct DescribeAccountHealthOutput: Swift.Equatable {
    /// Number of resources that DevOps Guru is monitoring in your Amazon Web Services account.
    public var analyzedResourceCount: Swift.Int?
    /// An integer that specifies the number of metrics that have been analyzed in your Amazon Web Services account.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init(
        analyzedResourceCount: Swift.Int? = nil,
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.analyzedResourceCount = analyzedResourceCount
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

struct DescribeAccountHealthOutputBody: Swift.Equatable {
    let openReactiveInsights: Swift.Int
    let openProactiveInsights: Swift.Int
    let metricsAnalyzed: Swift.Int
    let resourceHours: Swift.Int?
    let analyzedResourceCount: Swift.Int?
}

extension DescribeAccountHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResourceCount = "AnalyzedResourceCount"
        case metricsAnalyzed = "MetricsAnalyzed"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
        case resourceHours = "ResourceHours"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openReactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openReactiveInsights) ?? 0
        openReactiveInsights = openReactiveInsightsDecoded
        let openProactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openProactiveInsights) ?? 0
        openProactiveInsights = openProactiveInsightsDecoded
        let metricsAnalyzedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .metricsAnalyzed) ?? 0
        metricsAnalyzed = metricsAnalyzedDecoded
        let resourceHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceHours)
        resourceHours = resourceHoursDecoded
        let analyzedResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .analyzedResourceCount)
        analyzedResourceCount = analyzedResourceCountDecoded
    }
}

enum DescribeAccountHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountOverviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = self.fromTime {
            try encodeContainer.encodeTimestamp(fromTime, format: .epochSeconds, forKey: .fromTime)
        }
        if let toTime = self.toTime {
            try encodeContainer.encodeTimestamp(toTime, format: .epochSeconds, forKey: .toTime)
        }
    }
}

extension DescribeAccountOverviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts/overview"
    }
}

public struct DescribeAccountOverviewInput: Swift.Equatable {
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: ClientRuntime.Date?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: ClientRuntime.Date?

    public init(
        fromTime: ClientRuntime.Date? = nil,
        toTime: ClientRuntime.Date? = nil
    )
    {
        self.fromTime = fromTime
        self.toTime = toTime
    }
}

struct DescribeAccountOverviewInputBody: Swift.Equatable {
    let fromTime: ClientRuntime.Date?
    let toTime: ClientRuntime.Date?
}

extension DescribeAccountOverviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DescribeAccountOverviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountOverviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.meanTimeToRecoverInMilliseconds = output.meanTimeToRecoverInMilliseconds
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.meanTimeToRecoverInMilliseconds = nil
            self.proactiveInsights = 0
            self.reactiveInsights = 0
        }
    }
}

public struct DescribeAccountOverviewOutput: Swift.Equatable {
    /// The Mean Time to Recover (MTTR) for all closed insights that were created during the time range passed in.
    /// This member is required.
    public var meanTimeToRecoverInMilliseconds: Swift.Int?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account that were created during the time range passed in.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init(
        meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct DescribeAccountOverviewOutputBody: Swift.Equatable {
    let reactiveInsights: Swift.Int
    let proactiveInsights: Swift.Int
    let meanTimeToRecoverInMilliseconds: Swift.Int?
}

extension DescribeAccountOverviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reactiveInsights) ?? 0
        reactiveInsights = reactiveInsightsDecoded
        let proactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .proactiveInsights) ?? 0
        proactiveInsights = proactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

enum DescribeAccountOverviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAnomalyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let accountId = accountId {
                let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
                items.append(accountIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeAnomalyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/anomalies/\(id.urlPercentEncoding())"
    }
}

public struct DescribeAnomalyInput: Swift.Equatable {
    /// The ID of the member account.
    public var accountId: Swift.String?
    /// The ID of the anomaly.
    /// This member is required.
    public var id: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

struct DescribeAnomalyInputBody: Swift.Equatable {
}

extension DescribeAnomalyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAnomalyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAnomalyOutputBody = try responseDecoder.decode(responseBody: data)
            self.proactiveAnomaly = output.proactiveAnomaly
            self.reactiveAnomaly = output.reactiveAnomaly
        } else {
            self.proactiveAnomaly = nil
            self.reactiveAnomaly = nil
        }
    }
}

public struct DescribeAnomalyOutput: Swift.Equatable {
    /// A ProactiveAnomaly object that represents the requested anomaly.
    public var proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly?
    /// A ReactiveAnomaly object that represents the requested anomaly.
    public var reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly?

    public init(
        proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly? = nil,
        reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly? = nil
    )
    {
        self.proactiveAnomaly = proactiveAnomaly
        self.reactiveAnomaly = reactiveAnomaly
    }
}

struct DescribeAnomalyOutputBody: Swift.Equatable {
    let proactiveAnomaly: DevOpsGuruClientTypes.ProactiveAnomaly?
    let reactiveAnomaly: DevOpsGuruClientTypes.ReactiveAnomaly?
}

extension DescribeAnomalyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveAnomaly = "ProactiveAnomaly"
        case reactiveAnomaly = "ReactiveAnomaly"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomalyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ProactiveAnomaly.self, forKey: .proactiveAnomaly)
        proactiveAnomaly = proactiveAnomalyDecoded
        let reactiveAnomalyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ReactiveAnomaly.self, forKey: .reactiveAnomaly)
        reactiveAnomaly = reactiveAnomalyDecoded
    }
}

enum DescribeAnomalyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventSourcesConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-sources"
    }
}

public struct DescribeEventSourcesConfigInput: Swift.Equatable {

    public init() { }
}

struct DescribeEventSourcesConfigInputBody: Swift.Equatable {
}

extension DescribeEventSourcesConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEventSourcesConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventSourcesConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSources = output.eventSources
        } else {
            self.eventSources = nil
        }
    }
}

public struct DescribeEventSourcesConfigOutput: Swift.Equatable {
    /// Lists the event sources in the configuration.
    public var eventSources: DevOpsGuruClientTypes.EventSourcesConfig?

    public init(
        eventSources: DevOpsGuruClientTypes.EventSourcesConfig? = nil
    )
    {
        self.eventSources = eventSources
    }
}

struct DescribeEventSourcesConfigOutputBody: Swift.Equatable {
    let eventSources: DevOpsGuruClientTypes.EventSourcesConfig?
}

extension DescribeEventSourcesConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSources = "EventSources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventSourcesConfig.self, forKey: .eventSources)
        eventSources = eventSourcesDecoded
    }
}

enum DescribeEventSourcesConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
    }
}

extension DescribeFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/feedback"
    }
}

public struct DescribeFeedbackInput: Swift.Equatable {
    /// The ID of the insight for which the feedback was provided.
    public var insightId: Swift.String?

    public init(
        insightId: Swift.String? = nil
    )
    {
        self.insightId = insightId
    }
}

struct DescribeFeedbackInputBody: Swift.Equatable {
    let insightId: Swift.String?
}

extension DescribeFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
    }
}

extension DescribeFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFeedbackOutputBody = try responseDecoder.decode(responseBody: data)
            self.insightFeedback = output.insightFeedback
        } else {
            self.insightFeedback = nil
        }
    }
}

public struct DescribeFeedbackOutput: Swift.Equatable {
    /// Information about insight feedback received from a customer.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init(
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct DescribeFeedbackOutputBody: Swift.Equatable {
    let insightFeedback: DevOpsGuruClientTypes.InsightFeedback?
}

extension DescribeFeedbackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

enum DescribeFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInsightInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let accountId = accountId {
                let accountIdQueryItem = ClientRuntime.URLQueryItem(name: "AccountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
                items.append(accountIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/insights/\(id.urlPercentEncoding())"
    }
}

public struct DescribeInsightInput: Swift.Equatable {
    /// The ID of the member account in the organization.
    public var accountId: Swift.String?
    /// The ID of the insight.
    /// This member is required.
    public var id: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.id = id
    }
}

struct DescribeInsightInputBody: Swift.Equatable {
}

extension DescribeInsightInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInsightOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInsightOutputBody = try responseDecoder.decode(responseBody: data)
            self.proactiveInsight = output.proactiveInsight
            self.reactiveInsight = output.reactiveInsight
        } else {
            self.proactiveInsight = nil
            self.reactiveInsight = nil
        }
    }
}

public struct DescribeInsightOutput: Swift.Equatable {
    /// A ProactiveInsight object that represents the requested insight.
    public var proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight?
    /// A ReactiveInsight object that represents the requested insight.
    public var reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight?

    public init(
        proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight? = nil,
        reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight? = nil
    )
    {
        self.proactiveInsight = proactiveInsight
        self.reactiveInsight = reactiveInsight
    }
}

struct DescribeInsightOutputBody: Swift.Equatable {
    let proactiveInsight: DevOpsGuruClientTypes.ProactiveInsight?
    let reactiveInsight: DevOpsGuruClientTypes.ReactiveInsight?
}

extension DescribeInsightOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveInsight = "ProactiveInsight"
        case reactiveInsight = "ReactiveInsight"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ProactiveInsight.self, forKey: .proactiveInsight)
        proactiveInsight = proactiveInsightDecoded
        let reactiveInsightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ReactiveInsight.self, forKey: .reactiveInsight)
        reactiveInsight = reactiveInsightDecoded
    }
}

enum DescribeInsightOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationHealthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitid0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitid0)
            }
        }
    }
}

extension DescribeOrganizationHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/health"
    }
}

public struct DescribeOrganizationHealthInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.organizationalUnitIds = organizationalUnitIds
    }
}

struct DescribeOrganizationHealthInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
}

extension DescribeOrganizationHealthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
    }
}

extension DescribeOrganizationHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricsAnalyzed = output.metricsAnalyzed
            self.openProactiveInsights = output.openProactiveInsights
            self.openReactiveInsights = output.openReactiveInsights
            self.resourceHours = output.resourceHours
        } else {
            self.metricsAnalyzed = 0
            self.openProactiveInsights = 0
            self.openReactiveInsights = 0
            self.resourceHours = nil
        }
    }
}

public struct DescribeOrganizationHealthOutput: Swift.Equatable {
    /// An integer that specifies the number of metrics that have been analyzed in your organization.
    /// This member is required.
    public var metricsAnalyzed: Swift.Int
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openProactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var openReactiveInsights: Swift.Int
    /// The number of Amazon DevOps Guru resource analysis hours billed to the current Amazon Web Services account in the last hour.
    /// This member is required.
    public var resourceHours: Swift.Int?

    public init(
        metricsAnalyzed: Swift.Int = 0,
        openProactiveInsights: Swift.Int = 0,
        openReactiveInsights: Swift.Int = 0,
        resourceHours: Swift.Int? = nil
    )
    {
        self.metricsAnalyzed = metricsAnalyzed
        self.openProactiveInsights = openProactiveInsights
        self.openReactiveInsights = openReactiveInsights
        self.resourceHours = resourceHours
    }
}

struct DescribeOrganizationHealthOutputBody: Swift.Equatable {
    let openReactiveInsights: Swift.Int
    let openProactiveInsights: Swift.Int
    let metricsAnalyzed: Swift.Int
    let resourceHours: Swift.Int?
}

extension DescribeOrganizationHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsAnalyzed = "MetricsAnalyzed"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
        case resourceHours = "ResourceHours"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openReactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openReactiveInsights) ?? 0
        openReactiveInsights = openReactiveInsightsDecoded
        let openProactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openProactiveInsights) ?? 0
        openProactiveInsights = openProactiveInsightsDecoded
        let metricsAnalyzedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .metricsAnalyzed) ?? 0
        metricsAnalyzed = metricsAnalyzedDecoded
        let resourceHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceHours)
        resourceHours = resourceHoursDecoded
    }
}

enum DescribeOrganizationHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationOverviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case fromTime = "FromTime"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let fromTime = self.fromTime {
            try encodeContainer.encodeTimestamp(fromTime, format: .epochSeconds, forKey: .fromTime)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitid0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitid0)
            }
        }
        if let toTime = self.toTime {
            try encodeContainer.encodeTimestamp(toTime, format: .epochSeconds, forKey: .toTime)
        }
    }
}

extension DescribeOrganizationOverviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/overview"
    }
}

public struct DescribeOrganizationOverviewInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The start of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred after this day.
    /// This member is required.
    public var fromTime: ClientRuntime.Date?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// The end of the time range passed in. The start time granularity is at the day level. The floor of the start time is used. Returned information occurred before this day. If this is not specified, then the current day is used.
    public var toTime: ClientRuntime.Date?

    public init(
        accountIds: [Swift.String]? = nil,
        fromTime: ClientRuntime.Date? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        toTime: ClientRuntime.Date? = nil
    )
    {
        self.accountIds = accountIds
        self.fromTime = fromTime
        self.organizationalUnitIds = organizationalUnitIds
        self.toTime = toTime
    }
}

struct DescribeOrganizationOverviewInputBody: Swift.Equatable {
    let fromTime: ClientRuntime.Date?
    let toTime: ClientRuntime.Date?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
}

extension DescribeOrganizationOverviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case fromTime = "FromTime"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case toTime = "ToTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toTime)
        toTime = toTimeDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
    }
}

extension DescribeOrganizationOverviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationOverviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.proactiveInsights = 0
            self.reactiveInsights = 0
        }
    }
}

public struct DescribeOrganizationOverviewOutput: Swift.Equatable {
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    /// This member is required.
    public var proactiveInsights: Swift.Int
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    /// This member is required.
    public var reactiveInsights: Swift.Int

    public init(
        proactiveInsights: Swift.Int = 0,
        reactiveInsights: Swift.Int = 0
    )
    {
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct DescribeOrganizationOverviewOutputBody: Swift.Equatable {
    let reactiveInsights: Swift.Int
    let proactiveInsights: Swift.Int
}

extension DescribeOrganizationOverviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reactiveInsights) ?? 0
        reactiveInsights = reactiveInsightsDecoded
        let proactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .proactiveInsights) ?? 0
        proactiveInsights = proactiveInsightsDecoded
    }
}

enum DescribeOrganizationOverviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationResourceCollectionHealthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationResourceCollectionType = "OrganizationResourceCollectionType"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationResourceCollectionType = self.organizationResourceCollectionType {
            try encodeContainer.encode(organizationResourceCollectionType.rawValue, forKey: .organizationResourceCollectionType)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitid0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitid0)
            }
        }
    }
}

extension DescribeOrganizationResourceCollectionHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/health/resource-collection"
    }
}

public struct DescribeOrganizationResourceCollectionHealthInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType? = nil,
        organizationalUnitIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationResourceCollectionType = organizationResourceCollectionType
        self.organizationalUnitIds = organizationalUnitIds
    }
}

struct DescribeOrganizationResourceCollectionHealthInputBody: Swift.Equatable {
    let organizationResourceCollectionType: DevOpsGuruClientTypes.OrganizationResourceCollectionType?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeOrganizationResourceCollectionHealthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationResourceCollectionType = "OrganizationResourceCollectionType"
        case organizationalUnitIds = "OrganizationalUnitIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationResourceCollectionTypeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OrganizationResourceCollectionType.self, forKey: .organizationResourceCollectionType)
        organizationResourceCollectionType = organizationResourceCollectionTypeDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeOrganizationResourceCollectionHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationResourceCollectionHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
            self.cloudFormation = output.cloudFormation
            self.nextToken = output.nextToken
            self.service = output.service
            self.tags = output.tags
        } else {
            self.account = nil
            self.cloudFormation = nil
            self.nextToken = nil
            self.service = nil
            self.tags = nil
        }
    }
}

public struct DescribeOrganizationResourceCollectionHealthOutput: Swift.Equatable {
    /// The name of the organization's account.
    public var account: [DevOpsGuruClientTypes.AccountHealth]?
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?
    /// Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public var tags: [DevOpsGuruClientTypes.TagHealth]?

    public init(
        account: [DevOpsGuruClientTypes.AccountHealth]? = nil,
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil,
        tags: [DevOpsGuruClientTypes.TagHealth]? = nil
    )
    {
        self.account = account
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
        self.tags = tags
    }
}

struct DescribeOrganizationResourceCollectionHealthOutputBody: Swift.Equatable {
    let cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    let service: [DevOpsGuruClientTypes.ServiceHealth]?
    let account: [DevOpsGuruClientTypes.AccountHealth]?
    let nextToken: Swift.String?
    let tags: [DevOpsGuruClientTypes.TagHealth]?
}

extension DescribeOrganizationResourceCollectionHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case cloudFormation = "CloudFormation"
        case nextToken = "NextToken"
        case service = "Service"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudFormationHealth?].self, forKey: .cloudFormation)
        var cloudFormationDecoded0:[DevOpsGuruClientTypes.CloudFormationHealth]? = nil
        if let cloudFormationContainer = cloudFormationContainer {
            cloudFormationDecoded0 = [DevOpsGuruClientTypes.CloudFormationHealth]()
            for structure0 in cloudFormationContainer {
                if let structure0 = structure0 {
                    cloudFormationDecoded0?.append(structure0)
                }
            }
        }
        cloudFormation = cloudFormationDecoded0
        let serviceContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceHealth?].self, forKey: .service)
        var serviceDecoded0:[DevOpsGuruClientTypes.ServiceHealth]? = nil
        if let serviceContainer = serviceContainer {
            serviceDecoded0 = [DevOpsGuruClientTypes.ServiceHealth]()
            for structure0 in serviceContainer {
                if let structure0 = structure0 {
                    serviceDecoded0?.append(structure0)
                }
            }
        }
        service = serviceDecoded0
        let accountContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AccountHealth?].self, forKey: .account)
        var accountDecoded0:[DevOpsGuruClientTypes.AccountHealth]? = nil
        if let accountContainer = accountContainer {
            accountDecoded0 = [DevOpsGuruClientTypes.AccountHealth]()
            for structure0 in accountContainer {
                if let structure0 = structure0 {
                    accountDecoded0?.append(structure0)
                }
            }
        }
        account = accountDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagHealth?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagHealth]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagHealth]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeOrganizationResourceCollectionHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResourceCollectionHealthInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension DescribeResourceCollectionHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceCollectionType = resourceCollectionType else {
            return nil
        }
        return "/accounts/health/resource-collection/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

public struct DescribeResourceCollectionHealthInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// An Amazon Web Services resource collection type. This type specifies how analyzed Amazon Web Services resources are defined. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct DescribeResourceCollectionHealthInputBody: Swift.Equatable {
}

extension DescribeResourceCollectionHealthInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeResourceCollectionHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResourceCollectionHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.cloudFormation = output.cloudFormation
            self.nextToken = output.nextToken
            self.service = output.service
            self.tags = output.tags
        } else {
            self.cloudFormation = nil
            self.nextToken = nil
            self.service = nil
            self.tags = nil
        }
    }
}

public struct DescribeResourceCollectionHealthOutput: Swift.Equatable {
    /// The returned CloudFormationHealthOverview object that contains an InsightHealthOverview object with the requested system health information.
    public var cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ServiceHealth objects that describes the health of the Amazon Web Services services associated with the resources in the collection.
    public var service: [DevOpsGuruClientTypes.ServiceHealth]?
    /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public var tags: [DevOpsGuruClientTypes.TagHealth]?

    public init(
        cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]? = nil,
        nextToken: Swift.String? = nil,
        service: [DevOpsGuruClientTypes.ServiceHealth]? = nil,
        tags: [DevOpsGuruClientTypes.TagHealth]? = nil
    )
    {
        self.cloudFormation = cloudFormation
        self.nextToken = nextToken
        self.service = service
        self.tags = tags
    }
}

struct DescribeResourceCollectionHealthOutputBody: Swift.Equatable {
    let cloudFormation: [DevOpsGuruClientTypes.CloudFormationHealth]?
    let service: [DevOpsGuruClientTypes.ServiceHealth]?
    let nextToken: Swift.String?
    let tags: [DevOpsGuruClientTypes.TagHealth]?
}

extension DescribeResourceCollectionHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case nextToken = "NextToken"
        case service = "Service"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.CloudFormationHealth?].self, forKey: .cloudFormation)
        var cloudFormationDecoded0:[DevOpsGuruClientTypes.CloudFormationHealth]? = nil
        if let cloudFormationContainer = cloudFormationContainer {
            cloudFormationDecoded0 = [DevOpsGuruClientTypes.CloudFormationHealth]()
            for structure0 in cloudFormationContainer {
                if let structure0 = structure0 {
                    cloudFormationDecoded0?.append(structure0)
                }
            }
        }
        cloudFormation = cloudFormationDecoded0
        let serviceContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceHealth?].self, forKey: .service)
        var serviceDecoded0:[DevOpsGuruClientTypes.ServiceHealth]? = nil
        if let serviceContainer = serviceContainer {
            serviceDecoded0 = [DevOpsGuruClientTypes.ServiceHealth]()
            for structure0 in serviceContainer {
                if let structure0 = structure0 {
                    serviceDecoded0?.append(structure0)
                }
            }
        }
        service = serviceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagHealth?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagHealth]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagHealth]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribeResourceCollectionHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServiceIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-integrations"
    }
}

public struct DescribeServiceIntegrationInput: Swift.Equatable {

    public init() { }
}

struct DescribeServiceIntegrationInputBody: Swift.Equatable {
}

extension DescribeServiceIntegrationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeServiceIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServiceIntegrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceIntegration = output.serviceIntegration
        } else {
            self.serviceIntegration = nil
        }
    }
}

public struct DescribeServiceIntegrationOutput: Swift.Equatable {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public var serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig?

    public init(
        serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct DescribeServiceIntegrationOutputBody: Swift.Equatable {
    let serviceIntegration: DevOpsGuruClientTypes.ServiceIntegrationConfig?
}

extension DescribeServiceIntegrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

enum DescribeServiceIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.EndTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = self.fromTime {
            try encodeContainer.encodeTimestamp(fromTime, format: .epochSeconds, forKey: .fromTime)
        }
        if let toTime = self.toTime {
            try encodeContainer.encodeTimestamp(toTime, format: .epochSeconds, forKey: .toTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A range of time that specifies when anomalous behavior in an anomaly or insight ended.
    public struct EndTimeRange: Swift.Equatable {
        /// The earliest end time in the time range.
        public var fromTime: ClientRuntime.Date?
        /// The latest end time in the time range.
        public var toTime: ClientRuntime.Date?

        public init(
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case resources = "Resources"
        case time = "Time"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = self.eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresource0 in resources {
                try resourcesContainer.encode(eventresource0)
            }
        }
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.EventResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.EventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.EventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// An Amazon Web Services resource event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct Event: Swift.Equatable {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, where DevOps Guru analysis found the event.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the event. The class specifies what the event is related to, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the event.
        public var eventSource: Swift.String?
        /// The ID of the event.
        public var id: Swift.String?
        /// The name of the event.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// An EventResource object that contains information about the resource that emitted the event.
        public var resources: [DevOpsGuruClientTypes.EventResource]?
        /// A Timestamp that specifies the time the event occurred.
        public var time: ClientRuntime.Date?

        public init(
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            resources: [DevOpsGuruClientTypes.EventResource]? = nil,
            time: ClientRuntime.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.resources = resources
            self.time = time
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum EventClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configChange
        case deployment
        case infrastructure
        case schemaChange
        case securityChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventClass] {
            return [
                .configChange,
                .deployment,
                .infrastructure,
                .schemaChange,
                .securityChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configChange: return "CONFIG_CHANGE"
            case .deployment: return "DEPLOYMENT"
            case .infrastructure: return "INFRASTRUCTURE"
            case .schemaChange: return "SCHEMA_CHANGE"
            case .securityChange: return "SECURITY_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventClass(rawValue: rawValue) ?? EventClass.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum EventDataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCloudTrail
        case awsCodeDeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataSource] {
            return [
                .awsCloudTrail,
                .awsCodeDeploy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCloudTrail: return "AWS_CLOUD_TRAIL"
            case .awsCodeDeploy: return "AWS_CODE_DEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventDataSource(rawValue: rawValue) ?? EventDataSource.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.EventResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The Amazon Web Services resource that emitted an event. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventResource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource that emitted an event.
        public var arn: Swift.String?
        /// The name of the resource that emitted an event.
        public var name: Swift.String?
        /// The type of resource that emitted an event.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum EventSourceOptInStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSourceOptInStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventSourceOptInStatus(rawValue: rawValue) ?? EventSourceOptInStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.EventSourcesConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonCodeGuruProfiler = "AmazonCodeGuruProfiler"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonCodeGuruProfiler = self.amazonCodeGuruProfiler {
            try encodeContainer.encode(amazonCodeGuruProfiler, forKey: .amazonCodeGuruProfiler)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonCodeGuruProfilerDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration.self, forKey: .amazonCodeGuruProfiler)
        amazonCodeGuruProfiler = amazonCodeGuruProfilerDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru as consumer with another AWS service, such as AWS CodeGuru Profiler via EventBridge.
    public struct EventSourcesConfig: Swift.Equatable {
        /// Information about whether DevOps Guru is configured to consume recommendations which are generated from AWS CodeGuru Profiler.
        public var amazonCodeGuruProfiler: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration?

        public init(
            amazonCodeGuruProfiler: DevOpsGuruClientTypes.AmazonCodeGuruProfilerIntegration? = nil
        )
        {
            self.amazonCodeGuruProfiler = amazonCodeGuruProfiler
        }
    }

}

extension DevOpsGuruClientTypes.EventTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = self.fromTime {
            try encodeContainer.encodeTimestamp(fromTime, format: .epochSeconds, forKey: .fromTime)
        }
        if let toTime = self.toTime {
            try encodeContainer.encodeTimestamp(toTime, format: .epochSeconds, forKey: .toTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which an Amazon Web Services event occurred. Amazon Web Services resource events and metrics are analyzed by DevOps Guru to find anomalous behavior and provide recommendations to improve your operational solutions.
    public struct EventTimeRange: Swift.Equatable {
        /// The time when the event started.
        /// This member is required.
        public var fromTime: ClientRuntime.Date?
        /// The time when the event ended.
        /// This member is required.
        public var toTime: ClientRuntime.Date?

        public init(
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension GetCostEstimationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetCostEstimationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cost-estimation"
    }
}

public struct GetCostEstimationInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetCostEstimationInputBody: Swift.Equatable {
}

extension GetCostEstimationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCostEstimationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCostEstimationOutputBody = try responseDecoder.decode(responseBody: data)
            self.costs = output.costs
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
            self.status = output.status
            self.timeRange = output.timeRange
            self.totalCost = output.totalCost
        } else {
            self.costs = nil
            self.nextToken = nil
            self.resourceCollection = nil
            self.status = nil
            self.timeRange = nil
            self.totalCost = 0.0
        }
    }
}

public struct GetCostEstimationOutput: Swift.Equatable {
    /// An array of ResourceCost objects that each contains details about the monthly cost estimate to analyze one of your Amazon Web Services resources.
    public var costs: [DevOpsGuruClientTypes.ServiceResourceCost]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The collection of the Amazon Web Services resources used to create your monthly DevOps Guru cost estimate.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    /// The status of creating this cost estimate. If it's still in progress, the status ONGOING is returned. If it is finished, the status COMPLETED is returned.
    public var status: DevOpsGuruClientTypes.CostEstimationStatus?
    /// The start and end time of the cost estimation.
    public var timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange?
    /// The estimated monthly cost to analyze the Amazon Web Services resources. This value is the sum of the estimated costs to analyze each resource in the Costs object in this response.
    public var totalCost: Swift.Double

    public init(
        costs: [DevOpsGuruClientTypes.ServiceResourceCost]? = nil,
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil,
        status: DevOpsGuruClientTypes.CostEstimationStatus? = nil,
        timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange? = nil,
        totalCost: Swift.Double = 0.0
    )
    {
        self.costs = costs
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
        self.status = status
        self.timeRange = timeRange
        self.totalCost = totalCost
    }
}

struct GetCostEstimationOutputBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    let status: DevOpsGuruClientTypes.CostEstimationStatus?
    let costs: [DevOpsGuruClientTypes.ServiceResourceCost]?
    let timeRange: DevOpsGuruClientTypes.CostEstimationTimeRange?
    let totalCost: Swift.Double
    let nextToken: Swift.String?
}

extension GetCostEstimationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costs = "Costs"
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
        case status = "Status"
        case timeRange = "TimeRange"
        case totalCost = "TotalCost"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationStatus.self, forKey: .status)
        status = statusDecoded
        let costsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceResourceCost?].self, forKey: .costs)
        var costsDecoded0:[DevOpsGuruClientTypes.ServiceResourceCost]? = nil
        if let costsContainer = costsContainer {
            costsDecoded0 = [DevOpsGuruClientTypes.ServiceResourceCost]()
            for structure0 in costsContainer {
                if let structure0 = structure0 {
                    costsDecoded0?.append(structure0)
                }
            }
        }
        costs = costsDecoded0
        let timeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationTimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let totalCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalCost) ?? 0.0
        totalCost = totalCostDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetCostEstimationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceCollectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetResourceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceCollectionType = resourceCollectionType else {
            return nil
        }
        return "/resource-collections/\(resourceCollectionType.rawValue.urlPercentEncoding())"
    }
}

public struct GetResourceCollectionInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of Amazon Web Services resource collections to return. The one valid value is CLOUD_FORMATION for Amazon Web Services CloudFormation stacks.
    /// This member is required.
    public var resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollectionType: DevOpsGuruClientTypes.ResourceCollectionType? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollectionType = resourceCollectionType
    }
}

struct GetResourceCollectionInputBody: Swift.Equatable {
}

extension GetResourceCollectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceCollectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceCollection = output.resourceCollection
        } else {
            self.nextToken = nil
            self.resourceCollection = nil
        }
    }
}

public struct GetResourceCollectionOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The requested list of Amazon Web Services resource collections. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public var resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter?

    public init(
        nextToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceCollection = resourceCollection
    }
}

struct GetResourceCollectionOutputBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.ResourceCollectionFilter?
    let nextToken: Swift.String?
}

extension GetResourceCollectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceCollection = "ResourceCollection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetResourceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.InsightFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feedback = "Feedback"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedbackOption.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about insight feedback received from a customer.
    public struct InsightFeedback: Swift.Equatable {
        /// The feedback provided by the customer.
        public var feedback: DevOpsGuruClientTypes.InsightFeedbackOption?
        /// The insight feedback ID.
        public var id: Swift.String?

        public init(
            feedback: DevOpsGuruClientTypes.InsightFeedbackOption? = nil,
            id: Swift.String? = nil
        )
        {
            self.feedback = feedback
            self.id = id
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightFeedbackOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alertTooSensitive
        case dataIncorrect
        case dataNoisyAnomaly
        case recommendationUseful
        case validCollection
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightFeedbackOption] {
            return [
                .alertTooSensitive,
                .dataIncorrect,
                .dataNoisyAnomaly,
                .recommendationUseful,
                .validCollection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alertTooSensitive: return "ALERT_TOO_SENSITIVE"
            case .dataIncorrect: return "DATA_INCORRECT"
            case .dataNoisyAnomaly: return "DATA_NOISY_ANOMALY"
            case .recommendationUseful: return "RECOMMENDATION_USEFUL"
            case .validCollection: return "VALID_COLLECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightFeedbackOption(rawValue: rawValue) ?? InsightFeedbackOption.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.InsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanTimeToRecoverInMilliseconds = "MeanTimeToRecoverInMilliseconds"
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanTimeToRecoverInMilliseconds = self.meanTimeToRecoverInMilliseconds {
            try encodeContainer.encode(meanTimeToRecoverInMilliseconds, forKey: .meanTimeToRecoverInMilliseconds)
        }
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openProactiveInsights) ?? 0
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openReactiveInsights) ?? 0
        openReactiveInsights = openReactiveInsightsDecoded
        let meanTimeToRecoverInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meanTimeToRecoverInMilliseconds)
        meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMillisecondsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the number of open reactive and proactive insights that can be used to gauge the health of your system.
    public struct InsightHealth: Swift.Equatable {
        /// The Meant Time to Recover (MTTR) for the insight.
        public var meanTimeToRecoverInMilliseconds: Swift.Int?
        /// The number of open proactive insights.
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights.
        public var openReactiveInsights: Swift.Int

        public init(
            meanTimeToRecoverInMilliseconds: Swift.Int? = nil,
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.meanTimeToRecoverInMilliseconds = meanTimeToRecoverInMilliseconds
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightSeverity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightSeverity(rawValue: rawValue) ?? InsightSeverity.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum InsightStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case ongoing
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightStatus] {
            return [
                .closed,
                .ongoing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .ongoing: return "ONGOING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightStatus(rawValue: rawValue) ?? InsightStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.InsightTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time ranged that specifies when the observed behavior in an insight started and ended.
    public struct InsightTimeRange: Swift.Equatable {
        /// The time when the behavior described in an insight ended.
        public var endTime: ClientRuntime.Date?
        /// The time when the behavior described in an insight started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case proactive
        case reactive
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .proactive,
                .reactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .proactive: return "PROACTIVE"
            case .reactive: return "REACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal failure in an Amazon service occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds after which the action that caused the internal server exception can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KMSKeyId"
        case optInStatus = "OptInStatus"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServerSideEncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the KMS encryption used with DevOps Guru.
    public struct KMSServerSideEncryptionIntegration: Swift.Equatable {
        /// Describes the specified KMS key. To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix it with "alias/". If you specify a predefined Amazon Web Services alias (an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an Amazon Web Services managed key and returns its KeyId and Arn in the response. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example: Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public var kmsKeyId: Swift.String?
        /// Specifies if DevOps Guru is enabled for customer managed keys.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?
        /// The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        public var type: DevOpsGuruClientTypes.ServerSideEncryptionType?

        public init(
            kmsKeyId: Swift.String? = nil,
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil,
            type: DevOpsGuruClientTypes.ServerSideEncryptionType? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KMSKeyId"
        case optInStatus = "OptInStatus"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServerSideEncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
    public struct KMSServerSideEncryptionIntegrationConfig: Swift.Equatable {
        /// Describes the specified KMS key. To specify a KMS key, use its key ID, key ARN, alias name, or alias ARN. When using an alias name, prefix it with "alias/". If you specify a predefined Amazon Web Services alias (an Amazon Web Services alias with no key ID), Amazon Web Services KMS associates the alias with an Amazon Web Services managed key and returns its KeyId and Arn in the response. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example: Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab Alias name: alias/ExampleAlias Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
        public var kmsKeyId: Swift.String?
        /// Specifies if DevOps Guru is enabled for KMS integration.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?
        /// The type of KMS key used. Customer managed keys are the KMS keys that you create. Amazon Web Services owned keys are keys that are owned and managed by DevOps Guru.
        public var type: DevOpsGuruClientTypes.ServerSideEncryptionType?

        public init(
            kmsKeyId: Swift.String? = nil,
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil,
            type: DevOpsGuruClientTypes.ServerSideEncryptionType? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.optInStatus = optInStatus
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ListAnomaliesForInsightFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceCollection = "ServiceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Specifies one or more service names that are used to list anomalies.
    public struct ListAnomaliesForInsightFilters: Swift.Equatable {
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?

        public init(
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil
        )
        {
            self.serviceCollection = serviceCollection
        }
    }

}

extension ListAnomaliesForInsightInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = self.startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
    }
}

extension ListAnomaliesForInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let insightId = insightId else {
            return nil
        }
        return "/anomalies/insight/\(insightId.urlPercentEncoding())"
    }
}

public struct ListAnomaliesForInsightInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// Specifies one or more service names that are used to list anomalies.
    public var filters: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters?
    /// The ID of the insight. The returned anomalies belong to this insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the requested anomalies started. All returned anomalies started during this time range.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?

    public init(
        accountId: Swift.String? = nil,
        filters: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters? = nil,
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil
    )
    {
        self.accountId = accountId
        self.filters = filters
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
    }
}

struct ListAnomaliesForInsightInputBody: Swift.Equatable {
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
    let filters: DevOpsGuruClientTypes.ListAnomaliesForInsightFilters?
}

extension ListAnomaliesForInsightInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListAnomaliesForInsightFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListAnomaliesForInsightOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnomaliesForInsightOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveAnomalies = output.proactiveAnomalies
            self.reactiveAnomalies = output.reactiveAnomalies
        } else {
            self.nextToken = nil
            self.proactiveAnomalies = nil
            self.reactiveAnomalies = nil
        }
    }
}

public struct ListAnomaliesForInsightOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of ProactiveAnomalySummary objects that represent the requested anomalies
    public var proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]?
    /// An array of ReactiveAnomalySummary objects that represent the requested anomalies
    public var reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]? = nil,
        reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveAnomalies = proactiveAnomalies
        self.reactiveAnomalies = reactiveAnomalies
    }
}

struct ListAnomaliesForInsightOutputBody: Swift.Equatable {
    let proactiveAnomalies: [DevOpsGuruClientTypes.ProactiveAnomalySummary]?
    let reactiveAnomalies: [DevOpsGuruClientTypes.ReactiveAnomalySummary]?
    let nextToken: Swift.String?
}

extension ListAnomaliesForInsightOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveAnomalies = "ProactiveAnomalies"
        case reactiveAnomalies = "ReactiveAnomalies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveAnomalySummary?].self, forKey: .proactiveAnomalies)
        var proactiveAnomaliesDecoded0:[DevOpsGuruClientTypes.ProactiveAnomalySummary]? = nil
        if let proactiveAnomaliesContainer = proactiveAnomaliesContainer {
            proactiveAnomaliesDecoded0 = [DevOpsGuruClientTypes.ProactiveAnomalySummary]()
            for structure0 in proactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    proactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        proactiveAnomalies = proactiveAnomaliesDecoded0
        let reactiveAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveAnomalySummary?].self, forKey: .reactiveAnomalies)
        var reactiveAnomaliesDecoded0:[DevOpsGuruClientTypes.ReactiveAnomalySummary]? = nil
        if let reactiveAnomaliesContainer = reactiveAnomaliesContainer {
            reactiveAnomaliesDecoded0 = [DevOpsGuruClientTypes.ReactiveAnomalySummary]()
            for structure0 in reactiveAnomaliesContainer {
                if let structure0 = structure0 {
                    reactiveAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        reactiveAnomalies = reactiveAnomaliesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnomaliesForInsightOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAnomalousLogGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAnomalousLogGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-log-anomalies"
    }
}

public struct ListAnomalousLogGroupsInput: Swift.Equatable {
    /// The ID of the insight containing the log groups.
    /// This member is required.
    public var insightId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        insightId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnomalousLogGroupsInputBody: Swift.Equatable {
    let insightId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAnomalousLogGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalousLogGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnomalousLogGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalousLogGroups = output.anomalousLogGroups
            self.insightId = output.insightId
            self.nextToken = output.nextToken
        } else {
            self.anomalousLogGroups = nil
            self.insightId = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalousLogGroupsOutput: Swift.Equatable {
    /// The list of Amazon CloudWatch log groups that are related to an insight.
    /// This member is required.
    public var anomalousLogGroups: [DevOpsGuruClientTypes.AnomalousLogGroup]?
    /// The ID of the insight containing the log groups.
    /// This member is required.
    public var insightId: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        anomalousLogGroups: [DevOpsGuruClientTypes.AnomalousLogGroup]? = nil,
        insightId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalousLogGroups = anomalousLogGroups
        self.insightId = insightId
        self.nextToken = nextToken
    }
}

struct ListAnomalousLogGroupsOutputBody: Swift.Equatable {
    let insightId: Swift.String?
    let anomalousLogGroups: [DevOpsGuruClientTypes.AnomalousLogGroup]?
    let nextToken: Swift.String?
}

extension ListAnomalousLogGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalousLogGroups = "AnomalousLogGroups"
        case insightId = "InsightId"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let anomalousLogGroupsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalousLogGroup?].self, forKey: .anomalousLogGroups)
        var anomalousLogGroupsDecoded0:[DevOpsGuruClientTypes.AnomalousLogGroup]? = nil
        if let anomalousLogGroupsContainer = anomalousLogGroupsContainer {
            anomalousLogGroupsDecoded0 = [DevOpsGuruClientTypes.AnomalousLogGroup]()
            for structure0 in anomalousLogGroupsContainer {
                if let structure0 = structure0 {
                    anomalousLogGroupsDecoded0?.append(structure0)
                }
            }
        }
        anomalousLogGroups = anomalousLogGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnomalousLogGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.ListEventsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "DataSource"
        case eventClass = "EventClass"
        case eventSource = "EventSource"
        case eventTimeRange = "EventTimeRange"
        case insightId = "InsightId"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let eventClass = self.eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTimeRange = self.eventTimeRange {
            try encodeContainer.encode(eventTimeRange, forKey: .eventTimeRange)
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let eventTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventTimeRange.self, forKey: .eventTimeRange)
        eventTimeRange = eventTimeRangeDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct ListEventsFilters: Swift.Equatable {
        /// The source, AWS_CLOUD_TRAIL or AWS_CODE_DEPLOY, of the events you want returned.
        public var dataSource: DevOpsGuruClientTypes.EventDataSource?
        /// The class of the events you want to filter for, such as an infrastructure change, a deployment, or a schema change.
        public var eventClass: DevOpsGuruClientTypes.EventClass?
        /// The Amazon Web Services source that emitted the events you want to filter for.
        public var eventSource: Swift.String?
        /// A time range during which you want the filtered events to have occurred.
        public var eventTimeRange: DevOpsGuruClientTypes.EventTimeRange?
        /// An ID of an insight that is related to the events you want to filter for.
        public var insightId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?

        public init(
            dataSource: DevOpsGuruClientTypes.EventDataSource? = nil,
            eventClass: DevOpsGuruClientTypes.EventClass? = nil,
            eventSource: Swift.String? = nil,
            eventTimeRange: DevOpsGuruClientTypes.EventTimeRange? = nil,
            insightId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil
        )
        {
            self.dataSource = dataSource
            self.eventClass = eventClass
            self.eventSource = eventSource
            self.eventTimeRange = eventTimeRange
            self.insightId = insightId
            self.resourceCollection = resourceCollection
        }
    }

}

extension ListEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/events"
    }
}

public struct ListEventsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// A ListEventsFilters object used to specify which events to return.
    /// This member is required.
    public var filters: DevOpsGuruClientTypes.ListEventsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        filters: DevOpsGuruClientTypes.ListEventsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventsInputBody: Swift.Equatable {
    let filters: DevOpsGuruClientTypes.ListEventsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountId: Swift.String?
}

extension ListEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListEventsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventsOutput: Swift.Equatable {
    /// A list of the requested events.
    /// This member is required.
    public var events: [DevOpsGuruClientTypes.Event]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        events: [DevOpsGuruClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListEventsOutputBody: Swift.Equatable {
    let events: [DevOpsGuruClientTypes.Event]?
    let nextToken: Swift.String?
}

extension ListEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DevOpsGuruClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DevOpsGuruClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.ListInsightsAnyStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTimeRange = self.startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have any status.
    public struct ListInsightsAnyStatusFilter: Swift.Equatable {
        /// A time range used to specify when the behavior of the filtered insights started.
        /// This member is required.
        public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.startTimeRange = startTimeRange
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ListInsightsClosedStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimeRange = "EndTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeRange = self.endTimeRange {
            try encodeContainer.encode(endTimeRange, forKey: .endTimeRange)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
        let endTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EndTimeRange.self, forKey: .endTimeRange)
        endTimeRange = endTimeRangeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status CLOSED.
    public struct ListInsightsClosedStatusFilter: Swift.Equatable {
        /// A time range used to specify when the behavior of the filtered insights ended.
        /// This member is required.
        public var endTimeRange: DevOpsGuruClientTypes.EndTimeRange?
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            endTimeRange: DevOpsGuruClientTypes.EndTimeRange? = nil,
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.endTimeRange = endTimeRange
            self.type = type
        }
    }

}

extension ListInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let statusFilter = self.statusFilter {
            try encodeContainer.encode(statusFilter, forKey: .statusFilter)
        }
    }
}

extension ListInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights"
    }
}

public struct ListInsightsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A filter used to filter the returned insights by their status. You can specify one status filter.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListInsightsInputBody: Swift.Equatable {
    let statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case statusFilter = "StatusFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusFilterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Used to filter for insights that have the status ONGOING.
    public struct ListInsightsOngoingStatusFilter: Swift.Equatable {
        /// Use to filter for either REACTIVE or PROACTIVE insights.
        /// This member is required.
        public var type: DevOpsGuruClientTypes.InsightType?

        public init(
            type: DevOpsGuruClientTypes.InsightType? = nil
        )
        {
            self.type = type
        }
    }

}

extension ListInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct ListInsightsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned list of proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned list of reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct ListInsightsOutputBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension ListInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.ListInsightsStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case any = "Any"
        case closed = "Closed"
        case ongoing = "Ongoing"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let any = self.any {
            try encodeContainer.encode(any, forKey: .any)
        }
        if let closed = self.closed {
            try encodeContainer.encode(closed, forKey: .closed)
        }
        if let ongoing = self.ongoing {
            try encodeContainer.encode(ongoing, forKey: .ongoing)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ongoingDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter.self, forKey: .ongoing)
        ongoing = ongoingDecoded
        let closedDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsClosedStatusFilter.self, forKey: .closed)
        closed = closedDecoded
        let anyDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsAnyStatusFilter.self, forKey: .any)
        any = anyDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A filter used by ListInsights to specify which insights to return.
    public struct ListInsightsStatusFilter: Swift.Equatable {
        /// A ListInsightsAnyStatusFilter that specifies insights of any status that are either REACTIVE or PROACTIVE.
        public var any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter?
        /// A ListInsightsClosedStatusFilter that specifies closed insights that are either REACTIVE or PROACTIVE.
        public var closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter?
        /// A ListInsightsAnyStatusFilter that specifies ongoing insights that are either REACTIVE or PROACTIVE.
        public var ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter?

        public init(
            any: DevOpsGuruClientTypes.ListInsightsAnyStatusFilter? = nil,
            closed: DevOpsGuruClientTypes.ListInsightsClosedStatusFilter? = nil,
            ongoing: DevOpsGuruClientTypes.ListInsightsOngoingStatusFilter? = nil
        )
        {
            self.any = any
            self.closed = closed
            self.ongoing = ongoing
        }
    }

}

extension DevOpsGuruClientTypes.ListMonitoredResourcesFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePermission = "ResourcePermission"
        case resourceTypeFilters = "ResourceTypeFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourcePermission = self.resourcePermission {
            try encodeContainer.encode(resourcePermission.rawValue, forKey: .resourcePermission)
        }
        if let resourceTypeFilters = resourceTypeFilters {
            var resourceTypeFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypeFilters)
            for resourcetypefilter0 in resourceTypeFilters {
                try resourceTypeFiltersContainer.encode(resourcetypefilter0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePermissionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourcePermission.self, forKey: .resourcePermission)
        resourcePermission = resourcePermissionDecoded
        let resourceTypeFiltersContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ResourceTypeFilter?].self, forKey: .resourceTypeFilters)
        var resourceTypeFiltersDecoded0:[DevOpsGuruClientTypes.ResourceTypeFilter]? = nil
        if let resourceTypeFiltersContainer = resourceTypeFiltersContainer {
            resourceTypeFiltersDecoded0 = [DevOpsGuruClientTypes.ResourceTypeFilter]()
            for enum0 in resourceTypeFiltersContainer {
                if let enum0 = enum0 {
                    resourceTypeFiltersDecoded0?.append(enum0)
                }
            }
        }
        resourceTypeFilters = resourceTypeFiltersDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Filters to determine which monitored resources you want to retrieve. You can filter by resource type or resource permission status.
    public struct ListMonitoredResourcesFilters: Swift.Equatable {
        /// The permission status of a resource.
        /// This member is required.
        public var resourcePermission: DevOpsGuruClientTypes.ResourcePermission?
        /// The type of resource that you wish to retrieve, such as log groups.
        /// This member is required.
        public var resourceTypeFilters: [DevOpsGuruClientTypes.ResourceTypeFilter]?

        public init(
            resourcePermission: DevOpsGuruClientTypes.ResourcePermission? = nil,
            resourceTypeFilters: [DevOpsGuruClientTypes.ResourceTypeFilter]? = nil
        )
        {
            self.resourcePermission = resourcePermission
            self.resourceTypeFilters = resourceTypeFilters
        }
    }

}

extension ListMonitoredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMonitoredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/monitoredResources"
    }
}

public struct ListMonitoredResourcesInput: Swift.Equatable {
    /// Filters to determine which monitored resources you want to retrieve. You can filter by resource type or resource permission status.
    public var filters: DevOpsGuruClientTypes.ListMonitoredResourcesFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        filters: DevOpsGuruClientTypes.ListMonitoredResourcesFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMonitoredResourcesInputBody: Swift.Equatable {
    let filters: DevOpsGuruClientTypes.ListMonitoredResourcesFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMonitoredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListMonitoredResourcesFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMonitoredResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMonitoredResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitoredResourceIdentifiers = output.monitoredResourceIdentifiers
            self.nextToken = output.nextToken
        } else {
            self.monitoredResourceIdentifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListMonitoredResourcesOutput: Swift.Equatable {
    /// Information about the resource that is being monitored, including the name of the resource, the type of resource, and whether or not permission is given to DevOps Guru to access that resource.
    /// This member is required.
    public var monitoredResourceIdentifiers: [DevOpsGuruClientTypes.MonitoredResourceIdentifier]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        monitoredResourceIdentifiers: [DevOpsGuruClientTypes.MonitoredResourceIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitoredResourceIdentifiers = monitoredResourceIdentifiers
        self.nextToken = nextToken
    }
}

struct ListMonitoredResourcesOutputBody: Swift.Equatable {
    let monitoredResourceIdentifiers: [DevOpsGuruClientTypes.MonitoredResourceIdentifier]?
    let nextToken: Swift.String?
}

extension ListMonitoredResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoredResourceIdentifiers = "MonitoredResourceIdentifiers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoredResourceIdentifiersContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.MonitoredResourceIdentifier?].self, forKey: .monitoredResourceIdentifiers)
        var monitoredResourceIdentifiersDecoded0:[DevOpsGuruClientTypes.MonitoredResourceIdentifier]? = nil
        if let monitoredResourceIdentifiersContainer = monitoredResourceIdentifiersContainer {
            monitoredResourceIdentifiersDecoded0 = [DevOpsGuruClientTypes.MonitoredResourceIdentifier]()
            for structure0 in monitoredResourceIdentifiersContainer {
                if let structure0 = structure0 {
                    monitoredResourceIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        monitoredResourceIdentifiers = monitoredResourceIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMonitoredResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotificationChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListNotificationChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListNotificationChannelsInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListNotificationChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotificationChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListNotificationChannelsOutput: Swift.Equatable {
    /// An array that contains the requested notification channels.
    public var channels: [DevOpsGuruClientTypes.NotificationChannel]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init(
        channels: [DevOpsGuruClientTypes.NotificationChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListNotificationChannelsOutputBody: Swift.Equatable {
    let channels: [DevOpsGuruClientTypes.NotificationChannel]?
    let nextToken: Swift.String?
}

extension ListNotificationChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.NotificationChannel?].self, forKey: .channels)
        var channelsDecoded0:[DevOpsGuruClientTypes.NotificationChannel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [DevOpsGuruClientTypes.NotificationChannel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNotificationChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case statusFilter = "StatusFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationalUnitIds = organizationalUnitIds {
            var organizationalUnitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitIds)
            for organizationalunitid0 in organizationalUnitIds {
                try organizationalUnitIdsContainer.encode(organizationalunitid0)
            }
        }
        if let statusFilter = self.statusFilter {
            try encodeContainer.encode(statusFilter, forKey: .statusFilter)
        }
    }
}

extension ListOrganizationInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/insights"
    }
}

public struct ListOrganizationInsightsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The ID of the organizational unit.
    public var organizationalUnitIds: [Swift.String]?
    /// A filter used by ListInsights to specify which insights to return.
    /// This member is required.
    public var statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?

    public init(
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationalUnitIds: [Swift.String]? = nil,
        statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationalUnitIds = organizationalUnitIds
        self.statusFilter = statusFilter
    }
}

struct ListOrganizationInsightsInputBody: Swift.Equatable {
    let statusFilter: DevOpsGuruClientTypes.ListInsightsStatusFilter?
    let maxResults: Swift.Int?
    let accountIds: [Swift.String]?
    let organizationalUnitIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListOrganizationInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationalUnitIds = "OrganizationalUnitIds"
        case statusFilter = "StatusFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusFilterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ListInsightsStatusFilter.self, forKey: .statusFilter)
        statusFilter = statusFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let organizationalUnitIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitIds)
        var organizationalUnitIdsDecoded0:[Swift.String]? = nil
        if let organizationalUnitIdsContainer = organizationalUnitIdsContainer {
            organizationalUnitIdsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitIdsContainer {
                if let string0 = string0 {
                    organizationalUnitIdsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitIds = organizationalUnitIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct ListOrganizationInsightsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct ListOrganizationInsightsOutputBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]?
    let nextToken: Swift.String?
}

extension ListOrganizationInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOrganizationInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let insightId = self.insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recommendations"
    }
}

public struct ListRecommendationsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    public var accountId: Swift.String?
    /// The ID of the requested insight.
    /// This member is required.
    public var insightId: Swift.String?
    /// A locale that specifies the language to use for recommendations.
    public var locale: DevOpsGuruClientTypes.Locale?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        insightId: Swift.String? = nil,
        locale: DevOpsGuruClientTypes.Locale? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.insightId = insightId
        self.locale = locale
        self.nextToken = nextToken
    }
}

struct ListRecommendationsInputBody: Swift.Equatable {
    let insightId: Swift.String?
    let nextToken: Swift.String?
    let locale: DevOpsGuruClientTypes.Locale?
    let accountId: Swift.String?
}

extension ListRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case insightId = "InsightId"
        case locale = "Locale"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let localeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ListRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct ListRecommendationsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An array of the requested recommendations.
    public var recommendations: [DevOpsGuruClientTypes.Recommendation]?

    public init(
        nextToken: Swift.String? = nil,
        recommendations: [DevOpsGuruClientTypes.Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct ListRecommendationsOutputBody: Swift.Equatable {
    let recommendations: [DevOpsGuruClientTypes.Recommendation]?
    let nextToken: Swift.String?
}

extension ListRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recommendations = "Recommendations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[DevOpsGuruClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [DevOpsGuruClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case esEs
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .esEs,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "DE_DE"
            case .enGb: return "EN_GB"
            case .enUs: return "EN_US"
            case .esEs: return "ES_ES"
            case .frFr: return "FR_FR"
            case .itIt: return "IT_IT"
            case .jaJp: return "JA_JP"
            case .koKr: return "KO_KR"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.LogAnomalyClass: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case explanation = "Explanation"
        case logAnomalyToken = "LogAnomalyToken"
        case logAnomalyType = "LogAnomalyType"
        case logEventId = "LogEventId"
        case logEventTimestamp = "LogEventTimestamp"
        case logStreamName = "LogStreamName"
        case numberOfLogLinesOccurrences = "NumberOfLogLinesOccurrences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let explanation = self.explanation {
            try encodeContainer.encode(explanation, forKey: .explanation)
        }
        if let logAnomalyToken = self.logAnomalyToken {
            try encodeContainer.encode(logAnomalyToken, forKey: .logAnomalyToken)
        }
        if let logAnomalyType = self.logAnomalyType {
            try encodeContainer.encode(logAnomalyType.rawValue, forKey: .logAnomalyType)
        }
        if let logEventId = self.logEventId {
            try encodeContainer.encode(logEventId, forKey: .logEventId)
        }
        if let logEventTimestamp = self.logEventTimestamp {
            try encodeContainer.encodeTimestamp(logEventTimestamp, format: .epochSeconds, forKey: .logEventTimestamp)
        }
        if let logStreamName = self.logStreamName {
            try encodeContainer.encode(logStreamName, forKey: .logStreamName)
        }
        if numberOfLogLinesOccurrences != 0 {
            try encodeContainer.encode(numberOfLogLinesOccurrences, forKey: .numberOfLogLinesOccurrences)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamName)
        logStreamName = logStreamNameDecoded
        let logAnomalyTypeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.LogAnomalyType.self, forKey: .logAnomalyType)
        logAnomalyType = logAnomalyTypeDecoded
        let logAnomalyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logAnomalyToken)
        logAnomalyToken = logAnomalyTokenDecoded
        let logEventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logEventId)
        logEventId = logEventIdDecoded
        let explanationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .explanation)
        explanation = explanationDecoded
        let numberOfLogLinesOccurrencesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfLogLinesOccurrences) ?? 0
        numberOfLogLinesOccurrences = numberOfLogLinesOccurrencesDecoded
        let logEventTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .logEventTimestamp)
        logEventTimestamp = logEventTimestampDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomalous log event found within a log group.
    public struct LogAnomalyClass: Swift.Equatable {
        /// The explanation for why the log event is considered an anomaly.
        public var explanation: Swift.String?
        /// The token where the anomaly was detected. This may refer to an exception or another location, or it may be blank for log anomalies such as format anomalies.
        public var logAnomalyToken: Swift.String?
        /// The type of log anomaly that has been detected.
        public var logAnomalyType: DevOpsGuruClientTypes.LogAnomalyType?
        /// The ID of the log event.
        public var logEventId: Swift.String?
        /// The time of the first occurrence of the anomalous log event.
        public var logEventTimestamp: ClientRuntime.Date?
        /// The name of the Amazon CloudWatch log stream that the anomalous log event belongs to. A log stream is a sequence of log events that share the same source.
        public var logStreamName: Swift.String?
        /// The number of log lines where this anomalous log event occurs.
        public var numberOfLogLinesOccurrences: Swift.Int

        public init(
            explanation: Swift.String? = nil,
            logAnomalyToken: Swift.String? = nil,
            logAnomalyType: DevOpsGuruClientTypes.LogAnomalyType? = nil,
            logEventId: Swift.String? = nil,
            logEventTimestamp: ClientRuntime.Date? = nil,
            logStreamName: Swift.String? = nil,
            numberOfLogLinesOccurrences: Swift.Int = 0
        )
        {
            self.explanation = explanation
            self.logAnomalyToken = logAnomalyToken
            self.logAnomalyType = logAnomalyType
            self.logEventId = logEventId
            self.logEventTimestamp = logEventTimestamp
            self.logStreamName = logStreamName
            self.numberOfLogLinesOccurrences = numberOfLogLinesOccurrences
        }
    }

}

extension DevOpsGuruClientTypes.LogAnomalyShowcase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logAnomalyClasses = "LogAnomalyClasses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logAnomalyClasses = logAnomalyClasses {
            var logAnomalyClassesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logAnomalyClasses)
            for loganomalyclass0 in logAnomalyClasses {
                try logAnomalyClassesContainer.encode(loganomalyclass0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logAnomalyClassesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.LogAnomalyClass?].self, forKey: .logAnomalyClasses)
        var logAnomalyClassesDecoded0:[DevOpsGuruClientTypes.LogAnomalyClass]? = nil
        if let logAnomalyClassesContainer = logAnomalyClassesContainer {
            logAnomalyClassesDecoded0 = [DevOpsGuruClientTypes.LogAnomalyClass]()
            for structure0 in logAnomalyClassesContainer {
                if let structure0 = structure0 {
                    logAnomalyClassesDecoded0?.append(structure0)
                }
            }
        }
        logAnomalyClasses = logAnomalyClassesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A cluster of similar anomalous log events found within a log group.
    public struct LogAnomalyShowcase: Swift.Equatable {
        /// A list of anomalous log events that may be related.
        public var logAnomalyClasses: [DevOpsGuruClientTypes.LogAnomalyClass]?

        public init(
            logAnomalyClasses: [DevOpsGuruClientTypes.LogAnomalyClass]? = nil
        )
        {
            self.logAnomalyClasses = logAnomalyClasses
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum LogAnomalyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blockFormat
        case format
        case httpCode
        case keyword
        case keywordToken
        case newFieldName
        case numericalNan
        case numericalPoint
        case sdkUnknown(Swift.String)

        public static var allCases: [LogAnomalyType] {
            return [
                .blockFormat,
                .format,
                .httpCode,
                .keyword,
                .keywordToken,
                .newFieldName,
                .numericalNan,
                .numericalPoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blockFormat: return "BLOCK_FORMAT"
            case .format: return "FORMAT"
            case .httpCode: return "HTTP_CODE"
            case .keyword: return "KEYWORD"
            case .keywordToken: return "KEYWORD_TOKEN"
            case .newFieldName: return "NEW_FIELD_NAME"
            case .numericalNan: return "NUMERICAL_NAN"
            case .numericalPoint: return "NUMERICAL_POINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogAnomalyType(rawValue: rawValue) ?? LogAnomalyType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with CloudWatch log groups for log anomaly detection.
    public struct LogsAnomalyDetectionIntegration: Swift.Equatable {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with CloudWatch log groups for log anomaly detection. You can use this to update the configuration.
    public struct LogsAnomalyDetectionIntegrationConfig: Swift.Equatable {
        /// Specifies if DevOps Guru is configured to perform log anomaly detection on CloudWatch log groups.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes.MonitoredResourceIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdated = "LastUpdated"
        case monitoredResourceName = "MonitoredResourceName"
        case resourceCollection = "ResourceCollection"
        case resourcePermission = "ResourcePermission"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encodeTimestamp(lastUpdated, format: .epochSeconds, forKey: .lastUpdated)
        }
        if let monitoredResourceName = self.monitoredResourceName {
            try encodeContainer.encode(monitoredResourceName, forKey: .monitoredResourceName)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let resourcePermission = self.resourcePermission {
            try encodeContainer.encode(resourcePermission.rawValue, forKey: .resourcePermission)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoredResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoredResourceName)
        monitoredResourceName = monitoredResourceNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let resourcePermissionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourcePermission.self, forKey: .resourcePermission)
        resourcePermission = resourcePermissionDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the resource that is being monitored, including the name of the resource, the type of resource, and whether or not permission is given to DevOps Guru to access that resource.
    public struct MonitoredResourceIdentifier: Swift.Equatable {
        /// The time at which DevOps Guru last updated this resource.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the resource being monitored.
        public var monitoredResourceName: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The permission status of a resource.
        public var resourcePermission: DevOpsGuruClientTypes.ResourcePermission?
        /// The type of resource being monitored.
        public var type: Swift.String?

        public init(
            lastUpdated: ClientRuntime.Date? = nil,
            monitoredResourceName: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            resourcePermission: DevOpsGuruClientTypes.ResourcePermission? = nil,
            type: Swift.String? = nil
        )
        {
            self.lastUpdated = lastUpdated
            self.monitoredResourceName = monitoredResourceName
            self.resourceCollection = resourceCollection
            self.resourcePermission = resourcePermission
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.NotificationChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case config = "Config"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let config = self.config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let configDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.NotificationChannelConfig.self, forKey: .config)
        config = configDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a notification channel. A notification channel is used to notify you when DevOps Guru creates an insight. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS). If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSâ€“encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct NotificationChannel: Swift.Equatable {
        /// A NotificationChannelConfig object that contains information about configured notification channels.
        public var config: DevOpsGuruClientTypes.NotificationChannelConfig?
        /// The ID of a notification channel.
        public var id: Swift.String?

        public init(
            config: DevOpsGuruClientTypes.NotificationChannelConfig? = nil,
            id: Swift.String? = nil
        )
        {
            self.config = config
            self.id = id
        }
    }

}

extension DevOpsGuruClientTypes.NotificationChannelConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sns = "Sns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let sns = self.sns {
            try encodeContainer.encode(sns, forKey: .sns)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SnsChannelConfig.self, forKey: .sns)
        sns = snsDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.NotificationFilterConfig.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about notification channels you have configured with DevOps Guru. The one supported notification channel is Amazon Simple Notification Service (Amazon SNS).
    public struct NotificationChannelConfig: Swift.Equatable {
        /// The filter configurations for the Amazon SNS notification topic you use with DevOps Guru. If you do not provide filter configurations, the default configurations are to receive notifications for all message types of High or Medium severity.
        public var filters: DevOpsGuruClientTypes.NotificationFilterConfig?
        /// Information about a notification channel configured in DevOps Guru to send notifications when insights are created. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSâ€“encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
        /// This member is required.
        public var sns: DevOpsGuruClientTypes.SnsChannelConfig?

        public init(
            filters: DevOpsGuruClientTypes.NotificationFilterConfig? = nil,
            sns: DevOpsGuruClientTypes.SnsChannelConfig? = nil
        )
        {
            self.filters = filters
            self.sns = sns
        }
    }

}

extension DevOpsGuruClientTypes.NotificationFilterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageTypes = "MessageTypes"
        case severities = "Severities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageTypes = messageTypes {
            var messageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messageTypes)
            for notificationmessagetype0 in messageTypes {
                try messageTypesContainer.encode(notificationmessagetype0.rawValue)
            }
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverity0 in severities {
                try severitiesContainer.encode(insightseverity0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[DevOpsGuruClientTypes.InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [DevOpsGuruClientTypes.InsightSeverity]()
            for enum0 in severitiesContainer {
                if let enum0 = enum0 {
                    severitiesDecoded0?.append(enum0)
                }
            }
        }
        severities = severitiesDecoded0
        let messageTypesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.NotificationMessageType?].self, forKey: .messageTypes)
        var messageTypesDecoded0:[DevOpsGuruClientTypes.NotificationMessageType]? = nil
        if let messageTypesContainer = messageTypesContainer {
            messageTypesDecoded0 = [DevOpsGuruClientTypes.NotificationMessageType]()
            for enum0 in messageTypesContainer {
                if let enum0 = enum0 {
                    messageTypesDecoded0?.append(enum0)
                }
            }
        }
        messageTypes = messageTypesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// The filter configurations for the Amazon SNS notification topic you use with DevOps Guru. You can choose to specify which events or message types to receive notifications for. You can also choose to specify which severity levels to receive notifications for.
    public struct NotificationFilterConfig: Swift.Equatable {
        /// The events that you want to receive notifications for. For example, you can choose to receive notifications only when the severity level is upgraded or a new insight is created.
        public var messageTypes: [DevOpsGuruClientTypes.NotificationMessageType]?
        /// The severity levels that you want to receive notifications for. For example, you can choose to receive notifications only for insights with HIGH and MEDIUM severity levels. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities).
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?

        public init(
            messageTypes: [DevOpsGuruClientTypes.NotificationMessageType]? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil
        )
        {
            self.messageTypes = messageTypes
            self.severities = severities
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum NotificationMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closedInsight
        case newAssociation
        case newInsight
        case newRecommendation
        case severityUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationMessageType] {
            return [
                .closedInsight,
                .newAssociation,
                .newInsight,
                .newRecommendation,
                .severityUpgraded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closedInsight: return "CLOSED_INSIGHT"
            case .newAssociation: return "NEW_ASSOCIATION"
            case .newInsight: return "NEW_INSIGHT"
            case .newRecommendation: return "NEW_RECOMMENDATION"
            case .severityUpgraded: return "SEVERITY_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationMessageType(rawValue: rawValue) ?? NotificationMessageType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.OpsCenterIntegration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
    public struct OpsCenterIntegration: Swift.Equatable {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes.OpsCenterIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus.rawValue, forKey: .optInStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optInStatusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OptInStatus.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight. You can use this to update the configuration.
    public struct OpsCenterIntegrationConfig: Swift.Equatable {
        /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
        public var optInStatus: DevOpsGuruClientTypes.OptInStatus?

        public init(
            optInStatus: DevOpsGuruClientTypes.OptInStatus? = nil
        )
        {
            self.optInStatus = optInStatus
        }
    }

}

extension DevOpsGuruClientTypes {
    /// Specifies if DevOps Guru is enabled to create an Amazon Web Services Systems Manager OpsItem for each created insight.
    public enum OptInStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptInStatus(rawValue: rawValue) ?? OptInStatus.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum OrganizationResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case awsCloudFormation
        case awsService
        case awsTags
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceCollectionType] {
            return [
                .awsAccount,
                .awsCloudFormation,
                .awsService,
                .awsTags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case .awsTags: return "AWS_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationResourceCollectionType(rawValue: rawValue) ?? OrganizationResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
        case group = "Group"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for performanceinsightsmetricdimension0 in dimensions {
                try dimensionsContainer.encode(performanceinsightsmetricdimension0)
            }
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Swift.String]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Swift.String]()
            for string0 in dimensionsContainer {
                if let string0 = string0 {
                    dimensionsDecoded0?.append(string0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A logical grouping of Performance Insights metrics for a related subject area. For example, the db.sql dimension group consists of the following dimensions: db.sql.id, db.sql.db_id, db.sql.statement, and db.sql.tokenized_id. Each response element returns a maximum of 500 bytes. For larger elements, such as SQL statements, only the first 500 bytes are returned. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricDimensionGroup: Swift.Equatable {
        /// A list of specific dimensions from a dimension group. If this parameter is not present, then it signifies that all of the dimensions in the group were requested or are present in the response. Valid values for elements in the Dimensions array are:
        ///
        /// * db.application.name - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host.id - The host ID of the connected client (all engines)
        ///
        /// * db.host.name - The host name of the connected client (all engines)
        ///
        /// * db.name - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.session_type.name - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql.id - The SQL ID generated by Performance Insights (all engines)
        ///
        /// * db.sql.db_id - The SQL ID generated by the database (all engines)
        ///
        /// * db.sql.statement - The SQL text that is being executed (all engines)
        ///
        /// * db.sql.tokenized_id
        ///
        /// * db.sql_tokenized.id - The SQL digest ID generated by Performance Insights (all engines)
        ///
        /// * db.sql_tokenized.db_id - SQL digest ID generated by the database (all engines)
        ///
        /// * db.sql_tokenized.statement - The SQL digest text (all engines)
        ///
        /// * db.user.id - The ID of the user logged in to the database (all engines)
        ///
        /// * db.user.name - The name of the user logged in to the database (all engines)
        ///
        /// * db.wait_event.name - The event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event.type - The type of event for which the backend is waiting (all engines)
        ///
        /// * db.wait_event_type.name - The name of the event type for which the backend is waiting (all engines)
        public var dimensions: [Swift.String]?
        /// The name of the dimension group. Its valid values are:
        ///
        /// * db - The name of the database to which the client is connected (only Aurora PostgreSQL, Amazon RDS PostgreSQL, Aurora MySQL, Amazon RDS MySQL, and MariaDB)
        ///
        /// * db.application - The name of the application that is connected to the database (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.host - The host name of the connected client (all engines)
        ///
        /// * db.session_type - The type of the current session (only Aurora PostgreSQL and RDS PostgreSQL)
        ///
        /// * db.sql - The SQL that is currently executing (all engines)
        ///
        /// * db.sql_tokenized - The SQL digest (all engines)
        ///
        /// * db.wait_event - The event for which the database backend is waiting (all engines)
        ///
        /// * db.wait_event_type - The type of event for which the database backend is waiting (all engines)
        ///
        /// * db.user - The user logged in to the database (all engines)
        public var group: Swift.String?
        /// The maximum number of items to fetch for this dimension group.
        public var limit: Swift.Int?

        public init(
            dimensions: [Swift.String]? = nil,
            group: Swift.String? = nil,
            limit: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
            self.group = group
            self.limit = limit
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case groupBy = "GroupBy"
        case metric = "Metric"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, performanceInsightsMetricFilterMap0) in filter {
                try filterContainer.encode(performanceInsightsMetricFilterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:Swift.String]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:Swift.String]()
            for (key0, performanceinsightsmetricfiltervalue0) in filterContainer {
                if let performanceinsightsmetricfiltervalue0 = performanceinsightsmetricfiltervalue0 {
                    filterDecoded0?[key0] = performanceinsightsmetricfiltervalue0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A single query to be processed. Use these parameters to query the Performance Insights GetResourceMetrics API to retrieve the metrics for an anomaly. For more information, see [GetResourceMetrics](https://docs.aws.amazon.com/performance-insights/latest/APIReference/API_GetResourceMetrics.html) in the Amazon RDS Performance Insights API Reference. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricQuery: Swift.Equatable {
        /// One or more filters to apply to a Performance Insights GetResourceMetrics API query. Restrictions:
        ///
        /// * Any number of filters by the same dimension, as specified in the GroupBy parameter.
        ///
        /// * A single filter for any other dimension in this dimension group.
        public var filter: [Swift.String:Swift.String]?
        /// The specification for how to aggregate the data points from a Performance Insights GetResourceMetrics API query. The Performance Insights query returns all of the dimensions within that group, unless you provide the names of specific dimensions within that group. You can also request that Performance Insights return a limited number of values for a dimension.
        public var groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup?
        /// The name of the meteric used used when querying an Performance Insights GetResourceMetrics API for anomaly metrics. Valid values for Metric are:
        ///
        /// * db.load.avg - a scaled representation of the number of active sessions for the database engine.
        ///
        /// * db.sampledload.avg - the raw number of active sessions for the database engine.
        ///
        ///
        /// If the number of active sessions is less than an internal Performance Insights threshold, db.load.avg and db.sampledload.avg are the same value. If the number of active sessions is greater than the internal threshold, Performance Insights samples the active sessions, with db.load.avg showing the scaled values, db.sampledload.avg showing the raw values, and db.sampledload.avg less than db.load.avg. For most use cases, you can query db.load.avg only.
        public var metric: Swift.String?

        public init(
            filter: [Swift.String:Swift.String]? = nil,
            groupBy: DevOpsGuruClientTypes.PerformanceInsightsMetricDimensionGroup? = nil,
            metric: Swift.String? = nil
        )
        {
            self.filter = filter
            self.groupBy = groupBy
            self.metric = metric
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsMetricsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDisplayName = "MetricDisplayName"
        case metricQuery = "MetricQuery"
        case referenceData = "ReferenceData"
        case statsAtAnomaly = "StatsAtAnomaly"
        case statsAtBaseline = "StatsAtBaseline"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDisplayName = self.metricDisplayName {
            try encodeContainer.encode(metricDisplayName, forKey: .metricDisplayName)
        }
        if let metricQuery = self.metricQuery {
            try encodeContainer.encode(metricQuery, forKey: .metricQuery)
        }
        if let referenceData = referenceData {
            var referenceDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceData)
            for performanceinsightsreferencedata0 in referenceData {
                try referenceDataContainer.encode(performanceinsightsreferencedata0)
            }
        }
        if let statsAtAnomaly = statsAtAnomaly {
            var statsAtAnomalyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statsAtAnomaly)
            for performanceinsightsstat0 in statsAtAnomaly {
                try statsAtAnomalyContainer.encode(performanceinsightsstat0)
            }
        }
        if let statsAtBaseline = statsAtBaseline {
            var statsAtBaselineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statsAtBaseline)
            for performanceinsightsstat0 in statsAtBaseline {
                try statsAtBaselineContainer.encode(performanceinsightsstat0)
            }
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricDisplayName)
        metricDisplayName = metricDisplayNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let metricQueryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.self, forKey: .metricQuery)
        metricQuery = metricQueryDecoded
        let referenceDataContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsReferenceData?].self, forKey: .referenceData)
        var referenceDataDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsReferenceData]? = nil
        if let referenceDataContainer = referenceDataContainer {
            referenceDataDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]()
            for structure0 in referenceDataContainer {
                if let structure0 = structure0 {
                    referenceDataDecoded0?.append(structure0)
                }
            }
        }
        referenceData = referenceDataDecoded0
        let statsAtAnomalyContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsStat?].self, forKey: .statsAtAnomaly)
        var statsAtAnomalyDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil
        if let statsAtAnomalyContainer = statsAtAnomalyContainer {
            statsAtAnomalyDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsStat]()
            for structure0 in statsAtAnomalyContainer {
                if let structure0 = structure0 {
                    statsAtAnomalyDecoded0?.append(structure0)
                }
            }
        }
        statsAtAnomaly = statsAtAnomalyDecoded0
        let statsAtBaselineContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.PerformanceInsightsStat?].self, forKey: .statsAtBaseline)
        var statsAtBaselineDecoded0:[DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil
        if let statsAtBaselineContainer = statsAtBaselineContainer {
            statsAtBaselineDecoded0 = [DevOpsGuruClientTypes.PerformanceInsightsStat]()
            for structure0 in statsAtBaselineContainer {
                if let structure0 = structure0 {
                    statsAtBaselineDecoded0?.append(structure0)
                }
            }
        }
        statsAtBaseline = statsAtBaselineDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about Performance Insights metrics. Amazon RDS Performance Insights enables you to monitor and explore different dimensions of database load based on data captured from a running DB instance. DB load is measured as average active sessions. Performance Insights provides the data to API consumers as a two-dimensional time-series dataset. The time dimension provides DB load data for each time point in the queried time range. Each time point decomposes overall load in relation to the requested dimensions, measured at that time point. Examples include SQL, Wait event, User, and Host.
    ///
    /// * To learn more about Performance Insights and Amazon Aurora DB instances, go to the [ Amazon Aurora User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_PerfInsights.html).
    ///
    /// * To learn more about Performance Insights and Amazon RDS DB instances, go to the [ Amazon RDS User Guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html).
    public struct PerformanceInsightsMetricsDetail: Swift.Equatable {
        /// The name used for a specific Performance Insights metric.
        public var metricDisplayName: Swift.String?
        /// A single query to be processed for the metric. For more information, see [PerformanceInsightsMetricQuery](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsMetricQuery.html).
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?
        /// For more information, see [PerformanceInsightsReferenceData](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceData.html).
        public var referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]?
        /// The metric statistics during the anomalous period detected by DevOps Guru;
        public var statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// Typical metric statistics that are not considered anomalous. When DevOps Guru analyzes metrics, it compares them to StatsAtBaseline to help determine if they are anomalous.
        public var statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]?
        /// The unit of measure for a metric. For example, a session or a process.
        public var unit: Swift.String?

        public init(
            metricDisplayName: Swift.String? = nil,
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil,
            referenceData: [DevOpsGuruClientTypes.PerformanceInsightsReferenceData]? = nil,
            statsAtAnomaly: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            statsAtBaseline: [DevOpsGuruClientTypes.PerformanceInsightsStat]? = nil,
            unit: Swift.String? = nil
        )
        {
            self.metricDisplayName = metricDisplayName
            self.metricQuery = metricQuery
            self.referenceData = referenceData
            self.statsAtAnomaly = statsAtAnomaly
            self.statsAtBaseline = statsAtBaseline
            self.unit = unit
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceMetric = "ReferenceMetric"
        case referenceScalar = "ReferenceScalar"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceMetric = self.referenceMetric {
            try encodeContainer.encode(referenceMetric, forKey: .referenceMetric)
        }
        if let referenceScalar = self.referenceScalar {
            try encodeContainer.encode(referenceScalar, forKey: .referenceScalar)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceScalarDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar.self, forKey: .referenceScalar)
        referenceScalar = referenceScalarDecoded
        let referenceMetricDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric.self, forKey: .referenceMetric)
        referenceMetric = referenceMetricDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Reference scalar values and other metrics that DevOps Guru displays on a graph in its console along with the actual metrics it analyzed. Compare these reference values to your actual metrics to help you understand anomalous behavior that DevOps Guru detected.
    public struct PerformanceInsightsReferenceComparisonValues: Swift.Equatable {
        /// A metric that DevOps Guru compares to actual metric values. This reference metric is used to determine if an actual metric should be considered anomalous.
        public var referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric?
        /// A scalar value DevOps Guru for a metric that DevOps Guru compares to actual metric values. This reference value is used to determine if an actual metric value should be considered anomalous.
        public var referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar?

        public init(
            referenceMetric: DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric? = nil,
            referenceScalar: DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar? = nil
        )
        {
            self.referenceMetric = referenceMetric
            self.referenceScalar = referenceScalar
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonValues = "ComparisonValues"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonValues = self.comparisonValues {
            try encodeContainer.encode(comparisonValues, forKey: .comparisonValues)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let comparisonValuesDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues.self, forKey: .comparisonValues)
        comparisonValues = comparisonValuesDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Reference data used to evaluate Performance Insights to determine if its performance is anomalous or not.
    public struct PerformanceInsightsReferenceData: Swift.Equatable {
        /// The specific reference values used to evaluate the Performance Insights. For more information, see [PerformanceInsightsReferenceComparisonValues](https://docs.aws.amazon.com/devops-guru/latest/APIReference/API_PerformanceInsightsReferenceComparisonValues.html).
        public var comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues?
        /// The name of the reference data.
        public var name: Swift.String?

        public init(
            comparisonValues: DevOpsGuruClientTypes.PerformanceInsightsReferenceComparisonValues? = nil,
            name: Swift.String? = nil
        )
        {
            self.comparisonValues = comparisonValues
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricQuery = "MetricQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricQuery = self.metricQuery {
            try encodeContainer.encode(metricQuery, forKey: .metricQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricQueryDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PerformanceInsightsMetricQuery.self, forKey: .metricQuery)
        metricQuery = metricQueryDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reference metric used to evaluate Performance Insights.
    public struct PerformanceInsightsReferenceMetric: Swift.Equatable {
        /// A query to be processed on the metric.
        public var metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery?

        public init(
            metricQuery: DevOpsGuruClientTypes.PerformanceInsightsMetricQuery? = nil
        )
        {
            self.metricQuery = metricQuery
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsReferenceScalar: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A reference value to compare Performance Insights metrics against to determine if the metrics demonstrate anomalous behavior.
    public struct PerformanceInsightsReferenceScalar: Swift.Equatable {
        /// The reference value.
        public var value: Swift.Double?

        public init(
            value: Swift.Double? = nil
        )
        {
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes.PerformanceInsightsStat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A statistic in a Performance Insights collection.
    public struct PerformanceInsightsStat: Swift.Equatable {
        /// The statistic type.
        public var type: Swift.String?
        /// The value of the statistic.
        public var value: Swift.Double?

        public init(
            type: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension DevOpsGuruClientTypes.PredictionTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
    public struct PredictionTimeRange: Swift.Equatable {
        /// The time when the behavior in a proactive insight is expected to end.
        public var endTime: ClientRuntime.Date?
        /// The time range during which a metric limit is expected to be exceeded. This applies to proactive insights only.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case description = "Description"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case sourceMetadata = "SourceMetadata"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = self.anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresource0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresource0)
            }
        }
        if let anomalyTimeRange = self.anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = self.associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = self.sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let sourceMetadata = self.sourceMetadata {
            try encodeContainer.encode(sourceMetadata, forKey: .sourceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limit)
        limit = limitDecoded
        let sourceMetadataDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceMetadata.self, forKey: .sourceMetadata)
        sourceMetadata = sourceMetadataDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly. This object is returned by ListAnomalies.
    public struct ProactiveAnomaly: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// A description of the proactive anomaly.
        public var description: Swift.String?
        /// The ID of a proactive anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The metadata for the anomaly.
        public var sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata?
        /// The status of a proactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: ClientRuntime.Date?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveAnomalySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case description = "Description"
        case id = "Id"
        case limit = "Limit"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case sourceMetadata = "SourceMetadata"
        case status = "Status"
        case updateTime = "UpdateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = self.anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresource0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresource0)
            }
        }
        if let anomalyTimeRange = self.anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = self.associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = self.sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let sourceMetadata = self.sourceMetadata {
            try encodeContainer.encode(sourceMetadata, forKey: .sourceMetadata)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limit)
        limit = limitDecoded
        let sourceMetadataDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceMetadata.self, forKey: .sourceMetadata)
        sourceMetadata = sourceMetadataDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive anomaly. This object is returned by DescribeAnomaly.
    public struct ProactiveAnomalySummary: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// Information about a resource in which DevOps Guru detected anomalous behavior.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// A description of the proactive anomaly.
        public var description: Swift.String?
        /// The ID of the anomaly.
        public var id: Swift.String?
        /// A threshold that was exceeded by behavior in analyzed resources. Exceeding this threshold is related to the anomalous behavior that generated this anomaly.
        public var limit: Swift.Double?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The metadata of the source which detects proactive anomalies.
        public var sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The time of the anomaly's most recent update.
        public var updateTime: ClientRuntime.Date?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            limit: Swift.Double? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            sourceMetadata: DevOpsGuruClientTypes.AnomalySourceMetadata? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.description = description
            self.id = id
            self.limit = limit
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.sourceMetadata = sourceMetadata
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveInsight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = self.ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by ListInsights.
    public struct ProactiveInsight: Swift.Equatable {
        /// Describes the proactive insight.
        public var description: Swift.String?
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceArns = "AssociatedResourceArns"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceArns = associatedResourceArns {
            var associatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceArns)
            for resourcearn0 in associatedResourceArns {
                try associatedResourceArnsContainer.encode(resourcearn0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
        let associatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedResourceArns)
        var associatedResourceArnsDecoded0:[Swift.String]? = nil
        if let associatedResourceArnsContainer = associatedResourceArnsContainer {
            associatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in associatedResourceArnsContainer {
                if let string0 = string0 {
                    associatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        associatedResourceArns = associatedResourceArnsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveInsightSummary: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of the proactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the proactive insight.
        public var name: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of the proactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ProactiveOrganizationInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case organizationalUnitId = "OrganizationalUnitId"
        case predictionTimeRange = "PredictionTimeRange"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationalUnitId = self.organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a proactive insight. This object is returned by DescribeInsight.
    public struct ProactiveOrganizationInsightSummary: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// The time range during which anomalous behavior in a proactive anomaly or an insight is expected to occur.
        public var predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            predictionTimeRange: DevOpsGuruClientTypes.PredictionTimeRange? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.predictionTimeRange = predictionTimeRange
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightFeedback = self.insightFeedback {
            try encodeContainer.encode(insightFeedback, forKey: .insightFeedback)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/feedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The feedback from customers is about the recommendations in this insight.
    public var insightFeedback: DevOpsGuruClientTypes.InsightFeedback?

    public init(
        insightFeedback: DevOpsGuruClientTypes.InsightFeedback? = nil
    )
    {
        self.insightFeedback = insightFeedback
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let insightFeedback: DevOpsGuruClientTypes.InsightFeedback?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightFeedback = "InsightFeedback"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightFeedbackDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightFeedback.self, forKey: .insightFeedback)
        insightFeedback = insightFeedbackDecoded
    }
}

extension PutFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutFeedbackOutput: Swift.Equatable {

    public init() { }
}

enum PutFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.ReactiveAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case causalAnomalyId = "CausalAnomalyId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = self.anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresource0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresource0)
            }
        }
        if let anomalyTimeRange = self.anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = self.associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let causalAnomalyId = self.causalAnomalyId {
            try encodeContainer.encode(causalAnomalyId, forKey: .causalAnomalyId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = self.sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let causalAnomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causalAnomalyId)
        causalAnomalyId = causalAnomalyIdDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by ListAnomalies.
    public struct ReactiveAnomaly: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveAnomalySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyReportedTimeRange = "AnomalyReportedTimeRange"
        case anomalyResources = "AnomalyResources"
        case anomalyTimeRange = "AnomalyTimeRange"
        case associatedInsightId = "AssociatedInsightId"
        case causalAnomalyId = "CausalAnomalyId"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case sourceDetails = "SourceDetails"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyReportedTimeRange = self.anomalyReportedTimeRange {
            try encodeContainer.encode(anomalyReportedTimeRange, forKey: .anomalyReportedTimeRange)
        }
        if let anomalyResources = anomalyResources {
            var anomalyResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .anomalyResources)
            for anomalyresource0 in anomalyResources {
                try anomalyResourcesContainer.encode(anomalyresource0)
            }
        }
        if let anomalyTimeRange = self.anomalyTimeRange {
            try encodeContainer.encode(anomalyTimeRange, forKey: .anomalyTimeRange)
        }
        if let associatedInsightId = self.associatedInsightId {
            try encodeContainer.encode(associatedInsightId, forKey: .associatedInsightId)
        }
        if let causalAnomalyId = self.causalAnomalyId {
            try encodeContainer.encode(causalAnomalyId, forKey: .causalAnomalyId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let sourceDetails = self.sourceDetails {
            try encodeContainer.encode(sourceDetails, forKey: .sourceDetails)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyStatus.self, forKey: .status)
        status = statusDecoded
        let anomalyTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyTimeRange.self, forKey: .anomalyTimeRange)
        anomalyTimeRange = anomalyTimeRangeDecoded
        let anomalyReportedTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyReportedTimeRange.self, forKey: .anomalyReportedTimeRange)
        anomalyReportedTimeRange = anomalyReportedTimeRangeDecoded
        let sourceDetailsDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalySourceDetails.self, forKey: .sourceDetails)
        sourceDetails = sourceDetailsDecoded
        let associatedInsightIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedInsightId)
        associatedInsightId = associatedInsightIdDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.AnomalyType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let causalAnomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causalAnomalyId)
        causalAnomalyId = causalAnomalyIdDecoded
        let anomalyResourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.AnomalyResource?].self, forKey: .anomalyResources)
        var anomalyResourcesDecoded0:[DevOpsGuruClientTypes.AnomalyResource]? = nil
        if let anomalyResourcesContainer = anomalyResourcesContainer {
            anomalyResourcesDecoded0 = [DevOpsGuruClientTypes.AnomalyResource]()
            for structure0 in anomalyResourcesContainer {
                if let structure0 = structure0 {
                    anomalyResourcesDecoded0?.append(structure0)
                }
            }
        }
        anomalyResources = anomalyResourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Details about a reactive anomaly. This object is returned by DescribeAnomaly.
    public struct ReactiveAnomalySummary: Swift.Equatable {
        /// An AnomalyReportedTimeRange object that specifies the time range between when the anomaly is opened and the time when it is closed.
        public var anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange?
        /// The Amazon Web Services resources in which anomalous behavior was detected by DevOps Guru.
        public var anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]?
        /// A time range that specifies when the observed unusual behavior in an anomaly started and ended. This is different from AnomalyReportedTimeRange, which specifies the time range when DevOps Guru opens and then closes an anomaly.
        public var anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange?
        /// The ID of the insight that contains this anomaly. An insight is composed of related anomalies.
        public var associatedInsightId: Swift.String?
        /// The ID of the causal anomaly that is associated with this reactive anomaly. The ID of a `CAUSAL` anomaly is always `NULL`.
        public var causalAnomalyId: Swift.String?
        /// A description of the reactive anomaly.
        public var description: Swift.String?
        /// The ID of the reactive anomaly.
        public var id: Swift.String?
        /// The name of the reactive anomaly.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the anomaly. The severity of anomalies that generate an insight determine that insight's severity. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.AnomalySeverity?
        /// Details about the source of the analyzed operational data that triggered the anomaly. The one supported source is Amazon CloudWatch metrics.
        public var sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails?
        /// The status of the reactive anomaly.
        public var status: DevOpsGuruClientTypes.AnomalyStatus?
        /// The type of the reactive anomaly. It can be one of the following types.
        ///
        /// * CAUSAL - the anomaly can cause a new insight.
        ///
        /// * CONTEXTUAL - the anomaly contains additional information about an insight or its causal anomaly.
        public var type: DevOpsGuruClientTypes.AnomalyType?

        public init(
            anomalyReportedTimeRange: DevOpsGuruClientTypes.AnomalyReportedTimeRange? = nil,
            anomalyResources: [DevOpsGuruClientTypes.AnomalyResource]? = nil,
            anomalyTimeRange: DevOpsGuruClientTypes.AnomalyTimeRange? = nil,
            associatedInsightId: Swift.String? = nil,
            causalAnomalyId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.AnomalySeverity? = nil,
            sourceDetails: DevOpsGuruClientTypes.AnomalySourceDetails? = nil,
            status: DevOpsGuruClientTypes.AnomalyStatus? = nil,
            type: DevOpsGuruClientTypes.AnomalyType? = nil
        )
        {
            self.anomalyReportedTimeRange = anomalyReportedTimeRange
            self.anomalyResources = anomalyResources
            self.anomalyTimeRange = anomalyTimeRange
            self.associatedInsightId = associatedInsightId
            self.causalAnomalyId = causalAnomalyId
            self.description = description
            self.id = id
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.sourceDetails = sourceDetails
            self.status = status
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveInsight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case severity = "Severity"
        case ssmOpsItemId = "SsmOpsItemId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let ssmOpsItemId = self.ssmOpsItemId {
            try encodeContainer.encode(ssmOpsItemId, forKey: .ssmOpsItemId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let ssmOpsItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmOpsItemId)
        ssmOpsItemId = ssmOpsItemIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by ListInsights.
    public struct ReactiveInsight: Swift.Equatable {
        /// Describes the reactive insight.
        public var description: Swift.String?
        /// The ID of a reactive insight.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The ID of the Amazon Web Services System Manager OpsItem created for this insight. You must enable the creation of OpstItems insights before they are created for each insight.
        public var ssmOpsItemId: Swift.String?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            ssmOpsItemId: Swift.String? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.description = description
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.severity = severity
            self.ssmOpsItemId = ssmOpsItemId
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedResourceArns = "AssociatedResourceArns"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedResourceArns = associatedResourceArns {
            var associatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedResourceArns)
            for resourcearn0 in associatedResourceArns {
                try associatedResourceArnsContainer.encode(resourcearn0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
        let associatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedResourceArns)
        var associatedResourceArnsDecoded0:[Swift.String]? = nil
        if let associatedResourceArnsContainer = associatedResourceArnsContainer {
            associatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in associatedResourceArnsContainer {
                if let string0 = string0 {
                    associatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        associatedResourceArns = associatedResourceArnsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveInsightSummary: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the Amazon Web Services resources that generated this insight.
        public var associatedResourceArns: [Swift.String]?
        /// The ID of a reactive summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of a reactive insight.
        public var name: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// The severity of the insight. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// The status of a reactive insight.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            associatedResourceArns: [Swift.String]? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.associatedResourceArns = associatedResourceArns
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.ReactiveOrganizationInsightSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case id = "Id"
        case insightTimeRange = "InsightTimeRange"
        case name = "Name"
        case organizationalUnitId = "OrganizationalUnitId"
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severity = "Severity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insightTimeRange = self.insightTimeRange {
            try encodeContainer.encode(insightTimeRange, forKey: .insightTimeRange)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationalUnitId = self.organizationalUnitId {
            try encodeContainer.encode(organizationalUnitId, forKey: .organizationalUnitId)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationalUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitId)
        organizationalUnitId = organizationalUnitIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightSeverity.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightStatus.self, forKey: .status)
        status = statusDecoded
        let insightTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightTimeRange.self, forKey: .insightTimeRange)
        insightTimeRange = insightTimeRangeDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a reactive insight. This object is returned by DescribeInsight.
    public struct ReactiveOrganizationInsightSummary: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ID of the insight summary.
        public var id: Swift.String?
        /// A time ranged that specifies when the observed behavior in an insight started and ended.
        public var insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange?
        /// The name of the insight summary.
        public var name: Swift.String?
        /// The ID of the organizational unit.
        public var organizationalUnitId: Swift.String?
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights. For more information, see [Understanding insight severities](https://docs.aws.amazon.com/devops-guru/latest/userguide/working-with-insights.html#understanding-insights-severities) in the Amazon DevOps Guru User Guide.
        public var severity: DevOpsGuruClientTypes.InsightSeverity?
        /// An array of status values used to search for insights.
        public var status: DevOpsGuruClientTypes.InsightStatus?

        public init(
            accountId: Swift.String? = nil,
            id: Swift.String? = nil,
            insightTimeRange: DevOpsGuruClientTypes.InsightTimeRange? = nil,
            name: Swift.String? = nil,
            organizationalUnitId: Swift.String? = nil,
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severity: DevOpsGuruClientTypes.InsightSeverity? = nil,
            status: DevOpsGuruClientTypes.InsightStatus? = nil
        )
        {
            self.accountId = accountId
            self.id = id
            self.insightTimeRange = insightTimeRange
            self.name = name
            self.organizationalUnitId = organizationalUnitId
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severity = severity
            self.status = status
        }
    }

}

extension DevOpsGuruClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case description = "Description"
        case link = "Link"
        case name = "Name"
        case reason = "Reason"
        case relatedAnomalies = "RelatedAnomalies"
        case relatedEvents = "RelatedEvents"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let link = self.link {
            try encodeContainer.encode(link, forKey: .link)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let relatedAnomalies = relatedAnomalies {
            var relatedAnomaliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedAnomalies)
            for recommendationrelatedanomaly0 in relatedAnomalies {
                try relatedAnomaliesContainer.encode(recommendationrelatedanomaly0)
            }
        }
        if let relatedEvents = relatedEvents {
            var relatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedEvents)
            for recommendationrelatedevent0 in relatedEvents {
                try relatedEventsContainer.encode(recommendationrelatedevent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let linkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .link)
        link = linkDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let relatedEventsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedEvent?].self, forKey: .relatedEvents)
        var relatedEventsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedEvent]? = nil
        if let relatedEventsContainer = relatedEventsContainer {
            relatedEventsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedEvent]()
            for structure0 in relatedEventsContainer {
                if let structure0 = structure0 {
                    relatedEventsDecoded0?.append(structure0)
                }
            }
        }
        relatedEvents = relatedEventsDecoded0
        let relatedAnomaliesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomaly?].self, forKey: .relatedAnomalies)
        var relatedAnomaliesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomaly]? = nil
        if let relatedAnomaliesContainer = relatedAnomaliesContainer {
            relatedAnomaliesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]()
            for structure0 in relatedAnomaliesContainer {
                if let structure0 = structure0 {
                    relatedAnomaliesDecoded0?.append(structure0)
                }
            }
        }
        relatedAnomalies = relatedAnomaliesDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Recommendation information to help you remediate detected anomalous behavior that generated an insight.
    public struct Recommendation: Swift.Equatable {
        /// The category type of the recommendation.
        public var category: Swift.String?
        /// A description of the problem.
        public var description: Swift.String?
        /// A hyperlink to information to help you address the problem.
        public var link: Swift.String?
        /// The name of the recommendation.
        public var name: Swift.String?
        /// The reason DevOps Guru flagged the anomalous behavior as a problem.
        public var reason: Swift.String?
        /// Anomalies that are related to the problem. Use these Anomalies to learn more about what's happening and to help address the issue.
        public var relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]?
        /// Events that are related to the problem. Use these events to learn more about what's happening and to help address the issue.
        public var relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]?

        public init(
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            link: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil,
            relatedAnomalies: [DevOpsGuruClientTypes.RecommendationRelatedAnomaly]? = nil,
            relatedEvents: [DevOpsGuruClientTypes.RecommendationRelatedEvent]? = nil
        )
        {
            self.category = category
            self.description = description
            self.link = link
            self.name = name
            self.reason = reason
            self.relatedAnomalies = relatedAnomalies
            self.relatedEvents = relatedEvents
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case resources = "Resources"
        case sourceDetails = "SourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyId = self.anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedanomalyresource0 in resources {
                try resourcesContainer.encode(recommendationrelatedanomalyresource0)
            }
        }
        if let sourceDetails = sourceDetails {
            var sourceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDetails)
            for recommendationrelatedanomalysourcedetail0 in sourceDetails {
                try sourceDetailsContainer.encode(recommendationrelatedanomalysourcedetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let sourceDetailsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail?].self, forKey: .sourceDetails)
        var sourceDetailsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]? = nil
        if let sourceDetailsContainer = sourceDetailsContainer {
            sourceDetailsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]()
            for structure0 in sourceDetailsContainer {
                if let structure0 = structure0 {
                    sourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        sourceDetails = sourceDetailsDecoded0
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an anomaly that is related to a recommendation.
    public struct RecommendationRelatedAnomaly: Swift.Equatable {
        /// The ID of an anomaly that generated the insight with this recommendation.
        public var anomalyId: Swift.String?
        /// An array of objects that represent resources in which DevOps Guru detected anomalous behavior. Each object contains the name and type of the resource.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]?
        /// Information about where the anomalous behavior related the recommendation was found. For example, details in Amazon CloudWatch metrics.
        public var sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]?

        public init(
            anomalyId: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource]? = nil,
            sourceDetails: [DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail]? = nil
        )
        {
            self.anomalyId = anomalyId
            self.resources = resources
            self.sourceDetails = sourceDetails
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalyResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a resource in which DevOps Guru detected anomalous behavior.
    public struct RecommendationRelatedAnomalyResource: Swift.Equatable {
        /// The name of the resource.
        public var name: Swift.String?
        /// The type of the resource. Resource types take the same form that is used by Amazon Web Services CloudFormation resource type identifiers, service-provider::service-name::data-type-name. For example, AWS::RDS::DBCluster. For more information, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the Amazon Web Services CloudFormation User Guide.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedAnomalySourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetrics = "CloudWatchMetrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMetrics = cloudWatchMetrics {
            var cloudWatchMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchMetrics)
            for recommendationrelatedcloudwatchmetricssourcedetail0 in cloudWatchMetrics {
                try cloudWatchMetricsContainer.encode(recommendationrelatedcloudwatchmetricssourcedetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail?].self, forKey: .cloudWatchMetrics)
        var cloudWatchMetricsDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        if let cloudWatchMetricsContainer = cloudWatchMetricsContainer {
            cloudWatchMetricsDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]()
            for structure0 in cloudWatchMetricsContainer {
                if let structure0 = structure0 {
                    cloudWatchMetricsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchMetrics = cloudWatchMetricsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains an array of RecommendationRelatedCloudWatchMetricsSourceDetail objects that contain the name and namespace of an Amazon CloudWatch metric.
    public struct RecommendationRelatedAnomalySourceDetail: Swift.Equatable {
        /// An array of CloudWatchMetricsDetail objects that contains information about the analyzed metrics that displayed anomalous behavior.
        public var cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]?

        public init(
            cloudWatchMetrics: [DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail]? = nil
        )
        {
            self.cloudWatchMetrics = cloudWatchMetrics
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedCloudWatchMetricsSourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon CloudWatch metric that is analyzed by DevOps Guru. It is one of many analyzed metrics that are used to generate insights.
    public struct RecommendationRelatedCloudWatchMetricsSourceDetail: Swift.Equatable {
        /// The name of the CloudWatch metric.
        public var metricName: Swift.String?
        /// The namespace of the CloudWatch metric. A namespace is a container for CloudWatch metrics.
        public var namespace: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for recommendationrelatedeventresource0 in resources {
                try resourcesContainer.encode(recommendationrelatedeventresource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.RecommendationRelatedEventResource?].self, forKey: .resources)
        var resourcesDecoded0:[DevOpsGuruClientTypes.RecommendationRelatedEventResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [DevOpsGuruClientTypes.RecommendationRelatedEventResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an event that is related to a recommendation.
    public struct RecommendationRelatedEvent: Swift.Equatable {
        /// The name of the event. This corresponds to the Name field in an Event object.
        public var name: Swift.String?
        /// A ResourceCollection object that contains arrays of the names of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]?

        public init(
            name: Swift.String? = nil,
            resources: [DevOpsGuruClientTypes.RecommendationRelatedEventResource]? = nil
        )
        {
            self.name = name
            self.resources = resources
        }
    }

}

extension DevOpsGuruClientTypes.RecommendationRelatedEventResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about an Amazon Web Services resource that emitted and event that is related to a recommendation in an insight.
    public struct RecommendationRelatedEventResource: Swift.Equatable {
        /// The name of the resource that emitted the event. This corresponds to the Name field in an EventResource object.
        public var name: Swift.String?
        /// The type of the resource that emitted the event. This corresponds to the Type field in an EventResource object.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension RemoveNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/channels/\(id.urlPercentEncoding())"
    }
}

public struct RemoveNotificationChannelInput: Swift.Equatable {
    /// The ID of the notification channel to be removed.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct RemoveNotificationChannelInputBody: Swift.Equatable {
}

extension RemoveNotificationChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveNotificationChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveNotificationChannelOutput: Swift.Equatable {

    public init() { }
}

enum RemoveNotificationChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.ResourceCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = self.cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcollection0 in tags {
                try tagsContainer.encode(tagcollection0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCollection.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCollection?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCollection]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCollection]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct ResourceCollection: Swift.Equatable {
        /// An array of the names of Amazon Web Services CloudFormation stacks. The stacks define Amazon Web Services resources that DevOps Guru analyzes. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection?
        /// The Amazon Web Services tags that are used by resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollection]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollection? = nil,
            tags: [DevOpsGuruClientTypes.TagCollection]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes.ResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = self.cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagcollectionfilter0 in tags {
                try tagsContainer.encode(tagcollectionfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.TagCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.TagCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.TagCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a filter used to specify which Amazon Web Services resources are analyzed for anomalous behavior by DevOps Guru.
    public struct ResourceCollectionFilter: Swift.Equatable {
        /// Information about Amazon Web Services CloudFormation stacks. You can use up to 500 stacks to specify which Amazon Web Services resources in your account to analyze. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
        public var cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter?
        /// The Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.TagCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.CloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.TagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCloudFormation
        case awsService
        case awsTags
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .awsCloudFormation,
                .awsService,
                .awsTags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCloudFormation: return "AWS_CLOUD_FORMATION"
            case .awsService: return "AWS_SERVICE"
            case .awsTags: return "AWS_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A requested resource could not be found
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the Amazon Web Services resource that could not be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the Amazon Web Services resource that could not be found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DevOpsGuruClientTypes {
    public enum ResourcePermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullPermission
        case missingPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourcePermission] {
            return [
                .fullPermission,
                .missingPermission,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullPermission: return "FULL_PERMISSION"
            case .missingPermission: return "MISSING_PERMISSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourcePermission(rawValue: rawValue) ?? ResourcePermission.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum ResourceTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontDistribution
        case dynamodbTable
        case ec2NatGateway
        case ecsCluster
        case ecsService
        case eksCluster
        case elasticacheCacheCluster
        case elasticsearchDomain
        case elasticBeanstalkEnvironment
        case elasticLoadBalancerLoadBalancer
        case elasticLoadBalancingV2LoadBalancer
        case elasticLoadBalancingV2TargetGroup
        case kinesisStream
        case lambdaFunction
        case logGroups
        case openSearchServiceDomain
        case rdsDbCluster
        case rdsDbInstance
        case redshiftCluster
        case route53HealthCheck
        case route53HostedZone
        case s3Bucket
        case sagemakerEndpoint
        case snsTopic
        case sqsQueue
        case stepFunctionsActivity
        case stepFunctionsStateMachine
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeFilter] {
            return [
                .cloudfrontDistribution,
                .dynamodbTable,
                .ec2NatGateway,
                .ecsCluster,
                .ecsService,
                .eksCluster,
                .elasticacheCacheCluster,
                .elasticsearchDomain,
                .elasticBeanstalkEnvironment,
                .elasticLoadBalancerLoadBalancer,
                .elasticLoadBalancingV2LoadBalancer,
                .elasticLoadBalancingV2TargetGroup,
                .kinesisStream,
                .lambdaFunction,
                .logGroups,
                .openSearchServiceDomain,
                .rdsDbCluster,
                .rdsDbInstance,
                .redshiftCluster,
                .route53HealthCheck,
                .route53HostedZone,
                .s3Bucket,
                .sagemakerEndpoint,
                .snsTopic,
                .sqsQueue,
                .stepFunctionsActivity,
                .stepFunctionsStateMachine,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
            case .dynamodbTable: return "DYNAMODB_TABLE"
            case .ec2NatGateway: return "EC2_NAT_GATEWAY"
            case .ecsCluster: return "ECS_CLUSTER"
            case .ecsService: return "ECS_SERVICE"
            case .eksCluster: return "EKS_CLUSTER"
            case .elasticacheCacheCluster: return "ELASTICACHE_CACHE_CLUSTER"
            case .elasticsearchDomain: return "ELASTICSEARCH_DOMAIN"
            case .elasticBeanstalkEnvironment: return "ELASTIC_BEANSTALK_ENVIRONMENT"
            case .elasticLoadBalancerLoadBalancer: return "ELASTIC_LOAD_BALANCER_LOAD_BALANCER"
            case .elasticLoadBalancingV2LoadBalancer: return "ELASTIC_LOAD_BALANCING_V2_LOAD_BALANCER"
            case .elasticLoadBalancingV2TargetGroup: return "ELASTIC_LOAD_BALANCING_V2_TARGET_GROUP"
            case .kinesisStream: return "KINESIS_STREAM"
            case .lambdaFunction: return "LAMBDA_FUNCTION"
            case .logGroups: return "LOG_GROUPS"
            case .openSearchServiceDomain: return "OPEN_SEARCH_SERVICE_DOMAIN"
            case .rdsDbCluster: return "RDS_DB_CLUSTER"
            case .rdsDbInstance: return "RDS_DB_INSTANCE"
            case .redshiftCluster: return "REDSHIFT_CLUSTER"
            case .route53HealthCheck: return "ROUTE53_HEALTH_CHECK"
            case .route53HostedZone: return "ROUTE53_HOSTED_ZONE"
            case .s3Bucket: return "S3_BUCKET"
            case .sagemakerEndpoint: return "SAGEMAKER_ENDPOINT"
            case .snsTopic: return "SNS_TOPIC"
            case .sqsQueue: return "SQS_QUEUE"
            case .stepFunctionsActivity: return "STEP_FUNCTIONS_ACTIVITY"
            case .stepFunctionsStateMachine: return "STEP_FUNCTIONS_STATE_MACHINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceTypeFilter(rawValue: rawValue) ?? ResourceTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.SearchInsightsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severities = "Severities"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverity0 in severities {
                try severitiesContainer.encode(insightseverity0.rawValue)
            }
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for insightstatus0 in statuses {
                try statusesContainer.encode(insightstatus0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[DevOpsGuruClientTypes.InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [DevOpsGuruClientTypes.InsightSeverity]()
            for enum0 in severitiesContainer {
                if let enum0 = enum0 {
                    severitiesDecoded0?.append(enum0)
                }
            }
        }
        severities = severitiesDecoded0
        let statusesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightStatus?].self, forKey: .statuses)
        var statusesDecoded0:[DevOpsGuruClientTypes.InsightStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [DevOpsGuruClientTypes.InsightStatus]()
            for enum0 in statusesContainer {
                if let enum0 = enum0 {
                    statusesDecoded0?.append(enum0)
                }
            }
        }
        statuses = statusesDecoded0
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Specifies values used to filter responses when searching for insights. You can use a ResourceCollection, ServiceCollection, array of severities, and an array of status values. Each filter type contains one or more values to search for. If you specify multiple filter types, the filter types are joined with an AND, and the request returns only results that match all of the specified filters.
    public struct SearchInsightsFilters: Swift.Equatable {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init(
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

extension SearchInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = self.startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SearchInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/search"
    }
}

public struct SearchInsightsInput: Swift.Equatable {
    /// A SearchInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The start of the time range passed in. Returned insights occurred after this time.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init(
        filters: DevOpsGuruClientTypes.SearchInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

struct SearchInsightsInputBody: Swift.Equatable {
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let filters: DevOpsGuruClientTypes.SearchInsightsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let type: DevOpsGuruClientTypes.InsightType?
}

extension SearchInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SearchInsightsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct SearchInsightsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The returned proactive insights.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// The returned reactive insights.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct SearchInsightsOutputBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension SearchInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.SearchOrganizationInsightsFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceCollection = "ResourceCollection"
        case serviceCollection = "ServiceCollection"
        case severities = "Severities"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
        if let serviceCollection = self.serviceCollection {
            try encodeContainer.encode(serviceCollection, forKey: .serviceCollection)
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for insightseverity0 in severities {
                try severitiesContainer.encode(insightseverity0.rawValue)
            }
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for insightstatus0 in statuses {
                try statusesContainer.encode(insightstatus0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severitiesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightSeverity?].self, forKey: .severities)
        var severitiesDecoded0:[DevOpsGuruClientTypes.InsightSeverity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [DevOpsGuruClientTypes.InsightSeverity]()
            for enum0 in severitiesContainer {
                if let enum0 = enum0 {
                    severitiesDecoded0?.append(enum0)
                }
            }
        }
        severities = severitiesDecoded0
        let statusesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.InsightStatus?].self, forKey: .statuses)
        var statusesDecoded0:[DevOpsGuruClientTypes.InsightStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [DevOpsGuruClientTypes.InsightStatus]()
            for enum0 in statusesContainer {
                if let enum0 = enum0 {
                    statusesDecoded0?.append(enum0)
                }
            }
        }
        statuses = statusesDecoded0
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ResourceCollection.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let serviceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceCollection.self, forKey: .serviceCollection)
        serviceCollection = serviceCollectionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Filters you can use to specify which events are returned when ListEvents is called.
    public struct SearchOrganizationInsightsFilters: Swift.Equatable {
        /// A collection of Amazon Web Services resources supported by DevOps Guru. The two types of Amazon Web Services resource collections supported are Amazon Web Services CloudFormation stacks and Amazon Web Services resources that contain the same Amazon Web Services tag. DevOps Guru can be configured to analyze the Amazon Web Services resources that are defined in the stacks or that are tagged using the same tag key. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var resourceCollection: DevOpsGuruClientTypes.ResourceCollection?
        /// A collection of the names of Amazon Web Services services.
        public var serviceCollection: DevOpsGuruClientTypes.ServiceCollection?
        /// An array of severity values used to search for insights.
        public var severities: [DevOpsGuruClientTypes.InsightSeverity]?
        /// An array of status values used to search for insights.
        public var statuses: [DevOpsGuruClientTypes.InsightStatus]?

        public init(
            resourceCollection: DevOpsGuruClientTypes.ResourceCollection? = nil,
            serviceCollection: DevOpsGuruClientTypes.ServiceCollection? = nil,
            severities: [DevOpsGuruClientTypes.InsightSeverity]? = nil,
            statuses: [DevOpsGuruClientTypes.InsightStatus]? = nil
        )
        {
            self.resourceCollection = resourceCollection
            self.serviceCollection = serviceCollection
            self.severities = severities
            self.statuses = statuses
        }
    }

}

extension SearchOrganizationInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTimeRange = self.startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SearchOrganizationInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/insights/search"
    }
}

public struct SearchOrganizationInsightsInput: Swift.Equatable {
    /// The ID of the Amazon Web Services account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// A SearchOrganizationInsightsFilters object that is used to set the severity and status filters on your insight search.
    public var filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// A time range used to specify when the behavior of an insight or anomaly started.
    /// This member is required.
    public var startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    /// The type of insights you are searching for (REACTIVE or PROACTIVE).
    /// This member is required.
    public var type: DevOpsGuruClientTypes.InsightType?

    public init(
        accountIds: [Swift.String]? = nil,
        filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTimeRange: DevOpsGuruClientTypes.StartTimeRange? = nil,
        type: DevOpsGuruClientTypes.InsightType? = nil
    )
    {
        self.accountIds = accountIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTimeRange = startTimeRange
        self.type = type
    }
}

struct SearchOrganizationInsightsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let startTimeRange: DevOpsGuruClientTypes.StartTimeRange?
    let filters: DevOpsGuruClientTypes.SearchOrganizationInsightsFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let type: DevOpsGuruClientTypes.InsightType?
}

extension SearchOrganizationInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTimeRange = "StartTimeRange"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.StartTimeRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.SearchOrganizationInsightsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SearchOrganizationInsightsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchOrganizationInsightsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proactiveInsights = output.proactiveInsights
            self.reactiveInsights = output.reactiveInsights
        } else {
            self.nextToken = nil
            self.proactiveInsights = nil
            self.reactiveInsights = nil
        }
    }
}

public struct SearchOrganizationInsightsOutput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// An integer that specifies the number of open proactive insights in your Amazon Web Services account.
    public var proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    /// An integer that specifies the number of open reactive insights in your Amazon Web Services account.
    public var reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?

    public init(
        nextToken: Swift.String? = nil,
        proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil,
        reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.proactiveInsights = proactiveInsights
        self.reactiveInsights = reactiveInsights
    }
}

struct SearchOrganizationInsightsOutputBody: Swift.Equatable {
    let proactiveInsights: [DevOpsGuruClientTypes.ProactiveInsightSummary]?
    let reactiveInsights: [DevOpsGuruClientTypes.ReactiveInsightSummary]?
    let nextToken: Swift.String?
}

extension SearchOrganizationInsightsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proactiveInsights = "ProactiveInsights"
        case reactiveInsights = "ReactiveInsights"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ProactiveInsightSummary?].self, forKey: .proactiveInsights)
        var proactiveInsightsDecoded0:[DevOpsGuruClientTypes.ProactiveInsightSummary]? = nil
        if let proactiveInsightsContainer = proactiveInsightsContainer {
            proactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ProactiveInsightSummary]()
            for structure0 in proactiveInsightsContainer {
                if let structure0 = structure0 {
                    proactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        proactiveInsights = proactiveInsightsDecoded0
        let reactiveInsightsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ReactiveInsightSummary?].self, forKey: .reactiveInsights)
        var reactiveInsightsDecoded0:[DevOpsGuruClientTypes.ReactiveInsightSummary]? = nil
        if let reactiveInsightsContainer = reactiveInsightsContainer {
            reactiveInsightsDecoded0 = [DevOpsGuruClientTypes.ReactiveInsightSummary]()
            for structure0 in reactiveInsightsContainer {
                if let structure0 = structure0 {
                    reactiveInsightsDecoded0?.append(structure0)
                }
            }
        }
        reactiveInsights = reactiveInsightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchOrganizationInsightsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum ServerSideEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKmsKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionType] {
            return [
                .awsOwnedKmsKey,
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKmsKey: return "AWS_OWNED_KMS_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryptionType(rawValue: rawValue) ?? ServerSideEncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.ServiceCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceNames = "ServiceNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceNames = serviceNames {
            var serviceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceNames)
            for servicename0 in serviceNames {
                try serviceNamesContainer.encode(servicename0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNamesContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ServiceName?].self, forKey: .serviceNames)
        var serviceNamesDecoded0:[DevOpsGuruClientTypes.ServiceName]? = nil
        if let serviceNamesContainer = serviceNamesContainer {
            serviceNamesDecoded0 = [DevOpsGuruClientTypes.ServiceName]()
            for enum0 in serviceNamesContainer {
                if let enum0 = enum0 {
                    serviceNamesDecoded0?.append(enum0)
                }
            }
        }
        serviceNames = serviceNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of the names of Amazon Web Services services.
    public struct ServiceCollection: Swift.Equatable {
        /// An array of strings that each specifies the name of an Amazon Web Services service.
        public var serviceNames: [DevOpsGuruClientTypes.ServiceName]?

        public init(
            serviceNames: [DevOpsGuruClientTypes.ServiceName]? = nil
        )
        {
            self.serviceNames = serviceNames
        }
    }

}

extension DevOpsGuruClientTypes.ServiceHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResourceCount = "AnalyzedResourceCount"
        case insight = "Insight"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzedResourceCount = self.analyzedResourceCount {
            try encodeContainer.encode(analyzedResourceCount, forKey: .analyzedResourceCount)
        }
        if let insight = self.insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ServiceInsightHealth.self, forKey: .insight)
        insight = insightDecoded
        let analyzedResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .analyzedResourceCount)
        analyzedResourceCount = analyzedResourceCountDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Represents the health of an Amazon Web Services service.
    public struct ServiceHealth: Swift.Equatable {
        /// Number of resources that DevOps Guru is monitoring in an analyzed Amazon Web Services service.
        public var analyzedResourceCount: Swift.Int?
        /// Represents the health of an Amazon Web Services service. This is a ServiceInsightHealth that contains the number of open proactive and reactive insights for this service.
        public var insight: DevOpsGuruClientTypes.ServiceInsightHealth?
        /// The name of the Amazon Web Services service.
        public var serviceName: DevOpsGuruClientTypes.ServiceName?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            insight: DevOpsGuruClientTypes.ServiceInsightHealth? = nil,
            serviceName: DevOpsGuruClientTypes.ServiceName? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.insight = insight
            self.serviceName = serviceName
        }
    }

}

extension DevOpsGuruClientTypes.ServiceInsightHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case openProactiveInsights = "OpenProactiveInsights"
        case openReactiveInsights = "OpenReactiveInsights"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if openProactiveInsights != 0 {
            try encodeContainer.encode(openProactiveInsights, forKey: .openProactiveInsights)
        }
        if openReactiveInsights != 0 {
            try encodeContainer.encode(openReactiveInsights, forKey: .openReactiveInsights)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openProactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openProactiveInsights) ?? 0
        openProactiveInsights = openProactiveInsightsDecoded
        let openReactiveInsightsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openReactiveInsights) ?? 0
        openReactiveInsights = openReactiveInsightsDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the number of open proactive and reactive insights in an analyzed Amazon Web Services service.
    public struct ServiceInsightHealth: Swift.Equatable {
        /// The number of open proactive insights in the Amazon Web Services service
        public var openProactiveInsights: Swift.Int
        /// The number of open reactive insights in the Amazon Web Services service
        public var openReactiveInsights: Swift.Int

        public init(
            openProactiveInsights: Swift.Int = 0,
            openReactiveInsights: Swift.Int = 0
        )
        {
            self.openProactiveInsights = openProactiveInsights
            self.openReactiveInsights = openReactiveInsights
        }
    }

}

extension DevOpsGuruClientTypes.ServiceIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsServerSideEncryption = "KMSServerSideEncryption"
        case logsAnomalyDetection = "LogsAnomalyDetection"
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsServerSideEncryption = self.kmsServerSideEncryption {
            try encodeContainer.encode(kmsServerSideEncryption, forKey: .kmsServerSideEncryption)
        }
        if let logsAnomalyDetection = self.logsAnomalyDetection {
            try encodeContainer.encode(logsAnomalyDetection, forKey: .logsAnomalyDetection)
        }
        if let opsCenter = self.opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OpsCenterIntegration.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
        let logsAnomalyDetectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration.self, forKey: .logsAnomalyDetection)
        logsAnomalyDetection = logsAnomalyDetectionDecoded
        let kmsServerSideEncryptionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration.self, forKey: .kmsServerSideEncryption)
        kmsServerSideEncryption = kmsServerSideEncryptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the integration of DevOps Guru with another Amazon Web Services service, such as Amazon Web Services Systems Manager.
    public struct ServiceIntegrationConfig: Swift.Equatable {
        /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        public var kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration?
        /// Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        public var logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration?
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration?

        public init(
            kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegration? = nil,
            logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegration? = nil,
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegration? = nil
        )
        {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiGateway
        case applicationElb
        case autoScalingGroup
        case cloudFront
        case dynamoDb
        case ec2
        case ecs
        case eks
        case elasticBeanstalk
        case elastiCache
        case elb
        case es
        case kinesis
        case lambda
        case natGateway
        case networkElb
        case rds
        case redshift
        case route53
        case s3
        case sageMaker
        case sns
        case sqs
        case stepFunctions
        case swf
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .apiGateway,
                .applicationElb,
                .autoScalingGroup,
                .cloudFront,
                .dynamoDb,
                .ec2,
                .ecs,
                .eks,
                .elasticBeanstalk,
                .elastiCache,
                .elb,
                .es,
                .kinesis,
                .lambda,
                .natGateway,
                .networkElb,
                .rds,
                .redshift,
                .route53,
                .s3,
                .sageMaker,
                .sns,
                .sqs,
                .stepFunctions,
                .swf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiGateway: return "API_GATEWAY"
            case .applicationElb: return "APPLICATION_ELB"
            case .autoScalingGroup: return "AUTO_SCALING_GROUP"
            case .cloudFront: return "CLOUD_FRONT"
            case .dynamoDb: return "DYNAMO_DB"
            case .ec2: return "EC2"
            case .ecs: return "ECS"
            case .eks: return "EKS"
            case .elasticBeanstalk: return "ELASTIC_BEANSTALK"
            case .elastiCache: return "ELASTI_CACHE"
            case .elb: return "ELB"
            case .es: return "ES"
            case .kinesis: return "KINESIS"
            case .lambda: return "LAMBDA"
            case .natGateway: return "NAT_GATEWAY"
            case .networkElb: return "NETWORK_ELB"
            case .rds: return "RDS"
            case .redshift: return "REDSHIFT"
            case .route53: return "ROUTE_53"
            case .s3: return "S3"
            case .sageMaker: return "SAGE_MAKER"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case .stepFunctions: return "STEP_FUNCTIONS"
            case .swf: return "SWF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request contains a value that exceeds a maximum quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes.ServiceResourceCost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cost = "Cost"
        case count = "Count"
        case state = "State"
        case type = "Type"
        case unitCost = "UnitCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cost != 0.0 {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if unitCost != 0.0 {
            try encodeContainer.encode(unitCost, forKey: .unitCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationServiceResourceState.self, forKey: .state)
        state = stateDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let unitCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .unitCost) ?? 0.0
        unitCost = unitCostDecoded
        let costDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cost) ?? 0.0
        cost = costDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// An object that contains information about the estimated monthly cost to analyze an Amazon Web Services resource. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
    public struct ServiceResourceCost: Swift.Equatable {
        /// The total estimated monthly cost to analyze the active resources for this resource.
        public var cost: Swift.Double
        /// The number of active resources analyzed for this service to create a monthly cost estimate.
        public var count: Swift.Int
        /// The state of the resource. The resource is ACTIVE if it produces metrics, events, or logs within an hour, otherwise it is INACTIVE. You pay for the number of active Amazon Web Services resource hours analyzed for each resource. Inactive resources are not charged.
        public var state: DevOpsGuruClientTypes.CostEstimationServiceResourceState?
        /// The type of the Amazon Web Services resource.
        public var type: Swift.String?
        /// The price per hour to analyze the resources in the service. For more information, see [Estimate your Amazon DevOps Guru costs](https://docs.aws.amazon.com/devops-guru/latest/userguide/cost-estimate.html) and [Amazon DevOps Guru pricing](http://aws.amazon.com/devops-guru/pricing/).
        public var unitCost: Swift.Double

        public init(
            cost: Swift.Double = 0.0,
            count: Swift.Int = 0,
            state: DevOpsGuruClientTypes.CostEstimationServiceResourceState? = nil,
            type: Swift.String? = nil,
            unitCost: Swift.Double = 0.0
        )
        {
            self.cost = cost
            self.count = count
            self.state = state
            self.type = type
            self.unitCost = unitCost
        }
    }

}

extension DevOpsGuruClientTypes.SnsChannelConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = self.topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic. If you use an Amazon SNS topic in another account, you must attach a policy to it that grants DevOps Guru permission to send it notifications. DevOps Guru adds the required policy on your behalf to send notifications using Amazon SNS in your account. DevOps Guru only supports standard SNS topics. For more information, see [Permissions for Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-required-permissions.html). If you use an Amazon SNS topic that is encrypted by an Amazon Web Services Key Management Service customer-managed key (CMK), then you must add permissions to the CMK. For more information, see [Permissions for Amazon Web Services KMSâ€“encrypted Amazon SNS topics](https://docs.aws.amazon.com/devops-guru/latest/userguide/sns-kms-permissions.html).
    public struct SnsChannelConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service topic.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension StartCostEstimationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

extension StartCostEstimationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cost-estimation"
    }
}

public struct StartCostEstimationInput: Swift.Equatable {
    /// The idempotency token used to identify each cost estimate request.
    public var clientToken: Swift.String?
    /// The collection of Amazon Web Services resources used to create a monthly DevOps Guru cost estimate.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?

    public init(
        clientToken: Swift.String? = nil,
        resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceCollection = resourceCollection
    }
}

struct StartCostEstimationInputBody: Swift.Equatable {
    let resourceCollection: DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter?
    let clientToken: Swift.String?
}

extension StartCostEstimationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case resourceCollection = "ResourceCollection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.CostEstimationResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartCostEstimationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartCostEstimationOutput: Swift.Equatable {

    public init() { }
}

enum StartCostEstimationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.StartTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromTime = "FromTime"
        case toTime = "ToTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromTime = self.fromTime {
            try encodeContainer.encodeTimestamp(fromTime, format: .epochSeconds, forKey: .fromTime)
        }
        if let toTime = self.toTime {
            try encodeContainer.encodeTimestamp(toTime, format: .epochSeconds, forKey: .toTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromTime)
        fromTime = fromTimeDecoded
        let toTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toTime)
        toTime = toTimeDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A time range used to specify when the behavior of an insight or anomaly started.
    public struct StartTimeRange: Swift.Equatable {
        /// The start time of the time range.
        public var fromTime: ClientRuntime.Date?
        /// The end time of the time range.
        public var toTime: ClientRuntime.Date?

        public init(
            fromTime: ClientRuntime.Date? = nil,
            toTime: ClientRuntime.Date? = nil
        )
        {
            self.fromTime = fromTime
            self.toTime = toTime
        }
    }

}

extension DevOpsGuruClientTypes.TagCollection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = self.appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services tags. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
    ///
    /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
    ///
    /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
    ///
    ///
    /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
    public struct TagCollection: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = self.appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A collection of Amazon Web Services tags used to filter insights. This is used to return insights generated from only resources that contain the tags in the tag collection.
    public struct TagCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagCostEstimationResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = self.appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Information about a collection of Amazon Web Services resources that are identified by an Amazon Web Services tag. This collection of resources is used to create a monthly cost estimate for DevOps Guru to analyze Amazon Web Services resources. The maximum number of tags you can specify for a cost estimate is one. The estimate created is for the cost to analyze the Amazon Web Services resources defined by the tag. For more information, see [Stacks](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacks.html) in the Amazon Web Services CloudFormation User Guide.
    public struct TagCostEstimationResourceCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension DevOpsGuruClientTypes.TagHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResourceCount = "AnalyzedResourceCount"
        case appBoundaryKey = "AppBoundaryKey"
        case insight = "Insight"
        case tagValue = "TagValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzedResourceCount = self.analyzedResourceCount {
            try encodeContainer.encode(analyzedResourceCount, forKey: .analyzedResourceCount)
        }
        if let appBoundaryKey = self.appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let insight = self.insight {
            try encodeContainer.encode(insight, forKey: .insight)
        }
        if let tagValue = self.tagValue {
            try encodeContainer.encode(tagValue, forKey: .tagValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagValue)
        tagValue = tagValueDecoded
        let insightDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.InsightHealth.self, forKey: .insight)
        insight = insightDecoded
        let analyzedResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .analyzedResourceCount)
        analyzedResourceCount = analyzedResourceCountDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about the health of Amazon Web Services resources in your account that are specified by an Amazon Web Services tag key.
    public struct TagHealth: Swift.Equatable {
        /// Number of resources that DevOps Guru is monitoring in your account that are specified by an Amazon Web Services tag.
        public var analyzedResourceCount: Swift.Int?
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var appBoundaryKey: Swift.String?
        /// Information about the health of the Amazon Web Services resources in your account that are specified by an Amazon Web Services tag, including the number of open proactive, open reactive insights, and the Mean Time to Recover (MTTR) of closed insights.
        public var insight: DevOpsGuruClientTypes.InsightHealth?
        /// The value in an Amazon Web Services tag. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        public var tagValue: Swift.String?

        public init(
            analyzedResourceCount: Swift.Int? = nil,
            appBoundaryKey: Swift.String? = nil,
            insight: DevOpsGuruClientTypes.InsightHealth? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.analyzedResourceCount = analyzedResourceCount
            self.appBoundaryKey = appBoundaryKey
            self.insight = insight
            self.tagValue = tagValue
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to a request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code of the quota that was exceeded, causing the throttling exception.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds after which the action that caused the throttling exception can be retried.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code of the service that caused the throttling exception.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension DevOpsGuruClientTypes.TimestampMetricValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricValue = "MetricValue"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricValue)
        metricValue = metricValueDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// A pair that contains metric values at the respective timestamp.
    public struct TimestampMetricValuePair: Swift.Equatable {
        /// Value of the anomalous metric data point at respective Timestamp.
        public var metricValue: Swift.Double?
        /// A Timestamp that specifies the time the event occurred.
        public var timestamp: ClientRuntime.Date?

        public init(
            metricValue: Swift.Double? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.metricValue = metricValue
            self.timestamp = timestamp
        }
    }

}

extension DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackNames = "StackNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackNames = stackNames {
            var stackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackNames)
            for stackname0 in stackNames {
                try stackNamesContainer.encode(stackname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackNames)
        var stackNamesDecoded0:[Swift.String]? = nil
        if let stackNamesContainer = stackNamesContainer {
            stackNamesDecoded0 = [Swift.String]()
            for string0 in stackNamesContainer {
                if let string0 = string0 {
                    stackNamesDecoded0?.append(string0)
                }
            }
        }
        stackNames = stackNamesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains the names of Amazon Web Services CloudFormation stacks used to update a collection of stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
    public struct UpdateCloudFormationCollectionFilter: Swift.Equatable {
        /// An array of the names of the Amazon Web Services CloudFormation stacks to update. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var stackNames: [Swift.String]?

        public init(
            stackNames: [Swift.String]? = nil
        )
        {
            self.stackNames = stackNames
        }
    }

}

extension UpdateEventSourcesConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSources = "EventSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSources = self.eventSources {
            try encodeContainer.encode(eventSources, forKey: .eventSources)
        }
    }
}

extension UpdateEventSourcesConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/event-sources"
    }
}

public struct UpdateEventSourcesConfigInput: Swift.Equatable {
    /// Configuration information about the integration of DevOps Guru as the Consumer via EventBridge with another AWS Service.
    public var eventSources: DevOpsGuruClientTypes.EventSourcesConfig?

    public init(
        eventSources: DevOpsGuruClientTypes.EventSourcesConfig? = nil
    )
    {
        self.eventSources = eventSources
    }
}

struct UpdateEventSourcesConfigInputBody: Swift.Equatable {
    let eventSources: DevOpsGuruClientTypes.EventSourcesConfig?
}

extension UpdateEventSourcesConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSources = "EventSources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.EventSourcesConfig.self, forKey: .eventSources)
        eventSources = eventSourcesDecoded
    }
}

extension UpdateEventSourcesConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEventSourcesConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEventSourcesConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes {
    public enum UpdateResourceCollectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateResourceCollectionAction] {
            return [
                .add,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateResourceCollectionAction(rawValue: rawValue) ?? UpdateResourceCollectionAction.sdkUnknown(rawValue)
        }
    }
}

extension DevOpsGuruClientTypes.UpdateResourceCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFormation = "CloudFormation"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudFormation = self.cloudFormation {
            try encodeContainer.encode(cloudFormation, forKey: .cloudFormation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for updatetagcollectionfilter0 in tags {
                try tagsContainer.encode(updatetagcollectionfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFormationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter.self, forKey: .cloudFormation)
        cloudFormation = cloudFormationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.UpdateTagCollectionFilter?].self, forKey: .tags)
        var tagsDecoded0:[DevOpsGuruClientTypes.UpdateTagCollectionFilter]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DevOpsGuruClientTypes.UpdateTagCollectionFilter]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// Contains information used to update a collection of Amazon Web Services resources.
    public struct UpdateResourceCollectionFilter: Swift.Equatable {
        /// A collection of Amazon Web Services CloudFormation stacks. You can specify up to 500 Amazon Web Services CloudFormation stacks.
        public var cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter?
        /// The updated Amazon Web Services tags used to filter the resources in the resource collection. Tags help you identify and organize your Amazon Web Services resources. Many Amazon Web Services services support tagging, so you can assign the same tag to resources from different services to indicate that the resources are related. For example, you can assign the same tag to an Amazon DynamoDB table resource that you assign to an Lambda function. For more information about using tags, see the [Tagging best practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html) whitepaper. Each Amazon Web Services tag has two parts.
        ///
        /// * A tag key (for example, CostCenter, Environment, Project, or Secret). Tag keys are case-sensitive.
        ///
        /// * An optional field known as a tag value (for example, 111122223333, Production, or a team name). Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive.
        ///
        ///
        /// Together these are known as key-value pairs. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        public var tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]?

        public init(
            cloudFormation: DevOpsGuruClientTypes.UpdateCloudFormationCollectionFilter? = nil,
            tags: [DevOpsGuruClientTypes.UpdateTagCollectionFilter]? = nil
        )
        {
            self.cloudFormation = cloudFormation
            self.tags = tags
        }
    }

}

extension UpdateResourceCollectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let resourceCollection = self.resourceCollection {
            try encodeContainer.encode(resourceCollection, forKey: .resourceCollection)
        }
    }
}

extension UpdateResourceCollectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource-collections"
    }
}

public struct UpdateResourceCollectionInput: Swift.Equatable {
    /// Specifies if the resource collection in the request is added or deleted to the resource collection.
    /// This member is required.
    public var action: DevOpsGuruClientTypes.UpdateResourceCollectionAction?
    /// Contains information used to update a collection of Amazon Web Services resources.
    /// This member is required.
    public var resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?

    public init(
        action: DevOpsGuruClientTypes.UpdateResourceCollectionAction? = nil,
        resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter? = nil
    )
    {
        self.action = action
        self.resourceCollection = resourceCollection
    }
}

struct UpdateResourceCollectionInputBody: Swift.Equatable {
    let action: DevOpsGuruClientTypes.UpdateResourceCollectionAction?
    let resourceCollection: DevOpsGuruClientTypes.UpdateResourceCollectionFilter?
}

extension UpdateResourceCollectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceCollection = "ResourceCollection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateResourceCollectionAction.self, forKey: .action)
        action = actionDecoded
        let resourceCollectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateResourceCollectionFilter.self, forKey: .resourceCollection)
        resourceCollection = resourceCollectionDecoded
    }
}

extension UpdateResourceCollectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceCollectionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceCollectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.UpdateServiceIntegrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsServerSideEncryption = "KMSServerSideEncryption"
        case logsAnomalyDetection = "LogsAnomalyDetection"
        case opsCenter = "OpsCenter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsServerSideEncryption = self.kmsServerSideEncryption {
            try encodeContainer.encode(kmsServerSideEncryption, forKey: .kmsServerSideEncryption)
        }
        if let logsAnomalyDetection = self.logsAnomalyDetection {
            try encodeContainer.encode(logsAnomalyDetection, forKey: .logsAnomalyDetection)
        }
        if let opsCenter = self.opsCenter {
            try encodeContainer.encode(opsCenter, forKey: .opsCenter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opsCenterDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.OpsCenterIntegrationConfig.self, forKey: .opsCenter)
        opsCenter = opsCenterDecoded
        let logsAnomalyDetectionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig.self, forKey: .logsAnomalyDetection)
        logsAnomalyDetection = logsAnomalyDetectionDecoded
        let kmsServerSideEncryptionDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig.self, forKey: .kmsServerSideEncryption)
        kmsServerSideEncryption = kmsServerSideEncryptionDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// Information about updating the integration status of an Amazon Web Services service, such as Amazon Web Services Systems Manager, with DevOps Guru.
    public struct UpdateServiceIntegrationConfig: Swift.Equatable {
        /// Information about whether DevOps Guru is configured to encrypt server-side data using KMS.
        public var kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig?
        /// Information about whether DevOps Guru is configured to perform log anomaly detection on Amazon CloudWatch log groups.
        public var logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig?
        /// Information about whether DevOps Guru is configured to create an OpsItem in Amazon Web Services Systems Manager OpsCenter for each created insight. You can use this to update the configuration.
        public var opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig?

        public init(
            kmsServerSideEncryption: DevOpsGuruClientTypes.KMSServerSideEncryptionIntegrationConfig? = nil,
            logsAnomalyDetection: DevOpsGuruClientTypes.LogsAnomalyDetectionIntegrationConfig? = nil,
            opsCenter: DevOpsGuruClientTypes.OpsCenterIntegrationConfig? = nil
        )
        {
            self.kmsServerSideEncryption = kmsServerSideEncryption
            self.logsAnomalyDetection = logsAnomalyDetection
            self.opsCenter = opsCenter
        }
    }

}

extension UpdateServiceIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceIntegration = self.serviceIntegration {
            try encodeContainer.encode(serviceIntegration, forKey: .serviceIntegration)
        }
    }
}

extension UpdateServiceIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/service-integrations"
    }
}

public struct UpdateServiceIntegrationInput: Swift.Equatable {
    /// An IntegratedServiceConfig object used to specify the integrated service you want to update, and whether you want to update it to enabled or disabled.
    /// This member is required.
    public var serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?

    public init(
        serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig? = nil
    )
    {
        self.serviceIntegration = serviceIntegration
    }
}

struct UpdateServiceIntegrationInputBody: Swift.Equatable {
    let serviceIntegration: DevOpsGuruClientTypes.UpdateServiceIntegrationConfig?
}

extension UpdateServiceIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceIntegration = "ServiceIntegration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIntegrationDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.UpdateServiceIntegrationConfig.self, forKey: .serviceIntegration)
        serviceIntegration = serviceIntegrationDecoded
    }
}

extension UpdateServiceIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateServiceIntegrationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServiceIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DevOpsGuruClientTypes.UpdateTagCollectionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBoundaryKey = "AppBoundaryKey"
        case tagValues = "TagValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBoundaryKey = self.appBoundaryKey {
            try encodeContainer.encode(appBoundaryKey, forKey: .appBoundaryKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBoundaryKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBoundaryKey)
        appBoundaryKey = appBoundaryKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension DevOpsGuruClientTypes {
    /// A new collection of Amazon Web Services resources that are defined by an Amazon Web Services tag or tag key/value pair.
    public struct UpdateTagCollectionFilter: Swift.Equatable {
        /// An Amazon Web Services tag key that is used to identify the Amazon Web Services resources that DevOps Guru analyzes. All Amazon Web Services resources in your account and Region tagged with this key make up your DevOps Guru application and analysis boundary. The string used for a key in a tag that you use to define your resource coverage must begin with the prefix Devops-guru-. The tag key might be DevOps-Guru-deployment-application or devops-guru-rds-application. When you create a key, the case of characters in the key can be whatever you choose. After you create a key, it is case-sensitive. For example, DevOps Guru works with a key named devops-guru-rds and a key named DevOps-Guru-RDS, and these act as two different keys. Possible key/value pairs in your application might be Devops-Guru-production-application/RDS or Devops-Guru-production-application/containers.
        /// This member is required.
        public var appBoundaryKey: Swift.String?
        /// The values in an Amazon Web Services tag collection. The tag's value is an optional field used to associate a string with the tag key (for example, 111122223333, Production, or a team name). The key and value are the tag's key pair. Omitting the tag value is the same as using an empty string. Like tag keys, tag values are case-sensitive. You can specify a maximum of 256 characters for a tag value.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            appBoundaryKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.appBoundaryKey = appBoundaryKey
            self.tagValues = tagValues
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Contains information about data passed in to a field during a request that is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An array of fields that are associated with the validation exception.
        public internal(set) var fields: [DevOpsGuruClientTypes.ValidationExceptionField]? = nil
        /// A message that describes the validation exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the validation exception was thrown.
        public internal(set) var reason: DevOpsGuruClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [DevOpsGuruClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DevOpsGuruClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DevOpsGuruClientTypes.ValidationExceptionReason?
    let fields: [DevOpsGuruClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DevOpsGuruClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([DevOpsGuruClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[DevOpsGuruClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [DevOpsGuruClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension DevOpsGuruClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DevOpsGuruClientTypes {
    /// The field associated with the validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DevOpsGuruClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case invalidParameterCombination
        case other
        case parameterInconsistentWithServiceState
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .invalidParameterCombination,
                .other,
                .parameterInconsistentWithServiceState,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidParameterCombination: return "INVALID_PARAMETER_COMBINATION"
            case .other: return "OTHER"
            case .parameterInconsistentWithServiceState: return "PARAMETER_INCONSISTENT_WITH_SERVICE_STATE"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
