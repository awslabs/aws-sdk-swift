//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct DeleteFleetAdvisorCollectorOutput {

    public init() { }
}

public struct RunFleetAdvisorLsaAnalysisInput {

    public init() { }
}

public struct StartRecommendationsOutput {

    public init() { }
}

/// DMS was denied access to the endpoint. Check that the role is correctly configured.
public struct AccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a quota for an Amazon Web Services account, for example the number of replication instances allowed.
    public struct AccountQuota {
        /// The name of the DMS quota for this Amazon Web Services account.
        public var accountQuotaName: Swift.String?
        /// The maximum allowed value for the quota.
        public var max: Swift.Int
        /// The amount currently used toward the quota maximum.
        public var used: Swift.Int

        public init(
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

/// The resource could not be found.
public struct ResourceNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {
    /// A user-defined key-value pair that describes metadata added to an DMS resource and that is used by operations such as the following:
    ///
    /// * AddTagsToResource
    ///
    /// * ListTagsForResource
    ///
    /// * RemoveTagsFromResource
    public struct Tag {
        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var key: Swift.String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the resource for which the tag is created.
        public var resourceArn: Swift.String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.resourceArn = resourceArn
            self.value = value
        }
    }

}

/// Associates a set of tags with an DMS resource.
public struct AddTagsToResourceInput {
    /// Identifies the DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DMS, you can tag a replication instance, an endpoint, or a replication task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

///
public struct AddTagsToResourceOutput {

    public init() { }
}

///
public struct ApplyPendingMaintenanceActionInput {
    /// The pending maintenance action to apply to this resource. Valid values: os-upgrade, system-update, db-upgrade
    /// This member is required.
    public var applyAction: Swift.String?
    /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:
    ///
    /// * immediate - Apply the maintenance action immediately.
    ///
    /// * next-maintenance - Apply the maintenance action during the next maintenance window for the resource.
    ///
    /// * undo-opt-in - Cancel any existing next-maintenance opt-in requests.
    /// This member is required.
    public var optInType: Swift.String?
    /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.replicationInstanceArn = replicationInstanceArn
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a maintenance action pending for an DMS resource, including when and how it will be applied. This data type is a response element to the DescribePendingMaintenanceActions operation.
    public struct PendingMaintenanceAction {
        /// The type of pending maintenance action that is available for the resource.
        public var action: Swift.String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public var autoAppliedAfterDate: Foundation.Date?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public var currentApplyDate: Foundation.Date?
        /// A description providing more detail about the maintenance action.
        public var description: Swift.String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public var forcedApplyDate: Foundation.Date?
        /// The type of opt-in request that has been received for the resource.
        public var optInStatus: Swift.String?

        public init(
            action: Swift.String? = nil,
            autoAppliedAfterDate: Foundation.Date? = nil,
            currentApplyDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: Foundation.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Identifies an DMS resource and any pending actions for it.
    public struct ResourcePendingMaintenanceActions {
        /// Detailed information about the pending maintenance action.
        public var pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see [ Constructing an Amazon Resource Name (ARN) for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.AWS.ARN.html) in the DMS documentation.
        public var resourceIdentifier: Swift.String?

        public init(
            pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

///
public struct ApplyPendingMaintenanceActionOutput {
    /// The DMS resource that the pending maintenance action will be applied to.
    public var resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?

    public init(
        resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

/// The resource is in a state that prevents it from being used for database migration.
public struct InvalidResourceStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the required target engine settings.
    public struct RecommendationSettings {
        /// The size of your target instance. Fleet Advisor calculates this value based on your data collection type, such as total capacity and resource utilization. Valid values include "total-capacity" and "utilization".
        /// This member is required.
        public var instanceSizingType: Swift.String?
        /// The deployment option for your target engine. For production databases, Fleet Advisor chooses Multi-AZ deployment. For development or test databases, Fleet Advisor chooses Single-AZ deployment. Valid values include "development" and "production".
        /// This member is required.
        public var workloadType: Swift.String?

        public init(
            instanceSizingType: Swift.String? = nil,
            workloadType: Swift.String? = nil
        )
        {
            self.instanceSizingType = instanceSizingType
            self.workloadType = workloadType
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information about the source database to analyze and provide target recommendations according to the specified requirements.
    public struct StartRecommendationsRequestEntry {
        /// The identifier of the source database.
        /// This member is required.
        public var databaseId: Swift.String?
        /// The required target engine settings.
        /// This member is required.
        public var settings: DatabaseMigrationClientTypes.RecommendationSettings?

        public init(
            databaseId: Swift.String? = nil,
            settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil
        )
        {
            self.databaseId = databaseId
            self.settings = settings
        }
    }

}

public struct BatchStartRecommendationsInput {
    /// Provides information about source databases to analyze. After this analysis, Fleet Advisor recommends target engines for each source database.
    public var data: [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]?

    public init(
        data: [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]? = nil
    )
    {
        self.data = data
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the errors that occurred during the analysis of the source database.
    public struct BatchStartRecommendationsErrorEntry {
        /// The code of an error that occurred during the analysis of the source database.
        public var code: Swift.String?
        /// The identifier of the source database.
        public var databaseId: Swift.String?
        /// The information about the error.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.databaseId = databaseId
            self.message = message
        }
    }

}

public struct BatchStartRecommendationsOutput {
    /// A list with error details about the analysis of each source database.
    public var errorEntries: [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]?

    public init(
        errorEntries: [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

///
public struct CancelReplicationTaskAssessmentRunInput {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init(
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

extension DatabaseMigrationClientTypes {
    /// The progress values reported by the AssessmentProgress response element.
    public struct ReplicationTaskAssessmentRunProgress {
        /// The number of individual assessments that have completed, successfully or not.
        public var individualAssessmentCompletedCount: Swift.Int
        /// The number of individual assessments that are specified to run.
        public var individualAssessmentCount: Swift.Int

        public init(
            individualAssessmentCompletedCount: Swift.Int = 0,
            individualAssessmentCount: Swift.Int = 0
        )
        {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a premigration assessment run that you have started using the StartReplicationTaskAssessmentRun operation. Some of the information appears based on other operations that can return the ReplicationTaskAssessmentRun object.
    public struct ReplicationTaskAssessmentRun {
        /// Indication of the completion progress for the individual assessments specified to run.
        public var assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public var assessmentRunName: Swift.String?
        /// Last message generated by an individual assessment failure.
        public var lastFailureMessage: Swift.String?
        /// ARN of the migration task associated with this premigration assessment run.
        public var replicationTaskArn: Swift.String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskAssessmentRunCreationDate: Foundation.Date?
        /// Encryption mode used to encrypt the assessment run results.
        public var resultEncryptionMode: Swift.String?
        /// ARN of the KMS encryption key used to encrypt the assessment run results.
        public var resultKmsKeyArn: Swift.String?
        /// Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationBucket: Swift.String?
        /// Folder in an Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationFolder: Swift.String?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// Assessment run status. This status can have one of the following values:
        ///
        /// * "cancelling" – The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.
        ///
        /// * "deleting" – The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.
        ///
        /// * "failed" – At least one individual assessment completed with a failed status.
        ///
        /// * "error-provisioning" – An internal error occurred while resources were provisioned (during provisioning status).
        ///
        /// * "error-executing" – An internal error occurred while individual assessments ran (during running status).
        ///
        /// * "invalid state" – The assessment run is in an unknown state.
        ///
        /// * "passed" – All individual assessments have completed, and none has a failed status.
        ///
        /// * "provisioning" – Resources required to run individual assessments are being provisioned.
        ///
        /// * "running" – Individual assessments are being run.
        ///
        /// * "starting" – The assessment run is starting, but resources are not yet being provisioned for individual assessments.
        public var status: Swift.String?

        public init(
            assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress? = nil,
            assessmentRunName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskAssessmentRunCreationDate: Foundation.Date? = nil,
            resultEncryptionMode: Swift.String? = nil,
            resultKmsKeyArn: Swift.String? = nil,
            resultLocationBucket: Swift.String? = nil,
            resultLocationFolder: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }
    }

}

///
public struct CancelReplicationTaskAssessmentRunOutput {
    /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

/// The resource you are attempting to create already exists.
public struct ResourceAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var resourceArn: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
    }
}

/// The quota for this resource quota has been exceeded.
public struct ResourceQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceQuotaExceededFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {

    public enum DmsSslModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case require
        case verifyCa
        case verifyFull
        case sdkUnknown(Swift.String)

        public static var allCases: [DmsSslModeValue] {
            return [
                .none,
                .require,
                .verifyCa,
                .verifyFull
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .require: return "require"
            case .verifyCa: return "verify-ca"
            case .verifyFull: return "verify-full"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a DocumentDB data provider.
    public struct DocDbDataProviderSettings {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the DocumentDB data provider.
        public var databaseName: Swift.String?
        /// The port value for the DocumentDB data provider.
        public var port: Swift.Int?
        /// The name of the source DocumentDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the DocumentDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MariaDB data provider.
    public struct MariaDbDataProviderSettings {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The port value for the MariaDB data provider
        public var port: Swift.Int?
        /// The name of the MariaDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MariaDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Microsoft SQL Server data provider.
    public struct MicrosoftSqlServerDataProviderSettings {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the Microsoft SQL Server data provider.
        public var databaseName: Swift.String?
        /// The port value for the Microsoft SQL Server data provider.
        public var port: Swift.Int?
        /// The name of the Microsoft SQL Server server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the Microsoft SQL Server data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum AuthMechanismValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case mongodbCr
        case scramSha1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMechanismValue] {
            return [
                .default,
                .mongodbCr,
                .scramSha1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .mongodbCr: return "mongodb_cr"
            case .scramSha1: return "scram_sha_1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum AuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthTypeValue] {
            return [
                .no,
                .password
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MongoDB data provider.
    public struct MongoDbDataProviderSettings {
        /// The authentication method for connecting to the data provider. Valid values are DEFAULT, MONGODB_CR, or SCRAM_SHA_1.
        public var authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// The MongoDB database name. This setting isn't used when AuthType is set to "no". The default is "admin".
        public var authSource: Swift.String?
        /// The authentication type for the database connection. Valid values are PASSWORD or NO.
        public var authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the MongoDB data provider.
        public var databaseName: Swift.String?
        /// The port value for the MongoDB data provider.
        public var port: Swift.Int?
        /// The name of the MongoDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MongoDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MySQL data provider.
    public struct MySqlDataProviderSettings {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The port value for the MySQL data provider.
        public var port: Swift.Int?
        /// The name of the MySQL server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MySQL data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Oracle data provider.
    public struct OracleDataProviderSettings {
        /// The address of your Oracle Automatic Storage Management (ASM) server. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmServer: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the Oracle data provider.
        public var databaseName: Swift.String?
        /// The port value for the Oracle data provider.
        public var port: Swift.Int?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager that contains the Oracle ASM connection details.
        public var secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// The identifier of the secret in Secrets Manager that contains the Oracle ASM connection details. Required only if your data provider uses the Oracle ASM server.
        public var secretsManagerOracleAsmSecretId: Swift.String?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager that contains the TDE password.
        public var secretsManagerSecurityDbEncryptionAccessRoleArn: Swift.String?
        /// The identifier of the secret in Secrets Manager that contains the transparent data encryption (TDE) password. DMS requires this password to access Oracle redo logs encrypted by TDE using Binary Reader.
        public var secretsManagerSecurityDbEncryptionSecretId: Swift.String?
        /// The name of the Oracle server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the Oracle data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            asmServer: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecurityDbEncryptionAccessRoleArn: Swift.String? = nil,
            secretsManagerSecurityDbEncryptionSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.asmServer = asmServer
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecurityDbEncryptionAccessRoleArn = secretsManagerSecurityDbEncryptionAccessRoleArn
            self.secretsManagerSecurityDbEncryptionSecretId = secretsManagerSecurityDbEncryptionSecretId
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a PostgreSQL data provider.
    public struct PostgreSqlDataProviderSettings {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the PostgreSQL data provider.
        public var databaseName: Swift.String?
        /// The port value for the PostgreSQL data provider.
        public var port: Swift.Int?
        /// The name of the PostgreSQL server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the PostgreSQL data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Redshift data provider.
    public struct RedshiftDataProviderSettings {
        /// The database name on the Amazon Redshift data provider.
        public var databaseName: Swift.String?
        /// The port value for the Amazon Redshift data provider.
        public var port: Swift.Int?
        /// The name of the Amazon Redshift server.
        public var serverName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a data provider.
    public enum DataProviderSettings {
        /// Provides information that defines an Amazon Redshift data provider.
        case redshiftsettings(DatabaseMigrationClientTypes.RedshiftDataProviderSettings)
        /// Provides information that defines a PostgreSQL data provider.
        case postgresqlsettings(DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings)
        /// Provides information that defines a MySQL data provider.
        case mysqlsettings(DatabaseMigrationClientTypes.MySqlDataProviderSettings)
        /// Provides information that defines an Oracle data provider.
        case oraclesettings(DatabaseMigrationClientTypes.OracleDataProviderSettings)
        /// Provides information that defines a Microsoft SQL Server data provider.
        case microsoftsqlserversettings(DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings)
        /// Provides information that defines a DocumentDB data provider.
        case docdbsettings(DatabaseMigrationClientTypes.DocDbDataProviderSettings)
        /// Provides information that defines a MariaDB data provider.
        case mariadbsettings(DatabaseMigrationClientTypes.MariaDbDataProviderSettings)
        /// Provides information that defines a MongoDB data provider.
        case mongodbsettings(DatabaseMigrationClientTypes.MongoDbDataProviderSettings)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateDataProviderInput {
    /// A user-friendly name for the data provider.
    public var dataProviderName: Swift.String?
    /// A user-friendly description of the data provider.
    public var description: Swift.String?
    /// The type of database engine for the data provider. Valid values include "aurora", "aurora-postgresql", "mysql", "oracle", "postgres", "sqlserver", redshift, mariadb, mongodb, and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
    /// This member is required.
    public var engine: Swift.String?
    /// The settings in JSON format for a data provider.
    /// This member is required.
    public var settings: DatabaseMigrationClientTypes.DataProviderSettings?
    /// One or more tags to be assigned to the data provider.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        dataProviderName: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.dataProviderName = dataProviderName
        self.description = description
        self.engine = engine
        self.settings = settings
        self.tags = tags
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a data provider.
    public struct DataProvider {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the data provider.
        public var dataProviderArn: Swift.String?
        /// The time the data provider was created.
        public var dataProviderCreationTime: Foundation.Date?
        /// The name of the data provider.
        public var dataProviderName: Swift.String?
        /// A description of the data provider. Descriptions can have up to 31 characters. A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public var description: Swift.String?
        /// The type of database engine for the data provider. Valid values include "aurora", "aurora-postgresql", "mysql", "oracle", "postgres", "sqlserver", redshift, mariadb, mongodb, and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
        public var engine: Swift.String?
        /// The settings in JSON format for a data provider.
        public var settings: DatabaseMigrationClientTypes.DataProviderSettings?

        public init(
            dataProviderArn: Swift.String? = nil,
            dataProviderCreationTime: Foundation.Date? = nil,
            dataProviderName: Swift.String? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil
        )
        {
            self.dataProviderArn = dataProviderArn
            self.dataProviderCreationTime = dataProviderCreationTime
            self.dataProviderName = dataProviderName
            self.description = description
            self.engine = engine
            self.settings = settings
        }
    }

}

public struct CreateDataProviderOutput {
    /// The data provider that was created.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

/// DMS cannot access the KMS key.
public struct KMSKeyNotAccessibleFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSKeyNotAccessibleFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Insufficient privileges are preventing access to an Amazon S3 object.
public struct S3AccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3AccessDeniedFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {
    /// The settings in JSON format for the DMS Transfer type source endpoint.
    public struct DmsTransferSettings {
        /// The name of the S3 bucket to use.
        public var bucketName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum NestingLevelValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case one
        case sdkUnknown(Swift.String)

        public static var allCases: [NestingLevelValue] {
            return [
                .none,
                .one
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .one: return "one"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a DocumentDB endpoint.
    public struct DocDbSettings {
        /// The database name on the DocumentDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.Int?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.Bool?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the DocumentDB source endpoint.
        public var password: Swift.String?
        /// The port value for the DocumentDB source endpoint.
        public var port: Swift.Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:
        ///
        /// * You must set TargetTablePrepMode to nothing.
        ///
        /// * DMS automatically sets useUpdateLookup to false.
        public var replicateShardCollections: Swift.Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the DocumentDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the DocumentDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the DocumentDB source endpoint.
        public var serverName: Swift.String?
        /// If true, DMS retrieves the entire document from the DocumentDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public var useUpdateLookUp: Swift.Bool?
        /// The user name you use to access the DocumentDB source endpoint.
        public var username: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.Int? = nil,
            extractDocId: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            replicateShardCollections: Swift.Bool? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            useUpdateLookUp: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useUpdateLookUp = useUpdateLookUp
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocDbSettings(databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), replicateShardCollections: \(Swift.String(describing: replicateShardCollections)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), useUpdateLookUp: \(Swift.String(describing: useUpdateLookUp)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides the Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role used to define an Amazon DynamoDB target endpoint.
    public struct DynamoDbSettings {
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an OpenSearch endpoint.
    public struct ElasticsearchSettings {
        /// The endpoint for the OpenSearch cluster. DMS uses HTTPS if a transport protocol (http/https) is not specified.
        /// This member is required.
        public var endpointUri: Swift.String?
        /// The maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster.
        public var errorRetryDuration: Swift.Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. To avoid early failure, this counter is only effective after 1000 records are transferred. OpenSearch also has the concept of error monitoring during the last 10 minutes of an Observation Window. If transfer of all records fail in the last 10 minutes, the full load operation stops.
        public var fullLoadErrorPercentage: Swift.Int?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?
        /// Set this option to true for DMS to migrate documentation using the documentation type _doc. OpenSearch and an Elasticsearch cluster only support the _doc documentation type in versions 7. x and later. The default value is false.
        public var useNewMappingType: Swift.Bool?

        public init(
            endpointUri: Swift.String? = nil,
            errorRetryDuration: Swift.Int? = nil,
            fullLoadErrorPercentage: Swift.Int? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            useNewMappingType: Swift.Bool? = nil
        )
        {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.useNewMappingType = useNewMappingType
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum ReplicationEndpointTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationEndpointTypeValue] {
            return [
                .source,
                .target
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source: return "source"
            case .target: return "target"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum TargetDbType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multipleDatabases
        case specificDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDbType] {
            return [
                .multipleDatabases,
                .specificDatabase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multipleDatabases: return "multiple-databases"
            case .specificDatabase: return "specific-database"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public struct GcpMySQLSettings {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The MySQL host name.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.GcpMySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GcpMySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an IBM Db2 LUW endpoint.
    public struct IBMDb2Settings {
        /// For ongoing replication (CDC), use CurrentLSN to specify a log sequence number (LSN) where you want the replication to start.
        public var currentLsn: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// If true, DMS saves any .csv files to the Db2 LUW target that were used to replicate data. DMS uses these files for analysis and troubleshooting. The default value is false.
        public var keepCsvFiles: Swift.Bool?
        /// The amount of time (in milliseconds) before DMS times out operations performed by DMS on the Db2 target. The default value is 1200 (20 minutes).
        public var loadTimeout: Swift.Int?
        /// Specifies the maximum size (in KB) of .csv files used to transfer data to Db2 LUW.
        public var maxFileSize: Swift.Int?
        /// Maximum number of bytes per read, as a NUMBER value. The default is 64 KB.
        public var maxKBytesPerRead: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default value is 50000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Db2 LUW endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Db2 LUW endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Enables ongoing replication (CDC) as a BOOLEAN value. The default is true.
        public var setDataCaptureChanges: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk on the DMS replication instance. The default value is 1024 (1 MB).
        public var writeBufferSize: Swift.Int?

        public init(
            currentLsn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            keepCsvFiles: Swift.Bool? = nil,
            loadTimeout: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            maxKBytesPerRead: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            setDataCaptureChanges: Swift.Bool? = nil,
            username: Swift.String? = nil,
            writeBufferSize: Swift.Int? = nil
        )
        {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.keepCsvFiles = keepCsvFiles
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
            self.writeBufferSize = writeBufferSize
        }
    }

}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IBMDb2Settings(currentLsn: \(Swift.String(describing: currentLsn)), databaseName: \(Swift.String(describing: databaseName)), keepCsvFiles: \(Swift.String(describing: keepCsvFiles)), loadTimeout: \(Swift.String(describing: loadTimeout)), maxFileSize: \(Swift.String(describing: maxFileSize)), maxKBytesPerRead: \(Swift.String(describing: maxKBytesPerRead)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), setDataCaptureChanges: \(Swift.String(describing: setDataCaptureChanges)), username: \(Swift.String(describing: username)), writeBufferSize: \(Swift.String(describing: writeBufferSize)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {

    public enum MessageFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case jsonUnformatted
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatValue] {
            return [
                .json,
                .jsonUnformatted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .jsonUnformatted: return "json-unformatted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum KafkaSaslMechanism: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plain
        case scramSha512
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSaslMechanism] {
            return [
                .plain,
                .scramSha512
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .scramSha512: return "scram-sha-512"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum KafkaSecurityProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case saslSsl
        case sslAuthentication
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSecurityProtocol] {
            return [
                .plaintext,
                .saslSsl,
                .sslAuthentication,
                .sslEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .saslSsl: return "sasl-ssl"
            case .sslAuthentication: return "ssl-authentication"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum KafkaSslEndpointIdentificationAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case https
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSslEndpointIdentificationAlgorithm] {
            return [
                .https,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .https: return "https"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Apache Kafka endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KafkaSettings {
        /// A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345". For more information and examples of specifying a list of broker locations, see [Using Apache Kafka as a target for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html) in the Database Migration Service User Guide.
        public var broker: Swift.String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kafka message output unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public var messageMaxBytes: Swift.Int?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// For SASL/SSL authentication, DMS supports the SCRAM-SHA-512 mechanism by default. DMS versions 3.5.0 and later also support the PLAIN mechanism. To use the PLAIN mechanism, set this parameter to PLAIN.
        public var saslMechanism: DatabaseMigrationClientTypes.KafkaSaslMechanism?
        /// The secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslPassword: Swift.String?
        /// The secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslUsername: Swift.String?
        /// Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires SaslUsername and SaslPassword.
        public var securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol?
        /// The Amazon Resource Name (ARN) for the private certificate authority (CA) cert that DMS uses to securely connect to your Kafka target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.
        public var sslClientCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyArn: Swift.String?
        /// The password for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyPassword: Swift.String?
        /// Sets hostname verification for the certificate. This setting is supported in DMS version 3.5.1 and later.
        public var sslEndpointIdentificationAlgorithm: DatabaseMigrationClientTypes.KafkaSslEndpointIdentificationAlgorithm?
        /// The topic to which you migrate the data. If you don't specify a topic, DMS specifies "kafka-default-topic" as the migration topic.
        public var topic: Swift.String?

        public init(
            broker: Swift.String? = nil,
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            messageMaxBytes: Swift.Int? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            saslMechanism: DatabaseMigrationClientTypes.KafkaSaslMechanism? = nil,
            saslPassword: Swift.String? = nil,
            saslUsername: Swift.String? = nil,
            securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslClientCertificateArn: Swift.String? = nil,
            sslClientKeyArn: Swift.String? = nil,
            sslClientKeyPassword: Swift.String? = nil,
            sslEndpointIdentificationAlgorithm: DatabaseMigrationClientTypes.KafkaSslEndpointIdentificationAlgorithm? = nil,
            topic: Swift.String? = nil
        )
        {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslMechanism = saslMechanism
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.sslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithm
            self.topic = topic
        }
    }

}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KafkaSettings(broker: \(Swift.String(describing: broker)), includeControlDetails: \(Swift.String(describing: includeControlDetails)), includeNullAndEmpty: \(Swift.String(describing: includeNullAndEmpty)), includePartitionValue: \(Swift.String(describing: includePartitionValue)), includeTableAlterOperations: \(Swift.String(describing: includeTableAlterOperations)), includeTransactionDetails: \(Swift.String(describing: includeTransactionDetails)), messageFormat: \(Swift.String(describing: messageFormat)), messageMaxBytes: \(Swift.String(describing: messageMaxBytes)), noHexPrefix: \(Swift.String(describing: noHexPrefix)), partitionIncludeSchemaTable: \(Swift.String(describing: partitionIncludeSchemaTable)), saslMechanism: \(Swift.String(describing: saslMechanism)), saslUsername: \(Swift.String(describing: saslUsername)), securityProtocol: \(Swift.String(describing: securityProtocol)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslClientCertificateArn: \(Swift.String(describing: sslClientCertificateArn)), sslClientKeyArn: \(Swift.String(describing: sslClientKeyArn)), sslEndpointIdentificationAlgorithm: \(Swift.String(describing: sslEndpointIdentificationAlgorithm)), topic: \(Swift.String(describing: topic)), saslPassword: \"CONTENT_REDACTED\", sslClientKeyPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Amazon Kinesis Data Stream endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KinesisSettings {
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public var streamArn: Swift.String?

        public init(
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum SafeguardPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclusiveAutomaticTruncation
        case relyOnSqlServerReplicationAgent
        case sharedAutomaticTruncation
        case sdkUnknown(Swift.String)

        public static var allCases: [SafeguardPolicy] {
            return [
                .exclusiveAutomaticTruncation,
                .relyOnSqlServerReplicationAgent,
                .sharedAutomaticTruncation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclusiveAutomaticTruncation: return "exclusive-automatic-truncation"
            case .relyOnSqlServerReplicationAgent: return "rely-on-sql-server-replication-agent"
            case .sharedAutomaticTruncation: return "shared-automatic-truncation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum TlogAccessMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backuponly
        case preferbackup
        case prefertlog
        case tlogonly
        case sdkUnknown(Swift.String)

        public static var allCases: [TlogAccessMode] {
            return [
                .backuponly,
                .preferbackup,
                .prefertlog,
                .tlogonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backuponly: return "BackupOnly"
            case .preferbackup: return "PreferBackup"
            case .prefertlog: return "PreferTlog"
            case .tlogonly: return "TlogOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Microsoft SQL Server endpoint.
    public struct MicrosoftSQLServerSettings {
        /// The maximum size of the packets (in bytes) used to transfer data using BCP.
        public var bcpPacketSize: Swift.Int?
        /// Specifies a file group for the DMS internal tables. When the replication task starts, all the internal DMS control tables (awsdms_ apply_exception, awsdms_apply, awsdms_changes) are created for the specified file group.
        public var controlTablesFileGroup: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Forces LOB lookup on inline LOB.
        public var forceLobLookup: Swift.Bool?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. An example is a situation where running an alter DDL statement on a table might result in different information about the table cached in the replication instance.
        public var querySingleAlwaysOnNode: Swift.Bool?
        /// When this attribute is set to Y, DMS only reads changes from transaction log backups and doesn't read from the active transaction log file during ongoing replication. Setting this parameter to Y enables you to control active transaction log file growth during full load and ongoing replication tasks. However, it can add some source latency to ongoing replication.
        public var readBackupOnly: Swift.Bool?
        /// Use this attribute to minimize the need to access the backup log and enable DMS to prevent truncation using one of the following two methods. Start transactions in the database: This is the default method. When this method is used, DMS prevents TLOG truncation by mimicking a transaction in the database. As long as such a transaction is open, changes that appear after the transaction started aren't truncated. If you need Microsoft Replication to be enabled in your database, then you must choose this method. Exclusively use sp_repldone within a single task: When this method is used, DMS reads the changes and then uses sp_repldone to mark the TLOG transactions as ready for truncation. Although this method doesn't involve any transactional activities, it can only be used when Microsoft Replication isn't running. Also, when using this method, only one DMS task can access the database at any given time. Therefore, if you need to run parallel DMS tasks against the same database, use the default method.
        public var safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SQL Server endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SQL Server endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS SQL Server instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field.
        public var serverName: Swift.String?
        /// Indicates the mode used to fetch CDC data.
        public var tlogAccessMode: DatabaseMigrationClientTypes.TlogAccessMode?
        /// Use the TrimSpaceInChar source endpoint setting to right-trim data on CHAR and NCHAR data types during migration. Setting TrimSpaceInChar does not left-trim data. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Use this to attribute to transfer data for full-load operations using BCP. When the target table contains an identity column that does not exist in the source table, you must disable the use BCP for loading table option.
        public var useBcpFullLoad: Swift.Bool?
        /// When this attribute is set to Y, DMS processes third-party transaction log backups if they are created in native format.
        public var useThirdPartyBackupDevice: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            bcpPacketSize: Swift.Int? = nil,
            controlTablesFileGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            forceLobLookup: Swift.Bool? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            querySingleAlwaysOnNode: Swift.Bool? = nil,
            readBackupOnly: Swift.Bool? = nil,
            safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            tlogAccessMode: DatabaseMigrationClientTypes.TlogAccessMode? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useBcpFullLoad: Swift.Bool? = nil,
            useThirdPartyBackupDevice: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.forceLobLookup = forceLobLookup
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.tlogAccessMode = tlogAccessMode
            self.trimSpaceInChar = trimSpaceInChar
            self.useBcpFullLoad = useBcpFullLoad
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MicrosoftSQLServerSettings(bcpPacketSize: \(Swift.String(describing: bcpPacketSize)), controlTablesFileGroup: \(Swift.String(describing: controlTablesFileGroup)), databaseName: \(Swift.String(describing: databaseName)), forceLobLookup: \(Swift.String(describing: forceLobLookup)), port: \(Swift.String(describing: port)), querySingleAlwaysOnNode: \(Swift.String(describing: querySingleAlwaysOnNode)), readBackupOnly: \(Swift.String(describing: readBackupOnly)), safeguardPolicy: \(Swift.String(describing: safeguardPolicy)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), tlogAccessMode: \(Swift.String(describing: tlogAccessMode)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useBcpFullLoad: \(Swift.String(describing: useBcpFullLoad)), useThirdPartyBackupDevice: \(Swift.String(describing: useThirdPartyBackupDevice)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MongoDB endpoint.
    public struct MongoDbSettings {
        /// The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public var authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// The MongoDB database name. This setting isn't used when AuthType is set to "no". The default is "admin".
        public var authSource: Swift.String?
        /// The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty.
        public var authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// The database name on the MongoDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.String?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the MongoDB source endpoint.
        public var password: Swift.String?
        /// The port value for the MongoDB source endpoint.
        public var port: Swift.Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:
        ///
        /// * You must set TargetTablePrepMode to nothing.
        ///
        /// * DMS automatically sets useUpdateLookup to false.
        public var replicateShardCollections: Swift.Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MongoDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MongoDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the MongoDB source endpoint. For MongoDB Atlas, provide the server name for any of the servers in the replication set.
        public var serverName: Swift.String?
        /// If true, DMS retrieves the entire document from the MongoDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public var useUpdateLookUp: Swift.Bool?
        /// The user name you use to access the MongoDB source endpoint.
        public var username: Swift.String?

        public init(
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.String? = nil,
            extractDocId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            replicateShardCollections: Swift.Bool? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            useUpdateLookUp: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useUpdateLookUp = useUpdateLookUp
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MongoDbSettings(authMechanism: \(Swift.String(describing: authMechanism)), authSource: \(Swift.String(describing: authSource)), authType: \(Swift.String(describing: authType)), databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), replicateShardCollections: \(Swift.String(describing: replicateShardCollections)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), useUpdateLookUp: \(Swift.String(describing: useUpdateLookUp)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MySQL endpoint.
    public struct MySQLSettings {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Sets the client statement timeout (in seconds) for a MySQL source endpoint.
        public var executeTimeout: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The host name of the endpoint database. For an Amazon RDS MySQL instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field. For an Aurora MySQL instance, this is the output of [DescribeDBClusters](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html), in the Endpoint field.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. If you specify SPECIFIC_DATABASE, specify the database name using the DatabaseName parameter of the Endpoint object. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            executeTimeout: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.executeTimeout = executeTimeout
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), executeTimeout: \(Swift.String(describing: executeTimeout)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Neptune endpoint.
    public struct NeptuneSettings {
        /// The number of milliseconds for DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public var errorRetryDuration: Swift.Int?
        /// If you want Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public var iamAuthEnabled: Swift.Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, DMS clears the bucket, ready to store the next batch of migrated graph data.
        public var maxFileSize: Swift.Int?
        /// The number of times for DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public var maxRetryCount: Swift.Int?
        /// A folder path where you want DMS to store migrated graph data in the S3 bucket specified by S3BucketName
        /// This member is required.
        public var s3BucketFolder: Swift.String?
        /// The name of the Amazon S3 bucket where DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. DMS maps the SQL source data to graph data before storing it in these .csv files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. The role must allow the iam:PassRole action. For more information, see [Creating an IAM Service Role for Accessing Amazon Neptune as a Target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.ServiceRole) in the Database Migration Service User Guide.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            errorRetryDuration: Swift.Int? = nil,
            iamAuthEnabled: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            maxRetryCount: Swift.Int? = nil,
            s3BucketFolder: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum CharLengthSemantics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byte
        case char
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [CharLengthSemantics] {
            return [
                .byte,
                .char,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byte: return "byte"
            case .char: return "char"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Oracle endpoint.
    public struct OracleSettings {
        /// Set this attribute to false in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to not access redo logs through any specified path prefix replacement using direct file access.
        public var accessAlternateDirectly: Swift.Bool?
        /// Set this attribute to set up table-level supplemental logging for the Oracle database. This attribute enables PRIMARY KEY supplemental logging on all tables selected for a migration task. If you use this option, you still need to enable database-level supplemental logging.
        public var addSupplementalLogging: Swift.Bool?
        /// Set this attribute with ArchivedLogDestId in a primary/ standby setup. This attribute is useful in the case of a switchover. In this case, DMS needs to know which destination to get archive redo logs from to read changes. This need arises because the previous primary instance is now a standby instance after switchover. Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless necessary. For additional information about RESETLOGS, see [RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var additionalArchivedLogDestId: Swift.Int?
        /// Set this attribute to true to enable replication of Oracle tables containing columns that are nested tables or defined types.
        public var allowSelectNestedTables: Swift.Bool?
        /// Specifies the ID of the destination for the archived redo logs. This value should be the same as a number in the dest_id column of the v$archived_log view. If you work with an additional redo log destination, use the AdditionalArchivedLogDestId option to specify the additional destination ID. Doing this improves performance by ensuring that the correct logs are accessed from the outset.
        public var archivedLogDestId: Swift.Int?
        /// When this field is set to Y, DMS only accesses the archived redo logs. If the archived redo logs are stored on Automatic Storage Management (ASM) only, the DMS user account needs to be granted ASM privileges.
        public var archivedLogsOnly: Swift.Bool?
        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password  value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmPassword: Swift.String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmServer: Swift.String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmUser: Swift.String?
        /// Specifies whether the length of a character column is in bytes or in characters. To indicate that the character column length is in characters, set this attribute to CHAR. Otherwise, the character column length is in bytes. Example: charLengthSemantics=CHAR;
        public var charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics?
        /// When true, converts timestamps with the timezone datatype to their UTC value.
        public var convertTimestampWithZoneToUTC: Swift.Bool?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// When set to true, this attribute helps to increase the commit rate on the Oracle target database by writing directly to tables and not writing a trail to database logs.
        public var directPathNoLog: Swift.Bool?
        /// When set to true, this attribute specifies a parallel load when useDirectPathFullLoad is set to Y. This attribute also only applies when you use the DMS parallel load feature. Note that the target table cannot have any constraints or indexes.
        public var directPathParallelLoad: Swift.Bool?
        /// Set this attribute to enable homogenous tablespace replication and create existing tables or indexes under the same tablespace on the target.
        public var enableHomogenousTablespace: Swift.Bool?
        /// Specifies the IDs of one more destinations for one or more archived redo logs. These IDs are the values of the dest_id column in the v$archived_log view. Use this setting with the archivedLogDestId extra connection attribute in a primary-to-single setup or a primary-to-multiple-standby setup. This setting is useful in a switchover when you use an Oracle Data Guard database as a source. In this case, DMS needs information about what destination to get archive redo logs from to read changes. DMS needs this because after the switchover the previous primary is a standby instance. For example, in a primary-to-single standby setup you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2] In a primary-to-multiple-standby setup, you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2,3,4] Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless it's necessary. For more information about RESETLOGS, see [ RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var extraArchivedLogDestIds: [Swift.Int]?
        /// When set to true, this attribute causes a task to fail if the actual size of an LOB column is greater than the specified LobMaxSize. If a task is set to limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// Specifies the number scale. You can select a scale up to 38, or you can select FLOAT. By default, the NUMBER data type is converted to precision 38, scale 10. Example: numberDataTypeScale=12
        public var numberDatatypeScale: Swift.Int?
        /// The timeframe in minutes to check for open transactions for a CDC-only task. You can specify an integer value between 0 (the default) and 240 (the maximum). This parameter is only valid in DMS version 3.5.0 and later. DMS supports a window of up to 9.5 hours including the value for OpenTransactionWindow.
        public var openTransactionWindow: Swift.Int?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the default Oracle root used to access the redo logs.
        public var oraclePathPrefix: Swift.String?
        /// Set this attribute to change the number of threads that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 2 (the default) and 8 (the maximum). Use this attribute together with the readAheadBlocks attribute.
        public var parallelAsmReadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Set this attribute to change the number of read-ahead blocks that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 1000 (the default) and 200,000 (the maximum).
        public var readAheadBlocks: Swift.Int?
        /// When set to true, this attribute supports tablespace replication.
        public var readTableSpaceName: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This setting tells DMS instance to replace the default Oracle root with the specified usePathPrefix setting to access the redo logs.
        public var replacePathPrefix: Swift.Bool?
        /// Specifies the number of seconds that the system waits before resending a query. Example: retryInterval=6;
        public var retryInterval: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Oracle endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the SecretsManagerOracleAsmSecret. This SecretsManagerOracleAsmSecret has the secret value that allows access to the Oracle ASM of the endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerOracleAsmSecretId. Or you can specify clear-text values for AsmUser, AsmPassword, and AsmServerName. You can't specify both. For more information on creating this SecretsManagerOracleAsmSecret and the SecretsManagerOracleAsmAccessRoleArn and SecretsManagerOracleAsmSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN, partial ARN, or friendly name of the SecretsManagerOracleAsmSecret that contains the Oracle ASM connection details for the Oracle endpoint.
        public var secretsManagerOracleAsmSecretId: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Oracle endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password  part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryption: Swift.String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryptionName: Swift.String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS Oracle instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field.
        public var serverName: Swift.String?
        /// Use this attribute to convert SDO_GEOMETRY to GEOJSON format. By default, DMS calls the SDO2GEOJSON custom function if present and accessible. Or you can create your own custom function that mimics the operation of SDOGEOJSON and set SpatialDataOptionToGeoJsonFunctionName to call it instead.
        public var spatialDataOptionToGeoJsonFunctionName: Swift.String?
        /// Use this attribute to specify a time in minutes for the delay in standby sync. If the source is an Oracle Active Data Guard standby database, use this attribute to specify the time lag between primary and standby databases. In DMS, you can create an Oracle CDC task that uses an Active Data Guard standby instance as a source for replicating ongoing changes. Doing this eliminates the need to connect to an active database that might be in production.
        public var standbyDelayTime: Swift.Int?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to use any specified prefix replacement to access all online redo logs.
        public var useAlternateFolderForOnline: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Binary Reader utility. Set UseLogminerReader to N to set this attribute to Y. To use Binary Reader with Amazon RDS for Oracle as the source, you set additional attributes. For more information about using this setting with Oracle Automatic Storage Management (ASM), see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC).
        public var useBFile: Swift.Bool?
        /// Set this attribute to Y to have DMS use a direct path full load. Specify this value to use the direct path protocol in the Oracle Call Interface (OCI). By using this OCI protocol, you can bulk-load Oracle target tables during a full load.
        public var useDirectPathFullLoad: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Oracle LogMiner utility (the default). Set this attribute to N if you want to access the redo logs as a binary file. When you set UseLogminerReader to N, also set UseBfile to Y. For more information on this setting and using Oracle ASM, see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC) in the DMS User Guide.
        public var useLogminerReader: Swift.Bool?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the path prefix used to replace the default Oracle root to access the redo logs.
        public var usePathPrefix: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            accessAlternateDirectly: Swift.Bool? = nil,
            addSupplementalLogging: Swift.Bool? = nil,
            additionalArchivedLogDestId: Swift.Int? = nil,
            allowSelectNestedTables: Swift.Bool? = nil,
            archivedLogDestId: Swift.Int? = nil,
            archivedLogsOnly: Swift.Bool? = nil,
            asmPassword: Swift.String? = nil,
            asmServer: Swift.String? = nil,
            asmUser: Swift.String? = nil,
            charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics? = nil,
            convertTimestampWithZoneToUTC: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            directPathNoLog: Swift.Bool? = nil,
            directPathParallelLoad: Swift.Bool? = nil,
            enableHomogenousTablespace: Swift.Bool? = nil,
            extraArchivedLogDestIds: [Swift.Int]? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            numberDatatypeScale: Swift.Int? = nil,
            openTransactionWindow: Swift.Int? = nil,
            oraclePathPrefix: Swift.String? = nil,
            parallelAsmReadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            readAheadBlocks: Swift.Int? = nil,
            readTableSpaceName: Swift.Bool? = nil,
            replacePathPrefix: Swift.Bool? = nil,
            retryInterval: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            securityDbEncryption: Swift.String? = nil,
            securityDbEncryptionName: Swift.String? = nil,
            serverName: Swift.String? = nil,
            spatialDataOptionToGeoJsonFunctionName: Swift.String? = nil,
            standbyDelayTime: Swift.Int? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useAlternateFolderForOnline: Swift.Bool? = nil,
            useBFile: Swift.Bool? = nil,
            useDirectPathFullLoad: Swift.Bool? = nil,
            useLogminerReader: Swift.Bool? = nil,
            usePathPrefix: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.addSupplementalLogging = addSupplementalLogging
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.charLengthSemantics = charLengthSemantics
            self.convertTimestampWithZoneToUTC = convertTimestampWithZoneToUTC
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.extraArchivedLogDestIds = extraArchivedLogDestIds
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.openTransactionWindow = openTransactionWindow
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.standbyDelayTime = standbyDelayTime
            self.trimSpaceInChar = trimSpaceInChar
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.useBFile = useBFile
            self.useDirectPathFullLoad = useDirectPathFullLoad
            self.useLogminerReader = useLogminerReader
            self.usePathPrefix = usePathPrefix
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OracleSettings(accessAlternateDirectly: \(Swift.String(describing: accessAlternateDirectly)), addSupplementalLogging: \(Swift.String(describing: addSupplementalLogging)), additionalArchivedLogDestId: \(Swift.String(describing: additionalArchivedLogDestId)), allowSelectNestedTables: \(Swift.String(describing: allowSelectNestedTables)), archivedLogDestId: \(Swift.String(describing: archivedLogDestId)), archivedLogsOnly: \(Swift.String(describing: archivedLogsOnly)), asmServer: \(Swift.String(describing: asmServer)), asmUser: \(Swift.String(describing: asmUser)), charLengthSemantics: \(Swift.String(describing: charLengthSemantics)), convertTimestampWithZoneToUTC: \(Swift.String(describing: convertTimestampWithZoneToUTC)), databaseName: \(Swift.String(describing: databaseName)), directPathNoLog: \(Swift.String(describing: directPathNoLog)), directPathParallelLoad: \(Swift.String(describing: directPathParallelLoad)), enableHomogenousTablespace: \(Swift.String(describing: enableHomogenousTablespace)), extraArchivedLogDestIds: \(Swift.String(describing: extraArchivedLogDestIds)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), numberDatatypeScale: \(Swift.String(describing: numberDatatypeScale)), openTransactionWindow: \(Swift.String(describing: openTransactionWindow)), oraclePathPrefix: \(Swift.String(describing: oraclePathPrefix)), parallelAsmReadThreads: \(Swift.String(describing: parallelAsmReadThreads)), port: \(Swift.String(describing: port)), readAheadBlocks: \(Swift.String(describing: readAheadBlocks)), readTableSpaceName: \(Swift.String(describing: readTableSpaceName)), replacePathPrefix: \(Swift.String(describing: replacePathPrefix)), retryInterval: \(Swift.String(describing: retryInterval)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerOracleAsmAccessRoleArn: \(Swift.String(describing: secretsManagerOracleAsmAccessRoleArn)), secretsManagerOracleAsmSecretId: \(Swift.String(describing: secretsManagerOracleAsmSecretId)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), securityDbEncryptionName: \(Swift.String(describing: securityDbEncryptionName)), serverName: \(Swift.String(describing: serverName)), spatialDataOptionToGeoJsonFunctionName: \(Swift.String(describing: spatialDataOptionToGeoJsonFunctionName)), standbyDelayTime: \(Swift.String(describing: standbyDelayTime)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useAlternateFolderForOnline: \(Swift.String(describing: useAlternateFolderForOnline)), useBFile: \(Swift.String(describing: useBFile)), useDirectPathFullLoad: \(Swift.String(describing: useDirectPathFullLoad)), useLogminerReader: \(Swift.String(describing: useLogminerReader)), usePathPrefix: \(Swift.String(describing: usePathPrefix)), username: \(Swift.String(describing: username)), asmPassword: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\", securityDbEncryption: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {

    public enum DatabaseMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case babelfish
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseMode] {
            return [
                .babelfish,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .babelfish: return "babelfish"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum LongVarcharMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clob
        case nclob
        case wstring
        case sdkUnknown(Swift.String)

        public static var allCases: [LongVarcharMappingType] {
            return [
                .clob,
                .nclob,
                .wstring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clob: return "clob"
            case .nclob: return "nclob"
            case .wstring: return "wstring"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum PluginNameValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noPreference
        case pglogical
        case testDecoding
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginNameValue] {
            return [
                .noPreference,
                .pglogical,
                .testDecoding
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "no-preference"
            case .pglogical: return "pglogical"
            case .testDecoding: return "test-decoding"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a PostgreSQL endpoint.
    public struct PostgreSQLSettings {
        /// For use with change data capture (CDC) only, this attribute has DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data. Example: afterConnectScript=SET session_replication_role='replica'
        public var afterConnectScript: Swift.String?
        /// The Babelfish for Aurora PostgreSQL database name for the endpoint.
        public var babelfishDatabaseName: Swift.String?
        /// To capture DDL events, DMS creates various artifacts in the PostgreSQL database when the task starts. You can later remove these artifacts. If this value is set to N, you don't have to create tables or triggers on the source database.
        public var captureDdls: Swift.Bool?
        /// Specifies the default behavior of the replication's handling of PostgreSQL- compatible endpoints that require some additional configuration, such as Babelfish endpoints.
        public var databaseMode: DatabaseMigrationClientTypes.DatabaseMode?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// The schema in which the operational DDL database artifacts are created. Example: ddlArtifactsSchema=xyzddlschema;
        public var ddlArtifactsSchema: Swift.String?
        /// Sets the client statement timeout for the PostgreSQL instance, in seconds. The default value is 60 seconds. Example: executeTimeout=100;
        public var executeTimeout: Swift.Int?
        /// When set to true, this value causes a task to fail if the actual size of a LOB column is greater than the specified LobMaxSize. If task is set to Limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// The write-ahead log (WAL) heartbeat feature mimics a dummy transaction. By doing this, it prevents idle logical replication slots from holding onto old WAL logs, which can result in storage full situations on the source. This heartbeat keeps restart_lsn moving and prevents storage full scenarios.
        public var heartbeatEnable: Swift.Bool?
        /// Sets the WAL heartbeat frequency (in minutes).
        public var heartbeatFrequency: Swift.Int?
        /// Sets the schema in which the heartbeat artifacts are created.
        public var heartbeatSchema: Swift.String?
        /// When true, lets PostgreSQL migrate the boolean type as boolean. By default, PostgreSQL migrates booleans as varchar(5). You must set this setting on both the source and target endpoints for it to take effect.
        public var mapBooleanAsBoolean: Swift.Bool?
        /// When true, DMS migrates JSONB values as CLOB.
        public var mapJsonbAsClob: Swift.Bool?
        /// When true, DMS migrates LONG values as VARCHAR.
        public var mapLongVarcharAs: DatabaseMigrationClientTypes.LongVarcharMappingType?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Specifies the plugin to use to create a replication slot.
        public var pluginName: DatabaseMigrationClientTypes.PluginNameValue?
        /// Endpoint TCP port. The default is 5432.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the PostgreSQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the PostgreSQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The host name of the endpoint database. For an Amazon RDS PostgreSQL instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field. For an Aurora PostgreSQL instance, this is the output of [DescribeDBClusters](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html), in the Endpoint field.
        public var serverName: Swift.String?
        /// Sets the name of a previously created logical replication slot for a change data capture (CDC) load of the PostgreSQL source instance. When used with the CdcStartPosition request parameter for the DMS API , this attribute also makes it possible to use native CDC start points. DMS verifies that the specified logical replication slot exists before starting the CDC load task. It also verifies that the task was created with a valid setting of CdcStartPosition. If the specified slot doesn't exist or the task doesn't have a valid CdcStartPosition setting, DMS raises an error. For more information about setting the CdcStartPosition request parameter, see [Determining a CDC native start point](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Task.CDC.html#CHAP_Task.CDC.StartPoint.Native) in the Database Migration Service User Guide. For more information about using CdcStartPosition, see [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html), [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html), and [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html).
        public var slotName: Swift.String?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            babelfishDatabaseName: Swift.String? = nil,
            captureDdls: Swift.Bool? = nil,
            databaseMode: DatabaseMigrationClientTypes.DatabaseMode? = nil,
            databaseName: Swift.String? = nil,
            ddlArtifactsSchema: Swift.String? = nil,
            executeTimeout: Swift.Int? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            heartbeatEnable: Swift.Bool? = nil,
            heartbeatFrequency: Swift.Int? = nil,
            heartbeatSchema: Swift.String? = nil,
            mapBooleanAsBoolean: Swift.Bool? = nil,
            mapJsonbAsClob: Swift.Bool? = nil,
            mapLongVarcharAs: DatabaseMigrationClientTypes.LongVarcharMappingType? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            pluginName: DatabaseMigrationClientTypes.PluginNameValue? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            slotName: Swift.String? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.babelfishDatabaseName = babelfishDatabaseName
            self.captureDdls = captureDdls
            self.databaseMode = databaseMode
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.heartbeatEnable = heartbeatEnable
            self.heartbeatFrequency = heartbeatFrequency
            self.heartbeatSchema = heartbeatSchema
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.mapJsonbAsClob = mapJsonbAsClob
            self.mapLongVarcharAs = mapLongVarcharAs
            self.maxFileSize = maxFileSize
            self.password = password
            self.pluginName = pluginName
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.trimSpaceInChar = trimSpaceInChar
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostgreSQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), babelfishDatabaseName: \(Swift.String(describing: babelfishDatabaseName)), captureDdls: \(Swift.String(describing: captureDdls)), databaseMode: \(Swift.String(describing: databaseMode)), databaseName: \(Swift.String(describing: databaseName)), ddlArtifactsSchema: \(Swift.String(describing: ddlArtifactsSchema)), executeTimeout: \(Swift.String(describing: executeTimeout)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), heartbeatEnable: \(Swift.String(describing: heartbeatEnable)), heartbeatFrequency: \(Swift.String(describing: heartbeatFrequency)), heartbeatSchema: \(Swift.String(describing: heartbeatSchema)), mapBooleanAsBoolean: \(Swift.String(describing: mapBooleanAsBoolean)), mapJsonbAsClob: \(Swift.String(describing: mapJsonbAsClob)), mapLongVarcharAs: \(Swift.String(describing: mapLongVarcharAs)), maxFileSize: \(Swift.String(describing: maxFileSize)), pluginName: \(Swift.String(describing: pluginName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), slotName: \(Swift.String(describing: slotName)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {

    public enum RedisAuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authRole
        case authToken
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RedisAuthTypeValue] {
            return [
                .authRole,
                .authToken,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authRole: return "auth-role"
            case .authToken: return "auth-token"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum SslSecurityProtocolValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [SslSecurityProtocolValue] {
            return [
                .plaintext,
                .sslEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Redis target endpoint.
    public struct RedisSettings {
        /// The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
        public var authPassword: Swift.String?
        /// The type of authentication to perform when connecting to a Redis target. Options include none, auth-token, and auth-role. The auth-token option requires an AuthPassword value to be provided. The auth-role option requires AuthUserName and AuthPassword values to be provided.
        public var authType: DatabaseMigrationClientTypes.RedisAuthTypeValue?
        /// The user name provided with the auth-role option of the AuthType setting for a Redis target endpoint.
        public var authUserName: Swift.String?
        /// Transmission Control Protocol (TCP) port for the endpoint.
        /// This member is required.
        public var port: Swift.Int
        /// Fully qualified domain name of the endpoint.
        /// This member is required.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The connection to a Redis target endpoint using Transport Layer Security (TLS). Valid values include plaintext and ssl-encryption. The default is ssl-encryption. The ssl-encryption option makes an encrypted connection. Optionally, you can identify an Amazon Resource Name (ARN) for an SSL certificate authority (CA) using the SslCaCertificateArn setting. If an ARN isn't given for a CA, DMS uses the Amazon root CA. The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database.
        public var sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue?

        public init(
            authPassword: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.RedisAuthTypeValue? = nil,
            authUserName: Swift.String? = nil,
            port: Swift.Int = 0,
            serverName: Swift.String? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue? = nil
        )
        {
            self.authPassword = authPassword
            self.authType = authType
            self.authUserName = authUserName
            self.port = port
            self.serverName = serverName
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslSecurityProtocol = sslSecurityProtocol
        }
    }

}

extension DatabaseMigrationClientTypes.RedisSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedisSettings(authType: \(Swift.String(describing: authType)), authUserName: \(Swift.String(describing: authUserName)), port: \(Swift.String(describing: port)), serverName: \(Swift.String(describing: serverName)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslSecurityProtocol: \(Swift.String(describing: sslSecurityProtocol)), authPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {

    public enum EncryptionModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionModeValue] {
            return [
                .sseKms,
                .sseS3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "sse-kms"
            case .sseS3: return "sse-s3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Redshift endpoint.
    public struct RedshiftSettings {
        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field.
        public var acceptAnyDate: Swift.Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public var afterConnectScript: Swift.String?
        /// An S3 folder where the comma-separated-value (.csv) files are stored before being uploaded to the target Redshift cluster. For full load mode, DMS converts source records into .csv files and loads them to the BucketFolder/TableID path. DMS uses the Redshift COPY command to upload the .csv files to the target table. The files are deleted once the COPY operation has finished. For more information, see [COPY](https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html) in the Amazon Redshift Database Developer Guide. For change-data-capture (CDC) mode, DMS creates a NetChanges table, and loads the .csv files to this BucketFolder/NetChangesTableID path.
        public var bucketFolder: Swift.String?
        /// The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.
        public var bucketName: Swift.String?
        /// If Amazon Redshift is configured to support case sensitive schema names, set CaseSensitiveNames to true. The default is false.
        public var caseSensitiveNames: Swift.Bool?
        /// If you set CompUpdate to true Amazon Redshift applies automatic compression if the table is empty. This applies even if the table columns already have encodings other than RAW. If you set CompUpdate to false, automatic compression is disabled and existing column encodings aren't changed. The default is true.
        public var compUpdate: Swift.Bool?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public var connectionTimeout: Swift.Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public var databaseName: Swift.String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string. If your date and time values use formats different from each other, set this to auto.
        public var dateFormat: Swift.String?
        /// A value that specifies whether DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public var emptyAsNull: Swift.Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, create an Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket"
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// This setting is only valid for a full-load migration task. Set ExplicitIds to true to have tables with IDENTITY columns override their auto-generated values with explicit values loaded from the source data files used to populate the tables. The default is false.
        public var explicitIds: Swift.Bool?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10. The number of parallel streams used to upload a single .csv file to an S3 bucket using S3 Multipart Upload. For more information, see [Multipart upload overview](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html). FileTransferUploadStreams accepts a value from 1 through 64. It defaults to 10.
        public var fileTransferUploadStreams: Swift.Int?
        /// The amount of time to wait (in milliseconds) before timing out of operations performed by DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.
        public var loadTimeout: Swift.Int?
        /// When true, lets Redshift migrate the boolean type as boolean. By default, Redshift migrates booleans as varchar(1). You must set this setting on both the source and target endpoints for it to take effect.
        public var mapBooleanAsBoolean: Swift.Bool?
        /// The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer data to Amazon Redshift. It defaults to 1048576KB (1 GB).
        public var maxFileSize: Swift.Int?
        /// The password for the user named in the username property.
        public var password: Swift.String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public var port: Swift.Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public var removeQuotes: Swift.Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public var replaceChars: Swift.String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public var replaceInvalidChars: Swift.String?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Amazon Redshift endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Amazon Redshift endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the Amazon Redshift cluster you are using.
        public var serverName: Swift.String?
        /// The KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string. If your date and time values use formats different from each other, set this parameter to auto.
        public var timeFormat: Swift.String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public var trimBlanks: Swift.Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public var truncateColumns: Swift.Bool?
        /// An Amazon Redshift user name for a registered user.
        public var username: Swift.String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk at the DMS replication instance. The default value is 1000 (buffer size is 1000KB).
        public var writeBufferSize: Swift.Int?

        public init(
            acceptAnyDate: Swift.Bool? = nil,
            afterConnectScript: Swift.String? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            caseSensitiveNames: Swift.Bool? = nil,
            compUpdate: Swift.Bool? = nil,
            connectionTimeout: Swift.Int? = nil,
            databaseName: Swift.String? = nil,
            dateFormat: Swift.String? = nil,
            emptyAsNull: Swift.Bool? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            explicitIds: Swift.Bool? = nil,
            fileTransferUploadStreams: Swift.Int? = nil,
            loadTimeout: Swift.Int? = nil,
            mapBooleanAsBoolean: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            removeQuotes: Swift.Bool? = nil,
            replaceChars: Swift.String? = nil,
            replaceInvalidChars: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timeFormat: Swift.String? = nil,
            trimBlanks: Swift.Bool? = nil,
            truncateColumns: Swift.Bool? = nil,
            username: Swift.String? = nil,
            writeBufferSize: Swift.Int? = nil
        )
        {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }
    }

}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftSettings(acceptAnyDate: \(Swift.String(describing: acceptAnyDate)), afterConnectScript: \(Swift.String(describing: afterConnectScript)), bucketFolder: \(Swift.String(describing: bucketFolder)), bucketName: \(Swift.String(describing: bucketName)), caseSensitiveNames: \(Swift.String(describing: caseSensitiveNames)), compUpdate: \(Swift.String(describing: compUpdate)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), databaseName: \(Swift.String(describing: databaseName)), dateFormat: \(Swift.String(describing: dateFormat)), emptyAsNull: \(Swift.String(describing: emptyAsNull)), encryptionMode: \(Swift.String(describing: encryptionMode)), explicitIds: \(Swift.String(describing: explicitIds)), fileTransferUploadStreams: \(Swift.String(describing: fileTransferUploadStreams)), loadTimeout: \(Swift.String(describing: loadTimeout)), mapBooleanAsBoolean: \(Swift.String(describing: mapBooleanAsBoolean)), maxFileSize: \(Swift.String(describing: maxFileSize)), port: \(Swift.String(describing: port)), removeQuotes: \(Swift.String(describing: removeQuotes)), replaceChars: \(Swift.String(describing: replaceChars)), replaceInvalidChars: \(Swift.String(describing: replaceInvalidChars)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverSideEncryptionKmsKeyId: \(Swift.String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), timeFormat: \(Swift.String(describing: timeFormat)), trimBlanks: \(Swift.String(describing: trimBlanks)), truncateColumns: \(Swift.String(describing: truncateColumns)), username: \(Swift.String(describing: username)), writeBufferSize: \(Swift.String(describing: writeBufferSize)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {

    public enum CannedAclForObjectsValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `none`
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedAclForObjectsValue] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .none,
                .private,
                .publicRead,
                .publicReadWrite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .none: return "none"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum CompressionTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionTypeValue] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum DataFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormatValue] {
            return [
                .csv,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum DatePartitionDelimiterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dash
        case `none`
        case slash
        case underscore
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionDelimiterValue] {
            return [
                .dash,
                .none,
                .slash,
                .underscore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .none: return "NONE"
            case .slash: return "SLASH"
            case .underscore: return "UNDERSCORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum DatePartitionSequenceValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ddmmyyyy
        case mmyyyydd
        case yyyymm
        case yyyymmdd
        case yyyymmddhh
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionSequenceValue] {
            return [
                .ddmmyyyy,
                .mmyyyydd,
                .yyyymm,
                .yyyymmdd,
                .yyyymmddhh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ddmmyyyy: return "DDMMYYYY"
            case .mmyyyydd: return "MMYYYYDD"
            case .yyyymm: return "YYYYMM"
            case .yyyymmdd: return "YYYYMMDD"
            case .yyyymmddhh: return "YYYYMMDDHH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum EncodingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plain
        case plainDictionary
        case rleDictionary
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingTypeValue] {
            return [
                .plain,
                .plainDictionary,
                .rleDictionary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .plainDictionary: return "plain-dictionary"
            case .rleDictionary: return "rle-dictionary"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {

    public enum ParquetVersionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case parquet10
        case parquet20
        case sdkUnknown(Swift.String)

        public static var allCases: [ParquetVersionValue] {
            return [
                .parquet10,
                .parquet20
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .parquet10: return "parquet-1-0"
            case .parquet20: return "parquet-2-0"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Settings for exporting data to Amazon S3.
    public struct S3Settings {
        /// An optional parameter that, when set to true or y, you can use to add column name information to the .csv output file. The default value is false. Valid values are true, false, y, and n.
        public var addColumnName: Swift.Bool?
        /// Use the S3 target endpoint setting AddTrailingPaddingCharacter to add padding on string data. The default value is false.
        public var addTrailingPaddingCharacter: Swift.Bool?
        /// An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/.
        public var bucketFolder: Swift.String?
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// A value that enables DMS to specify a predefined (canned) access control list for objects created in an Amazon S3 bucket as .csv or .parquet files. For more information about Amazon S3 canned ACLs, see [Canned ACL](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the Amazon S3 Developer Guide. The default value is NONE. Valid values include NONE, PRIVATE, PUBLIC_READ, PUBLIC_READ_WRITE, AUTHENTICATED_READ, AWS_EXEC_READ, BUCKET_OWNER_READ, and BUCKET_OWNER_FULL_CONTROL.
        public var cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file. DMS supports the use of the .parquet files in versions 3.4.7 and later. How these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsAndUpdates: Swift.Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsOnly: Swift.Bool?
        /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. When CdcMaxBatchInterval and CdcMinFileSize are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 60 seconds.
        public var cdcMaxBatchInterval: Swift.Int?
        /// Minimum file size, defined in kilobytes, to reach for a file output to Amazon S3. When CdcMinFileSize and CdcMaxBatchInterval are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 32 MB.
        public var cdcMinFileSize: Swift.Int?
        /// Specifies the folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If CdcPath is set, DMS reads CDC files from this path and replicates the data changes to the target endpoint. For an S3 target if you set [PreserveTransactions](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-PreserveTransactions) to true, DMS verifies that you have set this parameter to a folder path on your S3 target where DMS can save the transaction order for the CDC load. DMS creates this CDC folder path in either your S3 target working directory or the S3 target location specified by [BucketFolder](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketFolder) and [BucketName](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketName). For example, if you specify CdcPath as MyChangedData, and you specify BucketName as MyTargetBucket but do not specify BucketFolder, DMS creates the CDC folder path following: MyTargetBucket/MyChangedData. If you specify the same CdcPath, and you specify BucketName as MyTargetBucket and BucketFolder as MyTargetData, DMS creates the CDC folder path following: MyTargetBucket/MyTargetData/MyChangedData. For more information on CDC including transaction order on an S3 target, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var cdcPath: Swift.String?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats.
        public var compressionType: DatabaseMigrationClientTypes.CompressionTypeValue?
        /// The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        public var csvDelimiter: Swift.String?
        /// This setting only applies if your Amazon S3 output files during a change data capture (CDC) load are written in .csv format. If [UseCsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-UseCsvNoSupValue) is set to true, specify a string value that you want DMS to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of the UseCsvNoSupValue setting. This setting is supported in DMS versions 3.4.1 and later.
        public var csvNoSupValue: Swift.String?
        /// An optional parameter that specifies how DMS treats null values. While handling the null value, you can use this parameter to pass a user-defined string as null when writing to the target. For example, when target columns are nullable, you can use this option to differentiate between the empty string value and the null value. So, if you set this parameter value to the empty string ("" or ''), DMS treats the empty string as the null value instead of NULL. The default value is NULL. Valid values include any valid string.
        public var csvNullValue: Swift.String?
        /// The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n).
        public var csvRowDelimiter: Swift.String?
        /// The format of the data that you want to use for output. You can choose one of the following:
        ///
        /// * csv : This is a row-based file format with comma-separated values (.csv).
        ///
        /// * parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.
        public var dataFormat: DatabaseMigrationClientTypes.DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only.
        public var dataPageSize: Swift.Int?
        /// Specifies a date separating delimiter to use during folder partitioning. The default value is SLASH. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue?
        /// When set to true, this parameter partitions S3 bucket folders based on transaction commit dates. The default value is false. For more information about date-based folder partitioning, see [Using date-based folder partitioning](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.DatePartitioning).
        public var datePartitionEnabled: Swift.Bool?
        /// Identifies the sequence of the date format to use during folder partitioning. The default value is YYYYMMDD. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue?
        /// When creating an S3 target endpoint, set DatePartitionTimezone to convert the current UTC time into a specified time zone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The time zone format is Area/Location. Use this parameter when DatePartitionedEnabled is set to true, as shown in the following example. s3-settings='{"DatePartitionEnabled": true, "DatePartitionSequence": "YYYYMMDDHH", "DatePartitionDelimiter": "SLASH", "DatePartitionTimezone":"Asia/Seoul", "BucketName": "dms-nattarat-test"}'
        public var datePartitionTimezone: Swift.String?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only.
        public var dictPageSizeLimit: Swift.Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public var enableStatistics: Swift.Bool?
        /// The type of encoding you are using:
        ///
        /// * RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.
        ///
        /// * PLAIN doesn't use encoding at all. Values are stored as they are.
        ///
        /// * PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.
        public var encodingType: DatabaseMigrationClientTypes.EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, you need an Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:
        ///
        /// * s3:CreateBucket
        ///
        /// * s3:ListBucket
        ///
        /// * s3:DeleteBucket
        ///
        /// * s3:GetBucketLocation
        ///
        /// * s3:GetObject
        ///
        /// * s3:PutObject
        ///
        /// * s3:DeleteObject
        ///
        /// * s3:GetObjectVersion
        ///
        /// * s3:GetBucketPolicy
        ///
        /// * s3:PutBucketPolicy
        ///
        /// * s3:DeleteBucketPolicy
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// To specify a bucket owner and prevent sniping, you can use the ExpectedBucketOwner endpoint setting. Example: --s3-settings='{"ExpectedBucketOwner": "AWS_Account_ID"}' When you make a request to test a connection or perform a migration, S3 checks the account ID of the bucket owner against the specified parameter.
        public var expectedBucketOwner: Swift.String?
        /// Specifies how tables are defined in the S3 source files only.
        public var externalTableDefinition: Swift.String?
        /// When true, allows Glue to catalog your S3 bucket. Creating an Glue catalog lets you use Athena to query your data.
        public var glueCatalogGeneration: Swift.Bool?
        /// When this value is set to 1, DMS ignores the first row header in a .csv file. A value of 1 turns on the feature; a value of 0 turns off the feature. The default is 0.
        public var ignoreHeaderRows: Swift.Int?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) or .parquet output files only to indicate how the rows were added to the source database. DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later. DMS supports the use of the .parquet files with the IncludeOpForFullLoad parameter in versions 3.4.7 and later. For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load. This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide..
        public var includeOpForFullLoad: Swift.Bool?
        /// A value that specifies the maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. The default value is 1,048,576 KB (1 GB). Valid values include 1 to 1,048,576.
        public var maxFileSize: Swift.Int?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format. DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later. When ParquetTimestampInMillisecond is set to true or y, DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or Glue. DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter.
        public var parquetTimestampInMillisecond: Swift.Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public var parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue?
        /// If set to true, DMS saves the transaction order for a change data capture (CDC) load on the Amazon S3 target specified by [CdcPath](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CdcPath). For more information, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var preserveTransactions: Swift.Bool?
        /// For an S3 source, when this value is set to true or y, each leading double quotation mark has to be followed by an ending double quotation mark. This formatting complies with RFC 4180. When this value is set to false or n, string literals are copied to the target as is. In this case, a delimiter (row or column) signals the end of the field. Thus, you can't use a delimiter as part of the string, because it signals the end of the value. For an S3 target, an optional parameter used to set behavior to comply with RFC 4180 for data migrated to Amazon S3 using .csv file format only. When this value is set to true or y using Amazon S3 as a target, if the data has quotation marks or newline characters in it, DMS encloses the entire column with an additional pair of double quotation marks ("). Every quotation mark within the data is repeated twice. The default value is true. Valid values include true, false, y, and n.
        public var rfc4180: Swift.Bool?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only. If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024).
        public var rowGroupLength: Swift.Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the KMS key ID. The key that you use needs an attached policy that enables Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action. It is a required parameter that enables DMS to write and read objects from an S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// A value that when nonblank causes DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target. DMS supports the TimestampColumnName parameter in versions 3.1.4 and later. DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS. For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public var timestampColumnName: Swift.String?
        /// This setting applies if the S3 output files during a change data capture (CDC) load are written in .csv format. If set to true for columns not included in the supplemental log, DMS uses the value specified by [CsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CsvNoSupValue). If not set or set to false, DMS uses the null value for these columns. This setting is supported in DMS versions 3.4.1 and later.
        public var useCsvNoSupValue: Swift.Bool?
        /// When set to true, this parameter uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when useTaskStartTimeForFullLoadTimestamp is set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When useTaskStartTimeForFullLoadTimestamp is set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target.
        public var useTaskStartTimeForFullLoadTimestamp: Swift.Bool?

        public init(
            addColumnName: Swift.Bool? = nil,
            addTrailingPaddingCharacter: Swift.Bool? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue? = nil,
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            cdcInsertsOnly: Swift.Bool? = nil,
            cdcMaxBatchInterval: Swift.Int? = nil,
            cdcMinFileSize: Swift.Int? = nil,
            cdcPath: Swift.String? = nil,
            compressionType: DatabaseMigrationClientTypes.CompressionTypeValue? = nil,
            csvDelimiter: Swift.String? = nil,
            csvNoSupValue: Swift.String? = nil,
            csvNullValue: Swift.String? = nil,
            csvRowDelimiter: Swift.String? = nil,
            dataFormat: DatabaseMigrationClientTypes.DataFormatValue? = nil,
            dataPageSize: Swift.Int? = nil,
            datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue? = nil,
            datePartitionEnabled: Swift.Bool? = nil,
            datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue? = nil,
            datePartitionTimezone: Swift.String? = nil,
            dictPageSizeLimit: Swift.Int? = nil,
            enableStatistics: Swift.Bool? = nil,
            encodingType: DatabaseMigrationClientTypes.EncodingTypeValue? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            expectedBucketOwner: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            glueCatalogGeneration: Swift.Bool? = nil,
            ignoreHeaderRows: Swift.Int? = nil,
            includeOpForFullLoad: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            parquetTimestampInMillisecond: Swift.Bool? = nil,
            parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue? = nil,
            preserveTransactions: Swift.Bool? = nil,
            rfc4180: Swift.Bool? = nil,
            rowGroupLength: Swift.Int? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timestampColumnName: Swift.String? = nil,
            useCsvNoSupValue: Swift.Bool? = nil,
            useTaskStartTimeForFullLoadTimestamp: Swift.Bool? = nil
        )
        {
            self.addColumnName = addColumnName
            self.addTrailingPaddingCharacter = addTrailingPaddingCharacter
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cannedAclForObjects = cannedAclForObjects
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcMaxBatchInterval = cdcMaxBatchInterval
            self.cdcMinFileSize = cdcMinFileSize
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvNullValue = csvNullValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.datePartitionTimezone = datePartitionTimezone
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.expectedBucketOwner = expectedBucketOwner
            self.externalTableDefinition = externalTableDefinition
            self.glueCatalogGeneration = glueCatalogGeneration
            self.ignoreHeaderRows = ignoreHeaderRows
            self.includeOpForFullLoad = includeOpForFullLoad
            self.maxFileSize = maxFileSize
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rfc4180 = rfc4180
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
            self.useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestamp
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a SAP ASE endpoint.
    public struct SybaseSettings {
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default is 5000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SAP ASE endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SAP SAE endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SybaseSettings(databaseName: \(Swift.String(describing: databaseName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Timestream endpoint.
    public struct TimestreamSettings {
        /// Set this attribute to true to specify that DMS only applies inserts and updates, and not deletes. Amazon Timestream does not allow deleting records, so if this value is false, DMS nulls out the corresponding record in the Timestream database rather than deleting it.
        public var cdcInsertsAndUpdates: Swift.Bool?
        /// Database name for the endpoint.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Set this attribute to true to enable memory store writes. When this value is false, DMS does not write records that are older in days than the value specified in MagneticDuration, because Amazon Timestream does not allow memory writes by default. For more information, see [Storage](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html) in the [Amazon Timestream Developer Guide](https://docs.aws.amazon.com/timestream/latest/developerguide/).
        public var enableMagneticStoreWrites: Swift.Bool?
        /// Set this attribute to specify the default magnetic duration applied to the Amazon Timestream tables in days. This is the number of days that records remain in magnetic store before being discarded. For more information, see [Storage](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html) in the [Amazon Timestream Developer Guide](https://docs.aws.amazon.com/timestream/latest/developerguide/).
        /// This member is required.
        public var magneticDuration: Swift.Int?
        /// Set this attribute to specify the length of time to store all of the tables in memory that are migrated into Amazon Timestream from the source database. Time is measured in units of hours. When Timestream data comes in, it first resides in memory for the specified duration, which allows quick access to it.
        /// This member is required.
        public var memoryDuration: Swift.Int?

        public init(
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            enableMagneticStoreWrites: Swift.Bool? = nil,
            magneticDuration: Swift.Int? = nil,
            memoryDuration: Swift.Int? = nil
        )
        {
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.databaseName = databaseName
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticDuration = magneticDuration
            self.memoryDuration = memoryDuration
        }
    }

}

///
public struct CreateEndpointInput {
    /// The Amazon Resource Name (ARN) for the certificate.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName. To migrate to a specific database, use this setting and targetDbType.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Possible settings include the following:
    ///
    /// * ServiceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", }
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Provides information that defines a DocumentDB endpoint.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    /// This member is required.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "opensearch", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", "neptune", and "babelfish".
    /// This member is required.
    public var engineName: Swift.String?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see [Working with DMS Endpoints](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html) in the Database Migration Service User Guide.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to log in to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the target Redis endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// One or more tags to be assigned to the endpoint.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Settings in JSON format for the target Amazon Timestream endpoint.
    public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
    /// The user name to be used to log in to the endpoint database.
    public var username: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        kmsKeyId: Swift.String? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        resourceIdentifier: Swift.String? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.resourceIdentifier = resourceIdentifier
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.tags = tags
        self.timestreamSettings = timestreamSettings
        self.username = username
    }
}

extension CreateEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), tags: \(Swift.String(describing: tags)), timestreamSettings: \(Swift.String(describing: timestreamSettings)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Describes an endpoint of a database instance in response to operations such as the following:
    ///
    /// * CreateEndpoint
    ///
    /// * DescribeEndpoint
    ///
    /// * ModifyEndpoint
    public struct Endpoint {
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public var certificateArn: Swift.String?
        /// The name of the database at the endpoint.
        public var databaseName: Swift.String?
        /// The settings for the DMS Transfer type source. For more information, see the DmsTransferSettings structure.
        public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
        /// Provides information that defines a DocumentDB endpoint.
        public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
        /// The settings for the OpenSearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "redshift-serverless", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account.
        public var externalId: Swift.String?
        /// The external table definition.
        public var externalTableDefinition: Swift.String?
        /// Additional connection attributes used to connect to the endpoint.
        public var extraConnectionAttributes: Swift.String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure.
        public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
        /// The port value used to access the endpoint.
        public var port: Swift.Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
        /// The settings for the Redis target endpoint. For more information, see the RedisSettings structure.
        public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
        /// Settings for the Amazon Redshift endpoint.
        public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
        /// The name of the server at the endpoint.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
        /// The status of the endpoint.
        public var status: Swift.String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
        /// The settings for the Amazon Timestream target endpoint. For more information, see the TimestreamSettings structure.
        public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
        /// The user name used to connect to the endpoint.
        public var username: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
            docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
            dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
            elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            externalId: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            extraConnectionAttributes: Swift.String? = nil,
            gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
            ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
            kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
            kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
            kmsKeyId: Swift.String? = nil,
            microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
            mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
            mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
            neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
            oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
            port: Swift.Int? = nil,
            postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
            redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
            redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
            s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
            serverName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
            status: Swift.String? = nil,
            sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
            timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
            username: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.timestreamSettings = timestreamSettings
            self.username = username
        }
    }

}

///
public struct CreateEndpointOutput {
    /// The endpoint that was created.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

/// The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.
public struct KMSAccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDeniedFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified KMS key isn't enabled.
public struct KMSDisabledFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabledFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The state of the specified KMS resource isn't valid for this request.
public struct KMSInvalidStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidStateFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified KMS entity or resource can't be found.
public struct KMSNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This request triggered KMS request throttling.
public struct KMSThrottlingFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSThrottlingFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The SNS topic is invalid.
public struct SNSInvalidTopicFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SNSInvalidTopicFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are not authorized for the SNS subscription.
public struct SNSNoAuthorizationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SNSNoAuthorizationFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct CreateEventSubscriptionInput {
    /// A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. For more information, see [Working with Events and Notifications](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html) in the Database Migration Service User Guide.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    /// This member is required.
    public var snsTopicArn: Swift.String?
    /// A list of identifiers for which DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
    public var sourceIds: [Swift.String]?
    /// The type of DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription. This name must be less than 255 characters.
    /// This member is required.
    public var subscriptionName: Swift.String?
    /// One or more tags to be assigned to the event subscription.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an event notification subscription created by the CreateEventSubscription operation.
    public struct EventSubscription {
        /// The DMS event notification subscription Id.
        public var custSubscriptionId: Swift.String?
        /// The Amazon Web Services customer account associated with the DMS event notification subscription.
        public var customerAwsId: Swift.String?
        /// Boolean value that indicates if the event subscription is enabled.
        public var enabled: Swift.Bool
        /// A lists of event categories.
        public var eventCategoriesList: [Swift.String]?
        /// The topic ARN of the DMS event notification subscription.
        public var snsTopicArn: Swift.String?
        /// A list of source Ids for the event subscription.
        public var sourceIdsList: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?
        /// The status of the DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public var status: Swift.String?
        /// The time the DMS event notification subscription was created.
        public var subscriptionCreationTime: Swift.String?

        public init(
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

///
public struct CreateEventSubscriptionOutput {
    /// The event subscription that was created.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

/// A specified Amazon S3 bucket, bucket folder, or other object can't be found.
public struct S3ResourceNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3ResourceNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateFleetAdvisorCollectorInput {
    /// The name of your Fleet Advisor collector (for example, sample-collector).
    /// This member is required.
    public var collectorName: Swift.String?
    /// A summary description of your Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        collectorName: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

public struct CreateFleetAdvisorCollectorOutput {
    /// The name of the new Fleet Advisor collector.
    public var collectorName: Swift.String?
    /// The unique ID of the new Fleet Advisor collector, for example: 22fda70c-40d5-4acf-b233-a495bd8eb7f5
    public var collectorReferencedId: Swift.String?
    /// A summary description of the Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the collector uses to store inventory metadata.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        collectorName: Swift.String? = nil,
        collectorReferencedId: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.collectorReferencedId = collectorReferencedId
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

public struct CreateInstanceProfileInput {
    /// The Availability Zone where the instance profile will be created. The default value is a random, system-chosen Availability Zone in the Amazon Web Services Region where your data provider is created, for examplem us-east-1d.
    public var availabilityZone: Swift.String?
    /// A user-friendly description of the instance profile.
    public var description: Swift.String?
    /// A user-friendly name for the instance profile.
    public var instanceProfileName: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyArn: Swift.String?
    /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
    public var networkType: Swift.String?
    /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// A subnet group to associate with the instance profile.
    public var subnetGroupIdentifier: Swift.String?
    /// One or more tags to be assigned to the instance profile.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Specifies the VPC security group names to be used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
    public var vpcSecurityGroups: [Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceProfileName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        networkType: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        subnetGroupIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroups: [Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.instanceProfileName = instanceProfileName
        self.kmsKeyArn = kmsKeyArn
        self.networkType = networkType
        self.publiclyAccessible = publiclyAccessible
        self.subnetGroupIdentifier = subnetGroupIdentifier
        self.tags = tags
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an instance profile.
    public struct InstanceProfile {
        /// The Availability Zone where the instance profile runs.
        public var availabilityZone: Swift.String?
        /// A description of the instance profile. Descriptions can have up to 31 characters. A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the instance profile.
        public var instanceProfileArn: Swift.String?
        /// The time the instance profile was created.
        public var instanceProfileCreationTime: Foundation.Date?
        /// The user-friendly name for the instance profile.
        public var instanceProfileName: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyArn: Swift.String?
        /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
        public var networkType: Swift.String?
        /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool?
        /// The identifier of the subnet group that is associated with the instance profile.
        public var subnetGroupIdentifier: Swift.String?
        /// The VPC security groups that are used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
        public var vpcSecurityGroups: [Swift.String]?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceProfileCreationTime: Foundation.Date? = nil,
            instanceProfileName: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            networkType: Swift.String? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            subnetGroupIdentifier: Swift.String? = nil,
            vpcSecurityGroups: [Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileCreationTime = instanceProfileCreationTime
            self.instanceProfileName = instanceProfileName
            self.kmsKeyArn = kmsKeyArn
            self.networkType = networkType
            self.publiclyAccessible = publiclyAccessible
            self.subnetGroupIdentifier = subnetGroupIdentifier
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

public struct CreateInstanceProfileOutput {
    /// The instance profile that was created.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a schema conversion application.
    public struct SCApplicationAttributes {
        /// The path for the Amazon S3 bucket that the application uses for exporting assessment reports.
        public var s3BucketPath: Swift.String?
        /// The ARN for the role the application uses to access its Amazon S3 bucket.
        public var s3BucketRoleArn: Swift.String?

        public init(
            s3BucketPath: Swift.String? = nil,
            s3BucketRoleArn: Swift.String? = nil
        )
        {
            self.s3BucketPath = s3BucketPath
            self.s3BucketRoleArn = s3BucketRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Information about a data provider.
    public struct DataProviderDescriptorDefinition {
        /// The name or Amazon Resource Name (ARN) of the data provider.
        /// This member is required.
        public var dataProviderIdentifier: Swift.String?
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public var secretsManagerSecretId: Swift.String?

        public init(
            dataProviderIdentifier: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil
        )
        {
            self.dataProviderIdentifier = dataProviderIdentifier
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }
    }

}

public struct CreateMigrationProjectInput {
    /// A user-friendly description of the migration project.
    public var description: Swift.String?
    /// The identifier of the associated instance profile. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?
    /// A user-friendly name for the migration project.
    public var migrationProjectName: Swift.String?
    /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
    public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
    /// Information about the source data provider, including the name, ARN, and Secrets Manager parameters.
    /// This member is required.
    public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// One or more tags to be assigned to the migration project.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    /// This member is required.
    public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
    public var transformationRules: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        migrationProjectName: Swift.String? = nil,
        schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
        sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        transformationRules: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.migrationProjectName = migrationProjectName
        self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
        self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
        self.tags = tags
        self.targetDataProviderDescriptors = targetDataProviderDescriptors
        self.transformationRules = transformationRules
    }
}

extension DatabaseMigrationClientTypes {
    /// Information about a data provider.
    public struct DataProviderDescriptor {
        /// The Amazon Resource Name (ARN) of the data provider.
        public var dataProviderArn: Swift.String?
        /// The user-friendly name of the data provider.
        public var dataProviderName: Swift.String?
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public var secretsManagerSecretId: Swift.String?

        public init(
            dataProviderArn: Swift.String? = nil,
            dataProviderName: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil
        )
        {
            self.dataProviderArn = dataProviderArn
            self.dataProviderName = dataProviderName
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a migration project.
    public struct MigrationProject {
        /// A user-friendly description of the migration project.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the instance profile for your migration project.
        public var instanceProfileArn: Swift.String?
        /// The name of the associated instance profile.
        public var instanceProfileName: Swift.String?
        /// The ARN string that uniquely identifies the migration project.
        public var migrationProjectArn: Swift.String?
        /// The time when the migration project was created.
        public var migrationProjectCreationTime: Foundation.Date?
        /// The name of the migration project.
        public var migrationProjectName: Swift.String?
        /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
        public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
        /// Information about the source data provider, including the name or ARN, and Secrets Manager parameters.
        public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]?
        /// Information about the target data provider, including the name or ARN, and Secrets Manager parameters.
        public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]?
        /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
        public var transformationRules: Swift.String?

        public init(
            description: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            migrationProjectArn: Swift.String? = nil,
            migrationProjectCreationTime: Foundation.Date? = nil,
            migrationProjectName: Swift.String? = nil,
            schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
            sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil,
            targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil,
            transformationRules: Swift.String? = nil
        )
        {
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileName = instanceProfileName
            self.migrationProjectArn = migrationProjectArn
            self.migrationProjectCreationTime = migrationProjectCreationTime
            self.migrationProjectName = migrationProjectName
            self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
            self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
            self.targetDataProviderDescriptors = targetDataProviderDescriptors
            self.transformationRules = transformationRules
        }
    }

}

public struct CreateMigrationProjectOutput {
    /// The migration project that was created.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

/// The subnet provided isn't valid.
public struct InvalidSubnet: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.
public struct ReplicationSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationSubnetGroupDoesNotCoverEnoughAZs" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DatabaseMigrationClientTypes {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    public struct ComputeConfig {
        /// The Availability Zone where the DMS Serverless replication using this configuration will run. The default value is a random, system-chosen Availability Zone in the configuration's Amazon Web Services Region, for example, "us-west-2". You can't set this parameter if the MultiAZ parameter is set to true.
        public var availabilityZone: Swift.String?
        /// A list of custom DNS name servers supported for the DMS Serverless replication to access your source or target database. This list overrides the default name servers supported by the DMS Serverless replication. You can specify a comma-separated list of internet addresses for up to four DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
        public var dnsNameServers: Swift.String?
        /// An Key Management Service (KMS) key Amazon Resource Name (ARN) that is used to encrypt the data during DMS Serverless replication. If you don't specify a value for the KmsKeyId parameter, DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies the maximum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the maximum value that you can specify for DMS Serverless is 384. The MaxCapacityUnits parameter is the only DCU parameter you are required to specify.
        public var maxCapacityUnits: Swift.Int?
        /// Specifies the minimum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the minimum DCU value that you can specify for DMS Serverless is 1. You don't have to specify a value for the MinCapacityUnits parameter. If you don't set this value, DMS scans the current activity of available source tables to identify an optimum setting for this parameter. If there is no current source activity or DMS can't otherwise identify a more appropriate value, it sets this parameter to the minimum DCU value allowed, 1.
        public var minCapacityUnits: Swift.Int?
        /// Specifies whether the DMS Serverless replication is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the MultiAZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The weekly time range during which system maintenance can occur for the DMS Serverless replication, in Universal Coordinated Time (UTC). The format is ddd:hh24:mi-ddd:hh24:mi. The default is a 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region. This maintenance occurs on a random day of the week. Valid values for days of the week include Mon, Tue, Wed, Thu, Fri, Sat, and Sun. Constraints include a minimum 30-minute window.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies a subnet group identifier to associate with the DMS Serverless replication.
        public var replicationSubnetGroupId: Swift.String?
        /// Specifies the virtual private cloud (VPC) security group to use with the DMS Serverless replication. The VPC security group must work with the VPC containing the replication.
        public var vpcSecurityGroupIds: [Swift.String]?

        public init(
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            maxCapacityUnits: Swift.Int? = nil,
            minCapacityUnits: Swift.Int? = nil,
            multiAZ: Swift.Bool? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            replicationSubnetGroupId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.kmsKeyId = kmsKeyId
            self.maxCapacityUnits = maxCapacityUnits
            self.minCapacityUnits = minCapacityUnits
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationSubnetGroupId = replicationSubnetGroupId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum MigrationTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cdc
        case fullLoad
        case fullLoadAndCdc
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationTypeValue] {
            return [
                .cdc,
                .fullLoad,
                .fullLoadAndCdc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cdc: return "cdc"
            case .fullLoad: return "full-load"
            case .fullLoadAndCdc: return "full-load-and-cdc"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct CreateReplicationConfigInput {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    /// This member is required.
    public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    /// A unique identifier that you want to use to create a ReplicationConfigArn that is returned as part of the output from this action. You can then pass this output ReplicationConfigArn as the value of the ReplicationConfigArn option for other actions to identify both DMS Serverless replications and replication configurations that you want those actions to operate on. For some actions, you can also use either this unique identifier or a corresponding ARN in action filters to identify the specific replication and replication configuration to operate on.
    /// This member is required.
    public var replicationConfigIdentifier: Swift.String?
    /// Optional JSON settings for DMS Serverless replications that are provisioned using this replication configuration. For example, see [ Change processing tuning settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.ChangeProcessingTuning.html).
    public var replicationSettings: Swift.String?
    /// The type of DMS Serverless replication to provision using this replication configuration. Possible values:
    ///
    /// * "full-load"
    ///
    /// * "cdc"
    ///
    /// * "full-load-and-cdc"
    /// This member is required.
    public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// Optional unique value or name that you set for a given resource that can be used to construct an Amazon Resource Name (ARN) for that resource. For more information, see [ Fine-grained access control using resource names and tags](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#CHAP_Security.FineGrainedAccess).
    public var resourceIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the source endpoint for this DMS Serverless replication configuration.
    /// This member is required.
    public var sourceEndpointArn: Swift.String?
    /// Optional JSON settings for specifying supplemental data. For more information, see [ Specifying supplemental data for task settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html).
    public var supplementalSettings: Swift.String?
    /// JSON table mappings for DMS Serverless replications that are provisioned using this replication configuration. For more information, see [ Specifying table selection and transformations rules using JSON](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.SelectionTransformation.html).
    /// This member is required.
    public var tableMappings: Swift.String?
    /// One or more optional tags associated with resources used by the DMS Serverless replication. For more information, see [ Tagging resources in Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tagging.html).
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
    /// This member is required.
    public var targetEndpointArn: Swift.String?

    public init(
        computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
        replicationConfigIdentifier: Swift.String? = nil,
        replicationSettings: Swift.String? = nil,
        replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        supplementalSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil
    )
    {
        self.computeConfig = computeConfig
        self.replicationConfigIdentifier = replicationConfigIdentifier
        self.replicationSettings = replicationSettings
        self.replicationType = replicationType
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.supplementalSettings = supplementalSettings
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
    }
}

extension DatabaseMigrationClientTypes {
    /// This object provides configuration information about a serverless replication.
    public struct ReplicationConfig {
        /// Configuration parameters for provisioning an DMS serverless replication.
        public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
        /// The Amazon Resource Name (ARN) of this DMS Serverless replication configuration.
        public var replicationConfigArn: Swift.String?
        /// The time the serverless replication config was created.
        public var replicationConfigCreateTime: Foundation.Date?
        /// The identifier for the ReplicationConfig associated with the replication.
        public var replicationConfigIdentifier: Swift.String?
        /// The time the serverless replication config was updated.
        public var replicationConfigUpdateTime: Foundation.Date?
        /// Configuration parameters for an DMS serverless replication.
        public var replicationSettings: Swift.String?
        /// The type of the replication.
        public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
        public var sourceEndpointArn: Swift.String?
        /// Additional parameters for an DMS serverless replication.
        public var supplementalSettings: Swift.String?
        /// Table mappings specified in the replication.
        public var tableMappings: Swift.String?
        /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
        public var targetEndpointArn: Swift.String?

        public init(
            computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
            replicationConfigArn: Swift.String? = nil,
            replicationConfigCreateTime: Foundation.Date? = nil,
            replicationConfigIdentifier: Swift.String? = nil,
            replicationConfigUpdateTime: Foundation.Date? = nil,
            replicationSettings: Swift.String? = nil,
            replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            sourceEndpointArn: Swift.String? = nil,
            supplementalSettings: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil
        )
        {
            self.computeConfig = computeConfig
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigCreateTime = replicationConfigCreateTime
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationConfigUpdateTime = replicationConfigUpdateTime
            self.replicationSettings = replicationSettings
            self.replicationType = replicationType
            self.sourceEndpointArn = sourceEndpointArn
            self.supplementalSettings = supplementalSettings
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
        }
    }

}

///
public struct CreateReplicationConfigOutput {
    /// Configuration parameters returned from the DMS Serverless replication after it is created.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

/// There are not enough resources allocated to the database migration.
public struct InsufficientResourceCapacityFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientResourceCapacityFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The storage quota has been exceeded.
public struct StorageQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageQuotaExceededFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct CreateReplicationInstanceInput {
    /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region, for example: us-east-1d.
    public var availabilityZone: Swift.String?
    /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
    public var dnsNameServers: Swift.String?
    /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
    public var engineVersion: Swift.String?
    /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Choosing the right DMS replication instance](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.Types.html); and, [Selecting the best size for a replication instance](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_BestPractices.SizingReplicationInstance.html).
    /// This member is required.
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain 1-63 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: myrepinstance
    /// This member is required.
    public var replicationInstanceIdentifier: Swift.String?
    /// A subnet group to associate with the replication instance.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// One or more tags to be assigned to the replication instance.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        dnsNameServers: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the values of pending modifications to a replication instance. This data type is an object of the [ReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_ReplicationInstance.html) user-defined data type.
    public struct ReplicationPendingModifiedValues {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int?
        /// The engine version number of the replication instance.
        public var engineVersion: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?

        public init(
            allocatedStorage: Swift.Int? = nil,
            engineVersion: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            networkType: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.replicationInstanceClass = replicationInstanceClass
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// The name of an Availability Zone for use during database migration. AvailabilityZone is an optional parameter to the [CreateReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationInstance.html) operation, and it’s value relates to the Amazon Web Services Region of an endpoint. For example, the availability zone of an endpoint in the us-east-1 region might be us-east-1a, us-east-1b, us-east-1c, or us-east-1d.
    public struct AvailabilityZone {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationSubnetGroups operation, this object identifies a subnet by its given Availability Zone, subnet identifier, and status.
    public struct Subnet {
        /// The Availability Zone of the subnet.
        public var subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone?
        /// The subnet identifier.
        public var subnetIdentifier: Swift.String?
        /// The status of the subnet.
        public var subnetStatus: Swift.String?

        public init(
            subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a subnet group in response to a request by the DescribeReplicationSubnetGroups operation.
    public struct ReplicationSubnetGroup {
        /// A description for the replication subnet group.
        public var replicationSubnetGroupDescription: Swift.String?
        /// The identifier of the replication instance subnet group.
        public var replicationSubnetGroupIdentifier: Swift.String?
        /// The status of the subnet group.
        public var subnetGroupStatus: Swift.String?
        /// The subnets that are in the subnet group.
        public var subnets: [DatabaseMigrationClientTypes.Subnet]?
        /// The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var supportedNetworkTypes: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            replicationSubnetGroupDescription: Swift.String? = nil,
            replicationSubnetGroupIdentifier: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [DatabaseMigrationClientTypes.Subnet]? = nil,
            supportedNetworkTypes: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.supportedNetworkTypes = supportedNetworkTypes
            self.vpcId = vpcId
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes the status of a security group associated with the virtual private cloud (VPC) hosting your replication and DB instances.
    public struct VpcSecurityGroupMembership {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The VPC security group ID.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a replication instance.
    public struct ReplicationInstance {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The Availability Zone for the instance.
        public var availabilityZone: Swift.String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public var dnsNameServers: Swift.String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public var engineVersion: Swift.String?
        /// The expiration date of the free replication instance that is part of the Free DMS program.
        public var freeUntil: Foundation.Date?
        /// The time the replication instance was created.
        public var instanceCreateTime: Foundation.Date?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The pending modification values.
        public var pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:
        ///
        /// * Must contain 1-63 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        ///
        ///
        /// Example: myrepinstance
        public var replicationInstanceIdentifier: Swift.String?
        /// One or more IPv6 addresses for the replication instance.
        public var replicationInstanceIpv6Addresses: [Swift.String]?
        /// The private IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePrivateIpAddress: Swift.String?
        /// One or more private IP addresses for the replication instance.
        public var replicationInstancePrivateIpAddresses: [Swift.String]?
        /// The public IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePublicIpAddress: Swift.String?
        /// One or more public IP addresses for the replication instance.
        public var replicationInstancePublicIpAddresses: [Swift.String]?
        /// The status of the replication instance. The possible return values include:
        ///
        /// * "available"
        ///
        /// * "creating"
        ///
        /// * "deleted"
        ///
        /// * "deleting"
        ///
        /// * "failed"
        ///
        /// * "modifying"
        ///
        /// * "upgrading"
        ///
        /// * "rebooting"
        ///
        /// * "resetting-master-credentials"
        ///
        /// * "storage-full"
        ///
        /// * "incompatible-credentials"
        ///
        /// * "incompatible-network"
        ///
        /// * "maintenance"
        public var replicationInstanceStatus: Swift.String?
        /// The subnet group for the replication instance.
        public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public var secondaryAvailabilityZone: Swift.String?
        /// The VPC security group for the instance.
        public var vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]?

        public init(
            allocatedStorage: Swift.Int = 0,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            freeUntil: Foundation.Date? = nil,
            instanceCreateTime: Foundation.Date? = nil,
            kmsKeyId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            networkType: Swift.String? = nil,
            pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            replicationInstanceIpv6Addresses: [Swift.String]? = nil,
            replicationInstancePrivateIpAddress: Swift.String? = nil,
            replicationInstancePrivateIpAddresses: [Swift.String]? = nil,
            replicationInstancePublicIpAddress: Swift.String? = nil,
            replicationInstancePublicIpAddresses: [Swift.String]? = nil,
            replicationInstanceStatus: Swift.String? = nil,
            replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

///
public struct CreateReplicationInstanceOutput {
    /// The replication instance that was created.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

///
public struct CreateReplicationSubnetGroupInput {
    /// The description for the subnet group.
    /// This member is required.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// Two or more subnet IDs to be assigned to the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// One or more tags to be assigned to the subnet group.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

///
public struct CreateReplicationSubnetGroupOutput {
    /// The replication subnet group that was created.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init(
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

///
public struct CreateReplicationTaskInput {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: Foundation.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time:2018-02-09T12:12:12“
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    /// This member is required.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of a replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// An identifier for the replication task. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var replicationTaskIdentifier: Swift.String?
    /// Overall settings for the task, in JSON format. For more information, see [Specifying Task Settings for Database Migration Service Tasks](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html) in the Database Migration Service User Guide.
    public var replicationTaskSettings: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
    /// This member is required.
    public var sourceEndpointArn: Swift.String?
    /// The table mappings for the task, in JSON format. For more information, see [Using Table Mapping to Specify Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html) in the Database Migration Service User Guide.
    /// This member is required.
    public var tableMappings: Swift.String?
    /// One or more tags to be assigned to the replication task.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
    /// This member is required.
    public var targetEndpointArn: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: Foundation.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
        self.taskData = taskData
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationTasks operation, this object provides a collection of statistics about a replication task.
    public struct ReplicationTaskStats {
        /// The elapsed time of the task, in milliseconds.
        public var elapsedTimeMillis: Swift.Int
        /// The date the replication task was started either with a fresh start or a target reload.
        public var freshStartDate: Foundation.Date?
        /// The date the replication task full load was completed.
        public var fullLoadFinishDate: Foundation.Date?
        /// The percent complete for the full load migration task.
        public var fullLoadProgressPercent: Swift.Int
        /// The date the replication task full load was started.
        public var fullLoadStartDate: Foundation.Date?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see [StartReplicationTaskType](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html#DMS-StartReplicationTask-request-StartReplicationTaskType).
        public var startDate: Foundation.Date?
        /// The date the replication task was stopped.
        public var stopDate: Foundation.Date?
        /// The number of errors that have occurred during this task.
        public var tablesErrored: Swift.Int
        /// The number of tables loaded for this task.
        public var tablesLoaded: Swift.Int
        /// The number of tables currently loading for this task.
        public var tablesLoading: Swift.Int
        /// The number of tables queued for this task.
        public var tablesQueued: Swift.Int

        public init(
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: Foundation.Date? = nil,
            fullLoadFinishDate: Foundation.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil,
            stopDate: Foundation.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a replication task created by the CreateReplicationTask operation.
    public struct ReplicationTask {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”
        public var cdcStartPosition: Swift.String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time:2018-02-09T12:12:12“
        public var cdcStopPosition: Swift.String?
        /// The last error (failure) message generated for the replication task.
        public var lastFailureMessage: Swift.String?
        /// The type of migration.
        public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public var recoveryCheckpoint: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The date the replication task was created.
        public var replicationTaskCreationDate: Foundation.Date?
        /// The user-assigned replication task identifier or name. Constraints:
        ///
        /// * Must contain 1-255 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        public var replicationTaskIdentifier: Swift.String?
        /// The settings for the replication task.
        public var replicationTaskSettings: Swift.String?
        /// The date the replication task is scheduled to start.
        public var replicationTaskStartDate: Foundation.Date?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public var replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) that uniquely identifies the endpoint.
        public var sourceEndpointArn: Swift.String?
        /// The status of the replication task. This response parameter can return one of the following values:
        ///
        /// * "moving" – The task is being moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "creating" – The task is being created in response to running the [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html) operation.
        ///
        /// * "deleting" – The task is being deleted in response to running the [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html) operation.
        ///
        /// * "failed" – The task failed to successfully complete the database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "failed-move" – The task failed to move in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "modifying" – The task definition is being modified in response to running the [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html) operation.
        ///
        /// * "ready" – The task is in a ready state where it can respond to other task operations, such as [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) or [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html).
        ///
        /// * "running" – The task is performing a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "starting" – The task is preparing to perform a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "stopped" – The task has stopped in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "stopping" – The task is preparing to stop in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "testing" – The database migration specified for this task is being tested in response to running either the [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) or the [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation. [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) is an improved premigration task assessment operation. The [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation assesses data type compatibility only between the source and target database of a given migration task. In contrast, [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) enables you to specify a variety of premigration task assessments in addition to data type compatibility. These assessments include ones for the validity of primary key definitions and likely issues with database migration performance, among others.
        public var status: Swift.String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:
        ///
        /// * "Stop Reason NORMAL"
        ///
        /// * "Stop Reason RECOVERABLE_ERROR"
        ///
        /// * "Stop Reason FATAL_ERROR"
        ///
        /// * "Stop Reason FULL_LOAD_ONLY_FINISHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_FULL_LOAD" – Full load completed, with cached changes not applied
        ///
        /// * "Stop Reason STOPPED_AFTER_CACHED_EVENTS" – Full load completed, with cached changes applied
        ///
        /// * "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_DDL_APPLY" – User-defined stop task after DDL applied
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_DISK"
        ///
        /// * "Stop Reason STOPPED_AT_SERVER_TIME" – User-defined server time for stopping task
        ///
        /// * "Stop Reason STOPPED_AT_COMMIT_TIME" – User-defined commit time for stopping task
        ///
        /// * "Stop Reason RECONFIGURATION_RESTART"
        ///
        /// * "Stop Reason RECYCLE_TASK"
        public var stopReason: Swift.String?
        /// Table mappings specified in the task.
        public var tableMappings: Swift.String?
        /// The ARN that uniquely identifies the endpoint.
        public var targetEndpointArn: Swift.String?
        /// The ARN of the replication instance to which this task is moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation. Otherwise, this response parameter isn't a member of the ReplicationTask object.
        public var targetReplicationInstanceArn: Swift.String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
        public var taskData: Swift.String?

        public init(
            cdcStartPosition: Swift.String? = nil,
            cdcStopPosition: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskCreationDate: Foundation.Date? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskSettings: Swift.String? = nil,
            replicationTaskStartDate: Foundation.Date? = nil,
            replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats? = nil,
            sourceEndpointArn: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil,
            targetReplicationInstanceArn: Swift.String? = nil,
            taskData: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }
    }

}

///
public struct CreateReplicationTaskOutput {
    /// The replication task that was created.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

public struct DeleteCertificateInput {
    /// The Amazon Resource Name (ARN) of the certificate.
    /// This member is required.
    public var certificateArn: Swift.String?

    public init(
        certificateArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

extension DatabaseMigrationClientTypes {
    /// The SSL certificate that can be used to encrypt connections between the endpoints and the replication instance.
    public struct Certificate {
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: Swift.String?
        /// The date that the certificate was created.
        public var certificateCreationDate: Foundation.Date?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var certificateIdentifier: Swift.String?
        /// The owner of the certificate.
        public var certificateOwner: Swift.String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public var certificatePem: Swift.String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
        public var certificateWallet: Foundation.Data?
        /// The key length of the cryptographic algorithm being used.
        public var keyLength: Swift.Int?
        /// The signing algorithm for the certificate.
        public var signingAlgorithm: Swift.String?
        /// The beginning date that the certificate is valid.
        public var validFromDate: Foundation.Date?
        /// The final date that the certificate is valid.
        public var validToDate: Foundation.Date?

        public init(
            certificateArn: Swift.String? = nil,
            certificateCreationDate: Foundation.Date? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateOwner: Swift.String? = nil,
            certificatePem: Swift.String? = nil,
            certificateWallet: Foundation.Data? = nil,
            keyLength: Swift.Int? = nil,
            signingAlgorithm: Swift.String? = nil,
            validFromDate: Foundation.Date? = nil,
            validToDate: Foundation.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }
    }

}

public struct DeleteCertificateOutput {
    /// The Secure Sockets Layer (SSL) certificate.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init(
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

///
public struct DeleteConnectionInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

extension DatabaseMigrationClientTypes {
    /// Status of the connection between an endpoint and a replication instance, including Amazon Resource Names (ARNs) and the last error message issued.
    public struct Connection {
        /// The ARN string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The error message when the connection last failed.
        public var lastFailureMessage: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public var replicationInstanceIdentifier: Swift.String?
        /// The connection status. This parameter can return one of the following values:
        ///
        /// * "successful"
        ///
        /// * "testing"
        ///
        /// * "failed"
        ///
        /// * "deleting"
        public var status: Swift.String?

        public init(
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }
    }

}

///
public struct DeleteConnectionOutput {
    /// The connection that is being deleted.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init(
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

public struct DeleteDataProviderInput {
    /// The identifier of the data provider to delete.
    /// This member is required.
    public var dataProviderIdentifier: Swift.String?

    public init(
        dataProviderIdentifier: Swift.String? = nil
    )
    {
        self.dataProviderIdentifier = dataProviderIdentifier
    }
}

public struct DeleteDataProviderOutput {
    /// The data provider that was deleted.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

///
public struct DeleteEndpointInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

///
public struct DeleteEndpointOutput {
    /// The endpoint that was deleted.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

///
public struct DeleteEventSubscriptionInput {
    /// The name of the DMS event notification subscription to be deleted.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init(
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

///
public struct DeleteEventSubscriptionOutput {
    /// The event subscription that was deleted.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

/// The specified collector doesn't exist.
public struct CollectorNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CollectorNotFoundFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFleetAdvisorCollectorInput {
    /// The reference ID of the Fleet Advisor collector to delete.
    /// This member is required.
    public var collectorReferencedId: Swift.String?

    public init(
        collectorReferencedId: Swift.String? = nil
    )
    {
        self.collectorReferencedId = collectorReferencedId
    }
}

/// The action or operation requested isn't valid.
public struct InvalidOperationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFleetAdvisorDatabasesInput {
    /// The IDs of the Fleet Advisor collector databases to delete.
    /// This member is required.
    public var databaseIds: [Swift.String]?

    public init(
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

public struct DeleteFleetAdvisorDatabasesOutput {
    /// The IDs of the databases that the operation deleted.
    public var databaseIds: [Swift.String]?

    public init(
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

public struct DeleteInstanceProfileInput {
    /// The identifier of the instance profile to delete.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?

    public init(
        instanceProfileIdentifier: Swift.String? = nil
    )
    {
        self.instanceProfileIdentifier = instanceProfileIdentifier
    }
}

public struct DeleteInstanceProfileOutput {
    /// The instance profile that was deleted.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

public struct DeleteMigrationProjectInput {
    /// The name or Amazon Resource Name (ARN) of the migration project to delete.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DeleteMigrationProjectOutput {
    /// The migration project that was deleted.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

///
public struct DeleteReplicationConfigInput {
    /// The replication config to delete.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

///
public struct DeleteReplicationConfigOutput {
    /// Configuration parameters returned for the DMS Serverless replication after it is deleted.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

///
public struct DeleteReplicationInstanceInput {
    /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationInstanceArn = replicationInstanceArn
    }
}

///
public struct DeleteReplicationInstanceOutput {
    /// The replication instance that was deleted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

///
public struct DeleteReplicationSubnetGroupInput {
    /// The subnet group name of the replication instance.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?

    public init(
        replicationSubnetGroupIdentifier: Swift.String? = nil
    )
    {
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
    }
}

///
public struct DeleteReplicationSubnetGroupOutput {

    public init() { }
}

///
public struct DeleteReplicationTaskInput {
    /// The Amazon Resource Name (ARN) of the replication task to be deleted.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

///
public struct DeleteReplicationTaskOutput {
    /// The deleted replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

///
public struct DeleteReplicationTaskAssessmentRunInput {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init(
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

///
public struct DeleteReplicationTaskAssessmentRunOutput {
    /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

///
public struct DescribeAccountAttributesInput {

    public init() { }
}

///
public struct DescribeAccountAttributesOutput {
    /// Account quota information.
    public var accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    /// A unique DMS identifier for an account in a particular Amazon Web Services Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given Amazon Web Services Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666. DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later.
    public var uniqueAccountIdentifier: Swift.String?

    public init(
        accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]? = nil,
        uniqueAccountIdentifier: Swift.String? = nil
    )
    {
        self.accountQuotas = accountQuotas
        self.uniqueAccountIdentifier = uniqueAccountIdentifier
    }
}

///
public struct DescribeApplicableIndividualAssessmentsInput {
    /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?
    /// Name of the migration type that each provided individual assessment must support.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// ARN of a replication instance on which you want to base the default list of individual assessments.
    public var replicationInstanceArn: Swift.String?
    /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
    public var replicationTaskArn: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a source.
    public var sourceEngineName: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a target.
    public var targetEngineName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        sourceEngineName: Swift.String? = nil,
        targetEngineName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.sourceEngineName = sourceEngineName
        self.targetEngineName = targetEngineName
    }
}

///
public struct DescribeApplicableIndividualAssessmentsOutput {
    /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see [Working with premigration assessment runs](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.AssessmentReport.html) in the Database Migration Service User Guide.
    public var individualAssessmentNames: [Swift.String]?
    /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?

    public init(
        individualAssessmentNames: [Swift.String]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.individualAssessmentNames = individualAssessmentNames
        self.marker = marker
    }
}

extension DatabaseMigrationClientTypes {
    /// Identifies the name and value of a filter object. This filter is used to limit the number and type of DMS objects that are returned for a particular Describe* call or similar operation. Filters are used as an optional parameter for certain API operations.
    public struct Filter {
        /// The name of the filter as specified for a Describe* or similar operation.
        /// This member is required.
        public var name: Swift.String?
        /// The filter value, which can specify one or more values used to narrow the returned results.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

public struct DescribeCertificatesInput {
    /// Filters applied to the certificates described in the form of key-value pairs. Valid values are certificate-arn and certificate-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 10
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

public struct DescribeCertificatesOutput {
    /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
    public var certificates: [DatabaseMigrationClientTypes.Certificate]?
    /// The pagination token.
    public var marker: Swift.String?

    public init(
        certificates: [DatabaseMigrationClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

///
public struct DescribeConnectionsInput {
    /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeConnectionsOutput {
    /// A description of the connections.
    public var connections: [DatabaseMigrationClientTypes.Connection]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        connections: [DatabaseMigrationClientTypes.Connection]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.connections = connections
        self.marker = marker
    }
}

public struct DescribeConversionConfigurationInput {
    /// The name or Amazon Resource Name (ARN) for the schema conversion project to describe.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeConversionConfigurationOutput {
    /// The configuration parameters for the schema conversion project.
    public var conversionConfiguration: Swift.String?
    /// The name or Amazon Resource Name (ARN) for the schema conversion project.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        conversionConfiguration: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.conversionConfiguration = conversionConfiguration
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeDataProvidersInput {
    /// Filters applied to the data providers described in the form of key-value pairs. Valid filter names: data-provider-identifier
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

public struct DescribeDataProvidersOutput {
    /// A description of data providers.
    public var dataProviders: [DatabaseMigrationClientTypes.DataProvider]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?

    public init(
        dataProviders: [DatabaseMigrationClientTypes.DataProvider]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dataProviders = dataProviders
        self.marker = marker
    }
}

///
public struct DescribeEndpointsInput {
    /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeEndpointsOutput {
    /// Endpoint description.
    public var endpoints: [DatabaseMigrationClientTypes.Endpoint]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        endpoints: [DatabaseMigrationClientTypes.Endpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.marker = marker
    }
}

public struct DescribeEndpointSettingsInput {
    /// The database engine used for your source or target endpoint.
    /// This member is required.
    public var engineName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        engineName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {

    public enum EndpointSettingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case `enum`
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointSettingTypeValue] {
            return [
                .boolean,
                .enum,
                .integer,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "boolean"
            case .enum: return "enum"
            case .integer: return "integer"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Endpoint settings.
    public struct EndpointSetting {
        /// The relevance or validity of an endpoint setting for an engine name and its endpoint type.
        public var applicability: Swift.String?
        /// The default value of the endpoint setting if no value is specified using CreateEndpoint or ModifyEndpoint.
        public var defaultValue: Swift.String?
        /// Enumerated values to use for this endpoint.
        public var enumValues: [Swift.String]?
        /// The maximum value of an endpoint setting that is of type int.
        public var intValueMax: Swift.Int?
        /// The minimum value of an endpoint setting that is of type int.
        public var intValueMin: Swift.Int?
        /// The name that you want to give the endpoint settings.
        public var name: Swift.String?
        /// A value that marks this endpoint setting as sensitive.
        public var sensitive: Swift.Bool?
        /// The type of endpoint. Valid values are source and target.
        public var type: DatabaseMigrationClientTypes.EndpointSettingTypeValue?
        /// The unit of measure for this endpoint setting.
        public var units: Swift.String?

        public init(
            applicability: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            enumValues: [Swift.String]? = nil,
            intValueMax: Swift.Int? = nil,
            intValueMin: Swift.Int? = nil,
            name: Swift.String? = nil,
            sensitive: Swift.Bool? = nil,
            type: DatabaseMigrationClientTypes.EndpointSettingTypeValue? = nil,
            units: Swift.String? = nil
        )
        {
            self.applicability = applicability
            self.defaultValue = defaultValue
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }
    }

}

public struct DescribeEndpointSettingsOutput {
    /// Descriptions of the endpoint settings available for your source or target database engine.
    public var endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointSettings = endpointSettings
        self.marker = marker
    }
}

///
public struct DescribeEndpointTypesInput {
    /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about types of supported endpoints in response to a request by the DescribeEndpointTypes operation. This information includes the type of endpoint, the database engine name, and whether change data capture (CDC) is supported.
    public struct SupportedEndpointType {
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// The earliest DMS engine version that supports this endpoint engine. Note that endpoint engines released with DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public var replicationInstanceEngineMinimumVersion: Swift.String?
        /// Indicates if change data capture (CDC) is supported.
        public var supportsCDC: Swift.Bool

        public init(
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            replicationInstanceEngineMinimumVersion: Swift.String? = nil,
            supportsCDC: Swift.Bool = false
        )
        {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }
    }

}

///
public struct DescribeEndpointTypesOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The types of endpoints that are supported.
    public var supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?

    public init(
        marker: Swift.String? = nil,
        supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
    )
    {
        self.marker = marker
        self.supportedEndpointTypes = supportedEndpointTypes
    }
}

public struct DescribeEngineVersionsInput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {

    public enum ReleaseStatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beta
        case prod
        case sdkUnknown(Swift.String)

        public static var allCases: [ReleaseStatusValues] {
            return [
                .beta,
                .prod
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beta: return "beta"
            case .prod: return "prod"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about a replication instance version.
    public struct EngineVersion {
        /// The date when the replication instance will be automatically upgraded. This setting only applies if the auto-minor-version setting is enabled.
        public var autoUpgradeDate: Foundation.Date?
        /// The list of valid replication instance versions that you can upgrade to.
        public var availableUpgrades: [Swift.String]?
        /// The date when the replication instance version will be deprecated and can no longer be requested.
        public var deprecationDate: Foundation.Date?
        /// The date when the replication instance will have a version upgrade forced.
        public var forceUpgradeDate: Foundation.Date?
        /// The date when the replication instance version became publicly available.
        public var launchDate: Foundation.Date?
        /// The lifecycle status of the replication instance version. Valid values are DEPRECATED, DEFAULT_VERSION, and ACTIVE.
        public var lifecycle: Swift.String?
        /// The release status of the replication instance version.
        public var releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// The version number of the replication instance.
        public var version: Swift.String?

        public init(
            autoUpgradeDate: Foundation.Date? = nil,
            availableUpgrades: [Swift.String]? = nil,
            deprecationDate: Foundation.Date? = nil,
            forceUpgradeDate: Foundation.Date? = nil,
            launchDate: Foundation.Date? = nil,
            lifecycle: Swift.String? = nil,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            version: Swift.String? = nil
        )
        {
            self.autoUpgradeDate = autoUpgradeDate
            self.availableUpgrades = availableUpgrades
            self.deprecationDate = deprecationDate
            self.forceUpgradeDate = forceUpgradeDate
            self.launchDate = launchDate
            self.lifecycle = lifecycle
            self.releaseStatus = releaseStatus
            self.version = version
        }
    }

}

public struct DescribeEngineVersionsOutput {
    /// Returned EngineVersion objects that describe the replication instance engine versions used in the project.
    public var engineVersions: [DatabaseMigrationClientTypes.EngineVersion]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        engineVersions: [DatabaseMigrationClientTypes.EngineVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.marker = marker
    }
}

///
public struct DescribeEventCategoriesInput {
    /// Filters applied to the event categories.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

extension DatabaseMigrationClientTypes {
    /// Lists categories of events subscribed to, and generated by, the applicable DMS resource type. This data type appears in response to the [DescribeEventCategories](https://docs.aws.amazon.com/dms/latest/APIReference/API_EventCategoryGroup.html) action.
    public struct EventCategoryGroup {
        /// A list of event categories from a source type that you've chosen.
        public var eventCategories: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?

        public init(
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

///
public struct DescribeEventCategoriesOutput {
    /// A list of event categories.
    public var eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?

    public init(
        eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
    )
    {
        self.eventCategoryGroupList = eventCategoryGroupList
    }
}

extension DatabaseMigrationClientTypes {

    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case replicationInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .replicationInstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .replicationInstance: return "replication-instance"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct DescribeEventsInput {
    /// The duration of the events to be listed.
    public var duration: Swift.Int?
    /// The end time for the events to be listed.
    public var endTime: Foundation.Date?
    /// A list of event categories for the source type that you've chosen.
    public var eventCategories: [Swift.String]?
    /// Filters applied to events. The only valid filter is replication-instance-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of an event source.
    public var sourceIdentifier: Swift.String?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: DatabaseMigrationClientTypes.SourceType?
    /// The start time for the events to be listed.
    public var startTime: Foundation.Date?

    public init(
        duration: Swift.Int? = nil,
        endTime: Foundation.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: DatabaseMigrationClientTypes.SourceType? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an identifiable significant activity that affects a replication instance or task. This object can provide the message, the available event categories, the date and source of the event, and the DMS resource type.
    public struct Event {
        /// The date of the event.
        public var date: Foundation.Date?
        /// The event categories available for the specified source type.
        public var eventCategories: [Swift.String]?
        /// The event message.
        public var message: Swift.String?
        /// The identifier of an event source.
        public var sourceIdentifier: Swift.String?
        /// The type of DMS resource that generates events. Valid values: replication-instance | endpoint | replication-task
        public var sourceType: DatabaseMigrationClientTypes.SourceType?

        public init(
            date: Foundation.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: DatabaseMigrationClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

///
public struct DescribeEventsOutput {
    /// The events described.
    public var events: [DatabaseMigrationClientTypes.Event]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        events: [DatabaseMigrationClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

///
public struct DescribeEventSubscriptionsInput {
    /// Filters applied to event subscriptions. Valid filter names: event-subscription-arn | event-subscription-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the DMS event subscription to be described.
    public var subscriptionName: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

///
public struct DescribeEventSubscriptionsOutput {
    /// A list of event subscriptions.
    public var eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

public struct DescribeExtensionPackAssociationsInput {
    /// Filters applied to the extension pack associations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The name or Amazon Resource Name (ARN) for the migration project.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides error information about a schema conversion operation.
    public struct DefaultErrorDetails {
        /// The error message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides error information about a project.
    public enum ErrorDetails {
        /// Error information about a project.
        case defaulterrordetails(DatabaseMigrationClientTypes.DefaultErrorDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information about a metadata model assessment exported to SQL.
    public struct ExportSqlDetails {
        /// The URL for the object containing the exported metadata model assessment.
        public var objectURL: Swift.String?
        /// The Amazon S3 object key for the object containing the exported metadata model assessment.
        public var s3ObjectKey: Swift.String?

        public init(
            objectURL: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information about a schema conversion action.
    public struct SchemaConversionRequest {
        /// Provides error information about a project.
        public var error: DatabaseMigrationClientTypes.ErrorDetails?
        /// Provides information about a metadata model assessment exported to SQL.
        public var exportSqlDetails: DatabaseMigrationClientTypes.ExportSqlDetails?
        /// The migration project ARN.
        public var migrationProjectArn: Swift.String?
        /// The identifier for the schema conversion action.
        public var requestIdentifier: Swift.String?
        /// The schema conversion action status.
        public var status: Swift.String?

        public init(
            error: DatabaseMigrationClientTypes.ErrorDetails? = nil,
            exportSqlDetails: DatabaseMigrationClientTypes.ExportSqlDetails? = nil,
            migrationProjectArn: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.error = error
            self.exportSqlDetails = exportSqlDetails
            self.migrationProjectArn = migrationProjectArn
            self.requestIdentifier = requestIdentifier
            self.status = status
        }
    }

}

public struct DescribeExtensionPackAssociationsOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of extension pack associations for the specified migration project.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeFleetAdvisorCollectorsInput {
    /// If you specify any of the following filters, the output includes information for only those collectors that meet the filter criteria:
    ///
    /// * collector-referenced-id – The ID of the collector agent, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    /// * collector-name – The name of the collector agent.
    ///
    ///
    /// An example is: describe-fleet-advisor-collectors --filter Name="collector-referenced-id",Values="d4610ac5-e323-4ad9-bc50-eaf7249dfe9d"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {

    public enum CollectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorStatus] {
            return [
                .active,
                .unregistered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .unregistered: return "UNREGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes the last Fleet Advisor collector health check.
    public struct CollectorHealthCheck {
        /// The status of the Fleet Advisor collector.
        public var collectorStatus: DatabaseMigrationClientTypes.CollectorStatus?
        /// Whether the local collector can access its Amazon S3 bucket.
        public var localCollectorS3Access: Swift.Bool?
        /// Whether the role that you provided when creating the Fleet Advisor collector has sufficient permissions to access the Fleet Advisor web collector.
        public var webCollectorGrantedRoleBasedAccess: Swift.Bool?
        /// Whether the web collector can access its Amazon S3 bucket.
        public var webCollectorS3Access: Swift.Bool?

        public init(
            collectorStatus: DatabaseMigrationClientTypes.CollectorStatus? = nil,
            localCollectorS3Access: Swift.Bool? = nil,
            webCollectorGrantedRoleBasedAccess: Swift.Bool? = nil,
            webCollectorS3Access: Swift.Bool? = nil
        )
        {
            self.collectorStatus = collectorStatus
            self.localCollectorS3Access = localCollectorS3Access
            self.webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccess
            self.webCollectorS3Access = webCollectorS3Access
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector inventory.
    public struct InventoryData {
        /// The number of databases in the Fleet Advisor collector inventory.
        public var numberOfDatabases: Swift.Int?
        /// The number of schemas in the Fleet Advisor collector inventory.
        public var numberOfSchemas: Swift.Int?

        public init(
            numberOfDatabases: Swift.Int? = nil,
            numberOfSchemas: Swift.Int? = nil
        )
        {
            self.numberOfDatabases = numberOfDatabases
            self.numberOfSchemas = numberOfSchemas
        }
    }

}

extension DatabaseMigrationClientTypes {

    public enum VersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case outdated
        case unsupported
        case upToDate
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionStatus] {
            return [
                .outdated,
                .unsupported,
                .upToDate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .outdated: return "OUTDATED"
            case .unsupported: return "UNSUPPORTED"
            case .upToDate: return "UP_TO_DATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector.
    public struct CollectorResponse {
        /// Describes the last Fleet Advisor collector health check.
        public var collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck?
        /// The name of the Fleet Advisor collector .
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?
        /// The version of your Fleet Advisor collector, in semantic versioning format, for example 1.0.2
        public var collectorVersion: Swift.String?
        /// The timestamp when you created the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var createdDate: Swift.String?
        /// A summary description of the Fleet Advisor collector.
        public var description: Swift.String?
        /// Describes a Fleet Advisor collector inventory.
        public var inventoryData: DatabaseMigrationClientTypes.InventoryData?
        /// The timestamp of the last time the collector received data, in the following format: 2022-01-24T19:04:02.596113Z
        public var lastDataReceived: Swift.String?
        /// The timestamp when DMS last modified the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var modifiedDate: Swift.String?
        /// The timestamp when DMS registered the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var registeredDate: Swift.String?
        /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
        public var s3BucketName: Swift.String?
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// Whether the collector version is up to date.
        public var versionStatus: DatabaseMigrationClientTypes.VersionStatus?

        public init(
            collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck? = nil,
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            inventoryData: DatabaseMigrationClientTypes.InventoryData? = nil,
            lastDataReceived: Swift.String? = nil,
            modifiedDate: Swift.String? = nil,
            registeredDate: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            versionStatus: DatabaseMigrationClientTypes.VersionStatus? = nil
        )
        {
            self.collectorHealthCheck = collectorHealthCheck
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
            self.collectorVersion = collectorVersion
            self.createdDate = createdDate
            self.description = description
            self.inventoryData = inventoryData
            self.lastDataReceived = lastDataReceived
            self.modifiedDate = modifiedDate
            self.registeredDate = registeredDate
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.versionStatus = versionStatus
        }
    }

}

public struct DescribeFleetAdvisorCollectorsOutput {
    /// Provides descriptions of the Fleet Advisor collectors, including the collectors' name and ID, and the latest inventory data.
    public var collectors: [DatabaseMigrationClientTypes.CollectorResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        collectors: [DatabaseMigrationClientTypes.CollectorResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

public struct DescribeFleetAdvisorDatabasesInput {
    /// If you specify any of the following filters, the output includes information for only those databases that meet the filter criteria:
    ///
    /// * database-id – The ID of the database.
    ///
    /// * database-name – The name of the database.
    ///
    /// * database-engine – The name of the database engine.
    ///
    /// * server-ip-address – The IP address of the database server.
    ///
    /// * database-ip-address – The IP address of the database.
    ///
    /// * collector-name – The name of the associated Fleet Advisor collector.
    ///
    ///
    /// An example is: describe-fleet-advisor-databases --filter Name="database-id",Values="45"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Briefly describes a Fleet Advisor collector.
    public struct CollectorShortInfoResponse {
        /// The name of the Fleet Advisor collector.
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?

        public init(
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil
        )
        {
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a server in a Fleet Advisor collector inventory.
    public struct ServerShortInfoResponse {
        /// The IP address of a server in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The ID of a server in a Fleet Advisor collector inventory.
        public var serverId: Swift.String?
        /// The name address of a server in a Fleet Advisor collector inventory.
        public var serverName: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            serverId: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.serverId = serverId
            self.serverName = serverName
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes an inventory database instance for a Fleet Advisor collector.
    public struct DatabaseInstanceSoftwareDetailsResponse {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example Microsoft SQL Server.
        public var engine: Swift.String?
        /// The database engine edition of a database in a Fleet Advisor collector inventory, for example Express.
        public var engineEdition: Swift.String?
        /// The database engine version of a database in a Fleet Advisor collector inventory, for example 2019.
        public var engineVersion: Swift.String?
        /// The operating system architecture of the database.
        public var osArchitecture: Swift.Int?
        /// The service pack level of the database.
        public var servicePack: Swift.String?
        /// The support level of the database, for example Mainstream support.
        public var supportLevel: Swift.String?
        /// Information about the database engine software, for example Mainstream support ends on November 14th, 2024.
        public var tooltip: Swift.String?

        public init(
            engine: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            osArchitecture: Swift.Int? = nil,
            servicePack: Swift.String? = nil,
            supportLevel: Swift.String? = nil,
            tooltip: Swift.String? = nil
        )
        {
            self.engine = engine
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.osArchitecture = osArchitecture
            self.servicePack = servicePack
            self.supportLevel = supportLevel
            self.tooltip = tooltip
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseResponse {
        /// A list of collectors associated with the database.
        public var collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The number of schemas in a Fleet Advisor collector inventory database.
        public var numberOfSchemas: Swift.Int?
        /// The server name of a database in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The software details of a database in a Fleet Advisor collector inventory, such as database engine and version.
        public var softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse?

        public init(
            collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            numberOfSchemas: Swift.Int? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse? = nil
        )
        {
            self.collectors = collectors
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.ipAddress = ipAddress
            self.numberOfSchemas = numberOfSchemas
            self.server = server
            self.softwareDetails = softwareDetails
        }
    }

}

public struct DescribeFleetAdvisorDatabasesOutput {
    /// Provides descriptions of the Fleet Advisor collector databases, including the database's collector, ID, and name.
    public var databases: [DatabaseMigrationClientTypes.DatabaseResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        databases: [DatabaseMigrationClientTypes.DatabaseResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

public struct DescribeFleetAdvisorLsaAnalysisInput {
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a large-scale assessment (LSA) analysis run by a Fleet Advisor collector.
    public struct FleetAdvisorLsaAnalysisResponse {
        /// The ID of an LSA analysis run by a Fleet Advisor collector.
        public var lsaAnalysisId: Swift.String?
        /// The status of an LSA analysis run by a Fleet Advisor collector.
        public var status: Swift.String?

        public init(
            lsaAnalysisId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.lsaAnalysisId = lsaAnalysisId
            self.status = status
        }
    }

}

public struct DescribeFleetAdvisorLsaAnalysisOutput {
    /// A list of FleetAdvisorLsaAnalysisResponse objects.
    public var analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysis = analysis
        self.nextToken = nextToken
    }
}

public struct DescribeFleetAdvisorSchemaObjectSummaryInput {
    /// If you specify any of the following filters, the output includes information for only those schema objects that meet the filter criteria:
    ///
    /// * schema-id – The ID of the schema, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    ///
    /// Example: describe-fleet-advisor-schema-object-summary --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema object in a Fleet Advisor collector inventory.
    public struct FleetAdvisorSchemaObjectResponse {
        /// The number of lines of code in a schema object in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema object in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The number of objects in a schema object in a Fleet Advisor collector inventory.
        public var numberOfObjects: Swift.Int?
        /// The type of the schema object, as reported by the database engine. Examples include the following:
        ///
        /// * function
        ///
        /// * trigger
        ///
        /// * SYSTEM_TABLE
        ///
        /// * QUEUE
        public var objectType: Swift.String?
        /// The ID of a schema object in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?

        public init(
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            numberOfObjects: Swift.Int? = nil,
            objectType: Swift.String? = nil,
            schemaId: Swift.String? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.numberOfObjects = numberOfObjects
            self.objectType = objectType
            self.schemaId = schemaId
        }
    }

}

public struct DescribeFleetAdvisorSchemaObjectSummaryOutput {
    /// A collection of FleetAdvisorSchemaObjectResponse objects.
    public var fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjects
        self.nextToken = nextToken
    }
}

public struct DescribeFleetAdvisorSchemasInput {
    /// If you specify any of the following filters, the output includes information for only those schemas that meet the filter criteria:
    ///
    /// * complexity – The schema's complexity, for example Simple.
    ///
    /// * database-id – The ID of the schema's database.
    ///
    /// * database-ip-address – The IP address of the schema's database.
    ///
    /// * database-name – The name of the schema's database.
    ///
    /// * database-engine – The name of the schema database's engine.
    ///
    /// * original-schema-name – The name of the schema's database's main schema.
    ///
    /// * schema-id – The ID of the schema, for example 15.
    ///
    /// * schema-name – The name of the schema.
    ///
    /// * server-ip-address – The IP address of the schema database's server.
    ///
    ///
    /// An example is: describe-fleet-advisor-schemas --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseShortInfoResponse {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example PostgreSQL.
        public var databaseEngine: Swift.String?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?

        public init(
            databaseEngine: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil
        )
        {
            self.databaseEngine = databaseEngine
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaShortInfoResponse {
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?

        public init(
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
            self.schemaId = schemaId
            self.schemaName = schemaName
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaResponse {
        /// The number of lines of code in a schema in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The complexity level of the code in a schema in a Fleet Advisor collector inventory.
        public var complexity: Swift.String?
        /// The database for a schema in a Fleet Advisor collector inventory.
        public var databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse?
        /// Describes a schema in a Fleet Advisor collector inventory.
        public var originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?
        /// The database server for a schema in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The similarity value for a schema in a Fleet Advisor collector inventory. A higher similarity value indicates that a schema is likely to be a duplicate.
        public var similarity: Swift.Double?

        public init(
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            complexity: Swift.String? = nil,
            databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse? = nil,
            originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            similarity: Swift.Double? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.complexity = complexity
            self.databaseInstance = databaseInstance
            self.originalSchema = originalSchema
            self.schemaId = schemaId
            self.schemaName = schemaName
            self.server = server
            self.similarity = similarity
        }
    }

}

public struct DescribeFleetAdvisorSchemasOutput {
    /// A collection of SchemaResponse objects.
    public var fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemas = fleetAdvisorSchemas
        self.nextToken = nextToken
    }
}

public struct DescribeInstanceProfilesInput {
    /// Filters applied to the instance profiles described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

public struct DescribeInstanceProfilesOutput {
    /// A description of instance profiles.
    public var instanceProfiles: [DatabaseMigrationClientTypes.InstanceProfile]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [DatabaseMigrationClientTypes.InstanceProfile]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.marker = marker
    }
}

public struct DescribeMetadataModelAssessmentsInput {
    /// Filters applied to the metadata model assessments described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The name or Amazon Resource Name (ARN) of the migration project.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeMetadataModelAssessmentsOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model assessments for the specified migration project.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeMetadataModelConversionsInput {
    /// Filters applied to the metadata model conversions described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeMetadataModelConversionsOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model conversions.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeMetadataModelExportsAsScriptInput {
    /// Filters applied to the metadata model exports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeMetadataModelExportsAsScriptOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model exports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeMetadataModelExportsToTargetInput {
    /// Filters applied to the metadata model exports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeMetadataModelExportsToTargetOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model exports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeMetadataModelImportsInput {
    /// Filters applied to the metadata model imports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model imports.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct DescribeMetadataModelImportsOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model imports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

public struct DescribeMigrationProjectsInput {
    /// Filters applied to the migration projects described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

public struct DescribeMigrationProjectsOutput {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A description of migration projects.
    public var migrationProjects: [DatabaseMigrationClientTypes.MigrationProject]?

    public init(
        marker: Swift.String? = nil,
        migrationProjects: [DatabaseMigrationClientTypes.MigrationProject]? = nil
    )
    {
        self.marker = marker
        self.migrationProjects = migrationProjects
    }
}

///
public struct DescribeOrderableReplicationInstancesInput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to the DescribeOrderableReplicationInstances operation, this object describes an available replication instance. This description includes the replication instance's type, engine version, and allocated storage.
    public struct OrderableReplicationInstance {
        /// List of Availability Zones for this replication instance.
        public var availabilityZones: [Swift.String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public var defaultAllocatedStorage: Swift.Int
        /// The version of the replication engine.
        public var engineVersion: Swift.String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var includedAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var maxAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var minAllocatedStorage: Swift.Int
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected. DMS supports the ReleaseStatus parameter in versions 3.1.4 and later.
        public var releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The type of storage used by the replication instance.
        public var storageType: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            defaultAllocatedStorage: Swift.Int = 0,
            engineVersion: Swift.String? = nil,
            includedAllocatedStorage: Swift.Int = 0,
            maxAllocatedStorage: Swift.Int = 0,
            minAllocatedStorage: Swift.Int = 0,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            replicationInstanceClass: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }
    }

}

///
public struct DescribeOrderableReplicationInstancesOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The order-able replication instances available.
    public var orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?

    public init(
        marker: Swift.String? = nil,
        orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.orderableReplicationInstances = orderableReplicationInstances
    }
}

///
public struct DescribePendingMaintenanceActionsInput {
    ///
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

///
public struct DescribePendingMaintenanceActionsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The pending maintenance action.
    public var pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?

    public init(
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

public struct DescribeRecommendationLimitationsInput {
    /// Filters applied to the limitations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the limitations of target Amazon Web Services engines. Your source database might include features that the target Amazon Web Services engine doesn't support. Fleet Advisor lists these features as limitations. You should consider these limitations during database migration. For each limitation, Fleet Advisor recommends an action that you can take to address or avoid this limitation.
    public struct Limitation {
        /// The identifier of the source database.
        public var databaseId: Swift.String?
        /// A description of the limitation. Provides additional information about the limitation, and includes recommended actions that you can take to address or avoid this limitation.
        public var description: Swift.String?
        /// The name of the target engine that Fleet Advisor should use in the target engine recommendation. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public var engineName: Swift.String?
        /// The impact of the limitation. You can use this parameter to prioritize limitations that you want to address. Valid values include "Blocker", "High", "Medium", and "Low".
        public var impact: Swift.String?
        /// The name of the limitation. Describes unsupported database features, migration action items, and other limitations.
        public var name: Swift.String?
        /// The type of the limitation, such as action required, upgrade required, and limited feature.
        public var type: Swift.String?

        public init(
            databaseId: Swift.String? = nil,
            description: Swift.String? = nil,
            engineName: Swift.String? = nil,
            impact: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.databaseId = databaseId
            self.description = description
            self.engineName = engineName
            self.impact = impact
            self.name = name
            self.type = type
        }
    }

}

public struct DescribeRecommendationLimitationsOutput {
    /// The list of limitations for recommendations of target Amazon Web Services engines.
    public var limitations: [DatabaseMigrationClientTypes.Limitation]?
    /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        limitations: [DatabaseMigrationClientTypes.Limitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limitations = limitations
        self.nextToken = nextToken
    }
}

public struct DescribeRecommendationsInput {
    /// Filters applied to the target engine recommendations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes the requirements to the target engine on Amazon RDS.
    public struct RdsRequirements {
        /// The required deployment option for the Amazon RDS DB instance. Valid values include "MULTI_AZ" for Multi-AZ deployments and "SINGLE_AZ" for Single-AZ deployments.
        public var deploymentOption: Swift.String?
        /// The required target Amazon RDS engine edition.
        public var engineEdition: Swift.String?
        /// The required target Amazon RDS engine version.
        public var engineVersion: Swift.String?
        /// The required memory on the Amazon RDS DB instance.
        public var instanceMemory: Swift.Double?
        /// The required number of virtual CPUs (vCPU) on the Amazon RDS DB instance.
        public var instanceVcpu: Swift.Double?
        /// The required number of I/O operations completed each second (IOPS) on your Amazon RDS DB instance.
        public var storageIops: Swift.Int?
        /// The required Amazon RDS DB instance storage size.
        public var storageSize: Swift.Int?

        public init(
            deploymentOption: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceMemory: Swift.Double? = nil,
            instanceVcpu: Swift.Double? = nil,
            storageIops: Swift.Int? = nil,
            storageSize: Swift.Int? = nil
        )
        {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes the configuration of the recommended target engine on Amazon RDS.
    public struct RdsConfiguration {
        /// Describes the deployment option for the recommended Amazon RDS DB instance. The deployment options include Multi-AZ and Single-AZ deployments. Valid values include "MULTI_AZ" and "SINGLE_AZ".
        public var deploymentOption: Swift.String?
        /// Describes the recommended target Amazon RDS engine edition.
        public var engineEdition: Swift.String?
        /// Describes the recommended target Amazon RDS engine version.
        public var engineVersion: Swift.String?
        /// Describes the memory on the recommended Amazon RDS DB instance that meets your requirements.
        public var instanceMemory: Swift.Double?
        /// Describes the recommended target Amazon RDS instance type.
        public var instanceType: Swift.String?
        /// Describes the number of virtual CPUs (vCPU) on the recommended Amazon RDS DB instance that meets your requirements.
        public var instanceVcpu: Swift.Double?
        /// Describes the number of I/O operations completed each second (IOPS) on the recommended Amazon RDS DB instance that meets your requirements.
        public var storageIops: Swift.Int?
        /// Describes the storage size of the recommended Amazon RDS DB instance that meets your requirements.
        public var storageSize: Swift.Int?
        /// Describes the storage type of the recommended Amazon RDS DB instance that meets your requirements. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2 and gp3), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard).
        public var storageType: Swift.String?

        public init(
            deploymentOption: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceMemory: Swift.Double? = nil,
            instanceType: Swift.String? = nil,
            instanceVcpu: Swift.Double? = nil,
            storageIops: Swift.Int? = nil,
            storageSize: Swift.Int? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceType = instanceType
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
            self.storageType = storageType
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a recommendation of a target engine on Amazon RDS.
    public struct RdsRecommendation {
        /// Supplemental information about the requirements to the recommended target database on Amazon RDS.
        public var requirementsToTarget: DatabaseMigrationClientTypes.RdsRequirements?
        /// Supplemental information about the configuration of the recommended target database on Amazon RDS.
        public var targetConfiguration: DatabaseMigrationClientTypes.RdsConfiguration?

        public init(
            requirementsToTarget: DatabaseMigrationClientTypes.RdsRequirements? = nil,
            targetConfiguration: DatabaseMigrationClientTypes.RdsConfiguration? = nil
        )
        {
            self.requirementsToTarget = requirementsToTarget
            self.targetConfiguration = targetConfiguration
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information about the target engine for the specified source database.
    public struct RecommendationData {
        /// The recommendation of a target Amazon RDS database engine.
        public var rdsEngine: DatabaseMigrationClientTypes.RdsRecommendation?

        public init(
            rdsEngine: DatabaseMigrationClientTypes.RdsRecommendation? = nil
        )
        {
            self.rdsEngine = rdsEngine
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a recommendation of a target engine. A recommendation is a set of possible Amazon Web Services target engines that you can choose to migrate your source on-premises database. In this set, Fleet Advisor suggests a single target engine as the right sized migration destination. To determine this rightsized migration destination, Fleet Advisor uses the inventory metadata and metrics from data collector. You can use recommendations before the start of migration to save costs and reduce risks. With recommendations, you can explore different target options and compare metrics, so you can make an informed decision when you choose the migration target.
    public struct Recommendation {
        /// The date when Fleet Advisor created the target engine recommendation.
        public var createdDate: Swift.String?
        /// The recommendation of a target engine for the specified source database.
        public var data: DatabaseMigrationClientTypes.RecommendationData?
        /// The identifier of the source database for which Fleet Advisor provided this recommendation.
        public var databaseId: Swift.String?
        /// The name of the target engine. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public var engineName: Swift.String?
        /// Indicates that this target is the rightsized migration destination.
        public var preferred: Swift.Bool?
        /// The settings in JSON format for the preferred target engine parameters. These parameters include capacity, resource utilization, and the usage type (production, development, or testing).
        public var settings: DatabaseMigrationClientTypes.RecommendationSettings?
        /// The status of the target engine recommendation. Valid values include "alternate", "in-progress", "not-viable", and "recommended".
        public var status: Swift.String?

        public init(
            createdDate: Swift.String? = nil,
            data: DatabaseMigrationClientTypes.RecommendationData? = nil,
            databaseId: Swift.String? = nil,
            engineName: Swift.String? = nil,
            preferred: Swift.Bool? = nil,
            settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.data = data
            self.databaseId = databaseId
            self.engineName = engineName
            self.preferred = preferred
            self.settings = settings
            self.status = status
        }
    }

}

public struct DescribeRecommendationsOutput {
    /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The list of recommendations of target engines that Fleet Advisor created for the source database.
    public var recommendations: [DatabaseMigrationClientTypes.Recommendation]?

    public init(
        nextToken: Swift.String? = nil,
        recommendations: [DatabaseMigrationClientTypes.Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

///
public struct DescribeRefreshSchemasStatusInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension DatabaseMigrationClientTypes {

    public enum RefreshSchemasStatusTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case refreshing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [RefreshSchemasStatusTypeValue] {
            return [
                .failed,
                .refreshing,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .refreshing: return "refreshing"
            case .successful: return "successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes status of a schema at an endpoint specified by the DescribeRefreshSchemaStatus operation.
    public struct RefreshSchemasStatus {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The last failure message for the schema.
        public var lastFailureMessage: Swift.String?
        /// The date the schema was last refreshed.
        public var lastRefreshDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The status of the schema.
        public var status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue?

        public init(
            endpointArn: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastRefreshDate: Foundation.Date? = nil,
            replicationInstanceArn: Swift.String? = nil,
            status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue? = nil
        )
        {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }
    }

}

///
public struct DescribeRefreshSchemasStatusOutput {
    /// The status of the schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init(
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

///
public struct DescribeReplicationConfigsInput {
    /// Filters applied to the replication configs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeReplicationConfigsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// Returned configuration parameters that describe each provisioned DMS Serverless replication.
    public var replicationConfigs: [DatabaseMigrationClientTypes.ReplicationConfig]?

    public init(
        marker: Swift.String? = nil,
        replicationConfigs: [DatabaseMigrationClientTypes.ReplicationConfig]? = nil
    )
    {
        self.marker = marker
        self.replicationConfigs = replicationConfigs
    }
}

///
public struct DescribeReplicationInstancesInput {
    /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeReplicationInstancesOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The replication instances described.
    public var replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?

    public init(
        marker: Swift.String? = nil,
        replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.replicationInstances = replicationInstances
    }
}

public struct DescribeReplicationInstanceTaskLogsInput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

extension DatabaseMigrationClientTypes {
    /// Contains metadata for a replication instance task log.
    public struct ReplicationInstanceTaskLog {
        /// The size, in bytes, of the replication task log.
        public var replicationInstanceTaskLogSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The name of the replication task.
        public var replicationTaskName: Swift.String?

        public init(
            replicationInstanceTaskLogSize: Swift.Int = 0,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskName: Swift.String? = nil
        )
        {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }
    }

}

public struct DescribeReplicationInstanceTaskLogsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?
    /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes).
    public var replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?

    public init(
        marker: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
    )
    {
        self.marker = marker
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
    }
}

///
public struct DescribeReplicationsInput {
    /// Filters applied to the replications.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {
    /// Information about provisioning resources for an DMS serverless replication.
    public struct ProvisionData {
        /// The timestamp when provisioning became available.
        public var dateNewProvisioningDataAvailable: Foundation.Date?
        /// The timestamp when DMS provisioned replication resources.
        public var dateProvisioned: Foundation.Date?
        /// Whether the new provisioning is available to the replication.
        public var isNewProvisioningAvailable: Swift.Bool
        /// The current provisioning state
        public var provisionState: Swift.String?
        /// The number of capacity units the replication is using.
        public var provisionedCapacityUnits: Swift.Int
        /// A message describing the reason that DMS provisioned new resources for the serverless replication.
        public var reasonForNewProvisioningData: Swift.String?

        public init(
            dateNewProvisioningDataAvailable: Foundation.Date? = nil,
            dateProvisioned: Foundation.Date? = nil,
            isNewProvisioningAvailable: Swift.Bool = false,
            provisionState: Swift.String? = nil,
            provisionedCapacityUnits: Swift.Int = 0,
            reasonForNewProvisioningData: Swift.String? = nil
        )
        {
            self.dateNewProvisioningDataAvailable = dateNewProvisioningDataAvailable
            self.dateProvisioned = dateProvisioned
            self.isNewProvisioningAvailable = isNewProvisioningAvailable
            self.provisionState = provisionState
            self.provisionedCapacityUnits = provisionedCapacityUnits
            self.reasonForNewProvisioningData = reasonForNewProvisioningData
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// This object provides a collection of statistics about a serverless replication.
    public struct ReplicationStats {
        /// The elapsed time of the replication, in milliseconds.
        public var elapsedTimeMillis: Swift.Int
        /// The date the replication was started either with a fresh start or a target reload.
        public var freshStartDate: Foundation.Date?
        /// The date the replication full load was finished.
        public var fullLoadFinishDate: Foundation.Date?
        /// The percent complete for the full load serverless replication.
        public var fullLoadProgressPercent: Swift.Int
        /// The date the replication full load was started.
        public var fullLoadStartDate: Foundation.Date?
        /// The date the replication is scheduled to start.
        public var startDate: Foundation.Date?
        /// The date the replication was stopped.
        public var stopDate: Foundation.Date?
        /// The number of errors that have occured for this replication.
        public var tablesErrored: Swift.Int
        /// The number of tables loaded for this replication.
        public var tablesLoaded: Swift.Int
        /// The number of tables currently loading for this replication.
        public var tablesLoading: Swift.Int
        /// The number of tables queued for this replication.
        public var tablesQueued: Swift.Int

        public init(
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: Foundation.Date? = nil,
            fullLoadFinishDate: Foundation.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil,
            stopDate: Foundation.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a serverless replication created by the CreateReplication operation.
    public struct Replication {
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public var cdcStartPosition: Swift.String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public var cdcStartTime: Foundation.Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
        public var cdcStopPosition: Swift.String?
        /// Error and other information about why a serverless replication failed.
        public var failureMessages: [Swift.String]?
        /// Information about provisioning resources for an DMS serverless replication.
        public var provisionData: DatabaseMigrationClientTypes.ProvisionData?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public var recoveryCheckpoint: Swift.String?
        /// The Amazon Resource Name for the ReplicationConfig associated with the replication.
        public var replicationConfigArn: Swift.String?
        /// The identifier for the ReplicationConfig associated with the replication.
        public var replicationConfigIdentifier: Swift.String?
        /// The time the serverless replication was created.
        public var replicationCreateTime: Foundation.Date?
        /// The timestamp when DMS will deprovision the replication.
        public var replicationDeprovisionTime: Foundation.Date?
        /// The timestamp when replication was last stopped.
        public var replicationLastStopTime: Foundation.Date?
        /// This object provides a collection of statistics about a serverless replication.
        public var replicationStats: DatabaseMigrationClientTypes.ReplicationStats?
        /// The type of the serverless replication.
        public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// The time the serverless replication was updated.
        public var replicationUpdateTime: Foundation.Date?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data source.
        public var sourceEndpointArn: Swift.String?
        /// The replication type.
        public var startReplicationType: Swift.String?
        /// The current status of the serverless replication.
        public var status: Swift.String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:
        ///
        /// * "Stop Reason NORMAL"
        ///
        /// * "Stop Reason RECOVERABLE_ERROR"
        ///
        /// * "Stop Reason FATAL_ERROR"
        ///
        /// * "Stop Reason FULL_LOAD_ONLY_FINISHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_FULL_LOAD" – Full load completed, with cached changes not applied
        ///
        /// * "Stop Reason STOPPED_AFTER_CACHED_EVENTS" – Full load completed, with cached changes applied
        ///
        /// * "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_DDL_APPLY" – User-defined stop task after DDL applied
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_DISK"
        ///
        /// * "Stop Reason STOPPED_AT_SERVER_TIME" – User-defined server time for stopping task
        ///
        /// * "Stop Reason STOPPED_AT_COMMIT_TIME" – User-defined commit time for stopping task
        ///
        /// * "Stop Reason RECONFIGURATION_RESTART"
        ///
        /// * "Stop Reason RECYCLE_TASK"
        public var stopReason: Swift.String?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data target.
        public var targetEndpointArn: Swift.String?

        public init(
            cdcStartPosition: Swift.String? = nil,
            cdcStartTime: Foundation.Date? = nil,
            cdcStopPosition: Swift.String? = nil,
            failureMessages: [Swift.String]? = nil,
            provisionData: DatabaseMigrationClientTypes.ProvisionData? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationConfigArn: Swift.String? = nil,
            replicationConfigIdentifier: Swift.String? = nil,
            replicationCreateTime: Foundation.Date? = nil,
            replicationDeprovisionTime: Foundation.Date? = nil,
            replicationLastStopTime: Foundation.Date? = nil,
            replicationStats: DatabaseMigrationClientTypes.ReplicationStats? = nil,
            replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            replicationUpdateTime: Foundation.Date? = nil,
            sourceEndpointArn: Swift.String? = nil,
            startReplicationType: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.failureMessages = failureMessages
            self.provisionData = provisionData
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationCreateTime = replicationCreateTime
            self.replicationDeprovisionTime = replicationDeprovisionTime
            self.replicationLastStopTime = replicationLastStopTime
            self.replicationStats = replicationStats
            self.replicationType = replicationType
            self.replicationUpdateTime = replicationUpdateTime
            self.sourceEndpointArn = sourceEndpointArn
            self.startReplicationType = startReplicationType
            self.status = status
            self.stopReason = stopReason
            self.targetEndpointArn = targetEndpointArn
        }
    }

}

///
public struct DescribeReplicationsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The replication descriptions.
    public var replications: [DatabaseMigrationClientTypes.Replication]?

    public init(
        marker: Swift.String? = nil,
        replications: [DatabaseMigrationClientTypes.Replication]? = nil
    )
    {
        self.marker = marker
        self.replications = replications
    }
}

///
public struct DescribeReplicationSubnetGroupsInput {
    /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeReplicationSubnetGroupsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication subnet groups.
    public var replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?

    public init(
        marker: Swift.String? = nil,
        replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
    )
    {
        self.marker = marker
        self.replicationSubnetGroups = replicationSubnetGroups
    }
}

///
public struct DescribeReplicationTableStatisticsInput {
    /// Filters applied to the replication table statistics.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?
    /// The replication config to describe.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationConfigArn = replicationConfigArn
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides a collection of table statistics in response to a request by the DescribeTableStatistics operation.
    public struct TableStatistics {
        /// The number of data definition language (DDL) statements used to build and modify the structure of your tables applied on the target.
        public var appliedDdls: Swift.Int?
        /// The number of delete actions applied on a target table.
        public var appliedDeletes: Swift.Int?
        /// The number of insert actions applied on a target table.
        public var appliedInserts: Swift.Int?
        /// The number of update actions applied on a target table.
        public var appliedUpdates: Swift.Int?
        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public var ddls: Swift.Int
        /// The number of delete actions performed on a table.
        public var deletes: Swift.Int
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadCondtnlChkFailedRows: Swift.Int
        /// The time when the full load operation completed.
        public var fullLoadEndTime: Foundation.Date?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadErrorRows: Swift.Int
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public var fullLoadReloaded: Swift.Bool?
        /// The number of rows added during the full load operation.
        public var fullLoadRows: Swift.Int
        /// The time when the full load operation started.
        public var fullLoadStartTime: Foundation.Date?
        /// The number of insert actions performed on a table.
        public var inserts: Swift.Int
        /// The last time a table was updated.
        public var lastUpdateTime: Foundation.Date?
        /// The schema name.
        public var schemaName: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table is being reloaded
        public var tableState: Swift.String?
        /// The number of update actions performed on a table.
        public var updates: Swift.Int
        /// The number of records that failed validation.
        public var validationFailedRecords: Swift.Int
        /// The number of records that have yet to be validated.
        public var validationPendingRecords: Swift.Int
        /// The validation state of the table. This parameter can have the following values:
        ///
        /// * Not enabled – Validation isn't enabled for the table in the migration task.
        ///
        /// * Pending records – Some records in the table are waiting for validation.
        ///
        /// * Mismatched records – Some records in the table don't match between the source and target.
        ///
        /// * Suspended records – Some records in the table couldn't be validated.
        ///
        /// * No primary key –The table couldn't be validated because it has no primary key.
        ///
        /// * Table error – The table wasn't validated because it's in an error state and some data wasn't migrated.
        ///
        /// * Validated – All rows in the table are validated. If the table is updated, the status can change from Validated.
        ///
        /// * Error – The table couldn't be validated because of an unexpected error.
        ///
        /// * Pending validation – The table is waiting validation.
        ///
        /// * Preparing table – Preparing the table enabled in the migration task for validation.
        ///
        /// * Pending revalidation – All rows in the table are pending validation after the table was updated.
        public var validationState: Swift.String?
        /// Additional details about the state of validation.
        public var validationStateDetails: Swift.String?
        /// The number of records that couldn't be validated.
        public var validationSuspendedRecords: Swift.Int

        public init(
            appliedDdls: Swift.Int? = nil,
            appliedDeletes: Swift.Int? = nil,
            appliedInserts: Swift.Int? = nil,
            appliedUpdates: Swift.Int? = nil,
            ddls: Swift.Int = 0,
            deletes: Swift.Int = 0,
            fullLoadCondtnlChkFailedRows: Swift.Int = 0,
            fullLoadEndTime: Foundation.Date? = nil,
            fullLoadErrorRows: Swift.Int = 0,
            fullLoadReloaded: Swift.Bool? = nil,
            fullLoadRows: Swift.Int = 0,
            fullLoadStartTime: Foundation.Date? = nil,
            inserts: Swift.Int = 0,
            lastUpdateTime: Foundation.Date? = nil,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableState: Swift.String? = nil,
            updates: Swift.Int = 0,
            validationFailedRecords: Swift.Int = 0,
            validationPendingRecords: Swift.Int = 0,
            validationState: Swift.String? = nil,
            validationStateDetails: Swift.String? = nil,
            validationSuspendedRecords: Swift.Int = 0
        )
        {
            self.appliedDdls = appliedDdls
            self.appliedDeletes = appliedDeletes
            self.appliedInserts = appliedInserts
            self.appliedUpdates = appliedUpdates
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }
    }

}

///
public struct DescribeReplicationTableStatisticsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name of the replication config.
    public var replicationConfigArn: Swift.String?
    /// Returns table statistics on the replication, including table name, rows inserted, rows updated, and rows deleted.
    public var replicationTableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init(
        marker: Swift.String? = nil,
        replicationConfigArn: Swift.String? = nil,
        replicationTableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationConfigArn = replicationConfigArn
        self.replicationTableStatistics = replicationTableStatistics
    }
}

///
public struct DescribeReplicationTaskAssessmentResultsInput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters.
    public var replicationTaskArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

extension DatabaseMigrationClientTypes {
    /// The task assessment report in JSON format.
    public struct ReplicationTaskAssessmentResult {
        /// The task assessment results in JSON format. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var assessmentResults: Swift.String?
        /// The file containing the results of the task assessment.
        public var assessmentResultsFile: Swift.String?
        /// The status of the task assessment.
        public var assessmentStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The replication task identifier of the task on which the task assessment was run.
        public var replicationTaskIdentifier: Swift.String?
        /// The date the task assessment was completed.
        public var replicationTaskLastAssessmentDate: Foundation.Date?
        /// The URL of the S3 object containing the task assessment results. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var s3ObjectUrl: Swift.String?

        public init(
            assessmentResults: Swift.String? = nil,
            assessmentResultsFile: Swift.String? = nil,
            assessmentStatus: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskLastAssessmentDate: Foundation.Date? = nil,
            s3ObjectUrl: Swift.String? = nil
        )
        {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }
    }

}

///
public struct DescribeReplicationTaskAssessmentResultsOutput {
    /// - The Amazon S3 bucket where the task assessment report is located.
    public var bucketName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The task assessment report.
    public var replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?

    public init(
        bucketName: Swift.String? = nil,
        marker: Swift.String? = nil,
        replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
    )
    {
        self.bucketName = bucketName
        self.marker = marker
        self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsInput {
    /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsOutput {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more premigration assessment runs as specified by Filters.
    public var replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
    }
}

///
public struct DescribeReplicationTaskIndividualAssessmentsInput {
    /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an individual assessment from a premigration assessment run.
    public struct ReplicationTaskIndividualAssessment {
        /// Name of this individual assessment.
        public var individualAssessmentName: Swift.String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public var replicationTaskIndividualAssessmentArn: Swift.String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskIndividualAssessmentStartDate: Foundation.Date?
        /// Individual assessment status. This status can have one of the following values:
        ///
        /// * "cancelled"
        ///
        /// * "error"
        ///
        /// * "failed"
        ///
        /// * "passed"
        ///
        /// * "pending"
        ///
        /// * "running"
        public var status: Swift.String?

        public init(
            individualAssessmentName: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentStartDate: Foundation.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }
    }

}

///
public struct DescribeReplicationTaskIndividualAssessmentsOutput {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more individual assessments as specified by Filters.
    public var replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
    }
}

///
public struct DescribeReplicationTasksInput {
    /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
    public var withoutSettings: Swift.Bool?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        withoutSettings: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.withoutSettings = withoutSettings
    }
}

///
public struct DescribeReplicationTasksOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication tasks.
    public var replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?

    public init(
        marker: Swift.String? = nil,
        replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]? = nil
    )
    {
        self.marker = marker
        self.replicationTasks = replicationTasks
    }
}

///
public struct DescribeSchemasInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        endpointArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.endpointArn = endpointArn
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

///
public struct DescribeSchemasOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The described schema.
    public var schemas: [Swift.String]?

    public init(
        marker: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.schemas = schemas
    }
}

///
public struct DescribeTableStatisticsInput {
    /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 500.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

///
public struct DescribeTableStatisticsOutput {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?
    /// The table statistics.
    public var tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskArn = replicationTaskArn
        self.tableStatistics = tableStatistics
    }
}

extension DatabaseMigrationClientTypes {

    public enum AssessmentReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportType] {
            return [
                .csv,
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .pdf: return "pdf"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ExportMetadataModelAssessmentInput {
    /// The file format of the assessment file.
    public var assessmentReportTypes: [DatabaseMigrationClientTypes.AssessmentReportType]?
    /// The name of the assessment file to create in your Amazon S3 bucket.
    public var fileName: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to assess.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        assessmentReportTypes: [DatabaseMigrationClientTypes.AssessmentReportType]? = nil,
        fileName: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.assessmentReportTypes = assessmentReportTypes
        self.fileName = fileName
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about an exported metadata model assessment.
    public struct ExportMetadataModelAssessmentResultEntry {
        /// The URL for the object containing the exported metadata model assessment.
        public var objectURL: Swift.String?
        /// The object key for the object containing the exported metadata model assessment.
        public var s3ObjectKey: Swift.String?

        public init(
            objectURL: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

public struct ExportMetadataModelAssessmentOutput {
    /// The Amazon S3 details for an assessment exported in CSV format.
    public var csvReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?
    /// The Amazon S3 details for an assessment exported in PDF format.
    public var pdfReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?

    public init(
        csvReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry? = nil,
        pdfReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry? = nil
    )
    {
        self.csvReport = csvReport
        self.pdfReport = pdfReport
    }
}

/// The certificate was not valid.
public struct InvalidCertificateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificateFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ImportCertificateInput {
    /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var certificateIdentifier: Swift.String?
    /// The contents of a .pem file, which contains an X.509 certificate.
    public var certificatePem: Swift.String?
    /// The location of an imported Oracle Wallet certificate for use with SSL. Provide the name of a .sso file using the fileb:// prefix. You can't provide the certificate inline. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
    public var certificateWallet: Foundation.Data?
    /// The tags associated with the certificate.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        certificateIdentifier: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        certificateWallet: Foundation.Data? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.tags = tags
    }
}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificateWallet: \(Swift.String(describing: certificateWallet)), tags: \(Swift.String(describing: tags)), certificatePem: \"CONTENT_REDACTED\")"}
}

public struct ImportCertificateOutput {
    /// The certificate to be uploaded.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init(
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

///
public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the DMS resource to list tags for. This returns a list of keys (names of tags) created for the resource and their associated tag values.
    public var resourceArn: Swift.String?
    /// List of ARNs that identify multiple DMS resources that you want to list tags for. This returns a list of keys (tag names) and their associated tag values. It also returns each tag's associated ResourceArn value, which is the ARN of the resource for which each listed tag is created.
    public var resourceArnList: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceArnList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceArnList = resourceArnList
    }
}

///
public struct ListTagsForResourceOutput {
    /// A list of tags for the resource.
    public var tagList: [DatabaseMigrationClientTypes.Tag]?

    public init(
        tagList: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct ModifyConversionConfigurationInput {
    /// The new conversion configuration.
    /// This member is required.
    public var conversionConfiguration: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        conversionConfiguration: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.conversionConfiguration = conversionConfiguration
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct ModifyConversionConfigurationOutput {
    /// The name or Amazon Resource Name (ARN) of the modified configuration.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct ModifyDataProviderInput {
    /// The identifier of the data provider. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var dataProviderIdentifier: Swift.String?
    /// The name of the data provider.
    public var dataProviderName: Swift.String?
    /// A user-friendly description of the data provider.
    public var description: Swift.String?
    /// The type of database engine for the data provider. Valid values include "aurora", "aurora-postgresql", "mysql", "oracle", "postgres", "sqlserver", redshift, mariadb, mongodb, and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
    public var engine: Swift.String?
    /// If this attribute is Y, the current call to ModifyDataProvider replaces all existing data provider settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyDataProvider does two things:
    ///
    /// * It replaces any data provider settings that already exist with new values, for settings with the same names.
    ///
    /// * It creates new data provider settings that you specify in the call, for settings with different names.
    public var exactSettings: Swift.Bool?
    /// The settings in JSON format for a data provider.
    public var settings: DatabaseMigrationClientTypes.DataProviderSettings?

    public init(
        dataProviderIdentifier: Swift.String? = nil,
        dataProviderName: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        exactSettings: Swift.Bool? = nil,
        settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil
    )
    {
        self.dataProviderIdentifier = dataProviderIdentifier
        self.dataProviderName = dataProviderName
        self.description = description
        self.engine = engine
        self.exactSettings = exactSettings
        self.settings = settings
    }
}

public struct ModifyDataProviderOutput {
    /// The data provider that was modified.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

///
public struct ModifyEndpointInput {
    /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Attributes include the following:
    ///
    /// * serviceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Settings in JSON format for the source DocumentDB endpoint. For more information about the available settings, see the configuration properties section in [ Using DocumentDB as a Target for Database Migration Service ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html) in the Database Migration Service User Guide.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
    public var engineName: Swift.String?
    /// If this attribute is Y, the current call to ModifyEndpoint replaces all existing endpoint settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyEndpoint does two things:
    ///
    /// * It replaces any endpoint settings that already exist with new values, for settings with the same names.
    ///
    /// * It creates new endpoint settings that you specify in the call, for settings with different names.
    ///
    ///
    /// For example, if you call create-endpoint ... --endpoint-settings '{"a":1}' ..., the endpoint has the following endpoint settings: '{"a":1}'. If you then call modify-endpoint ... --endpoint-settings '{"b":2}' ... for the same endpoint, the endpoint has the following settings: '{"a":1,"b":2}'. However, suppose that you follow this with a call to modify-endpoint ... --endpoint-settings '{"b":2}' --exact-settings ... for that same endpoint again. Then the endpoint has the following settings: '{"b":2}'. All existing settings are replaced with the exact settings that you specify.
    public var exactSettings: Swift.Bool?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to login to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the Redis target endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the IAM role you want to use to modify the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The SSL mode used to connect to the endpoint. The default value is none.
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// Settings in JSON format for the target Amazon Timestream endpoint.
    public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
    /// The user name to be used to login to the endpoint database.
    public var username: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointArn: Swift.String? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        exactSettings: Swift.Bool? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.exactSettings = exactSettings
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.timestreamSettings = timestreamSettings
        self.username = username
    }
}

extension ModifyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), exactSettings: \(Swift.String(describing: exactSettings)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), timestreamSettings: \(Swift.String(describing: timestreamSettings)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

///
public struct ModifyEndpointOutput {
    /// The modified endpoint.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

///
public struct ModifyEventSubscriptionInput {
    /// A Boolean value; set to true to activate the subscription.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    public var snsTopicArn: Swift.String?
    /// The type of DMS resource that generates the events you want to subscribe to. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription to be modified.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init(
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

///
public struct ModifyEventSubscriptionOutput {
    /// The modified event subscription.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

public struct ModifyInstanceProfileInput {
    /// The Availability Zone where the instance profile runs.
    public var availabilityZone: Swift.String?
    /// A user-friendly description for the instance profile.
    public var description: Swift.String?
    /// The identifier of the instance profile. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?
    /// A user-friendly name for the instance profile.
    public var instanceProfileName: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyArn: Swift.String?
    /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
    public var networkType: Swift.String?
    /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// A subnet group to associate with the instance profile.
    public var subnetGroupIdentifier: Swift.String?
    /// Specifies the VPC security groups to be used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
    public var vpcSecurityGroups: [Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        instanceProfileName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        networkType: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        subnetGroupIdentifier: Swift.String? = nil,
        vpcSecurityGroups: [Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.instanceProfileName = instanceProfileName
        self.kmsKeyArn = kmsKeyArn
        self.networkType = networkType
        self.publiclyAccessible = publiclyAccessible
        self.subnetGroupIdentifier = subnetGroupIdentifier
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

public struct ModifyInstanceProfileOutput {
    /// The instance profile that was modified.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

public struct ModifyMigrationProjectInput {
    /// A user-friendly description of the migration project.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) for the instance profile.
    public var instanceProfileIdentifier: Swift.String?
    /// The identifier of the migration project. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A user-friendly name for the migration project.
    public var migrationProjectName: Swift.String?
    /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
    public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
    /// Information about the source data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
    public var transformationRules: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        migrationProjectName: Swift.String? = nil,
        schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
        sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        transformationRules: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.migrationProjectName = migrationProjectName
        self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
        self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
        self.targetDataProviderDescriptors = targetDataProviderDescriptors
        self.transformationRules = transformationRules
    }
}

public struct ModifyMigrationProjectOutput {
    /// The migration project that was modified.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

///
public struct ModifyReplicationConfigInput {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    /// The Amazon Resource Name of the replication to modify.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The new replication config to apply to the replication.
    public var replicationConfigIdentifier: Swift.String?
    /// The settings for the replication.
    public var replicationSettings: Swift.String?
    /// The type of replication.
    public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
    public var sourceEndpointArn: Swift.String?
    /// Additional settings for the replication.
    public var supplementalSettings: Swift.String?
    /// Table mappings specified in the replication.
    public var tableMappings: Swift.String?
    /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
    public var targetEndpointArn: Swift.String?

    public init(
        computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
        replicationConfigArn: Swift.String? = nil,
        replicationConfigIdentifier: Swift.String? = nil,
        replicationSettings: Swift.String? = nil,
        replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        sourceEndpointArn: Swift.String? = nil,
        supplementalSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        targetEndpointArn: Swift.String? = nil
    )
    {
        self.computeConfig = computeConfig
        self.replicationConfigArn = replicationConfigArn
        self.replicationConfigIdentifier = replicationConfigIdentifier
        self.replicationSettings = replicationSettings
        self.replicationType = replicationType
        self.sourceEndpointArn = sourceEndpointArn
        self.supplementalSettings = supplementalSettings
        self.tableMappings = tableMappings
        self.targetEndpointArn = targetEndpointArn
    }
}

public struct ModifyReplicationConfigOutput {
    /// Information about the serverless replication config that was modified.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

/// An upgrade dependency is preventing the database migration.
public struct UpgradeDependencyFailureFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpgradeDependencyFailureFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ModifyReplicationInstanceInput {
    /// The amount of storage (in gigabytes) to be allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
    public var allowMajorVersionUpgrade: Swift.Bool?
    /// Indicates whether the changes should be applied immediately or during the next maintenance window.
    public var applyImmediately: Swift.Bool?
    /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case described following. The change is asynchronously applied as soon as possible. An outage does result if these factors apply:
    ///
    /// * This parameter is set to true during the maintenance window.
    ///
    /// * A newer minor version is available.
    ///
    /// * DMS has enabled automatic patching for the given engine version.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
    public var engineVersion: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
    public var preferredMaintenanceWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string.
    public var replicationInstanceIdentifier: Swift.String?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool? = false,
        applyImmediately: Swift.Bool? = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

///
public struct ModifyReplicationInstanceOutput {
    /// The modified replication instance.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

/// The specified subnet is already in use.
public struct SubnetAlreadyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetAlreadyInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ModifyReplicationSubnetGroupInput {
    /// A description for the replication instance subnet group.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name of the replication instance subnet group.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A list of subnet IDs.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init(
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
    }
}

///
public struct ModifyReplicationSubnetGroupOutput {
    /// The modified replication subnet group.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init(
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

///
public struct ModifyReplicationTaskInput {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: Foundation.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time:2018-02-09T12:12:12“
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The replication task identifier. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    public var replicationTaskIdentifier: Swift.String?
    /// JSON file that contains settings for the task, such as task metadata settings.
    public var replicationTaskSettings: Swift.String?
    /// When using the CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. For example, --table-mappings file://mappingfile.json. When working with the DMS API, provide the JSON as the parameter value.
    public var tableMappings: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: Foundation.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.tableMappings = tableMappings
        self.taskData = taskData
    }
}

///
public struct ModifyReplicationTaskOutput {
    /// The replication task that was modified.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

///
public struct MoveReplicationTaskInput {
    /// The Amazon Resource Name (ARN) of the task that you want to move.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The ARN of the replication instance where you want to move the task to.
    /// This member is required.
    public var targetReplicationInstanceArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil,
        targetReplicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
    }
}

///
public struct MoveReplicationTaskOutput {
    /// The replication task that was moved.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

public struct RebootReplicationInstanceInput {
    /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. If the instance isn't configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forceFailover: Swift.Bool?
    /// If this parameter is true, the reboot is conducted through a planned Multi-AZ failover where resources are released and cleaned up prior to conducting the failover. If the instance isn''t configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forcePlannedFailover: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        forceFailover: Swift.Bool? = nil,
        forcePlannedFailover: Swift.Bool? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.forceFailover = forceFailover
        self.forcePlannedFailover = forcePlannedFailover
        self.replicationInstanceArn = replicationInstanceArn
    }
}

public struct RebootReplicationInstanceOutput {
    /// The replication instance that is being rebooted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

///
public struct RefreshSchemasInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

///
public struct RefreshSchemasOutput {
    /// The status of the refreshed schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init(
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

extension DatabaseMigrationClientTypes {

    public enum ReloadOptionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataReload
        case validateOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReloadOptionValue] {
            return [
                .dataReload,
                .validateOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataReload: return "data-reload"
            case .validateOnly: return "validate-only"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides the name of the schema and table to be reloaded.
    public struct TableToReload {
        /// The schema name of the table to be reloaded.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The table name of the table to be reloaded.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.schemaName = schemaName
            self.tableName = tableName
        }
    }

}

///
public struct ReloadReplicationTablesInput {
    /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the replication.
    public var reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// The Amazon Resource Name of the replication config for which to reload tables.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The list of tables to reload.
    /// This member is required.
    public var tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init(
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationConfigArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationConfigArn = replicationConfigArn
        self.tablesToReload = tablesToReload
    }
}

///
public struct ReloadReplicationTablesOutput {
    /// The Amazon Resource Name of the replication config for which to reload tables.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

public struct ReloadTablesInput {
    /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task. Valid values: data-reload, validate-only Default value is data-reload.
    public var reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The name and schema of the table to be reloaded.
    /// This member is required.
    public var tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init(
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationTaskArn = replicationTaskArn
        self.tablesToReload = tablesToReload
    }
}

public struct ReloadTablesOutput {
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

/// Removes one or more tags from an DMS resource.
public struct RemoveTagsFromResourceInput {
    /// An DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

///
public struct RemoveTagsFromResourceOutput {

    public init() { }
}

public struct RunFleetAdvisorLsaAnalysisOutput {
    /// The ID of the LSA analysis run.
    public var lsaAnalysisId: Swift.String?
    /// The status of the LSA analysis, for example COMPLETED.
    public var status: Swift.String?

    public init(
        lsaAnalysisId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.lsaAnalysisId = lsaAnalysisId
        self.status = status
    }
}

public struct StartExtensionPackAssociationInput {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

public struct StartExtensionPackAssociationOutput {
    /// The identifier for the request operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

public struct StartMetadataModelAssessmentInput {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to assess.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

public struct StartMetadataModelAssessmentOutput {
    /// The identifier for the assessment operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

public struct StartMetadataModelConversionInput {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to convert.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

public struct StartMetadataModelConversionOutput {
    /// The identifier for the conversion operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

extension DatabaseMigrationClientTypes {

    public enum OriginTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginTypeValue] {
            return [
                .source,
                .target
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartMetadataModelExportAsScriptInput {
    /// The name of the model file to create in the Amazon S3 bucket.
    public var fileName: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to export the metadata model from the source or the target.
    /// This member is required.
    public var origin: DatabaseMigrationClientTypes.OriginTypeValue?
    /// A value that specifies the database objects to export.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        fileName: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        origin: DatabaseMigrationClientTypes.OriginTypeValue? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.origin = origin
        self.selectionRules = selectionRules
    }
}

public struct StartMetadataModelExportAsScriptOutput {
    /// The identifier for the export operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

public struct StartMetadataModelExportToTargetInput {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to overwrite the migration project extension pack. An extension pack is an add-on module that emulates functions present in a source database that are required when converting objects to the target database.
    public var overwriteExtensionPack: Swift.Bool?
    /// A value that specifies the database objects to export.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        overwriteExtensionPack: Swift.Bool? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.overwriteExtensionPack = overwriteExtensionPack
        self.selectionRules = selectionRules
    }
}

public struct StartMetadataModelExportToTargetOutput {
    /// The identifier for the export operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

public struct StartMetadataModelImportInput {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to load metadata to the source or target database.
    /// This member is required.
    public var origin: DatabaseMigrationClientTypes.OriginTypeValue?
    /// If true, DMS loads metadata for the specified objects from the source database.
    public var refresh: Swift.Bool?
    /// A value that specifies the database objects to import.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        origin: DatabaseMigrationClientTypes.OriginTypeValue? = nil,
        refresh: Swift.Bool? = false,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.origin = origin
        self.refresh = refresh
        self.selectionRules = selectionRules
    }
}

public struct StartMetadataModelImportOutput {
    /// The identifier for the import operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

public struct StartRecommendationsInput {
    /// The identifier of the source database to analyze and provide recommendations for.
    /// This member is required.
    public var databaseId: Swift.String?
    /// The settings in JSON format that Fleet Advisor uses to determine target engine recommendations. These parameters include target instance sizing and availability and durability settings. For target instance sizing, Fleet Advisor supports the following two options: total capacity and resource utilization. For availability and durability, Fleet Advisor supports the following two options: production (Multi-AZ deployments) and Dev/Test (Single-AZ deployments).
    /// This member is required.
    public var settings: DatabaseMigrationClientTypes.RecommendationSettings?

    public init(
        databaseId: Swift.String? = nil,
        settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil
    )
    {
        self.databaseId = databaseId
        self.settings = settings
    }
}

///
public struct StartReplicationInput {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format.
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
    public var cdcStartTime: Foundation.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
    public var cdcStopPosition: Swift.String?
    /// The Amazon Resource Name of the replication for which to start replication.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The replication type.
    /// This member is required.
    public var startReplicationType: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: Foundation.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationConfigArn: Swift.String? = nil,
        startReplicationType: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationConfigArn = replicationConfigArn
        self.startReplicationType = startReplicationType
    }
}

///
public struct StartReplicationOutput {
    /// The replication that DMS started.
    public var replication: DatabaseMigrationClientTypes.Replication?

    public init(
        replication: DatabaseMigrationClientTypes.Replication? = nil
    )
    {
        self.replication = replication
    }
}

extension DatabaseMigrationClientTypes {

    public enum StartReplicationTaskTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reloadTarget
        case resumeProcessing
        case startReplication
        case sdkUnknown(Swift.String)

        public static var allCases: [StartReplicationTaskTypeValue] {
            return [
                .reloadTarget,
                .resumeProcessing,
                .startReplication
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reloadTarget: return "reload-target"
            case .resumeProcessing: return "resume-processing"
            case .startReplication: return "start-replication"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct StartReplicationTaskInput {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: Foundation.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time:2018-02-09T12:12:12“
    public var cdcStopPosition: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task to be started.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The type of replication task to start. When the migration type is full-load or full-load-and-cdc, the only valid value for the first run of the task is start-replication. This option will start the migration. You can also use [ReloadTables] to reload specific tables that failed during migration instead of restarting the task. The resume-processing option isn't applicable for a full-load task, because you can't resume partially loaded tables during the full load phase. For a full-load-and-cdc task, DMS migrates table data, and then applies data changes that occur on the source. To load all the tables again, and start capturing source changes, use reload-target. Otherwise use resume-processing, to replicate the changes from the last stop position.
    /// This member is required.
    public var startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: Foundation.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationTaskArn = replicationTaskArn
        self.startReplicationTaskType = startReplicationTaskType
    }
}

///
public struct StartReplicationTaskOutput {
    /// The replication task started.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

///
public struct StartReplicationTaskAssessmentInput {
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

///
public struct StartReplicationTaskAssessmentOutput {
    /// The assessed replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

/// An Key Management Service (KMS) error is preventing access to KMS.
public struct KMSFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSFault" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct StartReplicationTaskAssessmentRunInput {
    /// Unique name to identify the assessment run.
    /// This member is required.
    public var assessmentRunName: Swift.String?
    /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var exclude: [Swift.String]?
    /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var includeOnly: [Swift.String]?
    /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, DMS stores the assessment run results without encryption. You can specify one of the options following:
    ///
    /// * "SSE_S3" – The server-side encryption provided as a default by Amazon S3.
    ///
    /// * "SSE_KMS" – Key Management Service (KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.
    public var resultEncryptionMode: Swift.String?
    /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
    public var resultKmsKeyArn: Swift.String?
    /// Amazon S3 bucket where you want DMS to store the results of this assessment run.
    /// This member is required.
    public var resultLocationBucket: Swift.String?
    /// Folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.
    public var resultLocationFolder: Swift.String?
    /// ARN of the service role needed to start the assessment run. The role must allow the iam:PassRole action.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        assessmentRunName: Swift.String? = nil,
        exclude: [Swift.String]? = nil,
        includeOnly: [Swift.String]? = nil,
        replicationTaskArn: Swift.String? = nil,
        resultEncryptionMode: Swift.String? = nil,
        resultKmsKeyArn: Swift.String? = nil,
        resultLocationBucket: Swift.String? = nil,
        resultLocationFolder: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.exclude = exclude
        self.includeOnly = includeOnly
        self.replicationTaskArn = replicationTaskArn
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

///
public struct StartReplicationTaskAssessmentRunOutput {
    /// The premigration assessment run that was started.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

///
public struct StopReplicationInput {
    /// The Amazon Resource Name of the replication to stop.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

public struct StopReplicationOutput {
    /// The replication that DMS stopped.
    public var replication: DatabaseMigrationClientTypes.Replication?

    public init(
        replication: DatabaseMigrationClientTypes.Replication? = nil
    )
    {
        self.replication = replication
    }
}

///
public struct StopReplicationTaskInput {
    /// The Amazon Resource Name(ARN) of the replication task to be stopped.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

///
public struct StopReplicationTaskOutput {
    /// The replication task stopped.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

///
public struct TestConnectionInput {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

///
public struct TestConnectionOutput {
    /// The connection tested.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init(
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

///
public struct UpdateSubscriptionsToEventBridgeInput {
    /// When set to true, this operation migrates DMS subscriptions for Amazon SNS notifications no matter what your replication instance version is. If not set or set to false, this operation runs only when all your replication instances are from DMS version 3.4.5 or higher.
    public var forceMove: Swift.Bool?

    public init(
        forceMove: Swift.Bool? = nil
    )
    {
        self.forceMove = forceMove
    }
}

///
public struct UpdateSubscriptionsToEventBridgeOutput {
    /// A string that indicates how many event subscriptions were migrated and how many remain to be migrated.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

extension AddTagsToResourceInput {

    static func urlPathProvider(_ value: AddTagsToResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ApplyPendingMaintenanceActionInput {

    static func urlPathProvider(_ value: ApplyPendingMaintenanceActionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchStartRecommendationsInput {

    static func urlPathProvider(_ value: BatchStartRecommendationsInput) -> Swift.String? {
        return "/"
    }
}

extension CancelReplicationTaskAssessmentRunInput {

    static func urlPathProvider(_ value: CancelReplicationTaskAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDataProviderInput {

    static func urlPathProvider(_ value: CreateDataProviderInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEndpointInput {

    static func urlPathProvider(_ value: CreateEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEventSubscriptionInput {

    static func urlPathProvider(_ value: CreateEventSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFleetAdvisorCollectorInput {

    static func urlPathProvider(_ value: CreateFleetAdvisorCollectorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceProfileInput {

    static func urlPathProvider(_ value: CreateInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMigrationProjectInput {

    static func urlPathProvider(_ value: CreateMigrationProjectInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReplicationConfigInput {

    static func urlPathProvider(_ value: CreateReplicationConfigInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReplicationInstanceInput {

    static func urlPathProvider(_ value: CreateReplicationInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReplicationSubnetGroupInput {

    static func urlPathProvider(_ value: CreateReplicationSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReplicationTaskInput {

    static func urlPathProvider(_ value: CreateReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCertificateInput {

    static func urlPathProvider(_ value: DeleteCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectionInput {

    static func urlPathProvider(_ value: DeleteConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDataProviderInput {

    static func urlPathProvider(_ value: DeleteDataProviderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEndpointInput {

    static func urlPathProvider(_ value: DeleteEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventSubscriptionInput {

    static func urlPathProvider(_ value: DeleteEventSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFleetAdvisorCollectorInput {

    static func urlPathProvider(_ value: DeleteFleetAdvisorCollectorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFleetAdvisorDatabasesInput {

    static func urlPathProvider(_ value: DeleteFleetAdvisorDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceProfileInput {

    static func urlPathProvider(_ value: DeleteInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMigrationProjectInput {

    static func urlPathProvider(_ value: DeleteMigrationProjectInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationConfigInput {

    static func urlPathProvider(_ value: DeleteReplicationConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationInstanceInput {

    static func urlPathProvider(_ value: DeleteReplicationInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationSubnetGroupInput {

    static func urlPathProvider(_ value: DeleteReplicationSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationTaskInput {

    static func urlPathProvider(_ value: DeleteReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationTaskAssessmentRunInput {

    static func urlPathProvider(_ value: DeleteReplicationTaskAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountAttributesInput {

    static func urlPathProvider(_ value: DescribeAccountAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicableIndividualAssessmentsInput {

    static func urlPathProvider(_ value: DescribeApplicableIndividualAssessmentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCertificatesInput {

    static func urlPathProvider(_ value: DescribeCertificatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionsInput {

    static func urlPathProvider(_ value: DescribeConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConversionConfigurationInput {

    static func urlPathProvider(_ value: DescribeConversionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDataProvidersInput {

    static func urlPathProvider(_ value: DescribeDataProvidersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEndpointsInput {

    static func urlPathProvider(_ value: DescribeEndpointsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEndpointSettingsInput {

    static func urlPathProvider(_ value: DescribeEndpointSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEndpointTypesInput {

    static func urlPathProvider(_ value: DescribeEndpointTypesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEngineVersionsInput {

    static func urlPathProvider(_ value: DescribeEngineVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventCategoriesInput {

    static func urlPathProvider(_ value: DescribeEventCategoriesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventsInput {

    static func urlPathProvider(_ value: DescribeEventsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventSubscriptionsInput {

    static func urlPathProvider(_ value: DescribeEventSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExtensionPackAssociationsInput {

    static func urlPathProvider(_ value: DescribeExtensionPackAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetAdvisorCollectorsInput {

    static func urlPathProvider(_ value: DescribeFleetAdvisorCollectorsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetAdvisorDatabasesInput {

    static func urlPathProvider(_ value: DescribeFleetAdvisorDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput {

    static func urlPathProvider(_ value: DescribeFleetAdvisorLsaAnalysisInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput {

    static func urlPathProvider(_ value: DescribeFleetAdvisorSchemaObjectSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFleetAdvisorSchemasInput {

    static func urlPathProvider(_ value: DescribeFleetAdvisorSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceProfilesInput {

    static func urlPathProvider(_ value: DescribeInstanceProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetadataModelAssessmentsInput {

    static func urlPathProvider(_ value: DescribeMetadataModelAssessmentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetadataModelConversionsInput {

    static func urlPathProvider(_ value: DescribeMetadataModelConversionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetadataModelExportsAsScriptInput {

    static func urlPathProvider(_ value: DescribeMetadataModelExportsAsScriptInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetadataModelExportsToTargetInput {

    static func urlPathProvider(_ value: DescribeMetadataModelExportsToTargetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMetadataModelImportsInput {

    static func urlPathProvider(_ value: DescribeMetadataModelImportsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMigrationProjectsInput {

    static func urlPathProvider(_ value: DescribeMigrationProjectsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrderableReplicationInstancesInput {

    static func urlPathProvider(_ value: DescribeOrderableReplicationInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePendingMaintenanceActionsInput {

    static func urlPathProvider(_ value: DescribePendingMaintenanceActionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRecommendationLimitationsInput {

    static func urlPathProvider(_ value: DescribeRecommendationLimitationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRecommendationsInput {

    static func urlPathProvider(_ value: DescribeRecommendationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRefreshSchemasStatusInput {

    static func urlPathProvider(_ value: DescribeRefreshSchemasStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationConfigsInput {

    static func urlPathProvider(_ value: DescribeReplicationConfigsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationInstancesInput {

    static func urlPathProvider(_ value: DescribeReplicationInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationInstanceTaskLogsInput {

    static func urlPathProvider(_ value: DescribeReplicationInstanceTaskLogsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationsInput {

    static func urlPathProvider(_ value: DescribeReplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationSubnetGroupsInput {

    static func urlPathProvider(_ value: DescribeReplicationSubnetGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationTableStatisticsInput {

    static func urlPathProvider(_ value: DescribeReplicationTableStatisticsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationTaskAssessmentResultsInput {

    static func urlPathProvider(_ value: DescribeReplicationTaskAssessmentResultsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationTaskAssessmentRunsInput {

    static func urlPathProvider(_ value: DescribeReplicationTaskAssessmentRunsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput {

    static func urlPathProvider(_ value: DescribeReplicationTaskIndividualAssessmentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReplicationTasksInput {

    static func urlPathProvider(_ value: DescribeReplicationTasksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSchemasInput {

    static func urlPathProvider(_ value: DescribeSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTableStatisticsInput {

    static func urlPathProvider(_ value: DescribeTableStatisticsInput) -> Swift.String? {
        return "/"
    }
}

extension ExportMetadataModelAssessmentInput {

    static func urlPathProvider(_ value: ExportMetadataModelAssessmentInput) -> Swift.String? {
        return "/"
    }
}

extension ImportCertificateInput {

    static func urlPathProvider(_ value: ImportCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyConversionConfigurationInput {

    static func urlPathProvider(_ value: ModifyConversionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyDataProviderInput {

    static func urlPathProvider(_ value: ModifyDataProviderInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyEndpointInput {

    static func urlPathProvider(_ value: ModifyEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyEventSubscriptionInput {

    static func urlPathProvider(_ value: ModifyEventSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyInstanceProfileInput {

    static func urlPathProvider(_ value: ModifyInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyMigrationProjectInput {

    static func urlPathProvider(_ value: ModifyMigrationProjectInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyReplicationConfigInput {

    static func urlPathProvider(_ value: ModifyReplicationConfigInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyReplicationInstanceInput {

    static func urlPathProvider(_ value: ModifyReplicationInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyReplicationSubnetGroupInput {

    static func urlPathProvider(_ value: ModifyReplicationSubnetGroupInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyReplicationTaskInput {

    static func urlPathProvider(_ value: ModifyReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension MoveReplicationTaskInput {

    static func urlPathProvider(_ value: MoveReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension RebootReplicationInstanceInput {

    static func urlPathProvider(_ value: RebootReplicationInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension RefreshSchemasInput {

    static func urlPathProvider(_ value: RefreshSchemasInput) -> Swift.String? {
        return "/"
    }
}

extension ReloadReplicationTablesInput {

    static func urlPathProvider(_ value: ReloadReplicationTablesInput) -> Swift.String? {
        return "/"
    }
}

extension ReloadTablesInput {

    static func urlPathProvider(_ value: ReloadTablesInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveTagsFromResourceInput {

    static func urlPathProvider(_ value: RemoveTagsFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RunFleetAdvisorLsaAnalysisInput {

    static func urlPathProvider(_ value: RunFleetAdvisorLsaAnalysisInput) -> Swift.String? {
        return "/"
    }
}

extension StartExtensionPackAssociationInput {

    static func urlPathProvider(_ value: StartExtensionPackAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension StartMetadataModelAssessmentInput {

    static func urlPathProvider(_ value: StartMetadataModelAssessmentInput) -> Swift.String? {
        return "/"
    }
}

extension StartMetadataModelConversionInput {

    static func urlPathProvider(_ value: StartMetadataModelConversionInput) -> Swift.String? {
        return "/"
    }
}

extension StartMetadataModelExportAsScriptInput {

    static func urlPathProvider(_ value: StartMetadataModelExportAsScriptInput) -> Swift.String? {
        return "/"
    }
}

extension StartMetadataModelExportToTargetInput {

    static func urlPathProvider(_ value: StartMetadataModelExportToTargetInput) -> Swift.String? {
        return "/"
    }
}

extension StartMetadataModelImportInput {

    static func urlPathProvider(_ value: StartMetadataModelImportInput) -> Swift.String? {
        return "/"
    }
}

extension StartRecommendationsInput {

    static func urlPathProvider(_ value: StartRecommendationsInput) -> Swift.String? {
        return "/"
    }
}

extension StartReplicationInput {

    static func urlPathProvider(_ value: StartReplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StartReplicationTaskInput {

    static func urlPathProvider(_ value: StartReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartReplicationTaskAssessmentInput {

    static func urlPathProvider(_ value: StartReplicationTaskAssessmentInput) -> Swift.String? {
        return "/"
    }
}

extension StartReplicationTaskAssessmentRunInput {

    static func urlPathProvider(_ value: StartReplicationTaskAssessmentRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopReplicationInput {

    static func urlPathProvider(_ value: StopReplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StopReplicationTaskInput {

    static func urlPathProvider(_ value: StopReplicationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension TestConnectionInput {

    static func urlPathProvider(_ value: TestConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSubscriptionsToEventBridgeInput {

    static func urlPathProvider(_ value: UpdateSubscriptionsToEventBridgeInput) -> Swift.String? {
        return "/"
    }
}

extension AddTagsToResourceInput {

    static func write(value: AddTagsToResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ApplyPendingMaintenanceActionInput {

    static func write(value: ApplyPendingMaintenanceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyAction"].write(value.applyAction)
        try writer["OptInType"].write(value.optInType)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension BatchStartRecommendationsInput {

    static func write(value: BatchStartRecommendationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Data"].writeList(value.data, memberWritingClosure: DatabaseMigrationClientTypes.StartRecommendationsRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelReplicationTaskAssessmentRunInput {

    static func write(value: CancelReplicationTaskAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskAssessmentRunArn"].write(value.replicationTaskAssessmentRunArn)
    }
}

extension CreateDataProviderInput {

    static func write(value: CreateDataProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataProviderName"].write(value.dataProviderName)
        try writer["Description"].write(value.description)
        try writer["Engine"].write(value.engine)
        try writer["Settings"].write(value.settings, with: DatabaseMigrationClientTypes.DataProviderSettings.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEndpointInput {

    static func write(value: CreateEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DmsTransferSettings"].write(value.dmsTransferSettings, with: DatabaseMigrationClientTypes.DmsTransferSettings.write(value:to:))
        try writer["DocDbSettings"].write(value.docDbSettings, with: DatabaseMigrationClientTypes.DocDbSettings.write(value:to:))
        try writer["DynamoDbSettings"].write(value.dynamoDbSettings, with: DatabaseMigrationClientTypes.DynamoDbSettings.write(value:to:))
        try writer["ElasticsearchSettings"].write(value.elasticsearchSettings, with: DatabaseMigrationClientTypes.ElasticsearchSettings.write(value:to:))
        try writer["EndpointIdentifier"].write(value.endpointIdentifier)
        try writer["EndpointType"].write(value.endpointType)
        try writer["EngineName"].write(value.engineName)
        try writer["ExternalTableDefinition"].write(value.externalTableDefinition)
        try writer["ExtraConnectionAttributes"].write(value.extraConnectionAttributes)
        try writer["GcpMySQLSettings"].write(value.gcpMySQLSettings, with: DatabaseMigrationClientTypes.GcpMySQLSettings.write(value:to:))
        try writer["IBMDb2Settings"].write(value.ibmDb2Settings, with: DatabaseMigrationClientTypes.IBMDb2Settings.write(value:to:))
        try writer["KafkaSettings"].write(value.kafkaSettings, with: DatabaseMigrationClientTypes.KafkaSettings.write(value:to:))
        try writer["KinesisSettings"].write(value.kinesisSettings, with: DatabaseMigrationClientTypes.KinesisSettings.write(value:to:))
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MicrosoftSQLServerSettings"].write(value.microsoftSQLServerSettings, with: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.write(value:to:))
        try writer["MongoDbSettings"].write(value.mongoDbSettings, with: DatabaseMigrationClientTypes.MongoDbSettings.write(value:to:))
        try writer["MySQLSettings"].write(value.mySQLSettings, with: DatabaseMigrationClientTypes.MySQLSettings.write(value:to:))
        try writer["NeptuneSettings"].write(value.neptuneSettings, with: DatabaseMigrationClientTypes.NeptuneSettings.write(value:to:))
        try writer["OracleSettings"].write(value.oracleSettings, with: DatabaseMigrationClientTypes.OracleSettings.write(value:to:))
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["PostgreSQLSettings"].write(value.postgreSQLSettings, with: DatabaseMigrationClientTypes.PostgreSQLSettings.write(value:to:))
        try writer["RedisSettings"].write(value.redisSettings, with: DatabaseMigrationClientTypes.RedisSettings.write(value:to:))
        try writer["RedshiftSettings"].write(value.redshiftSettings, with: DatabaseMigrationClientTypes.RedshiftSettings.write(value:to:))
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["S3Settings"].write(value.s3Settings, with: DatabaseMigrationClientTypes.S3Settings.write(value:to:))
        try writer["ServerName"].write(value.serverName)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["SslMode"].write(value.sslMode)
        try writer["SybaseSettings"].write(value.sybaseSettings, with: DatabaseMigrationClientTypes.SybaseSettings.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimestreamSettings"].write(value.timestreamSettings, with: DatabaseMigrationClientTypes.TimestreamSettings.write(value:to:))
        try writer["Username"].write(value.username)
    }
}

extension CreateEventSubscriptionInput {

    static func write(value: CreateEventSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["EventCategories"].writeList(value.eventCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SourceIds"].writeList(value.sourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["SubscriptionName"].write(value.subscriptionName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFleetAdvisorCollectorInput {

    static func write(value: CreateFleetAdvisorCollectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectorName"].write(value.collectorName)
        try writer["Description"].write(value.description)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
    }
}

extension CreateInstanceProfileInput {

    static func write(value: CreateInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["Description"].write(value.description)
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["NetworkType"].write(value.networkType)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["SubnetGroupIdentifier"].write(value.subnetGroupIdentifier)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMigrationProjectInput {

    static func write(value: CreateMigrationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InstanceProfileIdentifier"].write(value.instanceProfileIdentifier)
        try writer["MigrationProjectName"].write(value.migrationProjectName)
        try writer["SchemaConversionApplicationAttributes"].write(value.schemaConversionApplicationAttributes, with: DatabaseMigrationClientTypes.SCApplicationAttributes.write(value:to:))
        try writer["SourceDataProviderDescriptors"].writeList(value.sourceDataProviderDescriptors, memberWritingClosure: DatabaseMigrationClientTypes.DataProviderDescriptorDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetDataProviderDescriptors"].writeList(value.targetDataProviderDescriptors, memberWritingClosure: DatabaseMigrationClientTypes.DataProviderDescriptorDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransformationRules"].write(value.transformationRules)
    }
}

extension CreateReplicationConfigInput {

    static func write(value: CreateReplicationConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputeConfig"].write(value.computeConfig, with: DatabaseMigrationClientTypes.ComputeConfig.write(value:to:))
        try writer["ReplicationConfigIdentifier"].write(value.replicationConfigIdentifier)
        try writer["ReplicationSettings"].write(value.replicationSettings)
        try writer["ReplicationType"].write(value.replicationType)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["SourceEndpointArn"].write(value.sourceEndpointArn)
        try writer["SupplementalSettings"].write(value.supplementalSettings)
        try writer["TableMappings"].write(value.tableMappings)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetEndpointArn"].write(value.targetEndpointArn)
    }
}

extension CreateReplicationInstanceInput {

    static func write(value: CreateReplicationInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["DnsNameServers"].write(value.dnsNameServers)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["NetworkType"].write(value.networkType)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["ReplicationInstanceClass"].write(value.replicationInstanceClass)
        try writer["ReplicationInstanceIdentifier"].write(value.replicationInstanceIdentifier)
        try writer["ReplicationSubnetGroupIdentifier"].write(value.replicationSubnetGroupIdentifier)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateReplicationSubnetGroupInput {

    static func write(value: CreateReplicationSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationSubnetGroupDescription"].write(value.replicationSubnetGroupDescription)
        try writer["ReplicationSubnetGroupIdentifier"].write(value.replicationSubnetGroupIdentifier)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateReplicationTaskInput {

    static func write(value: CreateReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcStartPosition"].write(value.cdcStartPosition)
        try writer["CdcStartTime"].writeTimestamp(value.cdcStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CdcStopPosition"].write(value.cdcStopPosition)
        try writer["MigrationType"].write(value.migrationType)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
        try writer["ReplicationTaskIdentifier"].write(value.replicationTaskIdentifier)
        try writer["ReplicationTaskSettings"].write(value.replicationTaskSettings)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["SourceEndpointArn"].write(value.sourceEndpointArn)
        try writer["TableMappings"].write(value.tableMappings)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetEndpointArn"].write(value.targetEndpointArn)
        try writer["TaskData"].write(value.taskData)
    }
}

extension DeleteCertificateInput {

    static func write(value: DeleteCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
    }
}

extension DeleteConnectionInput {

    static func write(value: DeleteConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension DeleteDataProviderInput {

    static func write(value: DeleteDataProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataProviderIdentifier"].write(value.dataProviderIdentifier)
    }
}

extension DeleteEndpointInput {

    static func write(value: DeleteEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
    }
}

extension DeleteEventSubscriptionInput {

    static func write(value: DeleteEventSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionName"].write(value.subscriptionName)
    }
}

extension DeleteFleetAdvisorCollectorInput {

    static func write(value: DeleteFleetAdvisorCollectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectorReferencedId"].write(value.collectorReferencedId)
    }
}

extension DeleteFleetAdvisorDatabasesInput {

    static func write(value: DeleteFleetAdvisorDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseIds"].writeList(value.databaseIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteInstanceProfileInput {

    static func write(value: DeleteInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceProfileIdentifier"].write(value.instanceProfileIdentifier)
    }
}

extension DeleteMigrationProjectInput {

    static func write(value: DeleteMigrationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DeleteReplicationConfigInput {

    static func write(value: DeleteReplicationConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
    }
}

extension DeleteReplicationInstanceInput {

    static func write(value: DeleteReplicationInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension DeleteReplicationSubnetGroupInput {

    static func write(value: DeleteReplicationSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationSubnetGroupIdentifier"].write(value.replicationSubnetGroupIdentifier)
    }
}

extension DeleteReplicationTaskInput {

    static func write(value: DeleteReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
    }
}

extension DeleteReplicationTaskAssessmentRunInput {

    static func write(value: DeleteReplicationTaskAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskAssessmentRunArn"].write(value.replicationTaskAssessmentRunArn)
    }
}

extension DescribeAccountAttributesInput {

    static func write(value: DescribeAccountAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeApplicableIndividualAssessmentsInput {

    static func write(value: DescribeApplicableIndividualAssessmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationType"].write(value.migrationType)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["SourceEngineName"].write(value.sourceEngineName)
        try writer["TargetEngineName"].write(value.targetEngineName)
    }
}

extension DescribeCertificatesInput {

    static func write(value: DescribeCertificatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeConnectionsInput {

    static func write(value: DescribeConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeConversionConfigurationInput {

    static func write(value: DescribeConversionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeDataProvidersInput {

    static func write(value: DescribeDataProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeEndpointsInput {

    static func write(value: DescribeEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeEndpointSettingsInput {

    static func write(value: DescribeEndpointSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineName"].write(value.engineName)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeEndpointTypesInput {

    static func write(value: DescribeEndpointTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeEngineVersionsInput {

    static func write(value: DescribeEngineVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeEventCategoriesInput {

    static func write(value: DescribeEventCategoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
    }
}

extension DescribeEventsInput {

    static func write(value: DescribeEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EventCategories"].writeList(value.eventCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["SourceIdentifier"].write(value.sourceIdentifier)
        try writer["SourceType"].write(value.sourceType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DescribeEventSubscriptionsInput {

    static func write(value: DescribeEventSubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["SubscriptionName"].write(value.subscriptionName)
    }
}

extension DescribeExtensionPackAssociationsInput {

    static func write(value: DescribeExtensionPackAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeFleetAdvisorCollectorsInput {

    static func write(value: DescribeFleetAdvisorCollectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeFleetAdvisorDatabasesInput {

    static func write(value: DescribeFleetAdvisorDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput {

    static func write(value: DescribeFleetAdvisorLsaAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput {

    static func write(value: DescribeFleetAdvisorSchemaObjectSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeFleetAdvisorSchemasInput {

    static func write(value: DescribeFleetAdvisorSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstanceProfilesInput {

    static func write(value: DescribeInstanceProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeMetadataModelAssessmentsInput {

    static func write(value: DescribeMetadataModelAssessmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeMetadataModelConversionsInput {

    static func write(value: DescribeMetadataModelConversionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeMetadataModelExportsAsScriptInput {

    static func write(value: DescribeMetadataModelExportsAsScriptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeMetadataModelExportsToTargetInput {

    static func write(value: DescribeMetadataModelExportsToTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeMetadataModelImportsInput {

    static func write(value: DescribeMetadataModelImportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension DescribeMigrationProjectsInput {

    static func write(value: DescribeMigrationProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeOrderableReplicationInstancesInput {

    static func write(value: DescribeOrderableReplicationInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribePendingMaintenanceActionsInput {

    static func write(value: DescribePendingMaintenanceActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension DescribeRecommendationLimitationsInput {

    static func write(value: DescribeRecommendationLimitationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeRecommendationsInput {

    static func write(value: DescribeRecommendationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeRefreshSchemasStatusInput {

    static func write(value: DescribeRefreshSchemasStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
    }
}

extension DescribeReplicationConfigsInput {

    static func write(value: DescribeReplicationConfigsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationInstancesInput {

    static func write(value: DescribeReplicationInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationInstanceTaskLogsInput {

    static func write(value: DescribeReplicationInstanceTaskLogsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension DescribeReplicationsInput {

    static func write(value: DescribeReplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationSubnetGroupsInput {

    static func write(value: DescribeReplicationSubnetGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationTableStatisticsInput {

    static func write(value: DescribeReplicationTableStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
    }
}

extension DescribeReplicationTaskAssessmentResultsInput {

    static func write(value: DescribeReplicationTaskAssessmentResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
    }
}

extension DescribeReplicationTaskAssessmentRunsInput {

    static func write(value: DescribeReplicationTaskAssessmentRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput {

    static func write(value: DescribeReplicationTaskIndividualAssessmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeReplicationTasksInput {

    static func write(value: DescribeReplicationTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["WithoutSettings"].write(value.withoutSettings)
    }
}

extension DescribeSchemasInput {

    static func write(value: DescribeSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
    }
}

extension DescribeTableStatisticsInput {

    static func write(value: DescribeTableStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: DatabaseMigrationClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["MaxRecords"].write(value.maxRecords)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
    }
}

extension ExportMetadataModelAssessmentInput {

    static func write(value: ExportMetadataModelAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssessmentReportTypes"].writeList(value.assessmentReportTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DatabaseMigrationClientTypes.AssessmentReportType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FileName"].write(value.fileName)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension ImportCertificateInput {

    static func write(value: ImportCertificateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateIdentifier"].write(value.certificateIdentifier)
        try writer["CertificatePem"].write(value.certificatePem)
        try writer["CertificateWallet"].write(value.certificateWallet)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DatabaseMigrationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceArnList"].writeList(value.resourceArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ModifyConversionConfigurationInput {

    static func write(value: ModifyConversionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConversionConfiguration"].write(value.conversionConfiguration)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension ModifyDataProviderInput {

    static func write(value: ModifyDataProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataProviderIdentifier"].write(value.dataProviderIdentifier)
        try writer["DataProviderName"].write(value.dataProviderName)
        try writer["Description"].write(value.description)
        try writer["Engine"].write(value.engine)
        try writer["ExactSettings"].write(value.exactSettings)
        try writer["Settings"].write(value.settings, with: DatabaseMigrationClientTypes.DataProviderSettings.write(value:to:))
    }
}

extension ModifyEndpointInput {

    static func write(value: ModifyEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DmsTransferSettings"].write(value.dmsTransferSettings, with: DatabaseMigrationClientTypes.DmsTransferSettings.write(value:to:))
        try writer["DocDbSettings"].write(value.docDbSettings, with: DatabaseMigrationClientTypes.DocDbSettings.write(value:to:))
        try writer["DynamoDbSettings"].write(value.dynamoDbSettings, with: DatabaseMigrationClientTypes.DynamoDbSettings.write(value:to:))
        try writer["ElasticsearchSettings"].write(value.elasticsearchSettings, with: DatabaseMigrationClientTypes.ElasticsearchSettings.write(value:to:))
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["EndpointIdentifier"].write(value.endpointIdentifier)
        try writer["EndpointType"].write(value.endpointType)
        try writer["EngineName"].write(value.engineName)
        try writer["ExactSettings"].write(value.exactSettings)
        try writer["ExternalTableDefinition"].write(value.externalTableDefinition)
        try writer["ExtraConnectionAttributes"].write(value.extraConnectionAttributes)
        try writer["GcpMySQLSettings"].write(value.gcpMySQLSettings, with: DatabaseMigrationClientTypes.GcpMySQLSettings.write(value:to:))
        try writer["IBMDb2Settings"].write(value.ibmDb2Settings, with: DatabaseMigrationClientTypes.IBMDb2Settings.write(value:to:))
        try writer["KafkaSettings"].write(value.kafkaSettings, with: DatabaseMigrationClientTypes.KafkaSettings.write(value:to:))
        try writer["KinesisSettings"].write(value.kinesisSettings, with: DatabaseMigrationClientTypes.KinesisSettings.write(value:to:))
        try writer["MicrosoftSQLServerSettings"].write(value.microsoftSQLServerSettings, with: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.write(value:to:))
        try writer["MongoDbSettings"].write(value.mongoDbSettings, with: DatabaseMigrationClientTypes.MongoDbSettings.write(value:to:))
        try writer["MySQLSettings"].write(value.mySQLSettings, with: DatabaseMigrationClientTypes.MySQLSettings.write(value:to:))
        try writer["NeptuneSettings"].write(value.neptuneSettings, with: DatabaseMigrationClientTypes.NeptuneSettings.write(value:to:))
        try writer["OracleSettings"].write(value.oracleSettings, with: DatabaseMigrationClientTypes.OracleSettings.write(value:to:))
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["PostgreSQLSettings"].write(value.postgreSQLSettings, with: DatabaseMigrationClientTypes.PostgreSQLSettings.write(value:to:))
        try writer["RedisSettings"].write(value.redisSettings, with: DatabaseMigrationClientTypes.RedisSettings.write(value:to:))
        try writer["RedshiftSettings"].write(value.redshiftSettings, with: DatabaseMigrationClientTypes.RedshiftSettings.write(value:to:))
        try writer["S3Settings"].write(value.s3Settings, with: DatabaseMigrationClientTypes.S3Settings.write(value:to:))
        try writer["ServerName"].write(value.serverName)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["SslMode"].write(value.sslMode)
        try writer["SybaseSettings"].write(value.sybaseSettings, with: DatabaseMigrationClientTypes.SybaseSettings.write(value:to:))
        try writer["TimestreamSettings"].write(value.timestreamSettings, with: DatabaseMigrationClientTypes.TimestreamSettings.write(value:to:))
        try writer["Username"].write(value.username)
    }
}

extension ModifyEventSubscriptionInput {

    static func write(value: ModifyEventSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["EventCategories"].writeList(value.eventCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SourceType"].write(value.sourceType)
        try writer["SubscriptionName"].write(value.subscriptionName)
    }
}

extension ModifyInstanceProfileInput {

    static func write(value: ModifyInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["Description"].write(value.description)
        try writer["InstanceProfileIdentifier"].write(value.instanceProfileIdentifier)
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["NetworkType"].write(value.networkType)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["SubnetGroupIdentifier"].write(value.subnetGroupIdentifier)
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ModifyMigrationProjectInput {

    static func write(value: ModifyMigrationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InstanceProfileIdentifier"].write(value.instanceProfileIdentifier)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["MigrationProjectName"].write(value.migrationProjectName)
        try writer["SchemaConversionApplicationAttributes"].write(value.schemaConversionApplicationAttributes, with: DatabaseMigrationClientTypes.SCApplicationAttributes.write(value:to:))
        try writer["SourceDataProviderDescriptors"].writeList(value.sourceDataProviderDescriptors, memberWritingClosure: DatabaseMigrationClientTypes.DataProviderDescriptorDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetDataProviderDescriptors"].writeList(value.targetDataProviderDescriptors, memberWritingClosure: DatabaseMigrationClientTypes.DataProviderDescriptorDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransformationRules"].write(value.transformationRules)
    }
}

extension ModifyReplicationConfigInput {

    static func write(value: ModifyReplicationConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputeConfig"].write(value.computeConfig, with: DatabaseMigrationClientTypes.ComputeConfig.write(value:to:))
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
        try writer["ReplicationConfigIdentifier"].write(value.replicationConfigIdentifier)
        try writer["ReplicationSettings"].write(value.replicationSettings)
        try writer["ReplicationType"].write(value.replicationType)
        try writer["SourceEndpointArn"].write(value.sourceEndpointArn)
        try writer["SupplementalSettings"].write(value.supplementalSettings)
        try writer["TableMappings"].write(value.tableMappings)
        try writer["TargetEndpointArn"].write(value.targetEndpointArn)
    }
}

extension ModifyReplicationInstanceInput {

    static func write(value: ModifyReplicationInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AllowMajorVersionUpgrade"].write(value.allowMajorVersionUpgrade)
        try writer["ApplyImmediately"].write(value.applyImmediately)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["NetworkType"].write(value.networkType)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
        try writer["ReplicationInstanceClass"].write(value.replicationInstanceClass)
        try writer["ReplicationInstanceIdentifier"].write(value.replicationInstanceIdentifier)
        try writer["VpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ModifyReplicationSubnetGroupInput {

    static func write(value: ModifyReplicationSubnetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationSubnetGroupDescription"].write(value.replicationSubnetGroupDescription)
        try writer["ReplicationSubnetGroupIdentifier"].write(value.replicationSubnetGroupIdentifier)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ModifyReplicationTaskInput {

    static func write(value: ModifyReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcStartPosition"].write(value.cdcStartPosition)
        try writer["CdcStartTime"].writeTimestamp(value.cdcStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CdcStopPosition"].write(value.cdcStopPosition)
        try writer["MigrationType"].write(value.migrationType)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["ReplicationTaskIdentifier"].write(value.replicationTaskIdentifier)
        try writer["ReplicationTaskSettings"].write(value.replicationTaskSettings)
        try writer["TableMappings"].write(value.tableMappings)
        try writer["TaskData"].write(value.taskData)
    }
}

extension MoveReplicationTaskInput {

    static func write(value: MoveReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["TargetReplicationInstanceArn"].write(value.targetReplicationInstanceArn)
    }
}

extension RebootReplicationInstanceInput {

    static func write(value: RebootReplicationInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForceFailover"].write(value.forceFailover)
        try writer["ForcePlannedFailover"].write(value.forcePlannedFailover)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension RefreshSchemasInput {

    static func write(value: RefreshSchemasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension ReloadReplicationTablesInput {

    static func write(value: ReloadReplicationTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReloadOption"].write(value.reloadOption)
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
        try writer["TablesToReload"].writeList(value.tablesToReload, memberWritingClosure: DatabaseMigrationClientTypes.TableToReload.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ReloadTablesInput {

    static func write(value: ReloadTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReloadOption"].write(value.reloadOption)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["TablesToReload"].writeList(value.tablesToReload, memberWritingClosure: DatabaseMigrationClientTypes.TableToReload.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RemoveTagsFromResourceInput {

    static func write(value: RemoveTagsFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RunFleetAdvisorLsaAnalysisInput {

    static func write(value: RunFleetAdvisorLsaAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StartExtensionPackAssociationInput {

    static func write(value: StartExtensionPackAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
    }
}

extension StartMetadataModelAssessmentInput {

    static func write(value: StartMetadataModelAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension StartMetadataModelConversionInput {

    static func write(value: StartMetadataModelConversionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension StartMetadataModelExportAsScriptInput {

    static func write(value: StartMetadataModelExportAsScriptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileName"].write(value.fileName)
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["Origin"].write(value.origin)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension StartMetadataModelExportToTargetInput {

    static func write(value: StartMetadataModelExportToTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["OverwriteExtensionPack"].write(value.overwriteExtensionPack)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension StartMetadataModelImportInput {

    static func write(value: StartMetadataModelImportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MigrationProjectIdentifier"].write(value.migrationProjectIdentifier)
        try writer["Origin"].write(value.origin)
        try writer["Refresh"].write(value.refresh)
        try writer["SelectionRules"].write(value.selectionRules)
    }
}

extension StartRecommendationsInput {

    static func write(value: StartRecommendationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseId"].write(value.databaseId)
        try writer["Settings"].write(value.settings, with: DatabaseMigrationClientTypes.RecommendationSettings.write(value:to:))
    }
}

extension StartReplicationInput {

    static func write(value: StartReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcStartPosition"].write(value.cdcStartPosition)
        try writer["CdcStartTime"].writeTimestamp(value.cdcStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CdcStopPosition"].write(value.cdcStopPosition)
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
        try writer["StartReplicationType"].write(value.startReplicationType)
    }
}

extension StartReplicationTaskInput {

    static func write(value: StartReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcStartPosition"].write(value.cdcStartPosition)
        try writer["CdcStartTime"].writeTimestamp(value.cdcStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["CdcStopPosition"].write(value.cdcStopPosition)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["StartReplicationTaskType"].write(value.startReplicationTaskType)
    }
}

extension StartReplicationTaskAssessmentInput {

    static func write(value: StartReplicationTaskAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
    }
}

extension StartReplicationTaskAssessmentRunInput {

    static func write(value: StartReplicationTaskAssessmentRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssessmentRunName"].write(value.assessmentRunName)
        try writer["Exclude"].writeList(value.exclude, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeOnly"].writeList(value.includeOnly, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
        try writer["ResultEncryptionMode"].write(value.resultEncryptionMode)
        try writer["ResultKmsKeyArn"].write(value.resultKmsKeyArn)
        try writer["ResultLocationBucket"].write(value.resultLocationBucket)
        try writer["ResultLocationFolder"].write(value.resultLocationFolder)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
    }
}

extension StopReplicationInput {

    static func write(value: StopReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationConfigArn"].write(value.replicationConfigArn)
    }
}

extension StopReplicationTaskInput {

    static func write(value: StopReplicationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationTaskArn"].write(value.replicationTaskArn)
    }
}

extension TestConnectionInput {

    static func write(value: TestConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
    }
}

extension UpdateSubscriptionsToEventBridgeInput {

    static func write(value: UpdateSubscriptionsToEventBridgeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForceMove"].write(value.forceMove)
    }
}

extension AddTagsToResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsToResourceOutput {
        return AddTagsToResourceOutput()
    }
}

extension ApplyPendingMaintenanceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApplyPendingMaintenanceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ApplyPendingMaintenanceActionOutput()
        value.resourcePendingMaintenanceActions = try reader["ResourcePendingMaintenanceActions"].readIfPresent(with: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions.read(from:))
        return value
    }
}

extension BatchStartRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchStartRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchStartRecommendationsOutput()
        value.errorEntries = try reader["ErrorEntries"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelReplicationTaskAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelReplicationTaskAssessmentRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelReplicationTaskAssessmentRunOutput()
        value.replicationTaskAssessmentRun = try reader["ReplicationTaskAssessmentRun"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.read(from:))
        return value
    }
}

extension CreateDataProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataProviderOutput()
        value.dataProvider = try reader["DataProvider"].readIfPresent(with: DatabaseMigrationClientTypes.DataProvider.read(from:))
        return value
    }
}

extension CreateEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEndpointOutput()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: DatabaseMigrationClientTypes.Endpoint.read(from:))
        return value
    }
}

extension CreateEventSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventSubscriptionOutput()
        value.eventSubscription = try reader["EventSubscription"].readIfPresent(with: DatabaseMigrationClientTypes.EventSubscription.read(from:))
        return value
    }
}

extension CreateFleetAdvisorCollectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetAdvisorCollectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetAdvisorCollectorOutput()
        value.collectorName = try reader["CollectorName"].readIfPresent()
        value.collectorReferencedId = try reader["CollectorReferencedId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        return value
    }
}

extension CreateInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceProfileOutput()
        value.instanceProfile = try reader["InstanceProfile"].readIfPresent(with: DatabaseMigrationClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension CreateMigrationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMigrationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMigrationProjectOutput()
        value.migrationProject = try reader["MigrationProject"].readIfPresent(with: DatabaseMigrationClientTypes.MigrationProject.read(from:))
        return value
    }
}

extension CreateReplicationConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationConfigOutput()
        value.replicationConfig = try reader["ReplicationConfig"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationConfig.read(from:))
        return value
    }
}

extension CreateReplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationInstanceOutput()
        value.replicationInstance = try reader["ReplicationInstance"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationInstance.read(from:))
        return value
    }
}

extension CreateReplicationSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationSubnetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationSubnetGroupOutput()
        value.replicationSubnetGroup = try reader["ReplicationSubnetGroup"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationSubnetGroup.read(from:))
        return value
    }
}

extension CreateReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension DeleteCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCertificateOutput()
        value.certificate = try reader["Certificate"].readIfPresent(with: DatabaseMigrationClientTypes.Certificate.read(from:))
        return value
    }
}

extension DeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: DatabaseMigrationClientTypes.Connection.read(from:))
        return value
    }
}

extension DeleteDataProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataProviderOutput()
        value.dataProvider = try reader["DataProvider"].readIfPresent(with: DatabaseMigrationClientTypes.DataProvider.read(from:))
        return value
    }
}

extension DeleteEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEndpointOutput()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: DatabaseMigrationClientTypes.Endpoint.read(from:))
        return value
    }
}

extension DeleteEventSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventSubscriptionOutput()
        value.eventSubscription = try reader["EventSubscription"].readIfPresent(with: DatabaseMigrationClientTypes.EventSubscription.read(from:))
        return value
    }
}

extension DeleteFleetAdvisorCollectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetAdvisorCollectorOutput {
        return DeleteFleetAdvisorCollectorOutput()
    }
}

extension DeleteFleetAdvisorDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetAdvisorDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFleetAdvisorDatabasesOutput()
        value.databaseIds = try reader["DatabaseIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInstanceProfileOutput()
        value.instanceProfile = try reader["InstanceProfile"].readIfPresent(with: DatabaseMigrationClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension DeleteMigrationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMigrationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMigrationProjectOutput()
        value.migrationProject = try reader["MigrationProject"].readIfPresent(with: DatabaseMigrationClientTypes.MigrationProject.read(from:))
        return value
    }
}

extension DeleteReplicationConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteReplicationConfigOutput()
        value.replicationConfig = try reader["ReplicationConfig"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationConfig.read(from:))
        return value
    }
}

extension DeleteReplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteReplicationInstanceOutput()
        value.replicationInstance = try reader["ReplicationInstance"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationInstance.read(from:))
        return value
    }
}

extension DeleteReplicationSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationSubnetGroupOutput {
        return DeleteReplicationSubnetGroupOutput()
    }
}

extension DeleteReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension DeleteReplicationTaskAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationTaskAssessmentRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteReplicationTaskAssessmentRunOutput()
        value.replicationTaskAssessmentRun = try reader["ReplicationTaskAssessmentRun"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.read(from:))
        return value
    }
}

extension DescribeAccountAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAttributesOutput()
        value.accountQuotas = try reader["AccountQuotas"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.AccountQuota.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.uniqueAccountIdentifier = try reader["UniqueAccountIdentifier"].readIfPresent()
        return value
    }
}

extension DescribeApplicableIndividualAssessmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicableIndividualAssessmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicableIndividualAssessmentsOutput()
        value.individualAssessmentNames = try reader["IndividualAssessmentNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeCertificatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCertificatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCertificatesOutput()
        value.certificates = try reader["Certificates"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Certificate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionsOutput()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeConversionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConversionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConversionConfigurationOutput()
        value.conversionConfiguration = try reader["ConversionConfiguration"].readIfPresent()
        value.migrationProjectIdentifier = try reader["MigrationProjectIdentifier"].readIfPresent()
        return value
    }
}

extension DescribeDataProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataProvidersOutput()
        value.dataProviders = try reader["DataProviders"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.DataProvider.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointsOutput()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Endpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeEndpointSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointSettingsOutput()
        value.endpointSettings = try reader["EndpointSettings"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.EndpointSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeEndpointTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEndpointTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEndpointTypesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.supportedEndpointTypes = try reader["SupportedEndpointTypes"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SupportedEndpointType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEngineVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEngineVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEngineVersionsOutput()
        value.engineVersions = try reader["EngineVersions"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.EngineVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeEventCategoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventCategoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventCategoriesOutput()
        value.eventCategoryGroupList = try reader["EventCategoryGroupList"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.EventCategoryGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventsOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeEventSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventSubscriptionsOutput()
        value.eventSubscriptionsList = try reader["EventSubscriptionsList"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.EventSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeExtensionPackAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExtensionPackAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExtensionPackAssociationsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeFleetAdvisorCollectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetAdvisorCollectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetAdvisorCollectorsOutput()
        value.collectors = try reader["Collectors"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.CollectorResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeFleetAdvisorDatabasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetAdvisorDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetAdvisorDatabasesOutput()
        value.databases = try reader["Databases"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.DatabaseResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeFleetAdvisorLsaAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetAdvisorLsaAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetAdvisorLsaAnalysisOutput()
        value.analysis = try reader["Analysis"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetAdvisorSchemaObjectSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetAdvisorSchemaObjectSummaryOutput()
        value.fleetAdvisorSchemaObjects = try reader["FleetAdvisorSchemaObjects"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeFleetAdvisorSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFleetAdvisorSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFleetAdvisorSchemasOutput()
        value.fleetAdvisorSchemas = try reader["FleetAdvisorSchemas"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstanceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceProfilesOutput()
        value.instanceProfiles = try reader["InstanceProfiles"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.InstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeMetadataModelAssessmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetadataModelAssessmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetadataModelAssessmentsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMetadataModelConversionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetadataModelConversionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetadataModelConversionsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMetadataModelExportsAsScriptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetadataModelExportsAsScriptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetadataModelExportsAsScriptOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMetadataModelExportsToTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetadataModelExportsToTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetadataModelExportsToTargetOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMetadataModelImportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetadataModelImportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetadataModelImportsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.requests = try reader["Requests"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.SchemaConversionRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMigrationProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMigrationProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMigrationProjectsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.migrationProjects = try reader["MigrationProjects"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.MigrationProject.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOrderableReplicationInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrderableReplicationInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrderableReplicationInstancesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.orderableReplicationInstances = try reader["OrderableReplicationInstances"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.OrderableReplicationInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePendingMaintenanceActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePendingMaintenanceActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePendingMaintenanceActionsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.pendingMaintenanceActions = try reader["PendingMaintenanceActions"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRecommendationLimitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecommendationLimitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecommendationLimitationsOutput()
        value.limitations = try reader["Limitations"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Limitation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecommendationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.recommendations = try reader["Recommendations"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Recommendation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRefreshSchemasStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRefreshSchemasStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRefreshSchemasStatusOutput()
        value.refreshSchemasStatus = try reader["RefreshSchemasStatus"].readIfPresent(with: DatabaseMigrationClientTypes.RefreshSchemasStatus.read(from:))
        return value
    }
}

extension DescribeReplicationConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationConfigsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationConfigs = try reader["ReplicationConfigs"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationInstancesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationInstances = try reader["ReplicationInstances"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationInstanceTaskLogsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationInstanceTaskLogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationInstanceTaskLogsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.replicationInstanceTaskLogs = try reader["ReplicationInstanceTaskLogs"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationInstanceTaskLog.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replications = try reader["Replications"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Replication.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationSubnetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationSubnetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationSubnetGroupsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationSubnetGroups = try reader["ReplicationSubnetGroups"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationSubnetGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationTableStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationTableStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationTableStatisticsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationConfigArn = try reader["ReplicationConfigArn"].readIfPresent()
        value.replicationTableStatistics = try reader["ReplicationTableStatistics"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.TableStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationTaskAssessmentResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationTaskAssessmentResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationTaskAssessmentResultsOutput()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationTaskAssessmentResults = try reader["ReplicationTaskAssessmentResults"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationTaskAssessmentRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationTaskAssessmentRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationTaskAssessmentRunsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationTaskAssessmentRuns = try reader["ReplicationTaskAssessmentRuns"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationTaskIndividualAssessmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationTaskIndividualAssessmentsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationTaskIndividualAssessments = try reader["ReplicationTaskIndividualAssessments"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReplicationTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReplicationTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReplicationTasksOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationTasks = try reader["ReplicationTasks"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.ReplicationTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSchemasOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTableStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTableStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTableStatisticsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        value.tableStatistics = try reader["TableStatistics"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.TableStatistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ExportMetadataModelAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportMetadataModelAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportMetadataModelAssessmentOutput()
        value.csvReport = try reader["CsvReport"].readIfPresent(with: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry.read(from:))
        value.pdfReport = try reader["PdfReport"].readIfPresent(with: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry.read(from:))
        return value
    }
}

extension ImportCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportCertificateOutput()
        value.certificate = try reader["Certificate"].readIfPresent(with: DatabaseMigrationClientTypes.Certificate.read(from:))
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ModifyConversionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyConversionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyConversionConfigurationOutput()
        value.migrationProjectIdentifier = try reader["MigrationProjectIdentifier"].readIfPresent()
        return value
    }
}

extension ModifyDataProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyDataProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyDataProviderOutput()
        value.dataProvider = try reader["DataProvider"].readIfPresent(with: DatabaseMigrationClientTypes.DataProvider.read(from:))
        return value
    }
}

extension ModifyEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyEndpointOutput()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: DatabaseMigrationClientTypes.Endpoint.read(from:))
        return value
    }
}

extension ModifyEventSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyEventSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyEventSubscriptionOutput()
        value.eventSubscription = try reader["EventSubscription"].readIfPresent(with: DatabaseMigrationClientTypes.EventSubscription.read(from:))
        return value
    }
}

extension ModifyInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyInstanceProfileOutput()
        value.instanceProfile = try reader["InstanceProfile"].readIfPresent(with: DatabaseMigrationClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension ModifyMigrationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyMigrationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyMigrationProjectOutput()
        value.migrationProject = try reader["MigrationProject"].readIfPresent(with: DatabaseMigrationClientTypes.MigrationProject.read(from:))
        return value
    }
}

extension ModifyReplicationConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyReplicationConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyReplicationConfigOutput()
        value.replicationConfig = try reader["ReplicationConfig"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationConfig.read(from:))
        return value
    }
}

extension ModifyReplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyReplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyReplicationInstanceOutput()
        value.replicationInstance = try reader["ReplicationInstance"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationInstance.read(from:))
        return value
    }
}

extension ModifyReplicationSubnetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyReplicationSubnetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyReplicationSubnetGroupOutput()
        value.replicationSubnetGroup = try reader["ReplicationSubnetGroup"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationSubnetGroup.read(from:))
        return value
    }
}

extension ModifyReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ModifyReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension MoveReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> MoveReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = MoveReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension RebootReplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebootReplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RebootReplicationInstanceOutput()
        value.replicationInstance = try reader["ReplicationInstance"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationInstance.read(from:))
        return value
    }
}

extension RefreshSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RefreshSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RefreshSchemasOutput()
        value.refreshSchemasStatus = try reader["RefreshSchemasStatus"].readIfPresent(with: DatabaseMigrationClientTypes.RefreshSchemasStatus.read(from:))
        return value
    }
}

extension ReloadReplicationTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReloadReplicationTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReloadReplicationTablesOutput()
        value.replicationConfigArn = try reader["ReplicationConfigArn"].readIfPresent()
        return value
    }
}

extension ReloadTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReloadTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReloadTablesOutput()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        return value
    }
}

extension RemoveTagsFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsFromResourceOutput {
        return RemoveTagsFromResourceOutput()
    }
}

extension RunFleetAdvisorLsaAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RunFleetAdvisorLsaAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RunFleetAdvisorLsaAnalysisOutput()
        value.lsaAnalysisId = try reader["LsaAnalysisId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension StartExtensionPackAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExtensionPackAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExtensionPackAssociationOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartMetadataModelAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataModelAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataModelAssessmentOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartMetadataModelConversionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataModelConversionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataModelConversionOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartMetadataModelExportAsScriptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataModelExportAsScriptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataModelExportAsScriptOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartMetadataModelExportToTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataModelExportToTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataModelExportToTargetOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartMetadataModelImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMetadataModelImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMetadataModelImportOutput()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        return value
    }
}

extension StartRecommendationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRecommendationsOutput {
        return StartRecommendationsOutput()
    }
}

extension StartReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReplicationOutput()
        value.replication = try reader["Replication"].readIfPresent(with: DatabaseMigrationClientTypes.Replication.read(from:))
        return value
    }
}

extension StartReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension StartReplicationTaskAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReplicationTaskAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReplicationTaskAssessmentOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension StartReplicationTaskAssessmentRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartReplicationTaskAssessmentRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartReplicationTaskAssessmentRunOutput()
        value.replicationTaskAssessmentRun = try reader["ReplicationTaskAssessmentRun"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.read(from:))
        return value
    }
}

extension StopReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopReplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopReplicationOutput()
        value.replication = try reader["Replication"].readIfPresent(with: DatabaseMigrationClientTypes.Replication.read(from:))
        return value
    }
}

extension StopReplicationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopReplicationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopReplicationTaskOutput()
        value.replicationTask = try reader["ReplicationTask"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTask.read(from:))
        return value
    }
}

extension TestConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: DatabaseMigrationClientTypes.Connection.read(from:))
        return value
    }
}

extension UpdateSubscriptionsToEventBridgeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionsToEventBridgeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSubscriptionsToEventBridgeOutput()
        value.result = try reader["Result"].readIfPresent()
        return value
    }
}

enum AddTagsToResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ApplyPendingMaintenanceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchStartRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelReplicationTaskAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "KMSAccessDeniedFault": return try KMSAccessDeniedFault.makeError(baseError: baseError)
            case "KMSDisabledFault": return try KMSDisabledFault.makeError(baseError: baseError)
            case "KMSInvalidStateFault": return try KMSInvalidStateFault.makeError(baseError: baseError)
            case "KMSNotFoundFault": return try KMSNotFoundFault.makeError(baseError: baseError)
            case "KMSThrottlingFault": return try KMSThrottlingFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "SNSInvalidTopicFault": return try SNSInvalidTopicFault.makeError(baseError: baseError)
            case "SNSNoAuthorizationFault": return try SNSNoAuthorizationFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetAdvisorCollectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMigrationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try ReplicationSubnetGroupDoesNotCoverEnoughAZs.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InsufficientResourceCapacityFault": return try InsufficientResourceCapacityFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try ReplicationSubnetGroupDoesNotCoverEnoughAZs.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "StorageQuotaExceededFault": return try StorageQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try ReplicationSubnetGroupDoesNotCoverEnoughAZs.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetAdvisorCollectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CollectorNotFoundFault": return try CollectorNotFoundFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetAdvisorDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidOperationFault": return try InvalidOperationFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMigrationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationTaskAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicableIndividualAssessmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCertificatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConversionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEndpointTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEngineVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventCategoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExtensionPackAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetAdvisorCollectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetAdvisorDatabasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetAdvisorLsaAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetAdvisorSchemaObjectSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFleetAdvisorSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetadataModelAssessmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetadataModelConversionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetadataModelExportsAsScriptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetadataModelExportsToTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetadataModelImportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMigrationProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrderableReplicationInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePendingMaintenanceActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecommendationLimitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRefreshSchemasStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationInstanceTaskLogsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationSubnetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationTableStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationTaskAssessmentResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationTaskAssessmentRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationTaskIndividualAssessmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReplicationTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTableStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportMetadataModelAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidCertificateFault": return try InvalidCertificateFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyConversionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyDataProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyEventSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "KMSAccessDeniedFault": return try KMSAccessDeniedFault.makeError(baseError: baseError)
            case "KMSDisabledFault": return try KMSDisabledFault.makeError(baseError: baseError)
            case "KMSInvalidStateFault": return try KMSInvalidStateFault.makeError(baseError: baseError)
            case "KMSNotFoundFault": return try KMSNotFoundFault.makeError(baseError: baseError)
            case "KMSThrottlingFault": return try KMSThrottlingFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "SNSInvalidTopicFault": return try SNSInvalidTopicFault.makeError(baseError: baseError)
            case "SNSNoAuthorizationFault": return try SNSNoAuthorizationFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyMigrationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyReplicationConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try ReplicationSubnetGroupDoesNotCoverEnoughAZs.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyReplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InsufficientResourceCapacityFault": return try InsufficientResourceCapacityFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "StorageQuotaExceededFault": return try StorageQuotaExceededFault.makeError(baseError: baseError)
            case "UpgradeDependencyFailureFault": return try UpgradeDependencyFailureFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyReplicationSubnetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnet.makeError(baseError: baseError)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try ReplicationSubnetGroupDoesNotCoverEnoughAZs.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "SubnetAlreadyInUse": return try SubnetAlreadyInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum MoveReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebootReplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RefreshSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReloadReplicationTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReloadTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RunFleetAdvisorLsaAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExtensionPackAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataModelAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataModelConversionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataModelExportAsScriptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataModelExportToTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMetadataModelImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRecommendationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReplicationTaskAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartReplicationTaskAssessmentRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSAccessDeniedFault": return try KMSAccessDeniedFault.makeError(baseError: baseError)
            case "KMSDisabledFault": return try KMSDisabledFault.makeError(baseError: baseError)
            case "KMSFault": return try KMSFault.makeError(baseError: baseError)
            case "KMSInvalidStateFault": return try KMSInvalidStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "KMSNotFoundFault": return try KMSNotFoundFault.makeError(baseError: baseError)
            case "ResourceAlreadyExistsFault": return try ResourceAlreadyExistsFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "S3AccessDeniedFault": return try S3AccessDeniedFault.makeError(baseError: baseError)
            case "S3ResourceNotFoundFault": return try S3ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopReplicationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            case "KMSKeyNotAccessibleFault": return try KMSKeyNotAccessibleFault.makeError(baseError: baseError)
            case "ResourceNotFoundFault": return try ResourceNotFoundFault.makeError(baseError: baseError)
            case "ResourceQuotaExceededFault": return try ResourceQuotaExceededFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionsToEventBridgeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedFault": return try AccessDeniedFault.makeError(baseError: baseError)
            case "InvalidResourceStateFault": return try InvalidResourceStateFault.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceStateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedFault {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsFault {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = ResourceQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3AccessDeniedFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> S3AccessDeniedFault {
        let reader = baseError.errorBodyReader
        var value = S3AccessDeniedFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSKeyNotAccessibleFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSKeyNotAccessibleFault {
        let reader = baseError.errorBodyReader
        var value = KMSKeyNotAccessibleFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SNSInvalidTopicFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SNSInvalidTopicFault {
        let reader = baseError.errorBodyReader
        var value = SNSInvalidTopicFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSAccessDeniedFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSAccessDeniedFault {
        let reader = baseError.errorBodyReader
        var value = KMSAccessDeniedFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSDisabledFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSDisabledFault {
        let reader = baseError.errorBodyReader
        var value = KMSDisabledFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSInvalidStateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSInvalidStateFault {
        let reader = baseError.errorBodyReader
        var value = KMSInvalidStateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = KMSNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SNSNoAuthorizationFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SNSNoAuthorizationFault {
        let reader = baseError.errorBodyReader
        var value = SNSNoAuthorizationFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSThrottlingFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSThrottlingFault {
        let reader = baseError.errorBodyReader
        var value = KMSThrottlingFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3ResourceNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> S3ResourceNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = S3ResourceNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplicationSubnetGroupDoesNotCoverEnoughAZs {
        let reader = baseError.errorBodyReader
        var value = ReplicationSubnetGroupDoesNotCoverEnoughAZs()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSubnet {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSubnet {
        let reader = baseError.errorBodyReader
        var value = InvalidSubnet()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientResourceCapacityFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientResourceCapacityFault {
        let reader = baseError.errorBodyReader
        var value = InsufficientResourceCapacityFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StorageQuotaExceededFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StorageQuotaExceededFault {
        let reader = baseError.errorBodyReader
        var value = StorageQuotaExceededFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CollectorNotFoundFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CollectorNotFoundFault {
        let reader = baseError.errorBodyReader
        var value = CollectorNotFoundFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOperationFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOperationFault {
        let reader = baseError.errorBodyReader
        var value = InvalidOperationFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCertificateFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCertificateFault {
        let reader = baseError.errorBodyReader
        var value = InvalidCertificateFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UpgradeDependencyFailureFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UpgradeDependencyFailureFault {
        let reader = baseError.errorBodyReader
        var value = UpgradeDependencyFailureFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetAlreadyInUse {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubnetAlreadyInUse {
        let reader = baseError.errorBodyReader
        var value = SubnetAlreadyInUse()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSFault {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSFault {
        let reader = baseError.errorBodyReader
        var value = KMSFault()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions()
        value.resourceIdentifier = try reader["ResourceIdentifier"].readIfPresent()
        value.pendingMaintenanceActionDetails = try reader["PendingMaintenanceActionDetails"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.PendingMaintenanceAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.PendingMaintenanceAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.PendingMaintenanceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.PendingMaintenanceAction()
        value.action = try reader["Action"].readIfPresent()
        value.autoAppliedAfterDate = try reader["AutoAppliedAfterDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.forcedApplyDate = try reader["ForcedApplyDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.optInStatus = try reader["OptInStatus"].readIfPresent()
        value.currentApplyDate = try reader["CurrentApplyDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.code = try reader["Code"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun()
        value.replicationTaskAssessmentRunArn = try reader["ReplicationTaskAssessmentRunArn"].readIfPresent()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.replicationTaskAssessmentRunCreationDate = try reader["ReplicationTaskAssessmentRunCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assessmentProgress = try reader["AssessmentProgress"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress.read(from:))
        value.lastFailureMessage = try reader["LastFailureMessage"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.resultLocationBucket = try reader["ResultLocationBucket"].readIfPresent()
        value.resultLocationFolder = try reader["ResultLocationFolder"].readIfPresent()
        value.resultEncryptionMode = try reader["ResultEncryptionMode"].readIfPresent()
        value.resultKmsKeyArn = try reader["ResultKmsKeyArn"].readIfPresent()
        value.assessmentRunName = try reader["AssessmentRunName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress()
        value.individualAssessmentCount = try reader["IndividualAssessmentCount"].readIfPresent() ?? 0
        value.individualAssessmentCompletedCount = try reader["IndividualAssessmentCompletedCount"].readIfPresent() ?? 0
        return value
    }
}

extension DatabaseMigrationClientTypes.DataProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DataProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DataProvider()
        value.dataProviderName = try reader["DataProviderName"].readIfPresent()
        value.dataProviderArn = try reader["DataProviderArn"].readIfPresent()
        value.dataProviderCreationTime = try reader["DataProviderCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: DatabaseMigrationClientTypes.DataProviderSettings.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.DataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.DataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .docdbsettings(docdbsettings):
                try writer["DocDbSettings"].write(docdbsettings, with: DatabaseMigrationClientTypes.DocDbDataProviderSettings.write(value:to:))
            case let .mariadbsettings(mariadbsettings):
                try writer["MariaDbSettings"].write(mariadbsettings, with: DatabaseMigrationClientTypes.MariaDbDataProviderSettings.write(value:to:))
            case let .microsoftsqlserversettings(microsoftsqlserversettings):
                try writer["MicrosoftSqlServerSettings"].write(microsoftsqlserversettings, with: DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings.write(value:to:))
            case let .mongodbsettings(mongodbsettings):
                try writer["MongoDbSettings"].write(mongodbsettings, with: DatabaseMigrationClientTypes.MongoDbDataProviderSettings.write(value:to:))
            case let .mysqlsettings(mysqlsettings):
                try writer["MySqlSettings"].write(mysqlsettings, with: DatabaseMigrationClientTypes.MySqlDataProviderSettings.write(value:to:))
            case let .oraclesettings(oraclesettings):
                try writer["OracleSettings"].write(oraclesettings, with: DatabaseMigrationClientTypes.OracleDataProviderSettings.write(value:to:))
            case let .postgresqlsettings(postgresqlsettings):
                try writer["PostgreSqlSettings"].write(postgresqlsettings, with: DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings.write(value:to:))
            case let .redshiftsettings(redshiftsettings):
                try writer["RedshiftSettings"].write(redshiftsettings, with: DatabaseMigrationClientTypes.RedshiftDataProviderSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "RedshiftSettings":
                return .redshiftsettings(try reader["RedshiftSettings"].read(with: DatabaseMigrationClientTypes.RedshiftDataProviderSettings.read(from:)))
            case "PostgreSqlSettings":
                return .postgresqlsettings(try reader["PostgreSqlSettings"].read(with: DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings.read(from:)))
            case "MySqlSettings":
                return .mysqlsettings(try reader["MySqlSettings"].read(with: DatabaseMigrationClientTypes.MySqlDataProviderSettings.read(from:)))
            case "OracleSettings":
                return .oraclesettings(try reader["OracleSettings"].read(with: DatabaseMigrationClientTypes.OracleDataProviderSettings.read(from:)))
            case "MicrosoftSqlServerSettings":
                return .microsoftsqlserversettings(try reader["MicrosoftSqlServerSettings"].read(with: DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings.read(from:)))
            case "DocDbSettings":
                return .docdbsettings(try reader["DocDbSettings"].read(with: DatabaseMigrationClientTypes.DocDbDataProviderSettings.read(from:)))
            case "MariaDbSettings":
                return .mariadbsettings(try reader["MariaDbSettings"].read(with: DatabaseMigrationClientTypes.MariaDbDataProviderSettings.read(from:)))
            case "MongoDbSettings":
                return .mongodbsettings(try reader["MongoDbSettings"].read(with: DatabaseMigrationClientTypes.MongoDbDataProviderSettings.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DatabaseMigrationClientTypes.MongoDbDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.MongoDbDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthMechanism"].write(value.authMechanism)
        try writer["AuthSource"].write(value.authSource)
        try writer["AuthType"].write(value.authType)
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MongoDbDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MongoDbDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.authType = try reader["AuthType"].readIfPresent()
        value.authSource = try reader["AuthSource"].readIfPresent()
        value.authMechanism = try reader["AuthMechanism"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MariaDbDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.MariaDbDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MariaDbDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MariaDbDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DocDbDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.DocDbDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DocDbDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DocDbDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.OracleDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.OracleDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AsmServer"].write(value.asmServer)
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerOracleAsmAccessRoleArn"].write(value.secretsManagerOracleAsmAccessRoleArn)
        try writer["SecretsManagerOracleAsmSecretId"].write(value.secretsManagerOracleAsmSecretId)
        try writer["SecretsManagerSecurityDbEncryptionAccessRoleArn"].write(value.secretsManagerSecurityDbEncryptionAccessRoleArn)
        try writer["SecretsManagerSecurityDbEncryptionSecretId"].write(value.secretsManagerSecurityDbEncryptionSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.OracleDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.OracleDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.asmServer = try reader["AsmServer"].readIfPresent()
        value.secretsManagerOracleAsmSecretId = try reader["SecretsManagerOracleAsmSecretId"].readIfPresent()
        value.secretsManagerOracleAsmAccessRoleArn = try reader["SecretsManagerOracleAsmAccessRoleArn"].readIfPresent()
        value.secretsManagerSecurityDbEncryptionSecretId = try reader["SecretsManagerSecurityDbEncryptionSecretId"].readIfPresent()
        value.secretsManagerSecurityDbEncryptionAccessRoleArn = try reader["SecretsManagerSecurityDbEncryptionAccessRoleArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MySqlDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.MySqlDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MySqlDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MySqlDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.RedshiftDataProviderSettings {

    static func write(value: DatabaseMigrationClientTypes.RedshiftDataProviderSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RedshiftDataProviderSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RedshiftDataProviderSettings()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.Endpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Endpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Endpoint()
        value.endpointIdentifier = try reader["EndpointIdentifier"].readIfPresent()
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.engineName = try reader["EngineName"].readIfPresent()
        value.engineDisplayName = try reader["EngineDisplayName"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.extraConnectionAttributes = try reader["ExtraConnectionAttributes"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.externalTableDefinition = try reader["ExternalTableDefinition"].readIfPresent()
        value.externalId = try reader["ExternalId"].readIfPresent()
        value.dynamoDbSettings = try reader["DynamoDbSettings"].readIfPresent(with: DatabaseMigrationClientTypes.DynamoDbSettings.read(from:))
        value.s3Settings = try reader["S3Settings"].readIfPresent(with: DatabaseMigrationClientTypes.S3Settings.read(from:))
        value.dmsTransferSettings = try reader["DmsTransferSettings"].readIfPresent(with: DatabaseMigrationClientTypes.DmsTransferSettings.read(from:))
        value.mongoDbSettings = try reader["MongoDbSettings"].readIfPresent(with: DatabaseMigrationClientTypes.MongoDbSettings.read(from:))
        value.kinesisSettings = try reader["KinesisSettings"].readIfPresent(with: DatabaseMigrationClientTypes.KinesisSettings.read(from:))
        value.kafkaSettings = try reader["KafkaSettings"].readIfPresent(with: DatabaseMigrationClientTypes.KafkaSettings.read(from:))
        value.elasticsearchSettings = try reader["ElasticsearchSettings"].readIfPresent(with: DatabaseMigrationClientTypes.ElasticsearchSettings.read(from:))
        value.neptuneSettings = try reader["NeptuneSettings"].readIfPresent(with: DatabaseMigrationClientTypes.NeptuneSettings.read(from:))
        value.redshiftSettings = try reader["RedshiftSettings"].readIfPresent(with: DatabaseMigrationClientTypes.RedshiftSettings.read(from:))
        value.postgreSQLSettings = try reader["PostgreSQLSettings"].readIfPresent(with: DatabaseMigrationClientTypes.PostgreSQLSettings.read(from:))
        value.mySQLSettings = try reader["MySQLSettings"].readIfPresent(with: DatabaseMigrationClientTypes.MySQLSettings.read(from:))
        value.oracleSettings = try reader["OracleSettings"].readIfPresent(with: DatabaseMigrationClientTypes.OracleSettings.read(from:))
        value.sybaseSettings = try reader["SybaseSettings"].readIfPresent(with: DatabaseMigrationClientTypes.SybaseSettings.read(from:))
        value.microsoftSQLServerSettings = try reader["MicrosoftSQLServerSettings"].readIfPresent(with: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.read(from:))
        value.ibmDb2Settings = try reader["IBMDb2Settings"].readIfPresent(with: DatabaseMigrationClientTypes.IBMDb2Settings.read(from:))
        value.docDbSettings = try reader["DocDbSettings"].readIfPresent(with: DatabaseMigrationClientTypes.DocDbSettings.read(from:))
        value.redisSettings = try reader["RedisSettings"].readIfPresent(with: DatabaseMigrationClientTypes.RedisSettings.read(from:))
        value.gcpMySQLSettings = try reader["GcpMySQLSettings"].readIfPresent(with: DatabaseMigrationClientTypes.GcpMySQLSettings.read(from:))
        value.timestreamSettings = try reader["TimestreamSettings"].readIfPresent(with: DatabaseMigrationClientTypes.TimestreamSettings.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.TimestreamSettings {

    static func write(value: DatabaseMigrationClientTypes.TimestreamSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcInsertsAndUpdates"].write(value.cdcInsertsAndUpdates)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["EnableMagneticStoreWrites"].write(value.enableMagneticStoreWrites)
        try writer["MagneticDuration"].write(value.magneticDuration)
        try writer["MemoryDuration"].write(value.memoryDuration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.TimestreamSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.TimestreamSettings()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.memoryDuration = try reader["MemoryDuration"].readIfPresent() ?? 0
        value.magneticDuration = try reader["MagneticDuration"].readIfPresent() ?? 0
        value.cdcInsertsAndUpdates = try reader["CdcInsertsAndUpdates"].readIfPresent()
        value.enableMagneticStoreWrites = try reader["EnableMagneticStoreWrites"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.GcpMySQLSettings {

    static func write(value: DatabaseMigrationClientTypes.GcpMySQLSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterConnectScript"].write(value.afterConnectScript)
        try writer["CleanSourceMetadataOnMismatch"].write(value.cleanSourceMetadataOnMismatch)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["EventsPollInterval"].write(value.eventsPollInterval)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["ParallelLoadThreads"].write(value.parallelLoadThreads)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["ServerTimezone"].write(value.serverTimezone)
        try writer["TargetDbType"].write(value.targetDbType)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.GcpMySQLSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.GcpMySQLSettings()
        value.afterConnectScript = try reader["AfterConnectScript"].readIfPresent()
        value.cleanSourceMetadataOnMismatch = try reader["CleanSourceMetadataOnMismatch"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.eventsPollInterval = try reader["EventsPollInterval"].readIfPresent()
        value.targetDbType = try reader["TargetDbType"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.parallelLoadThreads = try reader["ParallelLoadThreads"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.serverTimezone = try reader["ServerTimezone"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.RedisSettings {

    static func write(value: DatabaseMigrationClientTypes.RedisSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthPassword"].write(value.authPassword)
        try writer["AuthType"].write(value.authType)
        try writer["AuthUserName"].write(value.authUserName)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslCaCertificateArn"].write(value.sslCaCertificateArn)
        try writer["SslSecurityProtocol"].write(value.sslSecurityProtocol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RedisSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RedisSettings()
        value.serverName = try reader["ServerName"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.sslSecurityProtocol = try reader["SslSecurityProtocol"].readIfPresent()
        value.authType = try reader["AuthType"].readIfPresent()
        value.authUserName = try reader["AuthUserName"].readIfPresent()
        value.authPassword = try reader["AuthPassword"].readIfPresent()
        value.sslCaCertificateArn = try reader["SslCaCertificateArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DocDbSettings {

    static func write(value: DatabaseMigrationClientTypes.DocDbSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DocsToInvestigate"].write(value.docsToInvestigate)
        try writer["ExtractDocId"].write(value.extractDocId)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["NestingLevel"].write(value.nestingLevel)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["ReplicateShardCollections"].write(value.replicateShardCollections)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["UseUpdateLookUp"].write(value.useUpdateLookUp)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DocDbSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DocDbSettings()
        value.username = try reader["Username"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.nestingLevel = try reader["NestingLevel"].readIfPresent()
        value.extractDocId = try reader["ExtractDocId"].readIfPresent()
        value.docsToInvestigate = try reader["DocsToInvestigate"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.useUpdateLookUp = try reader["UseUpdateLookUp"].readIfPresent()
        value.replicateShardCollections = try reader["ReplicateShardCollections"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.IBMDb2Settings {

    static func write(value: DatabaseMigrationClientTypes.IBMDb2Settings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentLsn"].write(value.currentLsn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["KeepCsvFiles"].write(value.keepCsvFiles)
        try writer["LoadTimeout"].write(value.loadTimeout)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["MaxKBytesPerRead"].write(value.maxKBytesPerRead)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["SetDataCaptureChanges"].write(value.setDataCaptureChanges)
        try writer["Username"].write(value.username)
        try writer["WriteBufferSize"].write(value.writeBufferSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.IBMDb2Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.IBMDb2Settings()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.setDataCaptureChanges = try reader["SetDataCaptureChanges"].readIfPresent()
        value.currentLsn = try reader["CurrentLsn"].readIfPresent()
        value.maxKBytesPerRead = try reader["MaxKBytesPerRead"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.loadTimeout = try reader["LoadTimeout"].readIfPresent()
        value.writeBufferSize = try reader["WriteBufferSize"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.keepCsvFiles = try reader["KeepCsvFiles"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings {

    static func write(value: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BcpPacketSize"].write(value.bcpPacketSize)
        try writer["ControlTablesFileGroup"].write(value.controlTablesFileGroup)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["ForceLobLookup"].write(value.forceLobLookup)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["QuerySingleAlwaysOnNode"].write(value.querySingleAlwaysOnNode)
        try writer["ReadBackupOnly"].write(value.readBackupOnly)
        try writer["SafeguardPolicy"].write(value.safeguardPolicy)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["TlogAccessMode"].write(value.tlogAccessMode)
        try writer["TrimSpaceInChar"].write(value.trimSpaceInChar)
        try writer["UseBcpFullLoad"].write(value.useBcpFullLoad)
        try writer["UseThirdPartyBackupDevice"].write(value.useThirdPartyBackupDevice)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MicrosoftSQLServerSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MicrosoftSQLServerSettings()
        value.port = try reader["Port"].readIfPresent()
        value.bcpPacketSize = try reader["BcpPacketSize"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.controlTablesFileGroup = try reader["ControlTablesFileGroup"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.querySingleAlwaysOnNode = try reader["QuerySingleAlwaysOnNode"].readIfPresent()
        value.readBackupOnly = try reader["ReadBackupOnly"].readIfPresent()
        value.safeguardPolicy = try reader["SafeguardPolicy"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.useBcpFullLoad = try reader["UseBcpFullLoad"].readIfPresent()
        value.useThirdPartyBackupDevice = try reader["UseThirdPartyBackupDevice"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.trimSpaceInChar = try reader["TrimSpaceInChar"].readIfPresent()
        value.tlogAccessMode = try reader["TlogAccessMode"].readIfPresent()
        value.forceLobLookup = try reader["ForceLobLookup"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.SybaseSettings {

    static func write(value: DatabaseMigrationClientTypes.SybaseSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SybaseSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SybaseSettings()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.OracleSettings {

    static func write(value: DatabaseMigrationClientTypes.OracleSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessAlternateDirectly"].write(value.accessAlternateDirectly)
        try writer["AddSupplementalLogging"].write(value.addSupplementalLogging)
        try writer["AdditionalArchivedLogDestId"].write(value.additionalArchivedLogDestId)
        try writer["AllowSelectNestedTables"].write(value.allowSelectNestedTables)
        try writer["ArchivedLogDestId"].write(value.archivedLogDestId)
        try writer["ArchivedLogsOnly"].write(value.archivedLogsOnly)
        try writer["AsmPassword"].write(value.asmPassword)
        try writer["AsmServer"].write(value.asmServer)
        try writer["AsmUser"].write(value.asmUser)
        try writer["CharLengthSemantics"].write(value.charLengthSemantics)
        try writer["ConvertTimestampWithZoneToUTC"].write(value.convertTimestampWithZoneToUTC)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DirectPathNoLog"].write(value.directPathNoLog)
        try writer["DirectPathParallelLoad"].write(value.directPathParallelLoad)
        try writer["EnableHomogenousTablespace"].write(value.enableHomogenousTablespace)
        try writer["ExtraArchivedLogDestIds"].writeList(value.extraArchivedLogDestIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FailTasksOnLobTruncation"].write(value.failTasksOnLobTruncation)
        try writer["NumberDatatypeScale"].write(value.numberDatatypeScale)
        try writer["OpenTransactionWindow"].write(value.openTransactionWindow)
        try writer["OraclePathPrefix"].write(value.oraclePathPrefix)
        try writer["ParallelAsmReadThreads"].write(value.parallelAsmReadThreads)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["ReadAheadBlocks"].write(value.readAheadBlocks)
        try writer["ReadTableSpaceName"].write(value.readTableSpaceName)
        try writer["ReplacePathPrefix"].write(value.replacePathPrefix)
        try writer["RetryInterval"].write(value.retryInterval)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerOracleAsmAccessRoleArn"].write(value.secretsManagerOracleAsmAccessRoleArn)
        try writer["SecretsManagerOracleAsmSecretId"].write(value.secretsManagerOracleAsmSecretId)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["SecurityDbEncryption"].write(value.securityDbEncryption)
        try writer["SecurityDbEncryptionName"].write(value.securityDbEncryptionName)
        try writer["ServerName"].write(value.serverName)
        try writer["SpatialDataOptionToGeoJsonFunctionName"].write(value.spatialDataOptionToGeoJsonFunctionName)
        try writer["StandbyDelayTime"].write(value.standbyDelayTime)
        try writer["TrimSpaceInChar"].write(value.trimSpaceInChar)
        try writer["UseAlternateFolderForOnline"].write(value.useAlternateFolderForOnline)
        try writer["UseBFile"].write(value.useBFile)
        try writer["UseDirectPathFullLoad"].write(value.useDirectPathFullLoad)
        try writer["UseLogminerReader"].write(value.useLogminerReader)
        try writer["UsePathPrefix"].write(value.usePathPrefix)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.OracleSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.OracleSettings()
        value.addSupplementalLogging = try reader["AddSupplementalLogging"].readIfPresent()
        value.archivedLogDestId = try reader["ArchivedLogDestId"].readIfPresent()
        value.additionalArchivedLogDestId = try reader["AdditionalArchivedLogDestId"].readIfPresent()
        value.extraArchivedLogDestIds = try reader["ExtraArchivedLogDestIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowSelectNestedTables = try reader["AllowSelectNestedTables"].readIfPresent()
        value.parallelAsmReadThreads = try reader["ParallelAsmReadThreads"].readIfPresent()
        value.readAheadBlocks = try reader["ReadAheadBlocks"].readIfPresent()
        value.accessAlternateDirectly = try reader["AccessAlternateDirectly"].readIfPresent()
        value.useAlternateFolderForOnline = try reader["UseAlternateFolderForOnline"].readIfPresent()
        value.oraclePathPrefix = try reader["OraclePathPrefix"].readIfPresent()
        value.usePathPrefix = try reader["UsePathPrefix"].readIfPresent()
        value.replacePathPrefix = try reader["ReplacePathPrefix"].readIfPresent()
        value.enableHomogenousTablespace = try reader["EnableHomogenousTablespace"].readIfPresent()
        value.directPathNoLog = try reader["DirectPathNoLog"].readIfPresent()
        value.archivedLogsOnly = try reader["ArchivedLogsOnly"].readIfPresent()
        value.asmPassword = try reader["AsmPassword"].readIfPresent()
        value.asmServer = try reader["AsmServer"].readIfPresent()
        value.asmUser = try reader["AsmUser"].readIfPresent()
        value.charLengthSemantics = try reader["CharLengthSemantics"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.directPathParallelLoad = try reader["DirectPathParallelLoad"].readIfPresent()
        value.failTasksOnLobTruncation = try reader["FailTasksOnLobTruncation"].readIfPresent()
        value.numberDatatypeScale = try reader["NumberDatatypeScale"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.readTableSpaceName = try reader["ReadTableSpaceName"].readIfPresent()
        value.retryInterval = try reader["RetryInterval"].readIfPresent()
        value.securityDbEncryption = try reader["SecurityDbEncryption"].readIfPresent()
        value.securityDbEncryptionName = try reader["SecurityDbEncryptionName"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.spatialDataOptionToGeoJsonFunctionName = try reader["SpatialDataOptionToGeoJsonFunctionName"].readIfPresent()
        value.standbyDelayTime = try reader["StandbyDelayTime"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.useBFile = try reader["UseBFile"].readIfPresent()
        value.useDirectPathFullLoad = try reader["UseDirectPathFullLoad"].readIfPresent()
        value.useLogminerReader = try reader["UseLogminerReader"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.secretsManagerOracleAsmAccessRoleArn = try reader["SecretsManagerOracleAsmAccessRoleArn"].readIfPresent()
        value.secretsManagerOracleAsmSecretId = try reader["SecretsManagerOracleAsmSecretId"].readIfPresent()
        value.trimSpaceInChar = try reader["TrimSpaceInChar"].readIfPresent()
        value.convertTimestampWithZoneToUTC = try reader["ConvertTimestampWithZoneToUTC"].readIfPresent()
        value.openTransactionWindow = try reader["OpenTransactionWindow"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings {

    static func write(value: DatabaseMigrationClientTypes.MySQLSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterConnectScript"].write(value.afterConnectScript)
        try writer["CleanSourceMetadataOnMismatch"].write(value.cleanSourceMetadataOnMismatch)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["EventsPollInterval"].write(value.eventsPollInterval)
        try writer["ExecuteTimeout"].write(value.executeTimeout)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["ParallelLoadThreads"].write(value.parallelLoadThreads)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["ServerTimezone"].write(value.serverTimezone)
        try writer["TargetDbType"].write(value.targetDbType)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MySQLSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MySQLSettings()
        value.afterConnectScript = try reader["AfterConnectScript"].readIfPresent()
        value.cleanSourceMetadataOnMismatch = try reader["CleanSourceMetadataOnMismatch"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.eventsPollInterval = try reader["EventsPollInterval"].readIfPresent()
        value.targetDbType = try reader["TargetDbType"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.parallelLoadThreads = try reader["ParallelLoadThreads"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.serverTimezone = try reader["ServerTimezone"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.executeTimeout = try reader["ExecuteTimeout"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings {

    static func write(value: DatabaseMigrationClientTypes.PostgreSQLSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterConnectScript"].write(value.afterConnectScript)
        try writer["BabelfishDatabaseName"].write(value.babelfishDatabaseName)
        try writer["CaptureDdls"].write(value.captureDdls)
        try writer["DatabaseMode"].write(value.databaseMode)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DdlArtifactsSchema"].write(value.ddlArtifactsSchema)
        try writer["ExecuteTimeout"].write(value.executeTimeout)
        try writer["FailTasksOnLobTruncation"].write(value.failTasksOnLobTruncation)
        try writer["HeartbeatEnable"].write(value.heartbeatEnable)
        try writer["HeartbeatFrequency"].write(value.heartbeatFrequency)
        try writer["HeartbeatSchema"].write(value.heartbeatSchema)
        try writer["MapBooleanAsBoolean"].write(value.mapBooleanAsBoolean)
        try writer["MapJsonbAsClob"].write(value.mapJsonbAsClob)
        try writer["MapLongVarcharAs"].write(value.mapLongVarcharAs)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["Password"].write(value.password)
        try writer["PluginName"].write(value.pluginName)
        try writer["Port"].write(value.port)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["SlotName"].write(value.slotName)
        try writer["TrimSpaceInChar"].write(value.trimSpaceInChar)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.PostgreSQLSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.PostgreSQLSettings()
        value.afterConnectScript = try reader["AfterConnectScript"].readIfPresent()
        value.captureDdls = try reader["CaptureDdls"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.ddlArtifactsSchema = try reader["DdlArtifactsSchema"].readIfPresent()
        value.executeTimeout = try reader["ExecuteTimeout"].readIfPresent()
        value.failTasksOnLobTruncation = try reader["FailTasksOnLobTruncation"].readIfPresent()
        value.heartbeatEnable = try reader["HeartbeatEnable"].readIfPresent()
        value.heartbeatSchema = try reader["HeartbeatSchema"].readIfPresent()
        value.heartbeatFrequency = try reader["HeartbeatFrequency"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.slotName = try reader["SlotName"].readIfPresent()
        value.pluginName = try reader["PluginName"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.trimSpaceInChar = try reader["TrimSpaceInChar"].readIfPresent()
        value.mapBooleanAsBoolean = try reader["MapBooleanAsBoolean"].readIfPresent()
        value.mapJsonbAsClob = try reader["MapJsonbAsClob"].readIfPresent()
        value.mapLongVarcharAs = try reader["MapLongVarcharAs"].readIfPresent()
        value.databaseMode = try reader["DatabaseMode"].readIfPresent()
        value.babelfishDatabaseName = try reader["BabelfishDatabaseName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.RedshiftSettings {

    static func write(value: DatabaseMigrationClientTypes.RedshiftSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptAnyDate"].write(value.acceptAnyDate)
        try writer["AfterConnectScript"].write(value.afterConnectScript)
        try writer["BucketFolder"].write(value.bucketFolder)
        try writer["BucketName"].write(value.bucketName)
        try writer["CaseSensitiveNames"].write(value.caseSensitiveNames)
        try writer["CompUpdate"].write(value.compUpdate)
        try writer["ConnectionTimeout"].write(value.connectionTimeout)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DateFormat"].write(value.dateFormat)
        try writer["EmptyAsNull"].write(value.emptyAsNull)
        try writer["EncryptionMode"].write(value.encryptionMode)
        try writer["ExplicitIds"].write(value.explicitIds)
        try writer["FileTransferUploadStreams"].write(value.fileTransferUploadStreams)
        try writer["LoadTimeout"].write(value.loadTimeout)
        try writer["MapBooleanAsBoolean"].write(value.mapBooleanAsBoolean)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["RemoveQuotes"].write(value.removeQuotes)
        try writer["ReplaceChars"].write(value.replaceChars)
        try writer["ReplaceInvalidChars"].write(value.replaceInvalidChars)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["ServerSideEncryptionKmsKeyId"].write(value.serverSideEncryptionKmsKeyId)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["TimeFormat"].write(value.timeFormat)
        try writer["TrimBlanks"].write(value.trimBlanks)
        try writer["TruncateColumns"].write(value.truncateColumns)
        try writer["Username"].write(value.username)
        try writer["WriteBufferSize"].write(value.writeBufferSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RedshiftSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RedshiftSettings()
        value.acceptAnyDate = try reader["AcceptAnyDate"].readIfPresent()
        value.afterConnectScript = try reader["AfterConnectScript"].readIfPresent()
        value.bucketFolder = try reader["BucketFolder"].readIfPresent()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.caseSensitiveNames = try reader["CaseSensitiveNames"].readIfPresent()
        value.compUpdate = try reader["CompUpdate"].readIfPresent()
        value.connectionTimeout = try reader["ConnectionTimeout"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.dateFormat = try reader["DateFormat"].readIfPresent()
        value.emptyAsNull = try reader["EmptyAsNull"].readIfPresent()
        value.encryptionMode = try reader["EncryptionMode"].readIfPresent()
        value.explicitIds = try reader["ExplicitIds"].readIfPresent()
        value.fileTransferUploadStreams = try reader["FileTransferUploadStreams"].readIfPresent()
        value.loadTimeout = try reader["LoadTimeout"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.removeQuotes = try reader["RemoveQuotes"].readIfPresent()
        value.replaceInvalidChars = try reader["ReplaceInvalidChars"].readIfPresent()
        value.replaceChars = try reader["ReplaceChars"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.serverSideEncryptionKmsKeyId = try reader["ServerSideEncryptionKmsKeyId"].readIfPresent()
        value.timeFormat = try reader["TimeFormat"].readIfPresent()
        value.trimBlanks = try reader["TrimBlanks"].readIfPresent()
        value.truncateColumns = try reader["TruncateColumns"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.writeBufferSize = try reader["WriteBufferSize"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.mapBooleanAsBoolean = try reader["MapBooleanAsBoolean"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.NeptuneSettings {

    static func write(value: DatabaseMigrationClientTypes.NeptuneSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ErrorRetryDuration"].write(value.errorRetryDuration)
        try writer["IamAuthEnabled"].write(value.iamAuthEnabled)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["MaxRetryCount"].write(value.maxRetryCount)
        try writer["S3BucketFolder"].write(value.s3BucketFolder)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.NeptuneSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.NeptuneSettings()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent() ?? ""
        value.s3BucketFolder = try reader["S3BucketFolder"].readIfPresent() ?? ""
        value.errorRetryDuration = try reader["ErrorRetryDuration"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.maxRetryCount = try reader["MaxRetryCount"].readIfPresent()
        value.iamAuthEnabled = try reader["IamAuthEnabled"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ElasticsearchSettings {

    static func write(value: DatabaseMigrationClientTypes.ElasticsearchSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointUri"].write(value.endpointUri)
        try writer["ErrorRetryDuration"].write(value.errorRetryDuration)
        try writer["FullLoadErrorPercentage"].write(value.fullLoadErrorPercentage)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["UseNewMappingType"].write(value.useNewMappingType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ElasticsearchSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ElasticsearchSettings()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent() ?? ""
        value.endpointUri = try reader["EndpointUri"].readIfPresent() ?? ""
        value.fullLoadErrorPercentage = try reader["FullLoadErrorPercentage"].readIfPresent()
        value.errorRetryDuration = try reader["ErrorRetryDuration"].readIfPresent()
        value.useNewMappingType = try reader["UseNewMappingType"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings {

    static func write(value: DatabaseMigrationClientTypes.KafkaSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Broker"].write(value.broker)
        try writer["IncludeControlDetails"].write(value.includeControlDetails)
        try writer["IncludeNullAndEmpty"].write(value.includeNullAndEmpty)
        try writer["IncludePartitionValue"].write(value.includePartitionValue)
        try writer["IncludeTableAlterOperations"].write(value.includeTableAlterOperations)
        try writer["IncludeTransactionDetails"].write(value.includeTransactionDetails)
        try writer["MessageFormat"].write(value.messageFormat)
        try writer["MessageMaxBytes"].write(value.messageMaxBytes)
        try writer["NoHexPrefix"].write(value.noHexPrefix)
        try writer["PartitionIncludeSchemaTable"].write(value.partitionIncludeSchemaTable)
        try writer["SaslMechanism"].write(value.saslMechanism)
        try writer["SaslPassword"].write(value.saslPassword)
        try writer["SaslUsername"].write(value.saslUsername)
        try writer["SecurityProtocol"].write(value.securityProtocol)
        try writer["SslCaCertificateArn"].write(value.sslCaCertificateArn)
        try writer["SslClientCertificateArn"].write(value.sslClientCertificateArn)
        try writer["SslClientKeyArn"].write(value.sslClientKeyArn)
        try writer["SslClientKeyPassword"].write(value.sslClientKeyPassword)
        try writer["SslEndpointIdentificationAlgorithm"].write(value.sslEndpointIdentificationAlgorithm)
        try writer["Topic"].write(value.topic)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.KafkaSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.KafkaSettings()
        value.broker = try reader["Broker"].readIfPresent()
        value.topic = try reader["Topic"].readIfPresent()
        value.messageFormat = try reader["MessageFormat"].readIfPresent()
        value.includeTransactionDetails = try reader["IncludeTransactionDetails"].readIfPresent()
        value.includePartitionValue = try reader["IncludePartitionValue"].readIfPresent()
        value.partitionIncludeSchemaTable = try reader["PartitionIncludeSchemaTable"].readIfPresent()
        value.includeTableAlterOperations = try reader["IncludeTableAlterOperations"].readIfPresent()
        value.includeControlDetails = try reader["IncludeControlDetails"].readIfPresent()
        value.messageMaxBytes = try reader["MessageMaxBytes"].readIfPresent()
        value.includeNullAndEmpty = try reader["IncludeNullAndEmpty"].readIfPresent()
        value.securityProtocol = try reader["SecurityProtocol"].readIfPresent()
        value.sslClientCertificateArn = try reader["SslClientCertificateArn"].readIfPresent()
        value.sslClientKeyArn = try reader["SslClientKeyArn"].readIfPresent()
        value.sslClientKeyPassword = try reader["SslClientKeyPassword"].readIfPresent()
        value.sslCaCertificateArn = try reader["SslCaCertificateArn"].readIfPresent()
        value.saslUsername = try reader["SaslUsername"].readIfPresent()
        value.saslPassword = try reader["SaslPassword"].readIfPresent()
        value.noHexPrefix = try reader["NoHexPrefix"].readIfPresent()
        value.saslMechanism = try reader["SaslMechanism"].readIfPresent()
        value.sslEndpointIdentificationAlgorithm = try reader["SslEndpointIdentificationAlgorithm"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.KinesisSettings {

    static func write(value: DatabaseMigrationClientTypes.KinesisSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeControlDetails"].write(value.includeControlDetails)
        try writer["IncludeNullAndEmpty"].write(value.includeNullAndEmpty)
        try writer["IncludePartitionValue"].write(value.includePartitionValue)
        try writer["IncludeTableAlterOperations"].write(value.includeTableAlterOperations)
        try writer["IncludeTransactionDetails"].write(value.includeTransactionDetails)
        try writer["MessageFormat"].write(value.messageFormat)
        try writer["NoHexPrefix"].write(value.noHexPrefix)
        try writer["PartitionIncludeSchemaTable"].write(value.partitionIncludeSchemaTable)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["StreamArn"].write(value.streamArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.KinesisSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.KinesisSettings()
        value.streamArn = try reader["StreamArn"].readIfPresent()
        value.messageFormat = try reader["MessageFormat"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.includeTransactionDetails = try reader["IncludeTransactionDetails"].readIfPresent()
        value.includePartitionValue = try reader["IncludePartitionValue"].readIfPresent()
        value.partitionIncludeSchemaTable = try reader["PartitionIncludeSchemaTable"].readIfPresent()
        value.includeTableAlterOperations = try reader["IncludeTableAlterOperations"].readIfPresent()
        value.includeControlDetails = try reader["IncludeControlDetails"].readIfPresent()
        value.includeNullAndEmpty = try reader["IncludeNullAndEmpty"].readIfPresent()
        value.noHexPrefix = try reader["NoHexPrefix"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings {

    static func write(value: DatabaseMigrationClientTypes.MongoDbSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthMechanism"].write(value.authMechanism)
        try writer["AuthSource"].write(value.authSource)
        try writer["AuthType"].write(value.authType)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DocsToInvestigate"].write(value.docsToInvestigate)
        try writer["ExtractDocId"].write(value.extractDocId)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["NestingLevel"].write(value.nestingLevel)
        try writer["Password"].write(value.password)
        try writer["Port"].write(value.port)
        try writer["ReplicateShardCollections"].write(value.replicateShardCollections)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
        try writer["ServerName"].write(value.serverName)
        try writer["UseUpdateLookUp"].write(value.useUpdateLookUp)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MongoDbSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MongoDbSettings()
        value.username = try reader["Username"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.authType = try reader["AuthType"].readIfPresent()
        value.authMechanism = try reader["AuthMechanism"].readIfPresent()
        value.nestingLevel = try reader["NestingLevel"].readIfPresent()
        value.extractDocId = try reader["ExtractDocId"].readIfPresent()
        value.docsToInvestigate = try reader["DocsToInvestigate"].readIfPresent()
        value.authSource = try reader["AuthSource"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.useUpdateLookUp = try reader["UseUpdateLookUp"].readIfPresent()
        value.replicateShardCollections = try reader["ReplicateShardCollections"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DmsTransferSettings {

    static func write(value: DatabaseMigrationClientTypes.DmsTransferSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DmsTransferSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DmsTransferSettings()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.bucketName = try reader["BucketName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.S3Settings {

    static func write(value: DatabaseMigrationClientTypes.S3Settings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddColumnName"].write(value.addColumnName)
        try writer["AddTrailingPaddingCharacter"].write(value.addTrailingPaddingCharacter)
        try writer["BucketFolder"].write(value.bucketFolder)
        try writer["BucketName"].write(value.bucketName)
        try writer["CannedAclForObjects"].write(value.cannedAclForObjects)
        try writer["CdcInsertsAndUpdates"].write(value.cdcInsertsAndUpdates)
        try writer["CdcInsertsOnly"].write(value.cdcInsertsOnly)
        try writer["CdcMaxBatchInterval"].write(value.cdcMaxBatchInterval)
        try writer["CdcMinFileSize"].write(value.cdcMinFileSize)
        try writer["CdcPath"].write(value.cdcPath)
        try writer["CompressionType"].write(value.compressionType)
        try writer["CsvDelimiter"].write(value.csvDelimiter)
        try writer["CsvNoSupValue"].write(value.csvNoSupValue)
        try writer["CsvNullValue"].write(value.csvNullValue)
        try writer["CsvRowDelimiter"].write(value.csvRowDelimiter)
        try writer["DataFormat"].write(value.dataFormat)
        try writer["DataPageSize"].write(value.dataPageSize)
        try writer["DatePartitionDelimiter"].write(value.datePartitionDelimiter)
        try writer["DatePartitionEnabled"].write(value.datePartitionEnabled)
        try writer["DatePartitionSequence"].write(value.datePartitionSequence)
        try writer["DatePartitionTimezone"].write(value.datePartitionTimezone)
        try writer["DictPageSizeLimit"].write(value.dictPageSizeLimit)
        try writer["EnableStatistics"].write(value.enableStatistics)
        try writer["EncodingType"].write(value.encodingType)
        try writer["EncryptionMode"].write(value.encryptionMode)
        try writer["ExpectedBucketOwner"].write(value.expectedBucketOwner)
        try writer["ExternalTableDefinition"].write(value.externalTableDefinition)
        try writer["GlueCatalogGeneration"].write(value.glueCatalogGeneration)
        try writer["IgnoreHeaderRows"].write(value.ignoreHeaderRows)
        try writer["IncludeOpForFullLoad"].write(value.includeOpForFullLoad)
        try writer["MaxFileSize"].write(value.maxFileSize)
        try writer["ParquetTimestampInMillisecond"].write(value.parquetTimestampInMillisecond)
        try writer["ParquetVersion"].write(value.parquetVersion)
        try writer["PreserveTransactions"].write(value.preserveTransactions)
        try writer["Rfc4180"].write(value.rfc4180)
        try writer["RowGroupLength"].write(value.rowGroupLength)
        try writer["ServerSideEncryptionKmsKeyId"].write(value.serverSideEncryptionKmsKeyId)
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
        try writer["TimestampColumnName"].write(value.timestampColumnName)
        try writer["UseCsvNoSupValue"].write(value.useCsvNoSupValue)
        try writer["UseTaskStartTimeForFullLoadTimestamp"].write(value.useTaskStartTimeForFullLoadTimestamp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.S3Settings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.S3Settings()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.externalTableDefinition = try reader["ExternalTableDefinition"].readIfPresent()
        value.csvRowDelimiter = try reader["CsvRowDelimiter"].readIfPresent()
        value.csvDelimiter = try reader["CsvDelimiter"].readIfPresent()
        value.bucketFolder = try reader["BucketFolder"].readIfPresent()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.compressionType = try reader["CompressionType"].readIfPresent()
        value.encryptionMode = try reader["EncryptionMode"].readIfPresent()
        value.serverSideEncryptionKmsKeyId = try reader["ServerSideEncryptionKmsKeyId"].readIfPresent()
        value.dataFormat = try reader["DataFormat"].readIfPresent()
        value.encodingType = try reader["EncodingType"].readIfPresent()
        value.dictPageSizeLimit = try reader["DictPageSizeLimit"].readIfPresent()
        value.rowGroupLength = try reader["RowGroupLength"].readIfPresent()
        value.dataPageSize = try reader["DataPageSize"].readIfPresent()
        value.parquetVersion = try reader["ParquetVersion"].readIfPresent()
        value.enableStatistics = try reader["EnableStatistics"].readIfPresent()
        value.includeOpForFullLoad = try reader["IncludeOpForFullLoad"].readIfPresent()
        value.cdcInsertsOnly = try reader["CdcInsertsOnly"].readIfPresent()
        value.timestampColumnName = try reader["TimestampColumnName"].readIfPresent()
        value.parquetTimestampInMillisecond = try reader["ParquetTimestampInMillisecond"].readIfPresent()
        value.cdcInsertsAndUpdates = try reader["CdcInsertsAndUpdates"].readIfPresent()
        value.datePartitionEnabled = try reader["DatePartitionEnabled"].readIfPresent()
        value.datePartitionSequence = try reader["DatePartitionSequence"].readIfPresent()
        value.datePartitionDelimiter = try reader["DatePartitionDelimiter"].readIfPresent()
        value.useCsvNoSupValue = try reader["UseCsvNoSupValue"].readIfPresent()
        value.csvNoSupValue = try reader["CsvNoSupValue"].readIfPresent()
        value.preserveTransactions = try reader["PreserveTransactions"].readIfPresent()
        value.cdcPath = try reader["CdcPath"].readIfPresent()
        value.useTaskStartTimeForFullLoadTimestamp = try reader["UseTaskStartTimeForFullLoadTimestamp"].readIfPresent()
        value.cannedAclForObjects = try reader["CannedAclForObjects"].readIfPresent()
        value.addColumnName = try reader["AddColumnName"].readIfPresent()
        value.cdcMaxBatchInterval = try reader["CdcMaxBatchInterval"].readIfPresent()
        value.cdcMinFileSize = try reader["CdcMinFileSize"].readIfPresent()
        value.csvNullValue = try reader["CsvNullValue"].readIfPresent()
        value.ignoreHeaderRows = try reader["IgnoreHeaderRows"].readIfPresent()
        value.maxFileSize = try reader["MaxFileSize"].readIfPresent()
        value.rfc4180 = try reader["Rfc4180"].readIfPresent()
        value.datePartitionTimezone = try reader["DatePartitionTimezone"].readIfPresent()
        value.addTrailingPaddingCharacter = try reader["AddTrailingPaddingCharacter"].readIfPresent()
        value.expectedBucketOwner = try reader["ExpectedBucketOwner"].readIfPresent()
        value.glueCatalogGeneration = try reader["GlueCatalogGeneration"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DynamoDbSettings {

    static func write(value: DatabaseMigrationClientTypes.DynamoDbSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceAccessRoleArn"].write(value.serviceAccessRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DynamoDbSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DynamoDbSettings()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension DatabaseMigrationClientTypes.EventSubscription {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.EventSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.EventSubscription()
        value.customerAwsId = try reader["CustomerAwsId"].readIfPresent()
        value.custSubscriptionId = try reader["CustSubscriptionId"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.subscriptionCreationTime = try reader["SubscriptionCreationTime"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.sourceIdsList = try reader["SourceIdsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventCategoriesList = try reader["EventCategoriesList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension DatabaseMigrationClientTypes.InstanceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.InstanceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.InstanceProfile()
        value.instanceProfileArn = try reader["InstanceProfileArn"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        value.networkType = try reader["NetworkType"].readIfPresent()
        value.instanceProfileName = try reader["InstanceProfileName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.instanceProfileCreationTime = try reader["InstanceProfileCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.subnetGroupIdentifier = try reader["SubnetGroupIdentifier"].readIfPresent()
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.MigrationProject {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.MigrationProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.MigrationProject()
        value.migrationProjectName = try reader["MigrationProjectName"].readIfPresent()
        value.migrationProjectArn = try reader["MigrationProjectArn"].readIfPresent()
        value.migrationProjectCreationTime = try reader["MigrationProjectCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.sourceDataProviderDescriptors = try reader["SourceDataProviderDescriptors"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.DataProviderDescriptor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetDataProviderDescriptors = try reader["TargetDataProviderDescriptors"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.DataProviderDescriptor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceProfileArn = try reader["InstanceProfileArn"].readIfPresent()
        value.instanceProfileName = try reader["InstanceProfileName"].readIfPresent()
        value.transformationRules = try reader["TransformationRules"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.schemaConversionApplicationAttributes = try reader["SchemaConversionApplicationAttributes"].readIfPresent(with: DatabaseMigrationClientTypes.SCApplicationAttributes.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.SCApplicationAttributes {

    static func write(value: DatabaseMigrationClientTypes.SCApplicationAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketPath"].write(value.s3BucketPath)
        try writer["S3BucketRoleArn"].write(value.s3BucketRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SCApplicationAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SCApplicationAttributes()
        value.s3BucketPath = try reader["S3BucketPath"].readIfPresent()
        value.s3BucketRoleArn = try reader["S3BucketRoleArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DataProviderDescriptor {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DataProviderDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DataProviderDescriptor()
        value.secretsManagerSecretId = try reader["SecretsManagerSecretId"].readIfPresent()
        value.secretsManagerAccessRoleArn = try reader["SecretsManagerAccessRoleArn"].readIfPresent()
        value.dataProviderName = try reader["DataProviderName"].readIfPresent()
        value.dataProviderArn = try reader["DataProviderArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationConfig()
        value.replicationConfigIdentifier = try reader["ReplicationConfigIdentifier"].readIfPresent()
        value.replicationConfigArn = try reader["ReplicationConfigArn"].readIfPresent()
        value.sourceEndpointArn = try reader["SourceEndpointArn"].readIfPresent()
        value.targetEndpointArn = try reader["TargetEndpointArn"].readIfPresent()
        value.replicationType = try reader["ReplicationType"].readIfPresent()
        value.computeConfig = try reader["ComputeConfig"].readIfPresent(with: DatabaseMigrationClientTypes.ComputeConfig.read(from:))
        value.replicationSettings = try reader["ReplicationSettings"].readIfPresent()
        value.supplementalSettings = try reader["SupplementalSettings"].readIfPresent()
        value.tableMappings = try reader["TableMappings"].readIfPresent()
        value.replicationConfigCreateTime = try reader["ReplicationConfigCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationConfigUpdateTime = try reader["ReplicationConfigUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.ComputeConfig {

    static func write(value: DatabaseMigrationClientTypes.ComputeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["DnsNameServers"].write(value.dnsNameServers)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MaxCapacityUnits"].write(value.maxCapacityUnits)
        try writer["MinCapacityUnits"].write(value.minCapacityUnits)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["ReplicationSubnetGroupId"].write(value.replicationSubnetGroupId)
        try writer["VpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ComputeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ComputeConfig()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.dnsNameServers = try reader["DnsNameServers"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.maxCapacityUnits = try reader["MaxCapacityUnits"].readIfPresent()
        value.minCapacityUnits = try reader["MinCapacityUnits"].readIfPresent()
        value.multiAZ = try reader["MultiAZ"].readIfPresent()
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.replicationSubnetGroupId = try reader["ReplicationSubnetGroupId"].readIfPresent()
        value.vpcSecurityGroupIds = try reader["VpcSecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationInstance()
        value.replicationInstanceIdentifier = try reader["ReplicationInstanceIdentifier"].readIfPresent()
        value.replicationInstanceClass = try reader["ReplicationInstanceClass"].readIfPresent()
        value.replicationInstanceStatus = try reader["ReplicationInstanceStatus"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent() ?? 0
        value.instanceCreateTime = try reader["InstanceCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.VpcSecurityGroupMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.replicationSubnetGroup = try reader["ReplicationSubnetGroup"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationSubnetGroup.read(from:))
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.pendingModifiedValues = try reader["PendingModifiedValues"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues.read(from:))
        value.multiAZ = try reader["MultiAZ"].readIfPresent() ?? false
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent() ?? false
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.replicationInstancePublicIpAddress = try reader["ReplicationInstancePublicIpAddress"].readIfPresent()
        value.replicationInstancePrivateIpAddress = try reader["ReplicationInstancePrivateIpAddress"].readIfPresent()
        value.replicationInstancePublicIpAddresses = try reader["ReplicationInstancePublicIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationInstancePrivateIpAddresses = try reader["ReplicationInstancePrivateIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationInstanceIpv6Addresses = try reader["ReplicationInstanceIpv6Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent() ?? false
        value.secondaryAvailabilityZone = try reader["SecondaryAvailabilityZone"].readIfPresent()
        value.freeUntil = try reader["FreeUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dnsNameServers = try reader["DnsNameServers"].readIfPresent()
        value.networkType = try reader["NetworkType"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationPendingModifiedValues {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationPendingModifiedValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationPendingModifiedValues()
        value.replicationInstanceClass = try reader["ReplicationInstanceClass"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.multiAZ = try reader["MultiAZ"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.networkType = try reader["NetworkType"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationSubnetGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationSubnetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationSubnetGroup()
        value.replicationSubnetGroupIdentifier = try reader["ReplicationSubnetGroupIdentifier"].readIfPresent()
        value.replicationSubnetGroupDescription = try reader["ReplicationSubnetGroupDescription"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnetGroupStatus = try reader["SubnetGroupStatus"].readIfPresent()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.Subnet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedNetworkTypes = try reader["SupportedNetworkTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.Subnet {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Subnet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Subnet()
        value.subnetIdentifier = try reader["SubnetIdentifier"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent(with: DatabaseMigrationClientTypes.AvailabilityZone.read(from:))
        value.subnetStatus = try reader["SubnetStatus"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.AvailabilityZone {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.AvailabilityZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.AvailabilityZone()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.VpcSecurityGroupMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.VpcSecurityGroupMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.VpcSecurityGroupMembership()
        value.vpcSecurityGroupId = try reader["VpcSecurityGroupId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTask {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTask()
        value.replicationTaskIdentifier = try reader["ReplicationTaskIdentifier"].readIfPresent()
        value.sourceEndpointArn = try reader["SourceEndpointArn"].readIfPresent()
        value.targetEndpointArn = try reader["TargetEndpointArn"].readIfPresent()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.migrationType = try reader["MigrationType"].readIfPresent()
        value.tableMappings = try reader["TableMappings"].readIfPresent()
        value.replicationTaskSettings = try reader["ReplicationTaskSettings"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lastFailureMessage = try reader["LastFailureMessage"].readIfPresent()
        value.stopReason = try reader["StopReason"].readIfPresent()
        value.replicationTaskCreationDate = try reader["ReplicationTaskCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationTaskStartDate = try reader["ReplicationTaskStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cdcStartPosition = try reader["CdcStartPosition"].readIfPresent()
        value.cdcStopPosition = try reader["CdcStopPosition"].readIfPresent()
        value.recoveryCheckpoint = try reader["RecoveryCheckpoint"].readIfPresent()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        value.replicationTaskStats = try reader["ReplicationTaskStats"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationTaskStats.read(from:))
        value.taskData = try reader["TaskData"].readIfPresent()
        value.targetReplicationInstanceArn = try reader["TargetReplicationInstanceArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskStats {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTaskStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTaskStats()
        value.fullLoadProgressPercent = try reader["FullLoadProgressPercent"].readIfPresent() ?? 0
        value.elapsedTimeMillis = try reader["ElapsedTimeMillis"].readIfPresent() ?? 0
        value.tablesLoaded = try reader["TablesLoaded"].readIfPresent() ?? 0
        value.tablesLoading = try reader["TablesLoading"].readIfPresent() ?? 0
        value.tablesQueued = try reader["TablesQueued"].readIfPresent() ?? 0
        value.tablesErrored = try reader["TablesErrored"].readIfPresent() ?? 0
        value.freshStartDate = try reader["FreshStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopDate = try reader["StopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadStartDate = try reader["FullLoadStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadFinishDate = try reader["FullLoadFinishDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.Certificate {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Certificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Certificate()
        value.certificateIdentifier = try reader["CertificateIdentifier"].readIfPresent()
        value.certificateCreationDate = try reader["CertificateCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.certificatePem = try reader["CertificatePem"].readIfPresent()
        value.certificateWallet = try reader["CertificateWallet"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.certificateOwner = try reader["CertificateOwner"].readIfPresent()
        value.validFromDate = try reader["ValidFromDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.validToDate = try reader["ValidToDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.signingAlgorithm = try reader["SigningAlgorithm"].readIfPresent()
        value.keyLength = try reader["KeyLength"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Connection()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lastFailureMessage = try reader["LastFailureMessage"].readIfPresent()
        value.endpointIdentifier = try reader["EndpointIdentifier"].readIfPresent()
        value.replicationInstanceIdentifier = try reader["ReplicationInstanceIdentifier"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.AccountQuota {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.AccountQuota {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.AccountQuota()
        value.accountQuotaName = try reader["AccountQuotaName"].readIfPresent()
        value.used = try reader["Used"].readIfPresent() ?? 0
        value.max = try reader["Max"].readIfPresent() ?? 0
        return value
    }
}

extension DatabaseMigrationClientTypes.EndpointSetting {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.EndpointSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.EndpointSetting()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.enumValues = try reader["EnumValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sensitive = try reader["Sensitive"].readIfPresent()
        value.units = try reader["Units"].readIfPresent()
        value.applicability = try reader["Applicability"].readIfPresent()
        value.intValueMin = try reader["IntValueMin"].readIfPresent()
        value.intValueMax = try reader["IntValueMax"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.SupportedEndpointType {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SupportedEndpointType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SupportedEndpointType()
        value.engineName = try reader["EngineName"].readIfPresent()
        value.supportsCDC = try reader["SupportsCDC"].readIfPresent() ?? false
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.replicationInstanceEngineMinimumVersion = try reader["ReplicationInstanceEngineMinimumVersion"].readIfPresent()
        value.engineDisplayName = try reader["EngineDisplayName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.EngineVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.EngineVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.EngineVersion()
        value.version = try reader["Version"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent()
        value.releaseStatus = try reader["ReleaseStatus"].readIfPresent()
        value.launchDate = try reader["LaunchDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.autoUpgradeDate = try reader["AutoUpgradeDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deprecationDate = try reader["DeprecationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.forceUpgradeDate = try reader["ForceUpgradeDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.availableUpgrades = try reader["AvailableUpgrades"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.EventCategoryGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.EventCategoryGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.EventCategoryGroup()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.eventCategories = try reader["EventCategories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Event()
        value.sourceIdentifier = try reader["SourceIdentifier"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.eventCategories = try reader["EventCategories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.SchemaConversionRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SchemaConversionRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SchemaConversionRequest()
        value.status = try reader["Status"].readIfPresent()
        value.requestIdentifier = try reader["RequestIdentifier"].readIfPresent()
        value.migrationProjectArn = try reader["MigrationProjectArn"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: DatabaseMigrationClientTypes.ErrorDetails.read(from:))
        value.exportSqlDetails = try reader["ExportSqlDetails"].readIfPresent(with: DatabaseMigrationClientTypes.ExportSqlDetails.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.ExportSqlDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ExportSqlDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ExportSqlDetails()
        value.s3ObjectKey = try reader["S3ObjectKey"].readIfPresent()
        value.objectURL = try reader["ObjectURL"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "defaultErrorDetails":
                return .defaulterrordetails(try reader["defaultErrorDetails"].read(with: DatabaseMigrationClientTypes.DefaultErrorDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DatabaseMigrationClientTypes.DefaultErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DefaultErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DefaultErrorDetails()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.CollectorResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.CollectorResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.CollectorResponse()
        value.collectorReferencedId = try reader["CollectorReferencedId"].readIfPresent()
        value.collectorName = try reader["CollectorName"].readIfPresent()
        value.collectorVersion = try reader["CollectorVersion"].readIfPresent()
        value.versionStatus = try reader["VersionStatus"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.serviceAccessRoleArn = try reader["ServiceAccessRoleArn"].readIfPresent()
        value.collectorHealthCheck = try reader["CollectorHealthCheck"].readIfPresent(with: DatabaseMigrationClientTypes.CollectorHealthCheck.read(from:))
        value.lastDataReceived = try reader["LastDataReceived"].readIfPresent()
        value.registeredDate = try reader["RegisteredDate"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.modifiedDate = try reader["ModifiedDate"].readIfPresent()
        value.inventoryData = try reader["InventoryData"].readIfPresent(with: DatabaseMigrationClientTypes.InventoryData.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.InventoryData {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.InventoryData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.InventoryData()
        value.numberOfDatabases = try reader["NumberOfDatabases"].readIfPresent()
        value.numberOfSchemas = try reader["NumberOfSchemas"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.CollectorHealthCheck {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.CollectorHealthCheck {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.CollectorHealthCheck()
        value.collectorStatus = try reader["CollectorStatus"].readIfPresent()
        value.localCollectorS3Access = try reader["LocalCollectorS3Access"].readIfPresent()
        value.webCollectorS3Access = try reader["WebCollectorS3Access"].readIfPresent()
        value.webCollectorGrantedRoleBasedAccess = try reader["WebCollectorGrantedRoleBasedAccess"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DatabaseResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DatabaseResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DatabaseResponse()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.numberOfSchemas = try reader["NumberOfSchemas"].readIfPresent()
        value.server = try reader["Server"].readIfPresent(with: DatabaseMigrationClientTypes.ServerShortInfoResponse.read(from:))
        value.softwareDetails = try reader["SoftwareDetails"].readIfPresent(with: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse.read(from:))
        value.collectors = try reader["Collectors"].readListIfPresent(memberReadingClosure: DatabaseMigrationClientTypes.CollectorShortInfoResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DatabaseMigrationClientTypes.CollectorShortInfoResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.CollectorShortInfoResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.CollectorShortInfoResponse()
        value.collectorReferencedId = try reader["CollectorReferencedId"].readIfPresent()
        value.collectorName = try reader["CollectorName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.engineEdition = try reader["EngineEdition"].readIfPresent()
        value.servicePack = try reader["ServicePack"].readIfPresent()
        value.supportLevel = try reader["SupportLevel"].readIfPresent()
        value.osArchitecture = try reader["OsArchitecture"].readIfPresent()
        value.tooltip = try reader["Tooltip"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ServerShortInfoResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ServerShortInfoResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ServerShortInfoResponse()
        value.serverId = try reader["ServerId"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse()
        value.lsaAnalysisId = try reader["LsaAnalysisId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.objectType = try reader["ObjectType"].readIfPresent()
        value.numberOfObjects = try reader["NumberOfObjects"].readIfPresent()
        value.codeLineCount = try reader["CodeLineCount"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.SchemaResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SchemaResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SchemaResponse()
        value.codeLineCount = try reader["CodeLineCount"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent()
        value.complexity = try reader["Complexity"].readIfPresent()
        value.server = try reader["Server"].readIfPresent(with: DatabaseMigrationClientTypes.ServerShortInfoResponse.read(from:))
        value.databaseInstance = try reader["DatabaseInstance"].readIfPresent(with: DatabaseMigrationClientTypes.DatabaseShortInfoResponse.read(from:))
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.originalSchema = try reader["OriginalSchema"].readIfPresent(with: DatabaseMigrationClientTypes.SchemaShortInfoResponse.read(from:))
        value.similarity = try reader["Similarity"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.SchemaShortInfoResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.SchemaShortInfoResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.SchemaShortInfoResponse()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.databaseIpAddress = try reader["DatabaseIpAddress"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.DatabaseShortInfoResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.DatabaseShortInfoResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.DatabaseShortInfoResponse()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.databaseIpAddress = try reader["DatabaseIpAddress"].readIfPresent()
        value.databaseEngine = try reader["DatabaseEngine"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.OrderableReplicationInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.OrderableReplicationInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.OrderableReplicationInstance()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.replicationInstanceClass = try reader["ReplicationInstanceClass"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        value.minAllocatedStorage = try reader["MinAllocatedStorage"].readIfPresent() ?? 0
        value.maxAllocatedStorage = try reader["MaxAllocatedStorage"].readIfPresent() ?? 0
        value.defaultAllocatedStorage = try reader["DefaultAllocatedStorage"].readIfPresent() ?? 0
        value.includedAllocatedStorage = try reader["IncludedAllocatedStorage"].readIfPresent() ?? 0
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.releaseStatus = try reader["ReleaseStatus"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.Limitation {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Limitation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Limitation()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.engineName = try reader["EngineName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.impact = try reader["Impact"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Recommendation()
        value.databaseId = try reader["DatabaseId"].readIfPresent()
        value.engineName = try reader["EngineName"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.preferred = try reader["Preferred"].readIfPresent()
        value.settings = try reader["Settings"].readIfPresent(with: DatabaseMigrationClientTypes.RecommendationSettings.read(from:))
        value.data = try reader["Data"].readIfPresent(with: DatabaseMigrationClientTypes.RecommendationData.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.RecommendationData {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RecommendationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RecommendationData()
        value.rdsEngine = try reader["RdsEngine"].readIfPresent(with: DatabaseMigrationClientTypes.RdsRecommendation.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.RdsRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RdsRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RdsRecommendation()
        value.requirementsToTarget = try reader["RequirementsToTarget"].readIfPresent(with: DatabaseMigrationClientTypes.RdsRequirements.read(from:))
        value.targetConfiguration = try reader["TargetConfiguration"].readIfPresent(with: DatabaseMigrationClientTypes.RdsConfiguration.read(from:))
        return value
    }
}

extension DatabaseMigrationClientTypes.RdsConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RdsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RdsConfiguration()
        value.engineEdition = try reader["EngineEdition"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.instanceVcpu = try reader["InstanceVcpu"].readIfPresent()
        value.instanceMemory = try reader["InstanceMemory"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        value.storageSize = try reader["StorageSize"].readIfPresent()
        value.storageIops = try reader["StorageIops"].readIfPresent()
        value.deploymentOption = try reader["DeploymentOption"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.RdsRequirements {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RdsRequirements {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RdsRequirements()
        value.engineEdition = try reader["EngineEdition"].readIfPresent()
        value.instanceVcpu = try reader["InstanceVcpu"].readIfPresent()
        value.instanceMemory = try reader["InstanceMemory"].readIfPresent()
        value.storageSize = try reader["StorageSize"].readIfPresent()
        value.storageIops = try reader["StorageIops"].readIfPresent()
        value.deploymentOption = try reader["DeploymentOption"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.RecommendationSettings {

    static func write(value: DatabaseMigrationClientTypes.RecommendationSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceSizingType"].write(value.instanceSizingType)
        try writer["WorkloadType"].write(value.workloadType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RecommendationSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RecommendationSettings()
        value.instanceSizingType = try reader["InstanceSizingType"].readIfPresent() ?? ""
        value.workloadType = try reader["WorkloadType"].readIfPresent() ?? ""
        return value
    }
}

extension DatabaseMigrationClientTypes.RefreshSchemasStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.RefreshSchemasStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.RefreshSchemasStatus()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.lastRefreshDate = try reader["LastRefreshDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastFailureMessage = try reader["LastFailureMessage"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstanceTaskLog {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationInstanceTaskLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationInstanceTaskLog()
        value.replicationTaskName = try reader["ReplicationTaskName"].readIfPresent()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        value.replicationInstanceTaskLogSize = try reader["ReplicationInstanceTaskLogSize"].readIfPresent() ?? 0
        return value
    }
}

extension DatabaseMigrationClientTypes.Replication {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Replication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Replication()
        value.replicationConfigIdentifier = try reader["ReplicationConfigIdentifier"].readIfPresent()
        value.replicationConfigArn = try reader["ReplicationConfigArn"].readIfPresent()
        value.sourceEndpointArn = try reader["SourceEndpointArn"].readIfPresent()
        value.targetEndpointArn = try reader["TargetEndpointArn"].readIfPresent()
        value.replicationType = try reader["ReplicationType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.provisionData = try reader["ProvisionData"].readIfPresent(with: DatabaseMigrationClientTypes.ProvisionData.read(from:))
        value.stopReason = try reader["StopReason"].readIfPresent()
        value.failureMessages = try reader["FailureMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationStats = try reader["ReplicationStats"].readIfPresent(with: DatabaseMigrationClientTypes.ReplicationStats.read(from:))
        value.startReplicationType = try reader["StartReplicationType"].readIfPresent()
        value.cdcStartTime = try reader["CdcStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cdcStartPosition = try reader["CdcStartPosition"].readIfPresent()
        value.cdcStopPosition = try reader["CdcStopPosition"].readIfPresent()
        value.recoveryCheckpoint = try reader["RecoveryCheckpoint"].readIfPresent()
        value.replicationCreateTime = try reader["ReplicationCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationUpdateTime = try reader["ReplicationUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationLastStopTime = try reader["ReplicationLastStopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationDeprovisionTime = try reader["ReplicationDeprovisionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationStats {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationStats()
        value.fullLoadProgressPercent = try reader["FullLoadProgressPercent"].readIfPresent() ?? 0
        value.elapsedTimeMillis = try reader["ElapsedTimeMillis"].readIfPresent() ?? 0
        value.tablesLoaded = try reader["TablesLoaded"].readIfPresent() ?? 0
        value.tablesLoading = try reader["TablesLoading"].readIfPresent() ?? 0
        value.tablesQueued = try reader["TablesQueued"].readIfPresent() ?? 0
        value.tablesErrored = try reader["TablesErrored"].readIfPresent() ?? 0
        value.freshStartDate = try reader["FreshStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopDate = try reader["StopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadStartDate = try reader["FullLoadStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadFinishDate = try reader["FullLoadFinishDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.ProvisionData {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ProvisionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ProvisionData()
        value.provisionState = try reader["ProvisionState"].readIfPresent()
        value.provisionedCapacityUnits = try reader["ProvisionedCapacityUnits"].readIfPresent() ?? 0
        value.dateProvisioned = try reader["DateProvisioned"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isNewProvisioningAvailable = try reader["IsNewProvisioningAvailable"].readIfPresent() ?? false
        value.dateNewProvisioningDataAvailable = try reader["DateNewProvisioningDataAvailable"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.reasonForNewProvisioningData = try reader["ReasonForNewProvisioningData"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.TableStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.TableStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.TableStatistics()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.inserts = try reader["Inserts"].readIfPresent() ?? 0
        value.deletes = try reader["Deletes"].readIfPresent() ?? 0
        value.updates = try reader["Updates"].readIfPresent() ?? 0
        value.ddls = try reader["Ddls"].readIfPresent() ?? 0
        value.appliedInserts = try reader["AppliedInserts"].readIfPresent()
        value.appliedDeletes = try reader["AppliedDeletes"].readIfPresent()
        value.appliedUpdates = try reader["AppliedUpdates"].readIfPresent()
        value.appliedDdls = try reader["AppliedDdls"].readIfPresent()
        value.fullLoadRows = try reader["FullLoadRows"].readIfPresent() ?? 0
        value.fullLoadCondtnlChkFailedRows = try reader["FullLoadCondtnlChkFailedRows"].readIfPresent() ?? 0
        value.fullLoadErrorRows = try reader["FullLoadErrorRows"].readIfPresent() ?? 0
        value.fullLoadStartTime = try reader["FullLoadStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadEndTime = try reader["FullLoadEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fullLoadReloaded = try reader["FullLoadReloaded"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tableState = try reader["TableState"].readIfPresent()
        value.validationPendingRecords = try reader["ValidationPendingRecords"].readIfPresent() ?? 0
        value.validationFailedRecords = try reader["ValidationFailedRecords"].readIfPresent() ?? 0
        value.validationSuspendedRecords = try reader["ValidationSuspendedRecords"].readIfPresent() ?? 0
        value.validationState = try reader["ValidationState"].readIfPresent()
        value.validationStateDetails = try reader["ValidationStateDetails"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult()
        value.replicationTaskIdentifier = try reader["ReplicationTaskIdentifier"].readIfPresent()
        value.replicationTaskArn = try reader["ReplicationTaskArn"].readIfPresent()
        value.replicationTaskLastAssessmentDate = try reader["ReplicationTaskLastAssessmentDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assessmentStatus = try reader["AssessmentStatus"].readIfPresent()
        value.assessmentResultsFile = try reader["AssessmentResultsFile"].readIfPresent()
        value.assessmentResults = try reader["AssessmentResults"].readIfPresent()
        value.s3ObjectUrl = try reader["S3ObjectUrl"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment()
        value.replicationTaskIndividualAssessmentArn = try reader["ReplicationTaskIndividualAssessmentArn"].readIfPresent()
        value.replicationTaskAssessmentRunArn = try reader["ReplicationTaskAssessmentRunArn"].readIfPresent()
        value.individualAssessmentName = try reader["IndividualAssessmentName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.replicationTaskIndividualAssessmentStartDate = try reader["ReplicationTaskIndividualAssessmentStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry()
        value.s3ObjectKey = try reader["S3ObjectKey"].readIfPresent()
        value.objectURL = try reader["ObjectURL"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.Tag {

    static func write(value: DatabaseMigrationClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DatabaseMigrationClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DatabaseMigrationClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension DatabaseMigrationClientTypes.StartRecommendationsRequestEntry {

    static func write(value: DatabaseMigrationClientTypes.StartRecommendationsRequestEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseId"].write(value.databaseId)
        try writer["Settings"].write(value.settings, with: DatabaseMigrationClientTypes.RecommendationSettings.write(value:to:))
    }
}

extension DatabaseMigrationClientTypes.DataProviderDescriptorDefinition {

    static func write(value: DatabaseMigrationClientTypes.DataProviderDescriptorDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataProviderIdentifier"].write(value.dataProviderIdentifier)
        try writer["SecretsManagerAccessRoleArn"].write(value.secretsManagerAccessRoleArn)
        try writer["SecretsManagerSecretId"].write(value.secretsManagerSecretId)
    }
}

extension DatabaseMigrationClientTypes.Filter {

    static func write(value: DatabaseMigrationClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DatabaseMigrationClientTypes.TableToReload {

    static func write(value: DatabaseMigrationClientTypes.TableToReload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaName"].write(value.schemaName)
        try writer["TableName"].write(value.tableName)
    }
}

public enum DatabaseMigrationClientTypes {}
