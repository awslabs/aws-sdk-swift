// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DatabaseMigrationClient {
    /// Paginate over `[DescribeApplicableIndividualAssessmentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeApplicableIndividualAssessmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeApplicableIndividualAssessmentsOutputResponse`
    public func describeApplicableIndividualAssessmentsPaginated(input: DescribeApplicableIndividualAssessmentsInput) -> ClientRuntime.PaginatorSequence<DescribeApplicableIndividualAssessmentsInput, DescribeApplicableIndividualAssessmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeApplicableIndividualAssessmentsInput, DescribeApplicableIndividualAssessmentsOutputResponse>(input: input, inputKey: \DescribeApplicableIndividualAssessmentsInput.marker, outputKey: \DescribeApplicableIndividualAssessmentsOutputResponse.marker, paginationFunction: self.describeApplicableIndividualAssessments(input:))
    }
}

extension DescribeApplicableIndividualAssessmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeApplicableIndividualAssessmentsInput {
        return DescribeApplicableIndividualAssessmentsInput(
            marker: token,
            maxRecords: self.maxRecords,
            migrationType: self.migrationType,
            replicationInstanceArn: self.replicationInstanceArn,
            replicationTaskArn: self.replicationTaskArn,
            sourceEngineName: self.sourceEngineName,
            targetEngineName: self.targetEngineName
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeCertificatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeCertificatesOutputResponse`
    public func describeCertificatesPaginated(input: DescribeCertificatesInput) -> ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutputResponse>(input: input, inputKey: \DescribeCertificatesInput.marker, outputKey: \DescribeCertificatesOutputResponse.marker, paginationFunction: self.describeCertificates(input:))
    }
}

extension DescribeCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCertificatesInput {
        return DescribeCertificatesInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeConnectionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeConnectionsOutputResponse`
    public func describeConnectionsPaginated(input: DescribeConnectionsInput) -> ClientRuntime.PaginatorSequence<DescribeConnectionsInput, DescribeConnectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeConnectionsInput, DescribeConnectionsOutputResponse>(input: input, inputKey: \DescribeConnectionsInput.marker, outputKey: \DescribeConnectionsOutputResponse.marker, paginationFunction: self.describeConnections(input:))
    }
}

extension DescribeConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConnectionsInput {
        return DescribeConnectionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeDataProvidersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataProvidersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataProvidersOutputResponse`
    public func describeDataProvidersPaginated(input: DescribeDataProvidersInput) -> ClientRuntime.PaginatorSequence<DescribeDataProvidersInput, DescribeDataProvidersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataProvidersInput, DescribeDataProvidersOutputResponse>(input: input, inputKey: \DescribeDataProvidersInput.marker, outputKey: \DescribeDataProvidersOutputResponse.marker, paginationFunction: self.describeDataProviders(input:))
    }
}

extension DescribeDataProvidersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataProvidersInput {
        return DescribeDataProvidersInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEndpointsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointsOutputResponse`
    public func describeEndpointsPaginated(input: DescribeEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointsInput, DescribeEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointsInput, DescribeEndpointsOutputResponse>(input: input, inputKey: \DescribeEndpointsInput.marker, outputKey: \DescribeEndpointsOutputResponse.marker, paginationFunction: self.describeEndpoints(input:))
    }
}

extension DescribeEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointsInput {
        return DescribeEndpointsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEndpointSettingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointSettingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointSettingsOutputResponse`
    public func describeEndpointSettingsPaginated(input: DescribeEndpointSettingsInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointSettingsInput, DescribeEndpointSettingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointSettingsInput, DescribeEndpointSettingsOutputResponse>(input: input, inputKey: \DescribeEndpointSettingsInput.marker, outputKey: \DescribeEndpointSettingsOutputResponse.marker, paginationFunction: self.describeEndpointSettings(input:))
    }
}

extension DescribeEndpointSettingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointSettingsInput {
        return DescribeEndpointSettingsInput(
            engineName: self.engineName,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEndpointTypesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointTypesOutputResponse`
    public func describeEndpointTypesPaginated(input: DescribeEndpointTypesInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointTypesInput, DescribeEndpointTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointTypesInput, DescribeEndpointTypesOutputResponse>(input: input, inputKey: \DescribeEndpointTypesInput.marker, outputKey: \DescribeEndpointTypesOutputResponse.marker, paginationFunction: self.describeEndpointTypes(input:))
    }
}

extension DescribeEndpointTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointTypesInput {
        return DescribeEndpointTypesInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEngineVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEngineVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEngineVersionsOutputResponse`
    public func describeEngineVersionsPaginated(input: DescribeEngineVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutputResponse>(input: input, inputKey: \DescribeEngineVersionsInput.marker, outputKey: \DescribeEngineVersionsOutputResponse.marker, paginationFunction: self.describeEngineVersions(input:))
    }
}

extension DescribeEngineVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEngineVersionsInput {
        return DescribeEngineVersionsInput(
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEventsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutputResponse`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse>(input: input, inputKey: \DescribeEventsInput.marker, outputKey: \DescribeEventsOutputResponse.marker, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            eventCategories: self.eventCategories,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeEventSubscriptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventSubscriptionsOutputResponse`
    public func describeEventSubscriptionsPaginated(input: DescribeEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse>(input: input, inputKey: \DescribeEventSubscriptionsInput.marker, outputKey: \DescribeEventSubscriptionsOutputResponse.marker, paginationFunction: self.describeEventSubscriptions(input:))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventSubscriptionsInput {
        return DescribeEventSubscriptionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeExtensionPackAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeExtensionPackAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeExtensionPackAssociationsOutputResponse`
    public func describeExtensionPackAssociationsPaginated(input: DescribeExtensionPackAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeExtensionPackAssociationsInput, DescribeExtensionPackAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeExtensionPackAssociationsInput, DescribeExtensionPackAssociationsOutputResponse>(input: input, inputKey: \DescribeExtensionPackAssociationsInput.marker, outputKey: \DescribeExtensionPackAssociationsOutputResponse.marker, paginationFunction: self.describeExtensionPackAssociations(input:))
    }
}

extension DescribeExtensionPackAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExtensionPackAssociationsInput {
        return DescribeExtensionPackAssociationsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeFleetAdvisorCollectorsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAdvisorCollectorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAdvisorCollectorsOutputResponse`
    public func describeFleetAdvisorCollectorsPaginated(input: DescribeFleetAdvisorCollectorsInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAdvisorCollectorsInput, DescribeFleetAdvisorCollectorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAdvisorCollectorsInput, DescribeFleetAdvisorCollectorsOutputResponse>(input: input, inputKey: \DescribeFleetAdvisorCollectorsInput.nextToken, outputKey: \DescribeFleetAdvisorCollectorsOutputResponse.nextToken, paginationFunction: self.describeFleetAdvisorCollectors(input:))
    }
}

extension DescribeFleetAdvisorCollectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAdvisorCollectorsInput {
        return DescribeFleetAdvisorCollectorsInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeFleetAdvisorDatabasesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAdvisorDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAdvisorDatabasesOutputResponse`
    public func describeFleetAdvisorDatabasesPaginated(input: DescribeFleetAdvisorDatabasesInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAdvisorDatabasesInput, DescribeFleetAdvisorDatabasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAdvisorDatabasesInput, DescribeFleetAdvisorDatabasesOutputResponse>(input: input, inputKey: \DescribeFleetAdvisorDatabasesInput.nextToken, outputKey: \DescribeFleetAdvisorDatabasesOutputResponse.nextToken, paginationFunction: self.describeFleetAdvisorDatabases(input:))
    }
}

extension DescribeFleetAdvisorDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAdvisorDatabasesInput {
        return DescribeFleetAdvisorDatabasesInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeFleetAdvisorLsaAnalysisOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAdvisorLsaAnalysisInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAdvisorLsaAnalysisOutputResponse`
    public func describeFleetAdvisorLsaAnalysisPaginated(input: DescribeFleetAdvisorLsaAnalysisInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAdvisorLsaAnalysisInput, DescribeFleetAdvisorLsaAnalysisOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAdvisorLsaAnalysisInput, DescribeFleetAdvisorLsaAnalysisOutputResponse>(input: input, inputKey: \DescribeFleetAdvisorLsaAnalysisInput.nextToken, outputKey: \DescribeFleetAdvisorLsaAnalysisOutputResponse.nextToken, paginationFunction: self.describeFleetAdvisorLsaAnalysis(input:))
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAdvisorLsaAnalysisInput {
        return DescribeFleetAdvisorLsaAnalysisInput(
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeFleetAdvisorSchemaObjectSummaryOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAdvisorSchemaObjectSummaryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAdvisorSchemaObjectSummaryOutputResponse`
    public func describeFleetAdvisorSchemaObjectSummaryPaginated(input: DescribeFleetAdvisorSchemaObjectSummaryInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAdvisorSchemaObjectSummaryInput, DescribeFleetAdvisorSchemaObjectSummaryOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAdvisorSchemaObjectSummaryInput, DescribeFleetAdvisorSchemaObjectSummaryOutputResponse>(input: input, inputKey: \DescribeFleetAdvisorSchemaObjectSummaryInput.nextToken, outputKey: \DescribeFleetAdvisorSchemaObjectSummaryOutputResponse.nextToken, paginationFunction: self.describeFleetAdvisorSchemaObjectSummary(input:))
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAdvisorSchemaObjectSummaryInput {
        return DescribeFleetAdvisorSchemaObjectSummaryInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeFleetAdvisorSchemasOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAdvisorSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAdvisorSchemasOutputResponse`
    public func describeFleetAdvisorSchemasPaginated(input: DescribeFleetAdvisorSchemasInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAdvisorSchemasInput, DescribeFleetAdvisorSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAdvisorSchemasInput, DescribeFleetAdvisorSchemasOutputResponse>(input: input, inputKey: \DescribeFleetAdvisorSchemasInput.nextToken, outputKey: \DescribeFleetAdvisorSchemasOutputResponse.nextToken, paginationFunction: self.describeFleetAdvisorSchemas(input:))
    }
}

extension DescribeFleetAdvisorSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAdvisorSchemasInput {
        return DescribeFleetAdvisorSchemasInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeInstanceProfilesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstanceProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceProfilesOutputResponse`
    public func describeInstanceProfilesPaginated(input: DescribeInstanceProfilesInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceProfilesInput, DescribeInstanceProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceProfilesInput, DescribeInstanceProfilesOutputResponse>(input: input, inputKey: \DescribeInstanceProfilesInput.marker, outputKey: \DescribeInstanceProfilesOutputResponse.marker, paginationFunction: self.describeInstanceProfiles(input:))
    }
}

extension DescribeInstanceProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceProfilesInput {
        return DescribeInstanceProfilesInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMetadataModelAssessmentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMetadataModelAssessmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMetadataModelAssessmentsOutputResponse`
    public func describeMetadataModelAssessmentsPaginated(input: DescribeMetadataModelAssessmentsInput) -> ClientRuntime.PaginatorSequence<DescribeMetadataModelAssessmentsInput, DescribeMetadataModelAssessmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMetadataModelAssessmentsInput, DescribeMetadataModelAssessmentsOutputResponse>(input: input, inputKey: \DescribeMetadataModelAssessmentsInput.marker, outputKey: \DescribeMetadataModelAssessmentsOutputResponse.marker, paginationFunction: self.describeMetadataModelAssessments(input:))
    }
}

extension DescribeMetadataModelAssessmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMetadataModelAssessmentsInput {
        return DescribeMetadataModelAssessmentsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMetadataModelConversionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMetadataModelConversionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMetadataModelConversionsOutputResponse`
    public func describeMetadataModelConversionsPaginated(input: DescribeMetadataModelConversionsInput) -> ClientRuntime.PaginatorSequence<DescribeMetadataModelConversionsInput, DescribeMetadataModelConversionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMetadataModelConversionsInput, DescribeMetadataModelConversionsOutputResponse>(input: input, inputKey: \DescribeMetadataModelConversionsInput.marker, outputKey: \DescribeMetadataModelConversionsOutputResponse.marker, paginationFunction: self.describeMetadataModelConversions(input:))
    }
}

extension DescribeMetadataModelConversionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMetadataModelConversionsInput {
        return DescribeMetadataModelConversionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMetadataModelExportsAsScriptOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMetadataModelExportsAsScriptInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMetadataModelExportsAsScriptOutputResponse`
    public func describeMetadataModelExportsAsScriptPaginated(input: DescribeMetadataModelExportsAsScriptInput) -> ClientRuntime.PaginatorSequence<DescribeMetadataModelExportsAsScriptInput, DescribeMetadataModelExportsAsScriptOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMetadataModelExportsAsScriptInput, DescribeMetadataModelExportsAsScriptOutputResponse>(input: input, inputKey: \DescribeMetadataModelExportsAsScriptInput.marker, outputKey: \DescribeMetadataModelExportsAsScriptOutputResponse.marker, paginationFunction: self.describeMetadataModelExportsAsScript(input:))
    }
}

extension DescribeMetadataModelExportsAsScriptInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMetadataModelExportsAsScriptInput {
        return DescribeMetadataModelExportsAsScriptInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMetadataModelExportsToTargetOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMetadataModelExportsToTargetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMetadataModelExportsToTargetOutputResponse`
    public func describeMetadataModelExportsToTargetPaginated(input: DescribeMetadataModelExportsToTargetInput) -> ClientRuntime.PaginatorSequence<DescribeMetadataModelExportsToTargetInput, DescribeMetadataModelExportsToTargetOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMetadataModelExportsToTargetInput, DescribeMetadataModelExportsToTargetOutputResponse>(input: input, inputKey: \DescribeMetadataModelExportsToTargetInput.marker, outputKey: \DescribeMetadataModelExportsToTargetOutputResponse.marker, paginationFunction: self.describeMetadataModelExportsToTarget(input:))
    }
}

extension DescribeMetadataModelExportsToTargetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMetadataModelExportsToTargetInput {
        return DescribeMetadataModelExportsToTargetInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMetadataModelImportsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMetadataModelImportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMetadataModelImportsOutputResponse`
    public func describeMetadataModelImportsPaginated(input: DescribeMetadataModelImportsInput) -> ClientRuntime.PaginatorSequence<DescribeMetadataModelImportsInput, DescribeMetadataModelImportsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMetadataModelImportsInput, DescribeMetadataModelImportsOutputResponse>(input: input, inputKey: \DescribeMetadataModelImportsInput.marker, outputKey: \DescribeMetadataModelImportsOutputResponse.marker, paginationFunction: self.describeMetadataModelImports(input:))
    }
}

extension DescribeMetadataModelImportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMetadataModelImportsInput {
        return DescribeMetadataModelImportsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeMigrationProjectsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMigrationProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMigrationProjectsOutputResponse`
    public func describeMigrationProjectsPaginated(input: DescribeMigrationProjectsInput) -> ClientRuntime.PaginatorSequence<DescribeMigrationProjectsInput, DescribeMigrationProjectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMigrationProjectsInput, DescribeMigrationProjectsOutputResponse>(input: input, inputKey: \DescribeMigrationProjectsInput.marker, outputKey: \DescribeMigrationProjectsOutputResponse.marker, paginationFunction: self.describeMigrationProjects(input:))
    }
}

extension DescribeMigrationProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMigrationProjectsInput {
        return DescribeMigrationProjectsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeOrderableReplicationInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOrderableReplicationInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOrderableReplicationInstancesOutputResponse`
    public func describeOrderableReplicationInstancesPaginated(input: DescribeOrderableReplicationInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeOrderableReplicationInstancesInput, DescribeOrderableReplicationInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrderableReplicationInstancesInput, DescribeOrderableReplicationInstancesOutputResponse>(input: input, inputKey: \DescribeOrderableReplicationInstancesInput.marker, outputKey: \DescribeOrderableReplicationInstancesOutputResponse.marker, paginationFunction: self.describeOrderableReplicationInstances(input:))
    }
}

extension DescribeOrderableReplicationInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrderableReplicationInstancesInput {
        return DescribeOrderableReplicationInstancesInput(
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribePendingMaintenanceActionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePendingMaintenanceActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePendingMaintenanceActionsOutputResponse`
    public func describePendingMaintenanceActionsPaginated(input: DescribePendingMaintenanceActionsInput) -> ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutputResponse>(input: input, inputKey: \DescribePendingMaintenanceActionsInput.marker, outputKey: \DescribePendingMaintenanceActionsOutputResponse.marker, paginationFunction: self.describePendingMaintenanceActions(input:))
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePendingMaintenanceActionsInput {
        return DescribePendingMaintenanceActionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationInstanceArn: self.replicationInstanceArn
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeRecommendationLimitationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRecommendationLimitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRecommendationLimitationsOutputResponse`
    public func describeRecommendationLimitationsPaginated(input: DescribeRecommendationLimitationsInput) -> ClientRuntime.PaginatorSequence<DescribeRecommendationLimitationsInput, DescribeRecommendationLimitationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRecommendationLimitationsInput, DescribeRecommendationLimitationsOutputResponse>(input: input, inputKey: \DescribeRecommendationLimitationsInput.nextToken, outputKey: \DescribeRecommendationLimitationsOutputResponse.nextToken, paginationFunction: self.describeRecommendationLimitations(input:))
    }
}

extension DescribeRecommendationLimitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRecommendationLimitationsInput {
        return DescribeRecommendationLimitationsInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeRecommendationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRecommendationsOutputResponse`
    public func describeRecommendationsPaginated(input: DescribeRecommendationsInput) -> ClientRuntime.PaginatorSequence<DescribeRecommendationsInput, DescribeRecommendationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeRecommendationsInput, DescribeRecommendationsOutputResponse>(input: input, inputKey: \DescribeRecommendationsInput.nextToken, outputKey: \DescribeRecommendationsOutputResponse.nextToken, paginationFunction: self.describeRecommendations(input:))
    }
}

extension DescribeRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRecommendationsInput {
        return DescribeRecommendationsInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationConfigsOutputResponse`
    public func describeReplicationConfigsPaginated(input: DescribeReplicationConfigsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationConfigsInput, DescribeReplicationConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationConfigsInput, DescribeReplicationConfigsOutputResponse>(input: input, inputKey: \DescribeReplicationConfigsInput.marker, outputKey: \DescribeReplicationConfigsOutputResponse.marker, paginationFunction: self.describeReplicationConfigs(input:))
    }
}

extension DescribeReplicationConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationConfigsInput {
        return DescribeReplicationConfigsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationInstancesOutputResponse`
    public func describeReplicationInstancesPaginated(input: DescribeReplicationInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationInstancesInput, DescribeReplicationInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationInstancesInput, DescribeReplicationInstancesOutputResponse>(input: input, inputKey: \DescribeReplicationInstancesInput.marker, outputKey: \DescribeReplicationInstancesOutputResponse.marker, paginationFunction: self.describeReplicationInstances(input:))
    }
}

extension DescribeReplicationInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationInstancesInput {
        return DescribeReplicationInstancesInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationInstanceTaskLogsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationInstanceTaskLogsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationInstanceTaskLogsOutputResponse`
    public func describeReplicationInstanceTaskLogsPaginated(input: DescribeReplicationInstanceTaskLogsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationInstanceTaskLogsInput, DescribeReplicationInstanceTaskLogsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationInstanceTaskLogsInput, DescribeReplicationInstanceTaskLogsOutputResponse>(input: input, inputKey: \DescribeReplicationInstanceTaskLogsInput.marker, outputKey: \DescribeReplicationInstanceTaskLogsOutputResponse.marker, paginationFunction: self.describeReplicationInstanceTaskLogs(input:))
    }
}

extension DescribeReplicationInstanceTaskLogsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationInstanceTaskLogsInput {
        return DescribeReplicationInstanceTaskLogsInput(
            marker: token,
            maxRecords: self.maxRecords,
            replicationInstanceArn: self.replicationInstanceArn
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationsOutputResponse`
    public func describeReplicationsPaginated(input: DescribeReplicationsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationsInput, DescribeReplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationsInput, DescribeReplicationsOutputResponse>(input: input, inputKey: \DescribeReplicationsInput.marker, outputKey: \DescribeReplicationsOutputResponse.marker, paginationFunction: self.describeReplications(input:))
    }
}

extension DescribeReplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationsInput {
        return DescribeReplicationsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationSubnetGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationSubnetGroupsOutputResponse`
    public func describeReplicationSubnetGroupsPaginated(input: DescribeReplicationSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationSubnetGroupsInput, DescribeReplicationSubnetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationSubnetGroupsInput, DescribeReplicationSubnetGroupsOutputResponse>(input: input, inputKey: \DescribeReplicationSubnetGroupsInput.marker, outputKey: \DescribeReplicationSubnetGroupsOutputResponse.marker, paginationFunction: self.describeReplicationSubnetGroups(input:))
    }
}

extension DescribeReplicationSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationSubnetGroupsInput {
        return DescribeReplicationSubnetGroupsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationTableStatisticsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationTableStatisticsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationTableStatisticsOutputResponse`
    public func describeReplicationTableStatisticsPaginated(input: DescribeReplicationTableStatisticsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationTableStatisticsInput, DescribeReplicationTableStatisticsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationTableStatisticsInput, DescribeReplicationTableStatisticsOutputResponse>(input: input, inputKey: \DescribeReplicationTableStatisticsInput.marker, outputKey: \DescribeReplicationTableStatisticsOutputResponse.marker, paginationFunction: self.describeReplicationTableStatistics(input:))
    }
}

extension DescribeReplicationTableStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationTableStatisticsInput {
        return DescribeReplicationTableStatisticsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationConfigArn: self.replicationConfigArn
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationTaskAssessmentResultsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationTaskAssessmentResultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationTaskAssessmentResultsOutputResponse`
    public func describeReplicationTaskAssessmentResultsPaginated(input: DescribeReplicationTaskAssessmentResultsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationTaskAssessmentResultsInput, DescribeReplicationTaskAssessmentResultsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationTaskAssessmentResultsInput, DescribeReplicationTaskAssessmentResultsOutputResponse>(input: input, inputKey: \DescribeReplicationTaskAssessmentResultsInput.marker, outputKey: \DescribeReplicationTaskAssessmentResultsOutputResponse.marker, paginationFunction: self.describeReplicationTaskAssessmentResults(input:))
    }
}

extension DescribeReplicationTaskAssessmentResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationTaskAssessmentResultsInput {
        return DescribeReplicationTaskAssessmentResultsInput(
            marker: token,
            maxRecords: self.maxRecords,
            replicationTaskArn: self.replicationTaskArn
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationTaskAssessmentRunsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationTaskAssessmentRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationTaskAssessmentRunsOutputResponse`
    public func describeReplicationTaskAssessmentRunsPaginated(input: DescribeReplicationTaskAssessmentRunsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationTaskAssessmentRunsInput, DescribeReplicationTaskAssessmentRunsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationTaskAssessmentRunsInput, DescribeReplicationTaskAssessmentRunsOutputResponse>(input: input, inputKey: \DescribeReplicationTaskAssessmentRunsInput.marker, outputKey: \DescribeReplicationTaskAssessmentRunsOutputResponse.marker, paginationFunction: self.describeReplicationTaskAssessmentRuns(input:))
    }
}

extension DescribeReplicationTaskAssessmentRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationTaskAssessmentRunsInput {
        return DescribeReplicationTaskAssessmentRunsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationTaskIndividualAssessmentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationTaskIndividualAssessmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationTaskIndividualAssessmentsOutputResponse`
    public func describeReplicationTaskIndividualAssessmentsPaginated(input: DescribeReplicationTaskIndividualAssessmentsInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationTaskIndividualAssessmentsInput, DescribeReplicationTaskIndividualAssessmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationTaskIndividualAssessmentsInput, DescribeReplicationTaskIndividualAssessmentsOutputResponse>(input: input, inputKey: \DescribeReplicationTaskIndividualAssessmentsInput.marker, outputKey: \DescribeReplicationTaskIndividualAssessmentsOutputResponse.marker, paginationFunction: self.describeReplicationTaskIndividualAssessments(input:))
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationTaskIndividualAssessmentsInput {
        return DescribeReplicationTaskIndividualAssessmentsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeReplicationTasksOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReplicationTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReplicationTasksOutputResponse`
    public func describeReplicationTasksPaginated(input: DescribeReplicationTasksInput) -> ClientRuntime.PaginatorSequence<DescribeReplicationTasksInput, DescribeReplicationTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReplicationTasksInput, DescribeReplicationTasksOutputResponse>(input: input, inputKey: \DescribeReplicationTasksInput.marker, outputKey: \DescribeReplicationTasksOutputResponse.marker, paginationFunction: self.describeReplicationTasks(input:))
    }
}

extension DescribeReplicationTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReplicationTasksInput {
        return DescribeReplicationTasksInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            withoutSettings: self.withoutSettings
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeSchemasOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSchemasOutputResponse`
    public func describeSchemasPaginated(input: DescribeSchemasInput) -> ClientRuntime.PaginatorSequence<DescribeSchemasInput, DescribeSchemasOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSchemasInput, DescribeSchemasOutputResponse>(input: input, inputKey: \DescribeSchemasInput.marker, outputKey: \DescribeSchemasOutputResponse.marker, paginationFunction: self.describeSchemas(input:))
    }
}

extension DescribeSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSchemasInput {
        return DescribeSchemasInput(
            endpointArn: self.endpointArn,
            marker: token,
            maxRecords: self.maxRecords
        )}
}
extension DatabaseMigrationClient {
    /// Paginate over `[DescribeTableStatisticsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTableStatisticsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTableStatisticsOutputResponse`
    public func describeTableStatisticsPaginated(input: DescribeTableStatisticsInput) -> ClientRuntime.PaginatorSequence<DescribeTableStatisticsInput, DescribeTableStatisticsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTableStatisticsInput, DescribeTableStatisticsOutputResponse>(input: input, inputKey: \DescribeTableStatisticsInput.marker, outputKey: \DescribeTableStatisticsOutputResponse.marker, paginationFunction: self.describeTableStatistics(input:))
    }
}

extension DescribeTableStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTableStatisticsInput {
        return DescribeTableStatisticsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationTaskArn: self.replicationTaskArn
        )}
}
