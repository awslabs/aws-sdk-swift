// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DMS was denied access to the endpoint. Check that the role is correctly configured.
public struct AccessDeniedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.AccountQuota: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountQuotaName = self.accountQuotaName {
            try encodeContainer.encode(accountQuotaName, forKey: .accountQuotaName)
        }
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used) ?? 0
        used = usedDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a quota for an Amazon Web Services account, for example the number of replication instances allowed.
    public struct AccountQuota: Swift.Equatable {
        /// The name of the DMS quota for this Amazon Web Services account.
        public var accountQuotaName: Swift.String?
        /// The maximum allowed value for the quota.
        public var max: Swift.Int
        /// The amount currently used toward the quota maximum.
        public var used: Swift.Int

        public init (
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Associates a set of tags with an DMS resource.
public struct AddTagsToResourceInput: Swift.Equatable {
    /// Identifies the DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DMS, you can tag a replication instance, an endpoint, or a replication task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct AddTagsToResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyAction = self.applyAction {
            try encodeContainer.encode(applyAction, forKey: .applyAction)
        }
        if let optInType = self.optInType {
            try encodeContainer.encode(optInType, forKey: .optInType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension ApplyPendingMaintenanceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// The pending maintenance action to apply to this resource. Valid values: os-upgrade, system-update, db-upgrade
    /// This member is required.
    public var applyAction: Swift.String?
    /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:
    ///
    /// * immediate - Apply the maintenance action immediately.
    ///
    /// * next-maintenance - Apply the maintenance action during the next maintenance window for the resource.
    ///
    /// * undo-opt-in - Cancel any existing next-maintenance opt-in requests.
    /// This member is required.
    public var optInType: Swift.String?
    /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct ApplyPendingMaintenanceActionInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let applyAction: Swift.String?
    let optInType: Swift.String?
}

extension ApplyPendingMaintenanceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let applyActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyAction)
        applyAction = applyActionDecoded
        let optInTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInType)
        optInType = optInTypeDecoded
    }
}

extension ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

///
public struct ApplyPendingMaintenanceActionOutputResponse: Swift.Equatable {
    /// The DMS resource that the pending maintenance action will be applied to.
    public var resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Swift.Equatable {
    let resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthMechanismValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case mongodbCr
        case scramSha1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMechanismValue] {
            return [
                .default,
                .mongodbCr,
                .scramSha1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .mongodbCr: return "mongodb_cr"
            case .scramSha1: return "scram_sha_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMechanismValue(rawValue: rawValue) ?? AuthMechanismValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthTypeValue] {
            return [
                .no,
                .password,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthTypeValue(rawValue: rawValue) ?? AuthTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The name of an Availability Zone for use during database migration. AvailabilityZone is an optional parameter to the [CreateReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationInstance.html) operation, and it’s value relates to the Amazon Web Services Region of an endpoint. For example, the availability zone of an endpoint in the us-east-1 region might be us-east-1a, us-east-1b, us-east-1c, or us-east-1d.
    public struct AvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CancelReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

extension CancelReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CancelReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init (
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct CancelReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskAssessmentRunArn: Swift.String?
}

extension CancelReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension CancelReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct CancelReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct CancelReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension CancelReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum CannedAclForObjectsValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `none`
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedAclForObjectsValue] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .none,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .none: return "none"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CannedAclForObjectsValue(rawValue: rawValue) ?? CannedAclForObjectsValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateCreationDate = "CertificateCreationDate"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateOwner = "CertificateOwner"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case keyLength = "KeyLength"
        case signingAlgorithm = "SigningAlgorithm"
        case validFromDate = "ValidFromDate"
        case validToDate = "ValidToDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateCreationDate = self.certificateCreationDate {
            try encodeContainer.encodeTimestamp(certificateCreationDate, format: .epochSeconds, forKey: .certificateCreationDate)
        }
        if let certificateIdentifier = self.certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificateOwner = self.certificateOwner {
            try encodeContainer.encode(certificateOwner, forKey: .certificateOwner)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = self.certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let keyLength = self.keyLength {
            try encodeContainer.encode(keyLength, forKey: .keyLength)
        }
        if let signingAlgorithm = self.signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm, forKey: .signingAlgorithm)
        }
        if let validFromDate = self.validFromDate {
            try encodeContainer.encodeTimestamp(validFromDate, format: .epochSeconds, forKey: .validFromDate)
        }
        if let validToDate = self.validToDate {
            try encodeContainer.encodeTimestamp(validToDate, format: .epochSeconds, forKey: .validToDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateCreationDate)
        certificateCreationDate = certificateCreationDateDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateOwner)
        certificateOwner = certificateOwnerDecoded
        let validFromDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validFromDate)
        validFromDate = validFromDateDecoded
        let validToDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validToDate)
        validToDate = validToDateDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let keyLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyLength)
        keyLength = keyLengthDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The SSL certificate that can be used to encrypt connections between the endpoints and the replication instance.
    public struct Certificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: Swift.String?
        /// The date that the certificate was created.
        public var certificateCreationDate: ClientRuntime.Date?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var certificateIdentifier: Swift.String?
        /// The owner of the certificate.
        public var certificateOwner: Swift.String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public var certificatePem: Swift.String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
        public var certificateWallet: ClientRuntime.Data?
        /// The key length of the cryptographic algorithm being used.
        public var keyLength: Swift.Int?
        /// The signing algorithm for the certificate.
        public var signingAlgorithm: Swift.String?
        /// The beginning date that the certificate is valid.
        public var validFromDate: ClientRuntime.Date?
        /// The final date that the certificate is valid.
        public var validToDate: ClientRuntime.Date?

        public init (
            certificateArn: Swift.String? = nil,
            certificateCreationDate: ClientRuntime.Date? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateOwner: Swift.String? = nil,
            certificatePem: Swift.String? = nil,
            certificateWallet: ClientRuntime.Data? = nil,
            keyLength: Swift.Int? = nil,
            signingAlgorithm: Swift.String? = nil,
            validFromDate: ClientRuntime.Date? = nil,
            validToDate: ClientRuntime.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum CharLengthSemantics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byte
        case char
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [CharLengthSemantics] {
            return [
                .byte,
                .char,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byte: return "byte"
            case .char: return "char"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CharLengthSemantics(rawValue: rawValue) ?? CharLengthSemantics.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.CollectorHealthCheck: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorStatus = "CollectorStatus"
        case localCollectorS3Access = "LocalCollectorS3Access"
        case webCollectorGrantedRoleBasedAccess = "WebCollectorGrantedRoleBasedAccess"
        case webCollectorS3Access = "WebCollectorS3Access"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorStatus = self.collectorStatus {
            try encodeContainer.encode(collectorStatus.rawValue, forKey: .collectorStatus)
        }
        if let localCollectorS3Access = self.localCollectorS3Access {
            try encodeContainer.encode(localCollectorS3Access, forKey: .localCollectorS3Access)
        }
        if let webCollectorGrantedRoleBasedAccess = self.webCollectorGrantedRoleBasedAccess {
            try encodeContainer.encode(webCollectorGrantedRoleBasedAccess, forKey: .webCollectorGrantedRoleBasedAccess)
        }
        if let webCollectorS3Access = self.webCollectorS3Access {
            try encodeContainer.encode(webCollectorS3Access, forKey: .webCollectorS3Access)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CollectorStatus.self, forKey: .collectorStatus)
        collectorStatus = collectorStatusDecoded
        let localCollectorS3AccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .localCollectorS3Access)
        localCollectorS3Access = localCollectorS3AccessDecoded
        let webCollectorS3AccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .webCollectorS3Access)
        webCollectorS3Access = webCollectorS3AccessDecoded
        let webCollectorGrantedRoleBasedAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .webCollectorGrantedRoleBasedAccess)
        webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccessDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes the last Fleet Advisor collector health check.
    public struct CollectorHealthCheck: Swift.Equatable {
        /// The status of the Fleet Advisor collector.
        public var collectorStatus: DatabaseMigrationClientTypes.CollectorStatus?
        /// Whether the local collector can access its Amazon S3 bucket.
        public var localCollectorS3Access: Swift.Bool?
        /// Whether the role that you provided when creating the Fleet Advisor collector has sufficient permissions to access the Fleet Advisor web collector.
        public var webCollectorGrantedRoleBasedAccess: Swift.Bool?
        /// Whether the web collector can access its Amazon S3 bucket.
        public var webCollectorS3Access: Swift.Bool?

        public init (
            collectorStatus: DatabaseMigrationClientTypes.CollectorStatus? = nil,
            localCollectorS3Access: Swift.Bool? = nil,
            webCollectorGrantedRoleBasedAccess: Swift.Bool? = nil,
            webCollectorS3Access: Swift.Bool? = nil
        )
        {
            self.collectorStatus = collectorStatus
            self.localCollectorS3Access = localCollectorS3Access
            self.webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccess
            self.webCollectorS3Access = webCollectorS3Access
        }
    }

}

extension CollectorNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CollectorNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified collector doesn't exist.
public struct CollectorNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CollectorNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CollectorNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.CollectorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorHealthCheck = "CollectorHealthCheck"
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
        case collectorVersion = "CollectorVersion"
        case createdDate = "CreatedDate"
        case description = "Description"
        case inventoryData = "InventoryData"
        case lastDataReceived = "LastDataReceived"
        case modifiedDate = "ModifiedDate"
        case registeredDate = "RegisteredDate"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case versionStatus = "VersionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorHealthCheck = self.collectorHealthCheck {
            try encodeContainer.encode(collectorHealthCheck, forKey: .collectorHealthCheck)
        }
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
        if let collectorVersion = self.collectorVersion {
            try encodeContainer.encode(collectorVersion, forKey: .collectorVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inventoryData = self.inventoryData {
            try encodeContainer.encode(inventoryData, forKey: .inventoryData)
        }
        if let lastDataReceived = self.lastDataReceived {
            try encodeContainer.encode(lastDataReceived, forKey: .lastDataReceived)
        }
        if let modifiedDate = self.modifiedDate {
            try encodeContainer.encode(modifiedDate, forKey: .modifiedDate)
        }
        if let registeredDate = self.registeredDate {
            try encodeContainer.encode(registeredDate, forKey: .registeredDate)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let versionStatus = self.versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let collectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorVersion)
        collectorVersion = collectorVersionDecoded
        let versionStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.VersionStatus.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let collectorHealthCheckDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CollectorHealthCheck.self, forKey: .collectorHealthCheck)
        collectorHealthCheck = collectorHealthCheckDecoded
        let lastDataReceivedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDataReceived)
        lastDataReceived = lastDataReceivedDecoded
        let registeredDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredDate)
        registeredDate = registeredDateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let inventoryDataDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.InventoryData.self, forKey: .inventoryData)
        inventoryData = inventoryDataDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector.
    public struct CollectorResponse: Swift.Equatable {
        /// Describes the last Fleet Advisor collector health check.
        public var collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck?
        /// The name of the Fleet Advisor collector .
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?
        /// The version of your Fleet Advisor collector, in semantic versioning format, for example 1.0.2
        public var collectorVersion: Swift.String?
        /// The timestamp when you created the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var createdDate: Swift.String?
        /// A summary description of the Fleet Advisor collector.
        public var description: Swift.String?
        /// Describes a Fleet Advisor collector inventory.
        public var inventoryData: DatabaseMigrationClientTypes.InventoryData?
        /// The timestamp of the last time the collector received data, in the following format: 2022-01-24T19:04:02.596113Z
        public var lastDataReceived: Swift.String?
        /// The timestamp when DMS last modified the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var modifiedDate: Swift.String?
        /// The timestamp when DMS registered the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var registeredDate: Swift.String?
        /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
        public var s3BucketName: Swift.String?
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// Whether the collector version is up to date.
        public var versionStatus: DatabaseMigrationClientTypes.VersionStatus?

        public init (
            collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck? = nil,
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            inventoryData: DatabaseMigrationClientTypes.InventoryData? = nil,
            lastDataReceived: Swift.String? = nil,
            modifiedDate: Swift.String? = nil,
            registeredDate: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            versionStatus: DatabaseMigrationClientTypes.VersionStatus? = nil
        )
        {
            self.collectorHealthCheck = collectorHealthCheck
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
            self.collectorVersion = collectorVersion
            self.createdDate = createdDate
            self.description = description
            self.inventoryData = inventoryData
            self.lastDataReceived = lastDataReceived
            self.modifiedDate = modifiedDate
            self.registeredDate = registeredDate
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.versionStatus = versionStatus
        }
    }

}

extension DatabaseMigrationClientTypes.CollectorShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Briefly describes a Fleet Advisor collector.
    public struct CollectorShortInfoResponse: Swift.Equatable {
        /// The name of the Fleet Advisor collector.
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?

        public init (
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil
        )
        {
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum CollectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorStatus] {
            return [
                .active,
                .unregistered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .unregistered: return "UNREGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectorStatus(rawValue: rawValue) ?? CollectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum CompressionTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionTypeValue] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionTypeValue(rawValue: rawValue) ?? CompressionTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case lastFailureMessage = "LastFailureMessage"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Status of the connection between an endpoint and a replication instance, including Amazon Resource Names (ARNs) and the last error message issued.
    public struct Connection: Swift.Equatable {
        /// The ARN string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The error message when the connection last failed.
        public var lastFailureMessage: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public var replicationInstanceIdentifier: Swift.String?
        /// The connection status. This parameter can return one of the following values:
        ///
        /// * "successful"
        ///
        /// * "testing"
        ///
        /// * "failed"
        ///
        /// * "deleting"
        public var status: Swift.String?

        public init (
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }
    }

}

extension CreateEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), tags: \(Swift.String(describing: tags)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension CreateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the certificate.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName. To migrate to a specific database, use this setting and targetDbType.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Possible settings include the following:
    ///
    /// * ServiceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", }
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Provides information that defines a DocumentDB endpoint.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    /// This member is required.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "opensearch", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", "neptune", and "babelfish".
    /// This member is required.
    public var engineName: Swift.String?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see [Working with DMS Endpoints](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html) in the Database Migration Service User Guide.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to log in to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the target Redis endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// One or more tags to be assigned to the endpoint.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// The user name to be used to log in to the endpoint database.
    public var username: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        kmsKeyId: Swift.String? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        resourceIdentifier: Swift.String? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.resourceIdentifier = resourceIdentifier
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.tags = tags
        self.username = username
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    let endpointIdentifier: Swift.String?
    let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    let engineName: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let serverName: Swift.String?
    let port: Swift.Int?
    let databaseName: Swift.String?
    let extraConnectionAttributes: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let certificateArn: Swift.String?
    let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    let serviceAccessRoleArn: Swift.String?
    let externalTableDefinition: Swift.String?
    let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    let ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    let resourceIdentifier: Swift.String?
    let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    let redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    let gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
    }
}

extension CreateEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct CreateEndpointOutputResponse: Swift.Equatable {
    /// The endpoint that was created.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension CreateEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension CreateEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIds)
            for string0 in sourceIds {
                try sourceIdsContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. For more information, see [Working with Events and Notifications](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html) in the Database Migration Service User Guide.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    /// This member is required.
    public var snsTopicArn: Swift.String?
    /// A list of identifiers for which DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
    public var sourceIds: [Swift.String]?
    /// The type of DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription. This name must be less than 255 characters.
    /// This member is required.
    public var subscriptionName: Swift.String?
    /// One or more tags to be assigned to the event subscription.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

struct CreateEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let sourceIds: [Swift.String]?
    let enabled: Swift.Bool?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let sourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIds)
        var sourceIdsDecoded0:[Swift.String]? = nil
        if let sourceIdsContainer = sourceIdsContainer {
            sourceIdsDecoded0 = [Swift.String]()
            for string0 in sourceIdsContainer {
                if let string0 = string0 {
                    sourceIdsDecoded0?.append(string0)
                }
            }
        }
        sourceIds = sourceIdsDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// The event subscription that was created.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension CreateFleetAdvisorCollectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

extension CreateFleetAdvisorCollectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetAdvisorCollectorInput: Swift.Equatable {
    /// The name of your Fleet Advisor collector (for example, sample-collector).
    /// This member is required.
    public var collectorName: Swift.String?
    /// A summary description of your Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init (
        collectorName: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct CreateFleetAdvisorCollectorInputBody: Swift.Equatable {
    let collectorName: Swift.String?
    let description: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let s3BucketName: Swift.String?
}

extension CreateFleetAdvisorCollectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension CreateFleetAdvisorCollectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetAdvisorCollectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3ResourceNotFoundFault" : self = .s3ResourceNotFoundFault(try S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFleetAdvisorCollectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case s3ResourceNotFoundFault(S3ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetAdvisorCollectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFleetAdvisorCollectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectorName = output.collectorName
            self.collectorReferencedId = output.collectorReferencedId
            self.description = output.description
            self.s3BucketName = output.s3BucketName
            self.serviceAccessRoleArn = output.serviceAccessRoleArn
        } else {
            self.collectorName = nil
            self.collectorReferencedId = nil
            self.description = nil
            self.s3BucketName = nil
            self.serviceAccessRoleArn = nil
        }
    }
}

public struct CreateFleetAdvisorCollectorOutputResponse: Swift.Equatable {
    /// The name of the new Fleet Advisor collector.
    public var collectorName: Swift.String?
    /// The unique ID of the new Fleet Advisor collector, for example: 22fda70c-40d5-4acf-b233-a495bd8eb7f5
    public var collectorReferencedId: Swift.String?
    /// A summary description of the Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the collector uses to store inventory metadata.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    public var serviceAccessRoleArn: Swift.String?

    public init (
        collectorName: Swift.String? = nil,
        collectorReferencedId: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.collectorReferencedId = collectorReferencedId
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct CreateFleetAdvisorCollectorOutputResponseBody: Swift.Equatable {
    let collectorReferencedId: Swift.String?
    let collectorName: Swift.String?
    let description: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let s3BucketName: Swift.String?
}

extension CreateFleetAdvisorCollectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension CreateReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = self.dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension CreateReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationInstanceInput: Swift.Equatable {
    /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region, for example: us-east-1d
    public var availabilityZone: Swift.String?
    /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
    public var dnsNameServers: Swift.String?
    /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
    public var engineVersion: Swift.String?
    /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
    /// This member is required.
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain 1-63 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: myrepinstance
    /// This member is required.
    public var replicationInstanceIdentifier: Swift.String?
    /// A subnet group to associate with the replication instance.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// One or more tags to be assigned to the replication instance.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        dnsNameServers: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceIdentifier: Swift.String?
    let allocatedStorage: Swift.Int?
    let replicationInstanceClass: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let availabilityZone: Swift.String?
    let replicationSubnetGroupIdentifier: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let dnsNameServers: Swift.String?
    let resourceIdentifier: Swift.String?
    let networkType: Swift.String?
}

extension CreateReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension CreateReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case invalidSubnet(InvalidSubnet)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct CreateReplicationInstanceOutputResponse: Swift.Equatable {
    /// The replication instance that was created.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct CreateReplicationInstanceOutputResponseBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension CreateReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension CreateReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationSubnetGroupInput: Swift.Equatable {
    /// The description for the subnet group.
    /// This member is required.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// One or more subnet IDs to be assigned to the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// One or more tags to be assigned to the subnet group.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
    let replicationSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

///
public struct CreateReplicationSubnetGroupOutputResponse: Swift.Equatable {
    /// The replication subnet group that was created.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct CreateReplicationSubnetGroupOutputResponseBody: Swift.Equatable {
    let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension CreateReplicationSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

extension CreateReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

extension CreateReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    /// This member is required.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of a replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// An identifier for the replication task. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var replicationTaskIdentifier: Swift.String?
    /// Overall settings for the task, in JSON format. For more information, see [Specifying Task Settings for Database Migration Service Tasks](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html) in the Database Migration Service User Guide.
    public var replicationTaskSettings: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
    /// This member is required.
    public var sourceEndpointArn: Swift.String?
    /// The table mappings for the task, in JSON format. For more information, see [Using Table Mapping to Specify Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html) in the Database Migration Service User Guide.
    /// This member is required.
    public var tableMappings: Swift.String?
    /// One or more tags to be assigned to the replication task.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
    /// This member is required.
    public var targetEndpointArn: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
        self.taskData = taskData
    }
}

struct CreateReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskIdentifier: Swift.String?
    let sourceEndpointArn: Swift.String?
    let targetEndpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationTaskSettings: Swift.String?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let taskData: Swift.String?
    let resourceIdentifier: Swift.String?
}

extension CreateReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct CreateReplicationTaskOutputResponse: Swift.Equatable {
    /// The replication task that was created.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct CreateReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension CreateReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum DataFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormatValue] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataFormatValue(rawValue: rawValue) ?? DataFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case engineEdition = "EngineEdition"
        case engineVersion = "EngineVersion"
        case osArchitecture = "OsArchitecture"
        case servicePack = "ServicePack"
        case supportLevel = "SupportLevel"
        case tooltip = "Tooltip"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineEdition = self.engineEdition {
            try encodeContainer.encode(engineEdition, forKey: .engineEdition)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let osArchitecture = self.osArchitecture {
            try encodeContainer.encode(osArchitecture, forKey: .osArchitecture)
        }
        if let servicePack = self.servicePack {
            try encodeContainer.encode(servicePack, forKey: .servicePack)
        }
        if let supportLevel = self.supportLevel {
            try encodeContainer.encode(supportLevel, forKey: .supportLevel)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineEdition)
        engineEdition = engineEditionDecoded
        let servicePackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .servicePack)
        servicePack = servicePackDecoded
        let supportLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLevel)
        supportLevel = supportLevelDecoded
        let osArchitectureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .osArchitecture)
        osArchitecture = osArchitectureDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tooltip)
        tooltip = tooltipDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an inventory database instance for a Fleet Advisor collector.
    public struct DatabaseInstanceSoftwareDetailsResponse: Swift.Equatable {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example Microsoft SQL Server.
        public var engine: Swift.String?
        /// The database engine edition of a database in a Fleet Advisor collector inventory, for example Express.
        public var engineEdition: Swift.String?
        /// The database engine version of a database in a Fleet Advisor collector inventory, for example 2019.
        public var engineVersion: Swift.String?
        /// The operating system architecture of the database.
        public var osArchitecture: Swift.Int?
        /// The service pack level of the database.
        public var servicePack: Swift.String?
        /// The support level of the database, for example Mainstream support.
        public var supportLevel: Swift.String?
        /// Information about the database engine software, for example Mainstream support ends on November 14th, 2024.
        public var tooltip: Swift.String?

        public init (
            engine: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            osArchitecture: Swift.Int? = nil,
            servicePack: Swift.String? = nil,
            supportLevel: Swift.String? = nil,
            tooltip: Swift.String? = nil
        )
        {
            self.engine = engine
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.osArchitecture = osArchitecture
            self.servicePack = servicePack
            self.supportLevel = supportLevel
            self.tooltip = tooltip
        }
    }

}

extension DatabaseMigrationClientTypes.DatabaseResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case databaseId = "DatabaseId"
        case databaseName = "DatabaseName"
        case ipAddress = "IpAddress"
        case numberOfSchemas = "NumberOfSchemas"
        case server = "Server"
        case softwareDetails = "SoftwareDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectors = collectors {
            var collectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collectors)
            for collectorshortinforesponse0 in collectors {
                try collectorsContainer.encode(collectorshortinforesponse0)
            }
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let numberOfSchemas = self.numberOfSchemas {
            try encodeContainer.encode(numberOfSchemas, forKey: .numberOfSchemas)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let softwareDetails = self.softwareDetails {
            try encodeContainer.encode(softwareDetails, forKey: .softwareDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let numberOfSchemasDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSchemas)
        numberOfSchemas = numberOfSchemasDecoded
        let serverDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ServerShortInfoResponse.self, forKey: .server)
        server = serverDecoded
        let softwareDetailsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse.self, forKey: .softwareDetails)
        softwareDetails = softwareDetailsDecoded
        let collectorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.CollectorShortInfoResponse?].self, forKey: .collectors)
        var collectorsDecoded0:[DatabaseMigrationClientTypes.CollectorShortInfoResponse]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [DatabaseMigrationClientTypes.CollectorShortInfoResponse]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseResponse: Swift.Equatable {
        /// A list of collectors associated with the database.
        public var collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The number of schemas in a Fleet Advisor collector inventory database.
        public var numberOfSchemas: Swift.Int?
        /// The server name of a database in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The software details of a database in a Fleet Advisor collector inventory, such as database engine and version.
        public var softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse?

        public init (
            collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            numberOfSchemas: Swift.Int? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse? = nil
        )
        {
            self.collectors = collectors
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.ipAddress = ipAddress
            self.numberOfSchemas = numberOfSchemas
            self.server = server
            self.softwareDetails = softwareDetails
        }
    }

}

extension DatabaseMigrationClientTypes.DatabaseShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseEngine = "DatabaseEngine"
        case databaseId = "DatabaseId"
        case databaseIpAddress = "DatabaseIpAddress"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseEngine = self.databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseIpAddress = self.databaseIpAddress {
            try encodeContainer.encode(databaseIpAddress, forKey: .databaseIpAddress)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseIpAddress)
        databaseIpAddress = databaseIpAddressDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseShortInfoResponse: Swift.Equatable {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example PostgreSQL.
        public var databaseEngine: Swift.String?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?

        public init (
            databaseEngine: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil
        )
        {
            self.databaseEngine = databaseEngine
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionDelimiterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dash
        case `none`
        case slash
        case underscore
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionDelimiterValue] {
            return [
                .dash,
                .none,
                .slash,
                .underscore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .none: return "NONE"
            case .slash: return "SLASH"
            case .underscore: return "UNDERSCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionDelimiterValue(rawValue: rawValue) ?? DatePartitionDelimiterValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionSequenceValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddmmyyyy
        case mmyyyydd
        case yyyymm
        case yyyymmdd
        case yyyymmddhh
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionSequenceValue] {
            return [
                .ddmmyyyy,
                .mmyyyydd,
                .yyyymm,
                .yyyymmdd,
                .yyyymmddhh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddmmyyyy: return "DDMMYYYY"
            case .mmyyyydd: return "MMYYYYDD"
            case .yyyymm: return "YYYYMM"
            case .yyyymmdd: return "YYYYMMDD"
            case .yyyymmddhh: return "YYYYMMDDHH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionSequenceValue(rawValue: rawValue) ?? DatePartitionSequenceValue.sdkUnknown(rawValue)
        }
    }
}

extension DeleteCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

extension DeleteCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCertificateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate.
    /// This member is required.
    public var certificateArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
    let certificateArn: Swift.String?
}

extension DeleteCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DeleteCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DeleteCertificateOutputResponse: Swift.Equatable {
    /// The Secure Sockets Layer (SSL) certificate.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init (
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DeleteCertificateOutputResponseBody: Swift.Equatable {
    let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension DeleteCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension DeleteConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

///
public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// The connection that is being deleted.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init (
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    let connection: DatabaseMigrationClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension DeleteEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEndpointOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct DeleteEndpointOutputResponse: Swift.Equatable {
    /// The endpoint that was deleted.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension DeleteEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension DeleteEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension DeleteEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// The name of the DMS event notification subscription to be deleted.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

struct DeleteEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
}

extension DeleteEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {
    /// The event subscription that was deleted.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension DeleteFleetAdvisorCollectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorReferencedId = "CollectorReferencedId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
    }
}

extension DeleteFleetAdvisorCollectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetAdvisorCollectorInput: Swift.Equatable {
    /// The reference ID of the Fleet Advisor collector to delete.
    /// This member is required.
    public var collectorReferencedId: Swift.String?

    public init (
        collectorReferencedId: Swift.String? = nil
    )
    {
        self.collectorReferencedId = collectorReferencedId
    }
}

struct DeleteFleetAdvisorCollectorInputBody: Swift.Equatable {
    let collectorReferencedId: Swift.String?
}

extension DeleteFleetAdvisorCollectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorReferencedId = "CollectorReferencedId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
    }
}

extension DeleteFleetAdvisorCollectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetAdvisorCollectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CollectorNotFoundFault" : self = .collectorNotFoundFault(try CollectorNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFleetAdvisorCollectorOutputError: Swift.Error, Swift.Equatable {
    case collectorNotFoundFault(CollectorNotFoundFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetAdvisorCollectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetAdvisorCollectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFleetAdvisorDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseIds = databaseIds {
            var databaseIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseIds)
            for string0 in databaseIds {
                try databaseIdsContainer.encode(string0)
            }
        }
    }
}

extension DeleteFleetAdvisorDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetAdvisorDatabasesInput: Swift.Equatable {
    /// The IDs of the Fleet Advisor collector databases to delete.
    /// This member is required.
    public var databaseIds: [Swift.String]?

    public init (
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

struct DeleteFleetAdvisorDatabasesInputBody: Swift.Equatable {
    let databaseIds: [Swift.String]?
}

extension DeleteFleetAdvisorDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databaseIds)
        var databaseIdsDecoded0:[Swift.String]? = nil
        if let databaseIdsContainer = databaseIdsContainer {
            databaseIdsDecoded0 = [Swift.String]()
            for string0 in databaseIdsContainer {
                if let string0 = string0 {
                    databaseIdsDecoded0?.append(string0)
                }
            }
        }
        databaseIds = databaseIdsDecoded0
    }
}

extension DeleteFleetAdvisorDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetAdvisorDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOperationFault" : self = .invalidOperationFault(try InvalidOperationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFleetAdvisorDatabasesOutputError: Swift.Error, Swift.Equatable {
    case invalidOperationFault(InvalidOperationFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetAdvisorDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFleetAdvisorDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseIds = output.databaseIds
        } else {
            self.databaseIds = nil
        }
    }
}

public struct DeleteFleetAdvisorDatabasesOutputResponse: Swift.Equatable {
    /// The IDs of the databases that the operation deleted.
    public var databaseIds: [Swift.String]?

    public init (
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

struct DeleteFleetAdvisorDatabasesOutputResponseBody: Swift.Equatable {
    let databaseIds: [Swift.String]?
}

extension DeleteFleetAdvisorDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databaseIds)
        var databaseIdsDecoded0:[Swift.String]? = nil
        if let databaseIdsContainer = databaseIdsContainer {
            databaseIdsDecoded0 = [Swift.String]()
            for string0 in databaseIdsContainer {
                if let string0 = string0 {
                    databaseIdsDecoded0?.append(string0)
                }
            }
        }
        databaseIds = databaseIdsDecoded0
    }
}

extension DeleteReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DeleteReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
}

extension DeleteReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct DeleteReplicationInstanceOutputResponse: Swift.Equatable {
    /// The replication instance that was deleted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct DeleteReplicationInstanceOutputResponseBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension DeleteReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension DeleteReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
    }
}

extension DeleteReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationSubnetGroupInput: Swift.Equatable {
    /// The subnet group name of the replication instance.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?

    public init (
        replicationSubnetGroupIdentifier: Swift.String? = nil
    )
    {
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
    }
}

struct DeleteReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
}

extension DeleteReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
    }
}

extension DeleteReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct DeleteReplicationSubnetGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

extension DeleteReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init (
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct DeleteReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskAssessmentRunArn: Swift.String?
}

extension DeleteReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct DeleteReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct DeleteReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension DeleteReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

extension DeleteReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DeleteReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task to be deleted.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DeleteReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension DeleteReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension DeleteReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct DeleteReplicationTaskOutputResponse: Swift.Equatable {
    /// The deleted replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct DeleteReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension DeleteReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DescribeAccountAttributesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init () { }
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountQuotas = output.accountQuotas
            self.uniqueAccountIdentifier = output.uniqueAccountIdentifier
        } else {
            self.accountQuotas = nil
            self.uniqueAccountIdentifier = nil
        }
    }
}

///
public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// Account quota information.
    public var accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    /// A unique DMS identifier for an account in a particular Amazon Web Services Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given Amazon Web Services Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666. DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later.
    public var uniqueAccountIdentifier: Swift.String?

    public init (
        accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]? = nil,
        uniqueAccountIdentifier: Swift.String? = nil
    )
    {
        self.accountQuotas = accountQuotas
        self.uniqueAccountIdentifier = uniqueAccountIdentifier
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    let accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    let uniqueAccountIdentifier: Swift.String?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotas = "AccountQuotas"
        case uniqueAccountIdentifier = "UniqueAccountIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotasContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.AccountQuota?].self, forKey: .accountQuotas)
        var accountQuotasDecoded0:[DatabaseMigrationClientTypes.AccountQuota]? = nil
        if let accountQuotasContainer = accountQuotasContainer {
            accountQuotasDecoded0 = [DatabaseMigrationClientTypes.AccountQuota]()
            for structure0 in accountQuotasContainer {
                if let structure0 = structure0 {
                    accountQuotasDecoded0?.append(structure0)
                }
            }
        }
        accountQuotas = accountQuotasDecoded0
        let uniqueAccountIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueAccountIdentifier)
        uniqueAccountIdentifier = uniqueAccountIdentifierDecoded
    }
}

extension DescribeApplicableIndividualAssessmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let sourceEngineName = self.sourceEngineName {
            try encodeContainer.encode(sourceEngineName, forKey: .sourceEngineName)
        }
        if let targetEngineName = self.targetEngineName {
            try encodeContainer.encode(targetEngineName, forKey: .targetEngineName)
        }
    }
}

extension DescribeApplicableIndividualAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeApplicableIndividualAssessmentsInput: Swift.Equatable {
    /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?
    /// Name of the migration type that each provided individual assessment must support.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// ARN of a replication instance on which you want to base the default list of individual assessments.
    public var replicationInstanceArn: Swift.String?
    /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
    public var replicationTaskArn: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a source.
    public var sourceEngineName: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a target.
    public var targetEngineName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        sourceEngineName: Swift.String? = nil,
        targetEngineName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.sourceEngineName = sourceEngineName
        self.targetEngineName = targetEngineName
    }
}

struct DescribeApplicableIndividualAssessmentsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let replicationInstanceArn: Swift.String?
    let sourceEngineName: Swift.String?
    let targetEngineName: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let sourceEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineName)
        sourceEngineName = sourceEngineNameDecoded
        let targetEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEngineName)
        targetEngineName = targetEngineNameDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicableIndividualAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicableIndividualAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicableIndividualAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicableIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.individualAssessmentNames = output.individualAssessmentNames
            self.marker = output.marker
        } else {
            self.individualAssessmentNames = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeApplicableIndividualAssessmentsOutputResponse: Swift.Equatable {
    /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see [Working with premigration assessment runs](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.AssessmentReport.html) in the Database Migration Service User Guide.
    public var individualAssessmentNames: [Swift.String]?
    /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?

    public init (
        individualAssessmentNames: [Swift.String]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.individualAssessmentNames = individualAssessmentNames
        self.marker = marker
    }
}

struct DescribeApplicableIndividualAssessmentsOutputResponseBody: Swift.Equatable {
    let individualAssessmentNames: [Swift.String]?
    let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentNames = "IndividualAssessmentNames"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .individualAssessmentNames)
        var individualAssessmentNamesDecoded0:[Swift.String]? = nil
        if let individualAssessmentNamesContainer = individualAssessmentNamesContainer {
            individualAssessmentNamesDecoded0 = [Swift.String]()
            for string0 in individualAssessmentNamesContainer {
                if let string0 = string0 {
                    individualAssessmentNamesDecoded0?.append(string0)
                }
            }
        }
        individualAssessmentNames = individualAssessmentNamesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCertificatesInput: Swift.Equatable {
    /// Filters applied to the certificates described in the form of key-value pairs. Valid values are certificate-arn and certificate-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 10
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCertificatesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCertificatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

public struct DescribeCertificatesOutputResponse: Swift.Equatable {
    /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
    public var certificates: [DatabaseMigrationClientTypes.Certificate]?
    /// The pagination token.
    public var marker: Swift.String?

    public init (
        certificates: [DatabaseMigrationClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let certificates: [DatabaseMigrationClientTypes.Certificate]?
}

extension DescribeCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[DatabaseMigrationClientTypes.Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [DatabaseMigrationClientTypes.Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

extension DescribeConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeConnectionsInput: Swift.Equatable {
    /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeConnectionsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConnectionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.marker = output.marker
        } else {
            self.connections = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeConnectionsOutputResponse: Swift.Equatable {
    /// A description of the connections.
    public var connections: [DatabaseMigrationClientTypes.Connection]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        connections: [DatabaseMigrationClientTypes.Connection]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.connections = connections
        self.marker = marker
    }
}

struct DescribeConnectionsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let connections: [DatabaseMigrationClientTypes.Connection]?
}

extension DescribeConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DatabaseMigrationClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DatabaseMigrationClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

extension DescribeEndpointSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointSettingsInput: Swift.Equatable {
    /// The databse engine used for your source or target endpoint.
    /// This member is required.
    public var engineName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init (
        engineName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointSettingsInputBody: Swift.Equatable {
    let engineName: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointSettingsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpointSettings = output.endpointSettings
            self.marker = output.marker
        } else {
            self.endpointSettings = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointSettingsOutputResponse: Swift.Equatable {
    /// Descriptions of the endpoint settings available for your source or target database engine.
    public var endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointSettings = endpointSettings
        self.marker = marker
    }
}

struct DescribeEndpointSettingsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
}

extension DescribeEndpointSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointSettings = "EndpointSettings"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointSettingsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EndpointSetting?].self, forKey: .endpointSettings)
        var endpointSettingsDecoded0:[DatabaseMigrationClientTypes.EndpointSetting]? = nil
        if let endpointSettingsContainer = endpointSettingsContainer {
            endpointSettingsDecoded0 = [DatabaseMigrationClientTypes.EndpointSetting]()
            for structure0 in endpointSettingsContainer {
                if let structure0 = structure0 {
                    endpointSettingsDecoded0?.append(structure0)
                }
            }
        }
        endpointSettings = endpointSettingsDecoded0
    }
}

extension DescribeEndpointTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEndpointTypesInput: Swift.Equatable {
    /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointTypesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEndpointTypesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.supportedEndpointTypes = output.supportedEndpointTypes
        } else {
            self.marker = nil
            self.supportedEndpointTypes = nil
        }
    }
}

///
public struct DescribeEndpointTypesOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The types of endpoints that are supported.
    public var supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?

    public init (
        marker: Swift.String? = nil,
        supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
    )
    {
        self.marker = marker
        self.supportedEndpointTypes = supportedEndpointTypes
    }
}

struct DescribeEndpointTypesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?
}

extension DescribeEndpointTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case supportedEndpointTypes = "SupportedEndpointTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let supportedEndpointTypesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SupportedEndpointType?].self, forKey: .supportedEndpointTypes)
        var supportedEndpointTypesDecoded0:[DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
        if let supportedEndpointTypesContainer = supportedEndpointTypesContainer {
            supportedEndpointTypesDecoded0 = [DatabaseMigrationClientTypes.SupportedEndpointType]()
            for structure0 in supportedEndpointTypesContainer {
                if let structure0 = structure0 {
                    supportedEndpointTypesDecoded0?.append(structure0)
                }
            }
        }
        supportedEndpointTypes = supportedEndpointTypesDecoded0
    }
}

extension DescribeEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEndpointsInput: Swift.Equatable {
    /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeEndpointsOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .resourceNotFoundFault: return "ResourceNotFoundFault"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeEndpointsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.marker = output.marker
        } else {
            self.endpoints = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEndpointsOutputResponse: Swift.Equatable {
    /// Endpoint description.
    public var endpoints: [DatabaseMigrationClientTypes.Endpoint]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        endpoints: [DatabaseMigrationClientTypes.Endpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.marker = marker
    }
}

struct DescribeEndpointsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let endpoints: [DatabaseMigrationClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[DatabaseMigrationClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [DatabaseMigrationClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension DescribeEventCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }
}

extension DescribeEventCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// Filters applied to the event categories.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

struct DescribeEventCategoriesInputBody: Swift.Equatable {
    let sourceType: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeEventCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoryGroupList = output.eventCategoryGroupList
        } else {
            self.eventCategoryGroupList = nil
        }
    }
}

///
public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// A list of event categories.
    public var eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?

    public init (
        eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
    )
    {
        self.eventCategoryGroupList = eventCategoryGroupList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    let eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoryGroupList = "EventCategoryGroupList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventCategoryGroupListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventCategoryGroup?].self, forKey: .eventCategoryGroupList)
        var eventCategoryGroupListDecoded0:[DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
        if let eventCategoryGroupListContainer = eventCategoryGroupListContainer {
            eventCategoryGroupListDecoded0 = [DatabaseMigrationClientTypes.EventCategoryGroup]()
            for structure0 in eventCategoryGroupListContainer {
                if let structure0 = structure0 {
                    eventCategoryGroupListDecoded0?.append(structure0)
                }
            }
        }
        eventCategoryGroupList = eventCategoryGroupListDecoded0
    }
}

extension DescribeEventSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// Filters applied to event subscriptions. Valid filter names: event-subscription-arn | event-subscription-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the DMS event subscription to be described.
    public var subscriptionName: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

struct DescribeEventSubscriptionsInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// A list of event subscriptions.
    public var eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventSubscriptionsListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventSubscription?].self, forKey: .eventSubscriptionsList)
        var eventSubscriptionsListDecoded0:[DatabaseMigrationClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
            eventSubscriptionsListDecoded0 = [DatabaseMigrationClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsListContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsListDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptionsList = eventSubscriptionsListDecoded0
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventsInput: Swift.Equatable {
    /// The duration of the events to be listed.
    public var duration: Swift.Int?
    /// The end time for the events to be listed.
    public var endTime: ClientRuntime.Date?
    /// A list of event categories for the source type that you've chosen.
    public var eventCategories: [Swift.String]?
    /// Filters applied to events. The only valid filter is replication-instance-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of an event source.
    public var sourceIdentifier: Swift.String?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: DatabaseMigrationClientTypes.SourceType?
    /// The start time for the events to be listed.
    public var startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: DatabaseMigrationClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let sourceIdentifier: Swift.String?
    let sourceType: DatabaseMigrationClientTypes.SourceType?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let duration: Swift.Int?
    let eventCategories: [Swift.String]?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// The events described.
    public var events: [DatabaseMigrationClientTypes.Event]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        events: [DatabaseMigrationClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let events: [DatabaseMigrationClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DatabaseMigrationClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DatabaseMigrationClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension DescribeFleetAdvisorCollectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorCollectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorCollectorsInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those collectors that meet the filter criteria:
    ///
    /// * collector-referenced-id – The ID of the collector agent, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    /// * collector-name – The name of the collector agent.
    ///
    ///
    /// An example is: describe-fleet-advisor-collectors --filter Name="collector-referenced-id",Values="d4610ac5-e323-4ad9-bc50-eaf7249dfe9d"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorCollectorsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorCollectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorCollectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetAdvisorCollectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetAdvisorCollectorsOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetAdvisorCollectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetAdvisorCollectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.collectors = output.collectors
            self.nextToken = output.nextToken
        } else {
            self.collectors = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorCollectorsOutputResponse: Swift.Equatable {
    /// Provides descriptions of the Fleet Advisor collectors, including the collectors' name and ID, and the latest inventory data.
    public var collectors: [DatabaseMigrationClientTypes.CollectorResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        collectors: [DatabaseMigrationClientTypes.CollectorResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorCollectorsOutputResponseBody: Swift.Equatable {
    let collectors: [DatabaseMigrationClientTypes.CollectorResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorCollectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.CollectorResponse?].self, forKey: .collectors)
        var collectorsDecoded0:[DatabaseMigrationClientTypes.CollectorResponse]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [DatabaseMigrationClientTypes.CollectorResponse]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorDatabasesInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those databases that meet the filter criteria:
    ///
    /// * database-id – The ID of the database.
    ///
    /// * database-name – The name of the database.
    ///
    /// * database-engine – The name of the database engine.
    ///
    /// * server-ip-address – The IP address of the database server.
    ///
    /// * database-ip-address – The IP address of the database.
    ///
    /// * collector-name – The name of the associated Fleet Advisor collector.
    ///
    ///
    /// An example is: describe-fleet-advisor-databases --filter Name="database-id",Values="45"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorDatabasesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorDatabasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetAdvisorDatabasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetAdvisorDatabasesOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetAdvisorDatabasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetAdvisorDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorDatabasesOutputResponse: Swift.Equatable {
    /// Provides descriptions of the Fleet Advisor collector databases, including the database's collector, ID, and name.
    public var databases: [DatabaseMigrationClientTypes.DatabaseResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        databases: [DatabaseMigrationClientTypes.DatabaseResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorDatabasesOutputResponseBody: Swift.Equatable {
    let databases: [DatabaseMigrationClientTypes.DatabaseResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorDatabasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DatabaseResponse?].self, forKey: .databases)
        var databasesDecoded0:[DatabaseMigrationClientTypes.DatabaseResponse]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [DatabaseMigrationClientTypes.DatabaseResponse]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorLsaAnalysisInput: Swift.Equatable {
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorLsaAnalysisInputBody: Swift.Equatable {
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorLsaAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorLsaAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetAdvisorLsaAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetAdvisorLsaAnalysisOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetAdvisorLsaAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetAdvisorLsaAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analysis = output.analysis
            self.nextToken = output.nextToken
        } else {
            self.analysis = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorLsaAnalysisOutputResponse: Swift.Equatable {
    /// A list of FleetAdvisorLsaAnalysisResponse objects.
    public var analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysis = analysis
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorLsaAnalysisOutputResponseBody: Swift.Equatable {
    let analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorLsaAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysis = "Analysis"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse?].self, forKey: .analysis)
        var analysisDecoded0:[DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]? = nil
        if let analysisContainer = analysisContainer {
            analysisDecoded0 = [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]()
            for structure0 in analysisContainer {
                if let structure0 = structure0 {
                    analysisDecoded0?.append(structure0)
                }
            }
        }
        analysis = analysisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorSchemaObjectSummaryInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those schema objects that meet the filter criteria:
    ///
    /// * schema-id – The ID of the schema, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    ///
    /// Example: describe-fleet-advisor-schema-object-summary --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemaObjectSummaryInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemaObjectSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetAdvisorSchemaObjectSummaryOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetAdvisorSchemaObjectSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetAdvisorSchemaObjects = output.fleetAdvisorSchemaObjects
            self.nextToken = output.nextToken
        } else {
            self.fleetAdvisorSchemaObjects = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorSchemaObjectSummaryOutputResponse: Swift.Equatable {
    /// A collection of FleetAdvisorSchemaObjectResponse objects.
    public var fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjects
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemaObjectSummaryOutputResponseBody: Swift.Equatable {
    let fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetAdvisorSchemaObjects = "FleetAdvisorSchemaObjects"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetAdvisorSchemaObjectsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse?].self, forKey: .fleetAdvisorSchemaObjects)
        var fleetAdvisorSchemaObjectsDecoded0:[DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]? = nil
        if let fleetAdvisorSchemaObjectsContainer = fleetAdvisorSchemaObjectsContainer {
            fleetAdvisorSchemaObjectsDecoded0 = [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]()
            for structure0 in fleetAdvisorSchemaObjectsContainer {
                if let structure0 = structure0 {
                    fleetAdvisorSchemaObjectsDecoded0?.append(structure0)
                }
            }
        }
        fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorSchemasInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those schemas that meet the filter criteria:
    ///
    /// * complexity – The schema's complexity, for example Simple.
    ///
    /// * database-id – The ID of the schema's database.
    ///
    /// * database-ip-address – The IP address of the schema's database.
    ///
    /// * database-name – The name of the schema's database.
    ///
    /// * database-engine – The name of the schema database's engine.
    ///
    /// * original-schema-name – The name of the schema's database's main schema.
    ///
    /// * schema-id – The ID of the schema, for example 15.
    ///
    /// * schema-name – The name of the schema.
    ///
    /// * server-ip-address – The IP address of the schema database's server.
    ///
    ///
    /// An example is: describe-fleet-advisor-schemas --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemasInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetAdvisorSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFleetAdvisorSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetAdvisorSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFleetAdvisorSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetAdvisorSchemas = output.fleetAdvisorSchemas
            self.nextToken = output.nextToken
        } else {
            self.fleetAdvisorSchemas = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorSchemasOutputResponse: Swift.Equatable {
    /// A collection of SchemaResponse objects.
    public var fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init (
        fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemas = fleetAdvisorSchemas
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemasOutputResponseBody: Swift.Equatable {
    let fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetAdvisorSchemas = "FleetAdvisorSchemas"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetAdvisorSchemasContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaResponse?].self, forKey: .fleetAdvisorSchemas)
        var fleetAdvisorSchemasDecoded0:[DatabaseMigrationClientTypes.SchemaResponse]? = nil
        if let fleetAdvisorSchemasContainer = fleetAdvisorSchemasContainer {
            fleetAdvisorSchemasDecoded0 = [DatabaseMigrationClientTypes.SchemaResponse]()
            for structure0 in fleetAdvisorSchemasContainer {
                if let structure0 = structure0 {
                    fleetAdvisorSchemasDecoded0?.append(structure0)
                }
            }
        }
        fleetAdvisorSchemas = fleetAdvisorSchemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrderableReplicationInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeOrderableReplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeOrderableReplicationInstancesInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeOrderableReplicationInstancesInputBody: Swift.Equatable {
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableReplicationInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrderableReplicationInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrderableReplicationInstancesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableReplicationInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrderableReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableReplicationInstances = output.orderableReplicationInstances
        } else {
            self.marker = nil
            self.orderableReplicationInstances = nil
        }
    }
}

///
public struct DescribeOrderableReplicationInstancesOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The order-able replication instances available.
    public var orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?

    public init (
        marker: Swift.String? = nil,
        orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.orderableReplicationInstances = orderableReplicationInstances
    }
}

struct DescribeOrderableReplicationInstancesOutputResponseBody: Swift.Equatable {
    let orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?
    let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableReplicationInstances = "OrderableReplicationInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderableReplicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.OrderableReplicationInstance?].self, forKey: .orderableReplicationInstances)
        var orderableReplicationInstancesDecoded0:[DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
        if let orderableReplicationInstancesContainer = orderableReplicationInstancesContainer {
            orderableReplicationInstancesDecoded0 = [DatabaseMigrationClientTypes.OrderableReplicationInstance]()
            for structure0 in orderableReplicationInstancesContainer {
                if let structure0 = structure0 {
                    orderableReplicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        orderableReplicationInstances = orderableReplicationInstancesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    ///
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribePendingMaintenanceActionsInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribePendingMaintenanceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

///
public struct DescribePendingMaintenanceActionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The pending maintenance action.
    public var pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?

    public init (
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Swift.Equatable {
    let pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?
    let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingMaintenanceActionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?].self, forKey: .pendingMaintenanceActions)
        var pendingMaintenanceActionsDecoded0:[DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
        if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
            pendingMaintenanceActionsDecoded0 = [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]()
            for structure0 in pendingMaintenanceActionsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActions = pendingMaintenanceActionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeRefreshSchemasStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

extension DescribeRefreshSchemasStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeRefreshSchemasStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DescribeRefreshSchemasStatusInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension DescribeRefreshSchemasStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DescribeRefreshSchemasStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRefreshSchemasStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRefreshSchemasStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRefreshSchemasStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRefreshSchemasStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

///
public struct DescribeRefreshSchemasStatusOutputResponse: Swift.Equatable {
    /// The status of the schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct DescribeRefreshSchemasStatusOutputResponseBody: Swift.Equatable {
    let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension DescribeRefreshSchemasStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

extension DescribeReplicationInstanceTaskLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DescribeReplicationInstanceTaskLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReplicationInstanceTaskLogsInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribeReplicationInstanceTaskLogsInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstanceTaskLogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationInstanceTaskLogsOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstanceTaskLogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationInstanceTaskLogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstanceArn = output.replicationInstanceArn
            self.replicationInstanceTaskLogs = output.replicationInstanceTaskLogs
        } else {
            self.marker = nil
            self.replicationInstanceArn = nil
            self.replicationInstanceTaskLogs = nil
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?
    /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes).
    public var replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?

    public init (
        marker: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
    )
    {
        self.marker = marker
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
    }
}

struct DescribeReplicationInstanceTaskLogsOutputResponseBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?
    let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstanceTaskLogsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstanceTaskLog?].self, forKey: .replicationInstanceTaskLogs)
        var replicationInstanceTaskLogsDecoded0:[DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
        if let replicationInstanceTaskLogsContainer = replicationInstanceTaskLogsContainer {
            replicationInstanceTaskLogsDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]()
            for structure0 in replicationInstanceTaskLogsContainer {
                if let structure0 = structure0 {
                    replicationInstanceTaskLogsDecoded0?.append(structure0)
                }
            }
        }
        replicationInstanceTaskLogs = replicationInstanceTaskLogsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationInstancesInput: Swift.Equatable {
    /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationInstancesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeReplicationInstancesOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .resourceNotFoundFault: return "ResourceNotFoundFault"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeReplicationInstancesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstances = output.replicationInstances
        } else {
            self.marker = nil
            self.replicationInstances = nil
        }
    }
}

///
public struct DescribeReplicationInstancesOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The replication instances described.
    public var replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?

    public init (
        marker: Swift.String? = nil,
        replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.replicationInstances = replicationInstances
    }
}

struct DescribeReplicationInstancesOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?
}

extension DescribeReplicationInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstances = "ReplicationInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstance?].self, forKey: .replicationInstances)
        var replicationInstancesDecoded0:[DatabaseMigrationClientTypes.ReplicationInstance]? = nil
        if let replicationInstancesContainer = replicationInstancesContainer {
            replicationInstancesDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstance]()
            for structure0 in replicationInstancesContainer {
                if let structure0 = structure0 {
                    replicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        replicationInstances = replicationInstancesDecoded0
    }
}

extension DescribeReplicationSubnetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationSubnetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationSubnetGroupsInput: Swift.Equatable {
    /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationSubnetGroupsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationSubnetGroups = output.replicationSubnetGroups
        } else {
            self.marker = nil
            self.replicationSubnetGroups = nil
        }
    }
}

///
public struct DescribeReplicationSubnetGroupsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication subnet groups.
    public var replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?

    public init (
        marker: Swift.String? = nil,
        replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
    )
    {
        self.marker = marker
        self.replicationSubnetGroups = replicationSubnetGroups
    }
}

struct DescribeReplicationSubnetGroupsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?
}

extension DescribeReplicationSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationSubnetGroups = "ReplicationSubnetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationSubnetGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationSubnetGroup?].self, forKey: .replicationSubnetGroups)
        var replicationSubnetGroupsDecoded0:[DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
        if let replicationSubnetGroupsContainer = replicationSubnetGroupsContainer {
            replicationSubnetGroupsDecoded0 = [DatabaseMigrationClientTypes.ReplicationSubnetGroup]()
            for structure0 in replicationSubnetGroupsContainer {
                if let structure0 = structure0 {
                    replicationSubnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        replicationSubnetGroups = replicationSubnetGroupsDecoded0
    }
}

extension DescribeReplicationTaskAssessmentResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DescribeReplicationTaskAssessmentResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskAssessmentResultsInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters.
    public var replicationTaskArn: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeReplicationTaskAssessmentResultsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationTaskAssessmentResultsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationTaskAssessmentResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.marker = output.marker
            self.replicationTaskAssessmentResults = output.replicationTaskAssessmentResults
        } else {
            self.bucketName = nil
            self.marker = nil
            self.replicationTaskAssessmentResults = nil
        }
    }
}

///
public struct DescribeReplicationTaskAssessmentResultsOutputResponse: Swift.Equatable {
    /// - The Amazon S3 bucket where the task assessment report is located.
    public var bucketName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The task assessment report.
    public var replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?

    public init (
        bucketName: Swift.String? = nil,
        marker: Swift.String? = nil,
        replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
    )
    {
        self.bucketName = bucketName
        self.marker = marker
        self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
    }
}

struct DescribeReplicationTaskAssessmentResultsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let bucketName: Swift.String?
    let replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?
}

extension DescribeReplicationTaskAssessmentResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case marker = "Marker"
        case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let replicationTaskAssessmentResultsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult?].self, forKey: .replicationTaskAssessmentResults)
        var replicationTaskAssessmentResultsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
        if let replicationTaskAssessmentResultsContainer = replicationTaskAssessmentResultsContainer {
            replicationTaskAssessmentResultsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]()
            for structure0 in replicationTaskAssessmentResultsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentResultsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentResults = replicationTaskAssessmentResultsDecoded0
    }
}

extension DescribeReplicationTaskAssessmentRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationTaskAssessmentRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsInput: Swift.Equatable {
    /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskAssessmentRunsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskAssessmentRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationTaskAssessmentRunsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskAssessmentRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationTaskAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskAssessmentRuns = output.replicationTaskAssessmentRuns
        } else {
            self.marker = nil
            self.replicationTaskAssessmentRuns = nil
        }
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsOutputResponse: Swift.Equatable {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more premigration assessment runs as specified by Filters.
    public var replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
    }
}

struct DescribeReplicationTaskAssessmentRunsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?
}

extension DescribeReplicationTaskAssessmentRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskAssessmentRunsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?].self, forKey: .replicationTaskAssessmentRuns)
        var replicationTaskAssessmentRunsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
        if let replicationTaskAssessmentRunsContainer = replicationTaskAssessmentRunsContainer {
            replicationTaskAssessmentRunsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]()
            for structure0 in replicationTaskAssessmentRunsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentRuns = replicationTaskAssessmentRunsDecoded0
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskIndividualAssessmentsInput: Swift.Equatable {
    /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationTaskIndividualAssessmentsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationTaskIndividualAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskIndividualAssessments = output.replicationTaskIndividualAssessments
        } else {
            self.marker = nil
            self.replicationTaskIndividualAssessments = nil
        }
    }
}

///
public struct DescribeReplicationTaskIndividualAssessmentsOutputResponse: Swift.Equatable {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more individual assessments as specified by Filters.
    public var replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
    }
}

struct DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?
}

extension DescribeReplicationTaskIndividualAssessmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskIndividualAssessmentsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment?].self, forKey: .replicationTaskIndividualAssessments)
        var replicationTaskIndividualAssessmentsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
        if let replicationTaskIndividualAssessmentsContainer = replicationTaskIndividualAssessmentsContainer {
            replicationTaskIndividualAssessmentsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]()
            for structure0 in replicationTaskIndividualAssessmentsContainer {
                if let structure0 = structure0 {
                    replicationTaskIndividualAssessmentsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskIndividualAssessments = replicationTaskIndividualAssessmentsDecoded0
    }
}

extension DescribeReplicationTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let withoutSettings = self.withoutSettings {
            try encodeContainer.encode(withoutSettings, forKey: .withoutSettings)
        }
    }
}

extension DescribeReplicationTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTasksInput: Swift.Equatable {
    /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
    public var withoutSettings: Swift.Bool?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        withoutSettings: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.withoutSettings = withoutSettings
    }
}

struct DescribeReplicationTasksInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let withoutSettings: Swift.Bool?
}

extension DescribeReplicationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let withoutSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withoutSettings)
        withoutSettings = withoutSettingsDecoded
    }
}

extension DescribeReplicationTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeReplicationTasksOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .resourceNotFoundFault: return "ResourceNotFoundFault"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeReplicationTasksOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTasks = output.replicationTasks
        } else {
            self.marker = nil
            self.replicationTasks = nil
        }
    }
}

///
public struct DescribeReplicationTasksOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication tasks.
    public var replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?

    public init (
        marker: Swift.String? = nil,
        replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]? = nil
    )
    {
        self.marker = marker
        self.replicationTasks = replicationTasks
    }
}

struct DescribeReplicationTasksOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?
}

extension DescribeReplicationTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTasks = "ReplicationTasks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTasksContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTask?].self, forKey: .replicationTasks)
        var replicationTasksDecoded0:[DatabaseMigrationClientTypes.ReplicationTask]? = nil
        if let replicationTasksContainer = replicationTasksContainer {
            replicationTasksDecoded0 = [DatabaseMigrationClientTypes.ReplicationTask]()
            for structure0 in replicationTasksContainer {
                if let structure0 = structure0 {
                    replicationTasksDecoded0?.append(structure0)
                }
            }
        }
        replicationTasks = replicationTasksDecoded0
    }
}

extension DescribeSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeSchemasInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        endpointArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.endpointArn = endpointArn
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeSchemasInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.schemas = output.schemas
        } else {
            self.marker = nil
            self.schemas = nil
        }
    }
}

///
public struct DescribeSchemasOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The described schema.
    public var schemas: [Swift.String]?

    public init (
        marker: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.schemas = schemas
    }
}

struct DescribeSchemasOutputResponseBody: Swift.Equatable {
    let marker: Swift.String?
    let schemas: [Swift.String]?
}

extension DescribeSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case schemas = "Schemas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let schemasContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemas)
        var schemasDecoded0:[Swift.String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [Swift.String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

extension DescribeTableStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DescribeTableStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeTableStatisticsInput: Swift.Equatable {
    /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 500.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init (
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeTableStatisticsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeTableStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeTableStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTableStatisticsOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTableStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskArn = output.replicationTaskArn
            self.tableStatistics = output.tableStatistics
        } else {
            self.marker = nil
            self.replicationTaskArn = nil
            self.tableStatistics = nil
        }
    }
}

///
public struct DescribeTableStatisticsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?
    /// The table statistics.
    public var tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init (
        marker: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskArn = replicationTaskArn
        self.tableStatistics = tableStatistics
    }
}

struct DescribeTableStatisticsOutputResponseBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?
    let marker: Swift.String?
}

extension DescribeTableStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskArn = "ReplicationTaskArn"
        case tableStatistics = "TableStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tableStatisticsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableStatistics?].self, forKey: .tableStatistics)
        var tableStatisticsDecoded0:[DatabaseMigrationClientTypes.TableStatistics]? = nil
        if let tableStatisticsContainer = tableStatisticsContainer {
            tableStatisticsDecoded0 = [DatabaseMigrationClientTypes.TableStatistics]()
            for structure0 in tableStatisticsContainer {
                if let structure0 = structure0 {
                    tableStatisticsDecoded0?.append(structure0)
                }
            }
        }
        tableStatistics = tableStatisticsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum DmsSslModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case require
        case verifyCa
        case verifyFull
        case sdkUnknown(Swift.String)

        public static var allCases: [DmsSslModeValue] {
            return [
                .none,
                .require,
                .verifyCa,
                .verifyFull,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .require: return "require"
            case .verifyCa: return "verify-ca"
            case .verifyFull: return "verify-full"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DmsSslModeValue(rawValue: rawValue) ?? DmsSslModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DmsTransferSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The settings in JSON format for the DMS Transfer type source endpoint.
    public struct DmsTransferSettings: Swift.Equatable {
        /// The name of the S3 bucket to use.
        public var bucketName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = self.docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = self.extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = self.nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocDbSettings(databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a DocumentDB endpoint.
    public struct DocDbSettings: Swift.Equatable {
        /// The database name on the DocumentDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.Int?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.Bool?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the DocumentDB source endpoint.
        public var password: Swift.String?
        /// The port value for the DocumentDB source endpoint.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the DocumentDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the DocumentDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the DocumentDB source endpoint.
        public var serverName: Swift.String?
        /// The user name you use to access the DocumentDB source endpoint.
        public var username: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.Int? = nil,
            extractDocId: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.DynamoDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides the Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role used to define an Amazon DynamoDB target endpoint.
    public struct DynamoDbSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?

        public init (
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.ElasticsearchSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointUri = "EndpointUri"
        case errorRetryDuration = "ErrorRetryDuration"
        case fullLoadErrorPercentage = "FullLoadErrorPercentage"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case useNewMappingType = "UseNewMappingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointUri = self.endpointUri {
            try encodeContainer.encode(endpointUri, forKey: .endpointUri)
        }
        if let errorRetryDuration = self.errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let fullLoadErrorPercentage = self.fullLoadErrorPercentage {
            try encodeContainer.encode(fullLoadErrorPercentage, forKey: .fullLoadErrorPercentage)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let useNewMappingType = self.useNewMappingType {
            try encodeContainer.encode(useNewMappingType, forKey: .useNewMappingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let endpointUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUri)
        endpointUri = endpointUriDecoded
        let fullLoadErrorPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadErrorPercentage)
        fullLoadErrorPercentage = fullLoadErrorPercentageDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let useNewMappingTypeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useNewMappingType)
        useNewMappingType = useNewMappingTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an OpenSearch endpoint.
    public struct ElasticsearchSettings: Swift.Equatable {
        /// The endpoint for the OpenSearch cluster. DMS uses HTTPS if a transport protocol (http/https) is not specified.
        /// This member is required.
        public var endpointUri: Swift.String?
        /// The maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster.
        public var errorRetryDuration: Swift.Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. To avoid early failure, this counter is only effective after 1000 records are transferred. OpenSearch also has the concept of error monitoring during the last 10 minutes of an Observation Window. If transfer of all records fail in the last 10 minutes, the full load operation stops.
        public var fullLoadErrorPercentage: Swift.Int?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?
        /// Set this option to true for DMS to migrate documentation using the documentation type _doc. OpenSearch and an Elasticsearch cluster only support the _doc documentation type in versions 7. x and later. The default value is false.
        public var useNewMappingType: Swift.Bool?

        public init (
            endpointUri: Swift.String? = nil,
            errorRetryDuration: Swift.Int? = nil,
            fullLoadErrorPercentage: Swift.Int? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            useNewMappingType: Swift.Bool? = nil
        )
        {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.useNewMappingType = useNewMappingType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EncodingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plain
        case plainDictionary
        case rleDictionary
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingTypeValue] {
            return [
                .plain,
                .plainDictionary,
                .rleDictionary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .plainDictionary: return "plain-dictionary"
            case .rleDictionary: return "rle-dictionary"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingTypeValue(rawValue: rawValue) ?? EncodingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum EncryptionModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionModeValue] {
            return [
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "sse-kms"
            case .sseS3: return "sse-s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionModeValue(rawValue: rawValue) ?? EncryptionModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case externalId = "ExternalId"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case status = "Status"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = self.engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an endpoint of a database instance in response to operations such as the following:
    ///
    /// * CreateEndpoint
    ///
    /// * DescribeEndpoint
    ///
    /// * ModifyEndpoint
    public struct Endpoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public var certificateArn: Swift.String?
        /// The name of the database at the endpoint.
        public var databaseName: Swift.String?
        /// The settings for the DMS Transfer type source. For more information, see the DmsTransferSettings structure.
        public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
        /// Provides information that defines a DocumentDB endpoint.
        public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
        /// The settings for the OpenSearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account.
        public var externalId: Swift.String?
        /// The external table definition.
        public var externalTableDefinition: Swift.String?
        /// Additional connection attributes used to connect to the endpoint.
        public var extraConnectionAttributes: Swift.String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure.
        public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
        /// The port value used to access the endpoint.
        public var port: Swift.Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
        /// The settings for the Redis target endpoint. For more information, see the RedisSettings structure.
        public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
        /// Settings for the Amazon Redshift endpoint.
        public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
        /// The name of the server at the endpoint.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
        /// The status of the endpoint.
        public var status: Swift.String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
        /// The user name used to connect to the endpoint.
        public var username: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
            docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
            dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
            elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            externalId: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            extraConnectionAttributes: Swift.String? = nil,
            gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
            ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
            kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
            kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
            kmsKeyId: Swift.String? = nil,
            microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
            mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
            mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
            neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
            oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
            port: Swift.Int? = nil,
            postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
            redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
            redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
            s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
            serverName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
            status: Swift.String? = nil,
            sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
            username: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.EndpointSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicability = "Applicability"
        case defaultValue = "DefaultValue"
        case enumValues = "EnumValues"
        case intValueMax = "IntValueMax"
        case intValueMin = "IntValueMin"
        case name = "Name"
        case sensitive = "Sensitive"
        case type = "Type"
        case units = "Units"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicability = self.applicability {
            try encodeContainer.encode(applicability, forKey: .applicability)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let enumValues = enumValues {
            var enumValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enumValues)
            for string0 in enumValues {
                try enumValuesContainer.encode(string0)
            }
        }
        if let intValueMax = self.intValueMax {
            try encodeContainer.encode(intValueMax, forKey: .intValueMax)
        }
        if let intValueMin = self.intValueMin {
            try encodeContainer.encode(intValueMin, forKey: .intValueMin)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sensitive = self.sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let units = self.units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EndpointSettingTypeValue.self, forKey: .type)
        type = typeDecoded
        let enumValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enumValues)
        var enumValuesDecoded0:[Swift.String]? = nil
        if let enumValuesContainer = enumValuesContainer {
            enumValuesDecoded0 = [Swift.String]()
            for string0 in enumValuesContainer {
                if let string0 = string0 {
                    enumValuesDecoded0?.append(string0)
                }
            }
        }
        enumValues = enumValuesDecoded0
        let sensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .units)
        units = unitsDecoded
        let applicabilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicability)
        applicability = applicabilityDecoded
        let intValueMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMin)
        intValueMin = intValueMinDecoded
        let intValueMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMax)
        intValueMax = intValueMaxDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Endpoint settings.
    public struct EndpointSetting: Swift.Equatable {
        /// The relevance or validity of an endpoint setting for an engine name and its endpoint type.
        public var applicability: Swift.String?
        /// The default value of the endpoint setting if no value is specified using CreateEndpoint or ModifyEndpoint.
        public var defaultValue: Swift.String?
        /// Enumerated values to use for this endpoint.
        public var enumValues: [Swift.String]?
        /// The maximum value of an endpoint setting that is of type int.
        public var intValueMax: Swift.Int?
        /// The minimum value of an endpoint setting that is of type int.
        public var intValueMin: Swift.Int?
        /// The name that you want to give the endpoint settings.
        public var name: Swift.String?
        /// A value that marks this endpoint setting as sensitive.
        public var sensitive: Swift.Bool?
        /// The type of endpoint. Valid values are source and target.
        public var type: DatabaseMigrationClientTypes.EndpointSettingTypeValue?
        /// The unit of measure for this endpoint setting.
        public var units: Swift.String?

        public init (
            applicability: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            enumValues: [Swift.String]? = nil,
            intValueMax: Swift.Int? = nil,
            intValueMin: Swift.Int? = nil,
            name: Swift.String? = nil,
            sensitive: Swift.Bool? = nil,
            type: DatabaseMigrationClientTypes.EndpointSettingTypeValue? = nil,
            units: Swift.String? = nil
        )
        {
            self.applicability = applicability
            self.defaultValue = defaultValue
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EndpointSettingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case `enum`
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointSettingTypeValue] {
            return [
                .boolean,
                .enum,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "boolean"
            case .enum: return "enum"
            case .integer: return "integer"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointSettingTypeValue(rawValue: rawValue) ?? EndpointSettingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an identifiable significant activity that affects a replication instance or task. This object can provide the message, the available event categories, the date and source of the event, and the DMS resource type.
    public struct Event: Swift.Equatable {
        /// The date of the event.
        public var date: ClientRuntime.Date?
        /// The event categories available for the specified source type.
        public var eventCategories: [Swift.String]?
        /// The event message.
        public var message: Swift.String?
        /// The identifier of an event source.
        public var sourceIdentifier: Swift.String?
        /// The type of DMS resource that generates events. Valid values: replication-instance | endpoint | replication-task
        public var sourceType: DatabaseMigrationClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: DatabaseMigrationClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventCategoryGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Lists categories of events subscribed to, and generated by, the applicable DMS resource type. This data type appears in response to the [DescribeEventCategories](https://docs.aws.amazon.com/dms/latest/APIReference/API_EventCategoryGroup.html) action.
    public struct EventCategoryGroup: Swift.Equatable {
        /// A list of event categories from a source type that you've chosen.
        public var eventCategories: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let custSubscriptionId = self.custSubscriptionId {
            try encodeContainer.encode(custSubscriptionId, forKey: .custSubscriptionId)
        }
        if let customerAwsId = self.customerAwsId {
            try encodeContainer.encode(customerAwsId, forKey: .customerAwsId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategoriesList)
            for string0 in eventCategoriesList {
                try eventCategoriesListContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIdsList)
            for string0 in sourceIdsList {
                try sourceIdsListContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionCreationTime = self.subscriptionCreationTime {
            try encodeContainer.encode(subscriptionCreationTime, forKey: .subscriptionCreationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceIdsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIdsList)
        var sourceIdsListDecoded0:[Swift.String]? = nil
        if let sourceIdsListContainer = sourceIdsListContainer {
            sourceIdsListDecoded0 = [Swift.String]()
            for string0 in sourceIdsListContainer {
                if let string0 = string0 {
                    sourceIdsListDecoded0?.append(string0)
                }
            }
        }
        sourceIdsList = sourceIdsListDecoded0
        let eventCategoriesListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategoriesList)
        var eventCategoriesListDecoded0:[Swift.String]? = nil
        if let eventCategoriesListContainer = eventCategoriesListContainer {
            eventCategoriesListDecoded0 = [Swift.String]()
            for string0 in eventCategoriesListContainer {
                if let string0 = string0 {
                    eventCategoriesListDecoded0?.append(string0)
                }
            }
        }
        eventCategoriesList = eventCategoriesListDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an event notification subscription created by the CreateEventSubscription operation.
    public struct EventSubscription: Swift.Equatable {
        /// The DMS event notification subscription Id.
        public var custSubscriptionId: Swift.String?
        /// The Amazon Web Services customer account associated with the DMS event notification subscription.
        public var customerAwsId: Swift.String?
        /// Boolean value that indicates if the event subscription is enabled.
        public var enabled: Swift.Bool
        /// A lists of event categories.
        public var eventCategoriesList: [Swift.String]?
        /// The topic ARN of the DMS event notification subscription.
        public var snsTopicArn: Swift.String?
        /// A list of source Ids for the event subscription.
        public var sourceIdsList: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?
        /// The status of the DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public var status: Swift.String?
        /// The time the DMS event notification subscription was created.
        public var subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension DatabaseMigrationClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Identifies the name and value of a filter object. This filter is used to limit the number and type of DMS objects that are returned for a particular Describe* call or similar operation. Filters are used as an optional parameter for certain API operations.
    public struct Filter: Swift.Equatable {
        /// The name of the filter as specified for a Describe* or similar operation.
        /// This member is required.
        public var name: Swift.String?
        /// The filter value, which can specify one or more values used to narrow the returned results.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lsaAnalysisId = "LsaAnalysisId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lsaAnalysisId = self.lsaAnalysisId {
            try encodeContainer.encode(lsaAnalysisId, forKey: .lsaAnalysisId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lsaAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lsaAnalysisId)
        lsaAnalysisId = lsaAnalysisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a large-scale assessment (LSA) analysis run by a Fleet Advisor collector.
    public struct FleetAdvisorLsaAnalysisResponse: Swift.Equatable {
        /// The ID of an LSA analysis run by a Fleet Advisor collector.
        public var lsaAnalysisId: Swift.String?
        /// The status of an LSA analysis run by a Fleet Advisor collector.
        public var status: Swift.String?

        public init (
            lsaAnalysisId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.lsaAnalysisId = lsaAnalysisId
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeLineCount = "CodeLineCount"
        case codeSize = "CodeSize"
        case numberOfObjects = "NumberOfObjects"
        case objectType = "ObjectType"
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeLineCount = self.codeLineCount {
            try encodeContainer.encode(codeLineCount, forKey: .codeLineCount)
        }
        if let codeSize = self.codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let numberOfObjects = self.numberOfObjects {
            try encodeContainer.encode(numberOfObjects, forKey: .numberOfObjects)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType, forKey: .objectType)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let objectTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let numberOfObjectsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfObjects)
        numberOfObjects = numberOfObjectsDecoded
        let codeLineCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeLineCount)
        codeLineCount = codeLineCountDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema object in a Fleet Advisor collector inventory.
    public struct FleetAdvisorSchemaObjectResponse: Swift.Equatable {
        /// The number of lines of code in a schema object in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema object in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The number of objects in a schema object in a Fleet Advisor collector inventory.
        public var numberOfObjects: Swift.Int?
        /// The type of the schema object, as reported by the database engine. Examples include the following:
        ///
        /// * function
        ///
        /// * trigger
        ///
        /// * SYSTEM_TABLE
        ///
        /// * QUEUE
        public var objectType: Swift.String?
        /// The ID of a schema object in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?

        public init (
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            numberOfObjects: Swift.Int? = nil,
            objectType: Swift.String? = nil,
            schemaId: Swift.String? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.numberOfObjects = numberOfObjects
            self.objectType = objectType
            self.schemaId = schemaId
        }
    }

}

extension DatabaseMigrationClientTypes.GcpMySQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = self.cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = self.eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = self.parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = self.serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = self.targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.GcpMySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GcpMySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public struct GcpMySQLSettings: Swift.Equatable {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Adjusts the behavior of DMS when migrating from an SQL Server source database that is hosted as part of an Always On availability group cluster. If you need DMS to poll all the nodes in the Always On cluster for transaction backups, set this attribute to false.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        ///
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Endpoint TCP port.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLsn = "CurrentLsn"
        case databaseName = "DatabaseName"
        case maxKBytesPerRead = "MaxKBytesPerRead"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case setDataCaptureChanges = "SetDataCaptureChanges"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLsn = self.currentLsn {
            try encodeContainer.encode(currentLsn, forKey: .currentLsn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxKBytesPerRead = self.maxKBytesPerRead {
            try encodeContainer.encode(maxKBytesPerRead, forKey: .maxKBytesPerRead)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let setDataCaptureChanges = self.setDataCaptureChanges {
            try encodeContainer.encode(setDataCaptureChanges, forKey: .setDataCaptureChanges)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let setDataCaptureChangesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setDataCaptureChanges)
        setDataCaptureChanges = setDataCaptureChangesDecoded
        let currentLsnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLsn)
        currentLsn = currentLsnDecoded
        let maxKBytesPerReadDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxKBytesPerRead)
        maxKBytesPerRead = maxKBytesPerReadDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IBMDb2Settings(currentLsn: \(Swift.String(describing: currentLsn)), databaseName: \(Swift.String(describing: databaseName)), maxKBytesPerRead: \(Swift.String(describing: maxKBytesPerRead)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), setDataCaptureChanges: \(Swift.String(describing: setDataCaptureChanges)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an IBM Db2 LUW endpoint.
    public struct IBMDb2Settings: Swift.Equatable {
        /// For ongoing replication (CDC), use CurrentLSN to specify a log sequence number (LSN) where you want the replication to start.
        public var currentLsn: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Maximum number of bytes per read, as a NUMBER value. The default is 64 KB.
        public var maxKBytesPerRead: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default value is 50000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Db2 LUW endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Db2 LUW endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Enables ongoing replication (CDC) as a BOOLEAN value. The default is true.
        public var setDataCaptureChanges: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            currentLsn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            maxKBytesPerRead: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            setDataCaptureChanges: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
        }
    }

}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificateWallet: \(Swift.String(describing: certificateWallet)), tags: \(Swift.String(describing: tags)), certificatePem: \"CONTENT_REDACTED\")"}
}

extension ImportCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIdentifier = self.certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = self.certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportCertificateInput: Swift.Equatable {
    /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var certificateIdentifier: Swift.String?
    /// The contents of a .pem file, which contains an X.509 certificate.
    public var certificatePem: Swift.String?
    /// The location of an imported Oracle Wallet certificate for use with SSL. Provide the name of a .sso file using the fileb:// prefix. You can't provide the certificate inline. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
    public var certificateWallet: ClientRuntime.Data?
    /// The tags associated with the certificate.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init (
        certificateIdentifier: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        certificateWallet: ClientRuntime.Data? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.tags = tags
    }
}

struct ImportCertificateInputBody: Swift.Equatable {
    let certificateIdentifier: Swift.String?
    let certificatePem: Swift.String?
    let certificateWallet: ClientRuntime.Data?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension ImportCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidCertificateFault" : self = .invalidCertificateFault(try InvalidCertificateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportCertificateOutputError: Swift.Error, Swift.Equatable {
    case invalidCertificateFault(InvalidCertificateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ImportCertificateOutputResponse: Swift.Equatable {
    /// The certificate to be uploaded.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init (
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ImportCertificateOutputResponseBody: Swift.Equatable {
    let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension ImportCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension InsufficientResourceCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InsufficientResourceCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are not enough resources allocated to the database migration.
public struct InsufficientResourceCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientResourceCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientResourceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidCertificateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The certificate was not valid.
public struct InvalidCertificateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidOperationFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action or operation requested isn't valid.
public struct InvalidOperationFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is in a state that prevents it from being used for database migration.
public struct InvalidResourceStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The subnet provided is invalid.
public struct InvalidSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.InventoryData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDatabases = "NumberOfDatabases"
        case numberOfSchemas = "NumberOfSchemas"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDatabases = self.numberOfDatabases {
            try encodeContainer.encode(numberOfDatabases, forKey: .numberOfDatabases)
        }
        if let numberOfSchemas = self.numberOfSchemas {
            try encodeContainer.encode(numberOfSchemas, forKey: .numberOfSchemas)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDatabasesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDatabases)
        numberOfDatabases = numberOfDatabasesDecoded
        let numberOfSchemasDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSchemas)
        numberOfSchemas = numberOfSchemasDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector inventory.
    public struct InventoryData: Swift.Equatable {
        /// The number of databases in the Fleet Advisor collector inventory.
        public var numberOfDatabases: Swift.Int?
        /// The number of schemas in the Fleet Advisor collector inventory.
        public var numberOfSchemas: Swift.Int?

        public init (
            numberOfDatabases: Swift.Int? = nil,
            numberOfSchemas: Swift.Int? = nil
        )
        {
            self.numberOfDatabases = numberOfDatabases
            self.numberOfSchemas = numberOfSchemas
        }
    }

}

extension KMSAccessDeniedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSAccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.
public struct KMSAccessDeniedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSAccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSAccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSDisabledFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified KMS key isn't enabled.
public struct KMSDisabledFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSDisabledFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An Key Management Service (KMS) error is preventing access to KMS.
public struct KMSFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSInvalidStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the specified KMS resource isn't valid for this request.
public struct KMSInvalidStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSInvalidStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSInvalidStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSKeyNotAccessibleFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// DMS cannot access the KMS key.
public struct KMSKeyNotAccessibleFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified KMS entity or resource can't be found.
public struct KMSNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSThrottlingFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request triggered KMS request throttling.
public struct KMSThrottlingFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSThrottlingFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSThrottlingFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum KafkaSecurityProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case saslSsl
        case sslAuthentication
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSecurityProtocol] {
            return [
                .plaintext,
                .saslSsl,
                .sslAuthentication,
                .sslEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .saslSsl: return "sasl-ssl"
            case .sslAuthentication: return "ssl-authentication"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaSecurityProtocol(rawValue: rawValue) ?? KafkaSecurityProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case broker = "Broker"
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case messageMaxBytes = "MessageMaxBytes"
        case noHexPrefix = "NoHexPrefix"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case saslPassword = "SaslPassword"
        case saslUsername = "SaslUsername"
        case securityProtocol = "SecurityProtocol"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslClientCertificateArn = "SslClientCertificateArn"
        case sslClientKeyArn = "SslClientKeyArn"
        case sslClientKeyPassword = "SslClientKeyPassword"
        case topic = "Topic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let broker = self.broker {
            try encodeContainer.encode(broker, forKey: .broker)
        }
        if let includeControlDetails = self.includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = self.includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = self.includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = self.includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = self.includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let messageMaxBytes = self.messageMaxBytes {
            try encodeContainer.encode(messageMaxBytes, forKey: .messageMaxBytes)
        }
        if let noHexPrefix = self.noHexPrefix {
            try encodeContainer.encode(noHexPrefix, forKey: .noHexPrefix)
        }
        if let partitionIncludeSchemaTable = self.partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let saslPassword = self.saslPassword {
            try encodeContainer.encode(saslPassword, forKey: .saslPassword)
        }
        if let saslUsername = self.saslUsername {
            try encodeContainer.encode(saslUsername, forKey: .saslUsername)
        }
        if let securityProtocol = self.securityProtocol {
            try encodeContainer.encode(securityProtocol.rawValue, forKey: .securityProtocol)
        }
        if let sslCaCertificateArn = self.sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslClientCertificateArn = self.sslClientCertificateArn {
            try encodeContainer.encode(sslClientCertificateArn, forKey: .sslClientCertificateArn)
        }
        if let sslClientKeyArn = self.sslClientKeyArn {
            try encodeContainer.encode(sslClientKeyArn, forKey: .sslClientKeyArn)
        }
        if let sslClientKeyPassword = self.sslClientKeyPassword {
            try encodeContainer.encode(sslClientKeyPassword, forKey: .sslClientKeyPassword)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .broker)
        broker = brokerDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let messageMaxBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageMaxBytes)
        messageMaxBytes = messageMaxBytesDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSecurityProtocol.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let sslClientCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientCertificateArn)
        sslClientCertificateArn = sslClientCertificateArnDecoded
        let sslClientKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyArn)
        sslClientKeyArn = sslClientKeyArnDecoded
        let sslClientKeyPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyPassword)
        sslClientKeyPassword = sslClientKeyPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
        let saslUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslUsername)
        saslUsername = saslUsernameDecoded
        let saslPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslPassword)
        saslPassword = saslPasswordDecoded
        let noHexPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noHexPrefix)
        noHexPrefix = noHexPrefixDecoded
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KafkaSettings(broker: \(Swift.String(describing: broker)), includeControlDetails: \(Swift.String(describing: includeControlDetails)), includeNullAndEmpty: \(Swift.String(describing: includeNullAndEmpty)), includePartitionValue: \(Swift.String(describing: includePartitionValue)), includeTableAlterOperations: \(Swift.String(describing: includeTableAlterOperations)), includeTransactionDetails: \(Swift.String(describing: includeTransactionDetails)), messageFormat: \(Swift.String(describing: messageFormat)), messageMaxBytes: \(Swift.String(describing: messageMaxBytes)), noHexPrefix: \(Swift.String(describing: noHexPrefix)), partitionIncludeSchemaTable: \(Swift.String(describing: partitionIncludeSchemaTable)), saslUsername: \(Swift.String(describing: saslUsername)), securityProtocol: \(Swift.String(describing: securityProtocol)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslClientCertificateArn: \(Swift.String(describing: sslClientCertificateArn)), sslClientKeyArn: \(Swift.String(describing: sslClientKeyArn)), topic: \(Swift.String(describing: topic)), saslPassword: \"CONTENT_REDACTED\", sslClientKeyPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Apache Kafka endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KafkaSettings: Swift.Equatable {
        /// A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345". For more information and examples of specifying a list of broker locations, see [Using Apache Kafka as a target for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html) in the Database Migration Service User Guide.
        public var broker: Swift.String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kafka message output unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public var messageMaxBytes: Swift.Int?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// The secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslPassword: Swift.String?
        /// The secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslUsername: Swift.String?
        /// Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires SaslUsername and SaslPassword.
        public var securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol?
        /// The Amazon Resource Name (ARN) for the private certificate authority (CA) cert that DMS uses to securely connect to your Kafka target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.
        public var sslClientCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyArn: Swift.String?
        /// The password for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyPassword: Swift.String?
        /// The topic to which you migrate the data. If you don't specify a topic, DMS specifies "kafka-default-topic" as the migration topic.
        public var topic: Swift.String?

        public init (
            broker: Swift.String? = nil,
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            messageMaxBytes: Swift.Int? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            saslPassword: Swift.String? = nil,
            saslUsername: Swift.String? = nil,
            securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslClientCertificateArn: Swift.String? = nil,
            sslClientKeyArn: Swift.String? = nil,
            sslClientKeyPassword: Swift.String? = nil,
            topic: Swift.String? = nil
        )
        {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.topic = topic
        }
    }

}

extension DatabaseMigrationClientTypes.KinesisSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case noHexPrefix = "NoHexPrefix"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeControlDetails = self.includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = self.includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = self.includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = self.includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = self.includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let noHexPrefix = self.noHexPrefix {
            try encodeContainer.encode(noHexPrefix, forKey: .noHexPrefix)
        }
        if let partitionIncludeSchemaTable = self.partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let noHexPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noHexPrefix)
        noHexPrefix = noHexPrefixDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Amazon Kinesis Data Stream endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KinesisSettings: Swift.Equatable {
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public var streamArn: Swift.String?

        public init (
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }
    }

}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceArnList = "ResourceArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceArnList = resourceArnList {
            var resourceArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArnList)
            for string0 in resourceArnList {
                try resourceArnListContainer.encode(string0)
            }
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the DMS resource to list tags for. This returns a list of keys (names of tags) created for the resource and their associated tag values.
    public var resourceArn: Swift.String?
    /// List of ARNs that identify multiple DMS resources that you want to list tags for. This returns a list of keys (tag names) and their associated tag values. It also returns each tag's associated ResourceArn value, which is the ARN of the resource for which each listed tag is created.
    public var resourceArnList: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        resourceArnList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceArnList = resourceArnList
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceArnList: [Swift.String]?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceArnList = "ResourceArnList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArnList)
        var resourceArnListDecoded0:[Swift.String]? = nil
        if let resourceArnListContainer = resourceArnListContainer {
            resourceArnListDecoded0 = [Swift.String]()
            for string0 in resourceArnListContainer {
                if let string0 = string0 {
                    resourceArnListDecoded0?.append(string0)
                }
            }
        }
        resourceArnList = resourceArnListDecoded0
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags for the resource.
    public var tagList: [DatabaseMigrationClientTypes.Tag]?

    public init (
        tagList: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tagList: [DatabaseMigrationClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    public enum MessageFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case jsonUnformatted
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatValue] {
            return [
                .json,
                .jsonUnformatted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .jsonUnformatted: return "json-unformatted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageFormatValue(rawValue: rawValue) ?? MessageFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcpPacketSize = "BcpPacketSize"
        case controlTablesFileGroup = "ControlTablesFileGroup"
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
        case readBackupOnly = "ReadBackupOnly"
        case safeguardPolicy = "SafeguardPolicy"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case trimSpaceInChar = "TrimSpaceInChar"
        case useBcpFullLoad = "UseBcpFullLoad"
        case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcpPacketSize = self.bcpPacketSize {
            try encodeContainer.encode(bcpPacketSize, forKey: .bcpPacketSize)
        }
        if let controlTablesFileGroup = self.controlTablesFileGroup {
            try encodeContainer.encode(controlTablesFileGroup, forKey: .controlTablesFileGroup)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let querySingleAlwaysOnNode = self.querySingleAlwaysOnNode {
            try encodeContainer.encode(querySingleAlwaysOnNode, forKey: .querySingleAlwaysOnNode)
        }
        if let readBackupOnly = self.readBackupOnly {
            try encodeContainer.encode(readBackupOnly, forKey: .readBackupOnly)
        }
        if let safeguardPolicy = self.safeguardPolicy {
            try encodeContainer.encode(safeguardPolicy.rawValue, forKey: .safeguardPolicy)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let useBcpFullLoad = self.useBcpFullLoad {
            try encodeContainer.encode(useBcpFullLoad, forKey: .useBcpFullLoad)
        }
        if let useThirdPartyBackupDevice = self.useThirdPartyBackupDevice {
            try encodeContainer.encode(useThirdPartyBackupDevice, forKey: .useThirdPartyBackupDevice)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let bcpPacketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcpPacketSize)
        bcpPacketSize = bcpPacketSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let controlTablesFileGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTablesFileGroup)
        controlTablesFileGroup = controlTablesFileGroupDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let querySingleAlwaysOnNodeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .querySingleAlwaysOnNode)
        querySingleAlwaysOnNode = querySingleAlwaysOnNodeDecoded
        let readBackupOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readBackupOnly)
        readBackupOnly = readBackupOnlyDecoded
        let safeguardPolicyDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SafeguardPolicy.self, forKey: .safeguardPolicy)
        safeguardPolicy = safeguardPolicyDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let useBcpFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBcpFullLoad)
        useBcpFullLoad = useBcpFullLoadDecoded
        let useThirdPartyBackupDeviceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useThirdPartyBackupDevice)
        useThirdPartyBackupDevice = useThirdPartyBackupDeviceDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MicrosoftSQLServerSettings(bcpPacketSize: \(Swift.String(describing: bcpPacketSize)), controlTablesFileGroup: \(Swift.String(describing: controlTablesFileGroup)), databaseName: \(Swift.String(describing: databaseName)), port: \(Swift.String(describing: port)), querySingleAlwaysOnNode: \(Swift.String(describing: querySingleAlwaysOnNode)), readBackupOnly: \(Swift.String(describing: readBackupOnly)), safeguardPolicy: \(Swift.String(describing: safeguardPolicy)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useBcpFullLoad: \(Swift.String(describing: useBcpFullLoad)), useThirdPartyBackupDevice: \(Swift.String(describing: useThirdPartyBackupDevice)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Microsoft SQL Server endpoint.
    public struct MicrosoftSQLServerSettings: Swift.Equatable {
        /// The maximum size of the packets (in bytes) used to transfer data using BCP.
        public var bcpPacketSize: Swift.Int?
        /// Specifies a file group for the DMS internal tables. When the replication task starts, all the internal DMS control tables (awsdms_ apply_exception, awsdms_apply, awsdms_changes) are created for the specified file group.
        public var controlTablesFileGroup: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. An example is a situation where running an alter DDL statement on a table might result in different information about the table cached in the replication instance.
        public var querySingleAlwaysOnNode: Swift.Bool?
        /// When this attribute is set to Y, DMS only reads changes from transaction log backups and doesn't read from the active transaction log file during ongoing replication. Setting this parameter to Y enables you to control active transaction log file growth during full load and ongoing replication tasks. However, it can add some source latency to ongoing replication.
        public var readBackupOnly: Swift.Bool?
        /// Use this attribute to minimize the need to access the backup log and enable DMS to prevent truncation using one of the following two methods. Start transactions in the database: This is the default method. When this method is used, DMS prevents TLOG truncation by mimicking a transaction in the database. As long as such a transaction is open, changes that appear after the transaction started aren't truncated. If you need Microsoft Replication to be enabled in your database, then you must choose this method. Exclusively use sp_repldone within a single task: When this method is used, DMS reads the changes and then uses sp_repldone to mark the TLOG transactions as ready for truncation. Although this method doesn't involve any transactional activities, it can only be used when Microsoft Replication isn't running. Also, when using this method, only one DMS task can access the database at any given time. Therefore, if you need to run parallel DMS tasks against the same database, use the default method.
        public var safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SQL Server endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SQL Server endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Use this to attribute to transfer data for full-load operations using BCP. When the target table contains an identity column that does not exist in the source table, you must disable the use BCP for loading table option.
        public var useBcpFullLoad: Swift.Bool?
        /// When this attribute is set to Y, DMS processes third-party transaction log backups if they are created in native format.
        public var useThirdPartyBackupDevice: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            bcpPacketSize: Swift.Int? = nil,
            controlTablesFileGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            querySingleAlwaysOnNode: Swift.Bool? = nil,
            readBackupOnly: Swift.Bool? = nil,
            safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useBcpFullLoad: Swift.Bool? = nil,
            useThirdPartyBackupDevice: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.trimSpaceInChar = trimSpaceInChar
            self.useBcpFullLoad = useBcpFullLoad
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum MigrationTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cdc
        case fullLoad
        case fullLoadAndCdc
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationTypeValue] {
            return [
                .cdc,
                .fullLoad,
                .fullLoadAndCdc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cdc: return "cdc"
            case .fullLoad: return "full-load"
            case .fullLoadAndCdc: return "full-load-and-cdc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MigrationTypeValue(rawValue: rawValue) ?? MigrationTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension ModifyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), exactSettings: \(Swift.String(describing: exactSettings)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension ModifyEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case exactSettings = "ExactSettings"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let exactSettings = self.exactSettings {
            try encodeContainer.encode(exactSettings, forKey: .exactSettings)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension ModifyEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Attributes include the following:
    ///
    /// * serviceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Settings in JSON format for the source DocumentDB endpoint. For more information about the available settings, see the configuration properties section in [ Using DocumentDB as a Target for Database Migration Service ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html) in the Database Migration Service User Guide.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
    public var engineName: Swift.String?
    /// If this attribute is Y, the current call to ModifyEndpoint replaces all existing endpoint settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyEndpoint does two things:
    ///
    /// * It replaces any endpoint settings that already exist with new values, for settings with the same names.
    ///
    /// * It creates new endpoint settings that you specify in the call, for settings with different names.
    ///
    ///
    /// For example, if you call create-endpoint ... --endpoint-settings '{"a":1}' ..., the endpoint has the following endpoint settings: '{"a":1}'. If you then call modify-endpoint ... --endpoint-settings '{"b":2}' ... for the same endpoint, the endpoint has the following settings: '{"a":1,"b":2}'. However, suppose that you follow this with a call to modify-endpoint ... --endpoint-settings '{"b":2}' --exact-settings ... for that same endpoint again. Then the endpoint has the following settings: '{"b":2}'. All existing settings are replaced with the exact settings that you specify.
    public var exactSettings: Swift.Bool?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to login to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the Redis target endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the IAM role you want to use to modify the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The SSL mode used to connect to the endpoint. The default value is none.
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// The user name to be used to login to the endpoint database.
    public var username: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointArn: Swift.String? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        exactSettings: Swift.Bool? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.exactSettings = exactSettings
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.username = username
    }
}

struct ModifyEndpointInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let endpointIdentifier: Swift.String?
    let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    let engineName: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let serverName: Swift.String?
    let port: Swift.Int?
    let databaseName: Swift.String?
    let extraConnectionAttributes: Swift.String?
    let certificateArn: Swift.String?
    let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    let serviceAccessRoleArn: Swift.String?
    let externalTableDefinition: Swift.String?
    let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    let ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    let redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    let exactSettings: Swift.Bool?
    let gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
}

extension ModifyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case exactSettings = "ExactSettings"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let exactSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exactSettings)
        exactSettings = exactSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
    }
}

extension ModifyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct ModifyEndpointOutputResponse: Swift.Equatable {
    /// The modified endpoint.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init (
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct ModifyEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension ModifyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ModifyEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension ModifyEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// A Boolean value; set to true to activate the subscription.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    public var snsTopicArn: Swift.String?
    /// The type of DMS resource that generates the events you want to subscribe to. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription to be modified.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

struct ModifyEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let enabled: Swift.Bool?
}

extension ModifyEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSThrottlingFault" : self = .kMSThrottlingFault(try KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopicFault" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorizationFault" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case kMSThrottlingFault(KMSThrottlingFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// The modified event subscription.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init (
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

extension ModifyReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if allowMajorVersionUpgrade != false {
            try encodeContainer.encode(allowMajorVersionUpgrade, forKey: .allowMajorVersionUpgrade)
        }
        if applyImmediately != false {
            try encodeContainer.encode(applyImmediately, forKey: .applyImmediately)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension ModifyReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationInstanceInput: Swift.Equatable {
    /// The amount of storage (in gigabytes) to be allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
    public var allowMajorVersionUpgrade: Swift.Bool
    /// Indicates whether the changes should be applied immediately or during the next maintenance window.
    public var applyImmediately: Swift.Bool
    /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case described following. The change is asynchronously applied as soon as possible. An outage does result if these factors apply:
    ///
    /// * This parameter is set to true during the maintenance window.
    ///
    /// * A newer minor version is available.
    ///
    /// * DMS has enabled automatic patching for the given engine version.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
    public var engineVersion: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
    public var preferredMaintenanceWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string.
    public var replicationInstanceIdentifier: Swift.String?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let allocatedStorage: Swift.Int?
    let applyImmediately: Swift.Bool
    let replicationInstanceClass: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let preferredMaintenanceWindow: Swift.String?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let allowMajorVersionUpgrade: Swift.Bool
    let autoMinorVersionUpgrade: Swift.Bool?
    let replicationInstanceIdentifier: Swift.String?
    let networkType: Swift.String?
}

extension ModifyReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let applyImmediatelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyImmediately) ?? false
        applyImmediately = applyImmediatelyDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowMajorVersionUpgrade) ?? false
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension ModifyReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientResourceCapacityFault" : self = .insufficientResourceCapacityFault(try InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceededFault" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UpgradeDependencyFailureFault" : self = .upgradeDependencyFailureFault(try UpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case insufficientResourceCapacityFault(InsufficientResourceCapacityFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case upgradeDependencyFailureFault(UpgradeDependencyFailureFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct ModifyReplicationInstanceOutputResponse: Swift.Equatable {
    /// The modified replication instance.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct ModifyReplicationInstanceOutputResponseBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension ModifyReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension ModifyReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }
}

extension ModifyReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationSubnetGroupInput: Swift.Equatable {
    /// A description for the replication instance subnet group.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name of the replication instance subnet group.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A list of subnet IDs.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init (
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
    }
}

struct ModifyReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
    let replicationSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
}

extension ModifyReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension ModifyReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationSubnetGroupDoesNotCoverEnoughAZs" : self = .replicationSubnetGroupDoesNotCoverEnoughAZs(try ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyReplicationSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidSubnet(InvalidSubnet)
    case replicationSubnetGroupDoesNotCoverEnoughAZs(ReplicationSubnetGroupDoesNotCoverEnoughAZs)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyReplicationSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

///
public struct ModifyReplicationSubnetGroupOutputResponse: Swift.Equatable {
    /// The modified replication subnet group.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init (
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct ModifyReplicationSubnetGroupOutputResponseBody: Swift.Equatable {
    let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension ModifyReplicationSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

extension ModifyReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

extension ModifyReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The replication task identifier. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    public var replicationTaskIdentifier: Swift.String?
    /// JSON file that contains settings for the task, such as task metadata settings.
    public var replicationTaskSettings: Swift.String?
    /// When using the CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. For example, --table-mappings file://mappingfile.json. When working with the DMS API, provide the JSON as the parameter value.
    public var tableMappings: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.tableMappings = tableMappings
        self.taskData = taskData
    }
}

struct ModifyReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let replicationTaskIdentifier: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationTaskSettings: Swift.String?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
    let taskData: Swift.String?
}

extension ModifyReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
    }
}

extension ModifyReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct ModifyReplicationTaskOutputResponse: Swift.Equatable {
    /// The replication task that was modified.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct ModifyReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension ModifyReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authMechanism = "AuthMechanism"
        case authSource = "AuthSource"
        case authType = "AuthType"
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authMechanism = self.authMechanism {
            try encodeContainer.encode(authMechanism.rawValue, forKey: .authMechanism)
        }
        if let authSource = self.authSource {
            try encodeContainer.encode(authSource, forKey: .authSource)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = self.docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = self.extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = self.nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authMechanismDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthMechanismValue.self, forKey: .authMechanism)
        authMechanism = authMechanismDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let authSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authSource)
        authSource = authSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MongoDbSettings(authMechanism: \(Swift.String(describing: authMechanism)), authSource: \(Swift.String(describing: authSource)), authType: \(Swift.String(describing: authType)), databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MongoDB endpoint.
    public struct MongoDbSettings: Swift.Equatable {
        /// The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public var authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// The MongoDB database name. This setting isn't used when AuthType is set to "no". The default is "admin".
        public var authSource: Swift.String?
        /// The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty.
        public var authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// The database name on the MongoDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.String?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the MongoDB source endpoint.
        public var password: Swift.String?
        /// The port value for the MongoDB source endpoint.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MongoDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MongoDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the MongoDB source endpoint.
        public var serverName: Swift.String?
        /// The user name you use to access the MongoDB source endpoint.
        public var username: Swift.String?

        public init (
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.String? = nil,
            extractDocId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension MoveReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let targetReplicationInstanceArn = self.targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
    }
}

extension MoveReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct MoveReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the task that you want to move.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The ARN of the replication instance where you want to move the task to.
    /// This member is required.
    public var targetReplicationInstanceArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil,
        targetReplicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
    }
}

struct MoveReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let targetReplicationInstanceArn: Swift.String?
}

extension MoveReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension MoveReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MoveReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MoveReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension MoveReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MoveReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct MoveReplicationTaskOutputResponse: Swift.Equatable {
    /// The replication task that was moved.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct MoveReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension MoveReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = self.cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = self.eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = self.parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = self.serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = self.targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MySQL endpoint.
    public struct MySQLSettings: Swift.Equatable {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Adjusts the behavior of DMS when migrating from an SQL Server source database that is hosted as part of an Always On availability group cluster. If you need DMS to poll all the nodes in the Always On cluster for transaction backups, set this attribute to false.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. If you specify SPECIFIC_DATABASE, specify the database name using the DatabaseName parameter of the Endpoint object. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.NeptuneSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorRetryDuration = "ErrorRetryDuration"
        case iamAuthEnabled = "IamAuthEnabled"
        case maxFileSize = "MaxFileSize"
        case maxRetryCount = "MaxRetryCount"
        case s3BucketFolder = "S3BucketFolder"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorRetryDuration = self.errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let iamAuthEnabled = self.iamAuthEnabled {
            try encodeContainer.encode(iamAuthEnabled, forKey: .iamAuthEnabled)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let maxRetryCount = self.maxRetryCount {
            try encodeContainer.encode(maxRetryCount, forKey: .maxRetryCount)
        }
        if let s3BucketFolder = self.s3BucketFolder {
            try encodeContainer.encode(s3BucketFolder, forKey: .s3BucketFolder)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketFolder)
        s3BucketFolder = s3BucketFolderDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let maxRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetryCount)
        maxRetryCount = maxRetryCountDecoded
        let iamAuthEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamAuthEnabled)
        iamAuthEnabled = iamAuthEnabledDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Neptune endpoint.
    public struct NeptuneSettings: Swift.Equatable {
        /// The number of milliseconds for DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public var errorRetryDuration: Swift.Int?
        /// If you want Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public var iamAuthEnabled: Swift.Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, DMS clears the bucket, ready to store the next batch of migrated graph data.
        public var maxFileSize: Swift.Int?
        /// The number of times for DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public var maxRetryCount: Swift.Int?
        /// A folder path where you want DMS to store migrated graph data in the S3 bucket specified by S3BucketName
        /// This member is required.
        public var s3BucketFolder: Swift.String?
        /// The name of the Amazon S3 bucket where DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. DMS maps the SQL source data to graph data before storing it in these .csv files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. The role must allow the iam:PassRole action. For more information, see [Creating an IAM Service Role for Accessing Amazon Neptune as a Target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.ServiceRole) in the Database Migration Service User Guide.
        public var serviceAccessRoleArn: Swift.String?

        public init (
            errorRetryDuration: Swift.Int? = nil,
            iamAuthEnabled: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            maxRetryCount: Swift.Int? = nil,
            s3BucketFolder: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum NestingLevelValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case one
        case sdkUnknown(Swift.String)

        public static var allCases: [NestingLevelValue] {
            return [
                .none,
                .one,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .one: return "one"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NestingLevelValue(rawValue: rawValue) ?? NestingLevelValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessAlternateDirectly = "AccessAlternateDirectly"
        case addSupplementalLogging = "AddSupplementalLogging"
        case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
        case allowSelectNestedTables = "AllowSelectNestedTables"
        case archivedLogDestId = "ArchivedLogDestId"
        case archivedLogsOnly = "ArchivedLogsOnly"
        case asmPassword = "AsmPassword"
        case asmServer = "AsmServer"
        case asmUser = "AsmUser"
        case charLengthSemantics = "CharLengthSemantics"
        case databaseName = "DatabaseName"
        case directPathNoLog = "DirectPathNoLog"
        case directPathParallelLoad = "DirectPathParallelLoad"
        case enableHomogenousTablespace = "EnableHomogenousTablespace"
        case extraArchivedLogDestIds = "ExtraArchivedLogDestIds"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case numberDatatypeScale = "NumberDatatypeScale"
        case oraclePathPrefix = "OraclePathPrefix"
        case parallelAsmReadThreads = "ParallelAsmReadThreads"
        case password = "Password"
        case port = "Port"
        case readAheadBlocks = "ReadAheadBlocks"
        case readTableSpaceName = "ReadTableSpaceName"
        case replacePathPrefix = "ReplacePathPrefix"
        case retryInterval = "RetryInterval"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case securityDbEncryption = "SecurityDbEncryption"
        case securityDbEncryptionName = "SecurityDbEncryptionName"
        case serverName = "ServerName"
        case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
        case standbyDelayTime = "StandbyDelayTime"
        case trimSpaceInChar = "TrimSpaceInChar"
        case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
        case useBFile = "UseBFile"
        case useDirectPathFullLoad = "UseDirectPathFullLoad"
        case useLogminerReader = "UseLogminerReader"
        case usePathPrefix = "UsePathPrefix"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessAlternateDirectly = self.accessAlternateDirectly {
            try encodeContainer.encode(accessAlternateDirectly, forKey: .accessAlternateDirectly)
        }
        if let addSupplementalLogging = self.addSupplementalLogging {
            try encodeContainer.encode(addSupplementalLogging, forKey: .addSupplementalLogging)
        }
        if let additionalArchivedLogDestId = self.additionalArchivedLogDestId {
            try encodeContainer.encode(additionalArchivedLogDestId, forKey: .additionalArchivedLogDestId)
        }
        if let allowSelectNestedTables = self.allowSelectNestedTables {
            try encodeContainer.encode(allowSelectNestedTables, forKey: .allowSelectNestedTables)
        }
        if let archivedLogDestId = self.archivedLogDestId {
            try encodeContainer.encode(archivedLogDestId, forKey: .archivedLogDestId)
        }
        if let archivedLogsOnly = self.archivedLogsOnly {
            try encodeContainer.encode(archivedLogsOnly, forKey: .archivedLogsOnly)
        }
        if let asmPassword = self.asmPassword {
            try encodeContainer.encode(asmPassword, forKey: .asmPassword)
        }
        if let asmServer = self.asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let asmUser = self.asmUser {
            try encodeContainer.encode(asmUser, forKey: .asmUser)
        }
        if let charLengthSemantics = self.charLengthSemantics {
            try encodeContainer.encode(charLengthSemantics.rawValue, forKey: .charLengthSemantics)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let directPathNoLog = self.directPathNoLog {
            try encodeContainer.encode(directPathNoLog, forKey: .directPathNoLog)
        }
        if let directPathParallelLoad = self.directPathParallelLoad {
            try encodeContainer.encode(directPathParallelLoad, forKey: .directPathParallelLoad)
        }
        if let enableHomogenousTablespace = self.enableHomogenousTablespace {
            try encodeContainer.encode(enableHomogenousTablespace, forKey: .enableHomogenousTablespace)
        }
        if let extraArchivedLogDestIds = extraArchivedLogDestIds {
            var extraArchivedLogDestIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extraArchivedLogDestIds)
            for integer0 in extraArchivedLogDestIds {
                try extraArchivedLogDestIdsContainer.encode(integer0)
            }
        }
        if let failTasksOnLobTruncation = self.failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let numberDatatypeScale = self.numberDatatypeScale {
            try encodeContainer.encode(numberDatatypeScale, forKey: .numberDatatypeScale)
        }
        if let oraclePathPrefix = self.oraclePathPrefix {
            try encodeContainer.encode(oraclePathPrefix, forKey: .oraclePathPrefix)
        }
        if let parallelAsmReadThreads = self.parallelAsmReadThreads {
            try encodeContainer.encode(parallelAsmReadThreads, forKey: .parallelAsmReadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let readAheadBlocks = self.readAheadBlocks {
            try encodeContainer.encode(readAheadBlocks, forKey: .readAheadBlocks)
        }
        if let readTableSpaceName = self.readTableSpaceName {
            try encodeContainer.encode(readTableSpaceName, forKey: .readTableSpaceName)
        }
        if let replacePathPrefix = self.replacePathPrefix {
            try encodeContainer.encode(replacePathPrefix, forKey: .replacePathPrefix)
        }
        if let retryInterval = self.retryInterval {
            try encodeContainer.encode(retryInterval, forKey: .retryInterval)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerOracleAsmAccessRoleArn = self.secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = self.secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let securityDbEncryption = self.securityDbEncryption {
            try encodeContainer.encode(securityDbEncryption, forKey: .securityDbEncryption)
        }
        if let securityDbEncryptionName = self.securityDbEncryptionName {
            try encodeContainer.encode(securityDbEncryptionName, forKey: .securityDbEncryptionName)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let spatialDataOptionToGeoJsonFunctionName = self.spatialDataOptionToGeoJsonFunctionName {
            try encodeContainer.encode(spatialDataOptionToGeoJsonFunctionName, forKey: .spatialDataOptionToGeoJsonFunctionName)
        }
        if let standbyDelayTime = self.standbyDelayTime {
            try encodeContainer.encode(standbyDelayTime, forKey: .standbyDelayTime)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let useAlternateFolderForOnline = self.useAlternateFolderForOnline {
            try encodeContainer.encode(useAlternateFolderForOnline, forKey: .useAlternateFolderForOnline)
        }
        if let useBFile = self.useBFile {
            try encodeContainer.encode(useBFile, forKey: .useBFile)
        }
        if let useDirectPathFullLoad = self.useDirectPathFullLoad {
            try encodeContainer.encode(useDirectPathFullLoad, forKey: .useDirectPathFullLoad)
        }
        if let useLogminerReader = self.useLogminerReader {
            try encodeContainer.encode(useLogminerReader, forKey: .useLogminerReader)
        }
        if let usePathPrefix = self.usePathPrefix {
            try encodeContainer.encode(usePathPrefix, forKey: .usePathPrefix)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSupplementalLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addSupplementalLogging)
        addSupplementalLogging = addSupplementalLoggingDecoded
        let archivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archivedLogDestId)
        archivedLogDestId = archivedLogDestIdDecoded
        let additionalArchivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .additionalArchivedLogDestId)
        additionalArchivedLogDestId = additionalArchivedLogDestIdDecoded
        let extraArchivedLogDestIdsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .extraArchivedLogDestIds)
        var extraArchivedLogDestIdsDecoded0:[Swift.Int]? = nil
        if let extraArchivedLogDestIdsContainer = extraArchivedLogDestIdsContainer {
            extraArchivedLogDestIdsDecoded0 = [Swift.Int]()
            for integer0 in extraArchivedLogDestIdsContainer {
                if let integer0 = integer0 {
                    extraArchivedLogDestIdsDecoded0?.append(integer0)
                }
            }
        }
        extraArchivedLogDestIds = extraArchivedLogDestIdsDecoded0
        let allowSelectNestedTablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelectNestedTables)
        allowSelectNestedTables = allowSelectNestedTablesDecoded
        let parallelAsmReadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelAsmReadThreads)
        parallelAsmReadThreads = parallelAsmReadThreadsDecoded
        let readAheadBlocksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readAheadBlocks)
        readAheadBlocks = readAheadBlocksDecoded
        let accessAlternateDirectlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessAlternateDirectly)
        accessAlternateDirectly = accessAlternateDirectlyDecoded
        let useAlternateFolderForOnlineDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAlternateFolderForOnline)
        useAlternateFolderForOnline = useAlternateFolderForOnlineDecoded
        let oraclePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oraclePathPrefix)
        oraclePathPrefix = oraclePathPrefixDecoded
        let usePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usePathPrefix)
        usePathPrefix = usePathPrefixDecoded
        let replacePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replacePathPrefix)
        replacePathPrefix = replacePathPrefixDecoded
        let enableHomogenousTablespaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableHomogenousTablespace)
        enableHomogenousTablespace = enableHomogenousTablespaceDecoded
        let directPathNoLogDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathNoLog)
        directPathNoLog = directPathNoLogDecoded
        let archivedLogsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archivedLogsOnly)
        archivedLogsOnly = archivedLogsOnlyDecoded
        let asmPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmPassword)
        asmPassword = asmPasswordDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let asmUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmUser)
        asmUser = asmUserDecoded
        let charLengthSemanticsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CharLengthSemantics.self, forKey: .charLengthSemantics)
        charLengthSemantics = charLengthSemanticsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let directPathParallelLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathParallelLoad)
        directPathParallelLoad = directPathParallelLoadDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let numberDatatypeScaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberDatatypeScale)
        numberDatatypeScale = numberDatatypeScaleDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let readTableSpaceNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readTableSpaceName)
        readTableSpaceName = readTableSpaceNameDecoded
        let retryIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryInterval)
        retryInterval = retryIntervalDecoded
        let securityDbEncryptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryption)
        securityDbEncryption = securityDbEncryptionDecoded
        let securityDbEncryptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryptionName)
        securityDbEncryptionName = securityDbEncryptionNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let spatialDataOptionToGeoJsonFunctionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spatialDataOptionToGeoJsonFunctionName)
        spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionNameDecoded
        let standbyDelayTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .standbyDelayTime)
        standbyDelayTime = standbyDelayTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let useBFileDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBFile)
        useBFile = useBFileDecoded
        let useDirectPathFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDirectPathFullLoad)
        useDirectPathFullLoad = useDirectPathFullLoadDecoded
        let useLogminerReaderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useLogminerReader)
        useLogminerReader = useLogminerReaderDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
    }
}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OracleSettings(accessAlternateDirectly: \(Swift.String(describing: accessAlternateDirectly)), addSupplementalLogging: \(Swift.String(describing: addSupplementalLogging)), additionalArchivedLogDestId: \(Swift.String(describing: additionalArchivedLogDestId)), allowSelectNestedTables: \(Swift.String(describing: allowSelectNestedTables)), archivedLogDestId: \(Swift.String(describing: archivedLogDestId)), archivedLogsOnly: \(Swift.String(describing: archivedLogsOnly)), asmServer: \(Swift.String(describing: asmServer)), asmUser: \(Swift.String(describing: asmUser)), charLengthSemantics: \(Swift.String(describing: charLengthSemantics)), databaseName: \(Swift.String(describing: databaseName)), directPathNoLog: \(Swift.String(describing: directPathNoLog)), directPathParallelLoad: \(Swift.String(describing: directPathParallelLoad)), enableHomogenousTablespace: \(Swift.String(describing: enableHomogenousTablespace)), extraArchivedLogDestIds: \(Swift.String(describing: extraArchivedLogDestIds)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), numberDatatypeScale: \(Swift.String(describing: numberDatatypeScale)), oraclePathPrefix: \(Swift.String(describing: oraclePathPrefix)), parallelAsmReadThreads: \(Swift.String(describing: parallelAsmReadThreads)), port: \(Swift.String(describing: port)), readAheadBlocks: \(Swift.String(describing: readAheadBlocks)), readTableSpaceName: \(Swift.String(describing: readTableSpaceName)), replacePathPrefix: \(Swift.String(describing: replacePathPrefix)), retryInterval: \(Swift.String(describing: retryInterval)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerOracleAsmAccessRoleArn: \(Swift.String(describing: secretsManagerOracleAsmAccessRoleArn)), secretsManagerOracleAsmSecretId: \(Swift.String(describing: secretsManagerOracleAsmSecretId)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), securityDbEncryptionName: \(Swift.String(describing: securityDbEncryptionName)), serverName: \(Swift.String(describing: serverName)), spatialDataOptionToGeoJsonFunctionName: \(Swift.String(describing: spatialDataOptionToGeoJsonFunctionName)), standbyDelayTime: \(Swift.String(describing: standbyDelayTime)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useAlternateFolderForOnline: \(Swift.String(describing: useAlternateFolderForOnline)), useBFile: \(Swift.String(describing: useBFile)), useDirectPathFullLoad: \(Swift.String(describing: useDirectPathFullLoad)), useLogminerReader: \(Swift.String(describing: useLogminerReader)), usePathPrefix: \(Swift.String(describing: usePathPrefix)), username: \(Swift.String(describing: username)), asmPassword: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\", securityDbEncryption: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Oracle endpoint.
    public struct OracleSettings: Swift.Equatable {
        /// Set this attribute to false in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to not access redo logs through any specified path prefix replacement using direct file access.
        public var accessAlternateDirectly: Swift.Bool?
        /// Set this attribute to set up table-level supplemental logging for the Oracle database. This attribute enables PRIMARY KEY supplemental logging on all tables selected for a migration task. If you use this option, you still need to enable database-level supplemental logging.
        public var addSupplementalLogging: Swift.Bool?
        /// Set this attribute with ArchivedLogDestId in a primary/ standby setup. This attribute is useful in the case of a switchover. In this case, DMS needs to know which destination to get archive redo logs from to read changes. This need arises because the previous primary instance is now a standby instance after switchover. Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless necessary. For additional information about RESETLOGS, see [RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var additionalArchivedLogDestId: Swift.Int?
        /// Set this attribute to true to enable replication of Oracle tables containing columns that are nested tables or defined types.
        public var allowSelectNestedTables: Swift.Bool?
        /// Specifies the ID of the destination for the archived redo logs. This value should be the same as a number in the dest_id column of the v$archived_log view. If you work with an additional redo log destination, use the AdditionalArchivedLogDestId option to specify the additional destination ID. Doing this improves performance by ensuring that the correct logs are accessed from the outset.
        public var archivedLogDestId: Swift.Int?
        /// When this field is set to Y, DMS only accesses the archived redo logs. If the archived redo logs are stored on Automatic Storage Management (ASM) only, the DMS user account needs to be granted ASM privileges.
        public var archivedLogsOnly: Swift.Bool?
        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password  value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmPassword: Swift.String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmServer: Swift.String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmUser: Swift.String?
        /// Specifies whether the length of a character column is in bytes or in characters. To indicate that the character column length is in characters, set this attribute to CHAR. Otherwise, the character column length is in bytes. Example: charLengthSemantics=CHAR;
        public var charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// When set to true, this attribute helps to increase the commit rate on the Oracle target database by writing directly to tables and not writing a trail to database logs.
        public var directPathNoLog: Swift.Bool?
        /// When set to true, this attribute specifies a parallel load when useDirectPathFullLoad is set to Y. This attribute also only applies when you use the DMS parallel load feature. Note that the target table cannot have any constraints or indexes.
        public var directPathParallelLoad: Swift.Bool?
        /// Set this attribute to enable homogenous tablespace replication and create existing tables or indexes under the same tablespace on the target.
        public var enableHomogenousTablespace: Swift.Bool?
        /// Specifies the IDs of one more destinations for one or more archived redo logs. These IDs are the values of the dest_id column in the v$archived_log view. Use this setting with the archivedLogDestId extra connection attribute in a primary-to-single setup or a primary-to-multiple-standby setup. This setting is useful in a switchover when you use an Oracle Data Guard database as a source. In this case, DMS needs information about what destination to get archive redo logs from to read changes. DMS needs this because after the switchover the previous primary is a standby instance. For example, in a primary-to-single standby setup you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2] In a primary-to-multiple-standby setup, you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2,3,4] Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless it's necessary. For more information about RESETLOGS, see [ RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var extraArchivedLogDestIds: [Swift.Int]?
        /// When set to true, this attribute causes a task to fail if the actual size of an LOB column is greater than the specified LobMaxSize. If a task is set to limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// Specifies the number scale. You can select a scale up to 38, or you can select FLOAT. By default, the NUMBER data type is converted to precision 38, scale 10. Example: numberDataTypeScale=12
        public var numberDatatypeScale: Swift.Int?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the default Oracle root used to access the redo logs.
        public var oraclePathPrefix: Swift.String?
        /// Set this attribute to change the number of threads that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 2 (the default) and 8 (the maximum). Use this attribute together with the readAheadBlocks attribute.
        public var parallelAsmReadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Set this attribute to change the number of read-ahead blocks that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 1000 (the default) and 200,000 (the maximum).
        public var readAheadBlocks: Swift.Int?
        /// When set to true, this attribute supports tablespace replication.
        public var readTableSpaceName: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This setting tells DMS instance to replace the default Oracle root with the specified usePathPrefix setting to access the redo logs.
        public var replacePathPrefix: Swift.Bool?
        /// Specifies the number of seconds that the system waits before resending a query. Example: retryInterval=6;
        public var retryInterval: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Oracle endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the SecretsManagerOracleAsmSecret. This SecretsManagerOracleAsmSecret has the secret value that allows access to the Oracle ASM of the endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerOracleAsmSecretId. Or you can specify clear-text values for AsmUserName, AsmPassword, and AsmServerName. You can't specify both. For more information on creating this SecretsManagerOracleAsmSecret and the SecretsManagerOracleAsmAccessRoleArn and SecretsManagerOracleAsmSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN, partial ARN, or friendly name of the SecretsManagerOracleAsmSecret that contains the Oracle ASM connection details for the Oracle endpoint.
        public var secretsManagerOracleAsmSecretId: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Oracle endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password  part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryption: Swift.String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryptionName: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Use this attribute to convert SDO_GEOMETRY to GEOJSON format. By default, DMS calls the SDO2GEOJSON custom function if present and accessible. Or you can create your own custom function that mimics the operation of SDOGEOJSON and set SpatialDataOptionToGeoJsonFunctionName to call it instead.
        public var spatialDataOptionToGeoJsonFunctionName: Swift.String?
        /// Use this attribute to specify a time in minutes for the delay in standby sync. If the source is an Oracle Active Data Guard standby database, use this attribute to specify the time lag between primary and standby databases. In DMS, you can create an Oracle CDC task that uses an Active Data Guard standby instance as a source for replicating ongoing changes. Doing this eliminates the need to connect to an active database that might be in production.
        public var standbyDelayTime: Swift.Int?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to use any specified prefix replacement to access all online redo logs.
        public var useAlternateFolderForOnline: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Binary Reader utility. Set UseLogminerReader to N to set this attribute to Y. To use Binary Reader with Amazon RDS for Oracle as the source, you set additional attributes. For more information about using this setting with Oracle Automatic Storage Management (ASM), see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC).
        public var useBFile: Swift.Bool?
        /// Set this attribute to Y to have DMS use a direct path full load. Specify this value to use the direct path protocol in the Oracle Call Interface (OCI). By using this OCI protocol, you can bulk-load Oracle target tables during a full load.
        public var useDirectPathFullLoad: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Oracle LogMiner utility (the default). Set this attribute to N if you want to access the redo logs as a binary file. When you set UseLogminerReader to N, also set UseBfile to Y. For more information on this setting and using Oracle ASM, see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC) in the DMS User Guide.
        public var useLogminerReader: Swift.Bool?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the path prefix used to replace the default Oracle root to access the redo logs.
        public var usePathPrefix: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            accessAlternateDirectly: Swift.Bool? = nil,
            addSupplementalLogging: Swift.Bool? = nil,
            additionalArchivedLogDestId: Swift.Int? = nil,
            allowSelectNestedTables: Swift.Bool? = nil,
            archivedLogDestId: Swift.Int? = nil,
            archivedLogsOnly: Swift.Bool? = nil,
            asmPassword: Swift.String? = nil,
            asmServer: Swift.String? = nil,
            asmUser: Swift.String? = nil,
            charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics? = nil,
            databaseName: Swift.String? = nil,
            directPathNoLog: Swift.Bool? = nil,
            directPathParallelLoad: Swift.Bool? = nil,
            enableHomogenousTablespace: Swift.Bool? = nil,
            extraArchivedLogDestIds: [Swift.Int]? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            numberDatatypeScale: Swift.Int? = nil,
            oraclePathPrefix: Swift.String? = nil,
            parallelAsmReadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            readAheadBlocks: Swift.Int? = nil,
            readTableSpaceName: Swift.Bool? = nil,
            replacePathPrefix: Swift.Bool? = nil,
            retryInterval: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            securityDbEncryption: Swift.String? = nil,
            securityDbEncryptionName: Swift.String? = nil,
            serverName: Swift.String? = nil,
            spatialDataOptionToGeoJsonFunctionName: Swift.String? = nil,
            standbyDelayTime: Swift.Int? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useAlternateFolderForOnline: Swift.Bool? = nil,
            useBFile: Swift.Bool? = nil,
            useDirectPathFullLoad: Swift.Bool? = nil,
            useLogminerReader: Swift.Bool? = nil,
            usePathPrefix: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.addSupplementalLogging = addSupplementalLogging
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.charLengthSemantics = charLengthSemantics
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.extraArchivedLogDestIds = extraArchivedLogDestIds
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.standbyDelayTime = standbyDelayTime
            self.trimSpaceInChar = trimSpaceInChar
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.useBFile = useBFile
            self.useDirectPathFullLoad = useDirectPathFullLoad
            self.useLogminerReader = useLogminerReader
            self.usePathPrefix = usePathPrefix
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.OrderableReplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case defaultAllocatedStorage = "DefaultAllocatedStorage"
        case engineVersion = "EngineVersion"
        case includedAllocatedStorage = "IncludedAllocatedStorage"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case minAllocatedStorage = "MinAllocatedStorage"
        case releaseStatus = "ReleaseStatus"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if defaultAllocatedStorage != 0 {
            try encodeContainer.encode(defaultAllocatedStorage, forKey: .defaultAllocatedStorage)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if includedAllocatedStorage != 0 {
            try encodeContainer.encode(includedAllocatedStorage, forKey: .includedAllocatedStorage)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if minAllocatedStorage != 0 {
            try encodeContainer.encode(minAllocatedStorage, forKey: .minAllocatedStorage)
        }
        if let releaseStatus = self.releaseStatus {
            try encodeContainer.encode(releaseStatus.rawValue, forKey: .releaseStatus)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let minAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minAllocatedStorage) ?? 0
        minAllocatedStorage = minAllocatedStorageDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage) ?? 0
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let defaultAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultAllocatedStorage) ?? 0
        defaultAllocatedStorage = defaultAllocatedStorageDecoded
        let includedAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .includedAllocatedStorage) ?? 0
        includedAllocatedStorage = includedAllocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let releaseStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReleaseStatusValues.self, forKey: .releaseStatus)
        releaseStatus = releaseStatusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to the DescribeOrderableReplicationInstances operation, this object describes an available replication instance. This description includes the replication instance's type, engine version, and allocated storage.
    public struct OrderableReplicationInstance: Swift.Equatable {
        /// List of Availability Zones for this replication instance.
        public var availabilityZones: [Swift.String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public var defaultAllocatedStorage: Swift.Int
        /// The version of the replication engine.
        public var engineVersion: Swift.String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var includedAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var maxAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var minAllocatedStorage: Swift.Int
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected. DMS supports the ReleaseStatus parameter in versions 3.1.4 and later.
        public var releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The type of storage used by the replication instance.
        public var storageType: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            defaultAllocatedStorage: Swift.Int = 0,
            engineVersion: Swift.String? = nil,
            includedAllocatedStorage: Swift.Int = 0,
            maxAllocatedStorage: Swift.Int = 0,
            minAllocatedStorage: Swift.Int = 0,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            replicationInstanceClass: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum ParquetVersionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parquet10
        case parquet20
        case sdkUnknown(Swift.String)

        public static var allCases: [ParquetVersionValue] {
            return [
                .parquet10,
                .parquet20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parquet10: return "parquet-1-0"
            case .parquet20: return "parquet-2-0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParquetVersionValue(rawValue: rawValue) ?? ParquetVersionValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.PendingMaintenanceAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let autoAppliedAfterDate = self.autoAppliedAfterDate {
            try encodeContainer.encodeTimestamp(autoAppliedAfterDate, format: .epochSeconds, forKey: .autoAppliedAfterDate)
        }
        if let currentApplyDate = self.currentApplyDate {
            try encodeContainer.encodeTimestamp(currentApplyDate, format: .epochSeconds, forKey: .currentApplyDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forcedApplyDate = self.forcedApplyDate {
            try encodeContainer.encodeTimestamp(forcedApplyDate, format: .epochSeconds, forKey: .forcedApplyDate)
        }
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus, forKey: .optInStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .autoAppliedAfterDate)
        autoAppliedAfterDate = autoAppliedAfterDateDecoded
        let forcedApplyDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .forcedApplyDate)
        forcedApplyDate = forcedApplyDateDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .currentApplyDate)
        currentApplyDate = currentApplyDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a maintenance action pending for an DMS resource, including when and how it will be applied. This data type is a response element to the DescribePendingMaintenanceActions operation.
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// The type of pending maintenance action that is available for the resource.
        public var action: Swift.String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public var autoAppliedAfterDate: ClientRuntime.Date?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public var currentApplyDate: ClientRuntime.Date?
        /// A description providing more detail about the maintenance action.
        public var description: Swift.String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public var forcedApplyDate: ClientRuntime.Date?
        /// The type of opt-in request that has been received for the resource.
        public var optInStatus: Swift.String?

        public init (
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum PluginNameValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noPreference
        case pglogical
        case testDecoding
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginNameValue] {
            return [
                .noPreference,
                .pglogical,
                .testDecoding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "no-preference"
            case .pglogical: return "pglogical"
            case .testDecoding: return "test-decoding"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginNameValue(rawValue: rawValue) ?? PluginNameValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case captureDdls = "CaptureDdls"
        case databaseName = "DatabaseName"
        case ddlArtifactsSchema = "DdlArtifactsSchema"
        case executeTimeout = "ExecuteTimeout"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case heartbeatEnable = "HeartbeatEnable"
        case heartbeatFrequency = "HeartbeatFrequency"
        case heartbeatSchema = "HeartbeatSchema"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case pluginName = "PluginName"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case slotName = "SlotName"
        case trimSpaceInChar = "TrimSpaceInChar"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let captureDdls = self.captureDdls {
            try encodeContainer.encode(captureDdls, forKey: .captureDdls)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ddlArtifactsSchema = self.ddlArtifactsSchema {
            try encodeContainer.encode(ddlArtifactsSchema, forKey: .ddlArtifactsSchema)
        }
        if let executeTimeout = self.executeTimeout {
            try encodeContainer.encode(executeTimeout, forKey: .executeTimeout)
        }
        if let failTasksOnLobTruncation = self.failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let heartbeatEnable = self.heartbeatEnable {
            try encodeContainer.encode(heartbeatEnable, forKey: .heartbeatEnable)
        }
        if let heartbeatFrequency = self.heartbeatFrequency {
            try encodeContainer.encode(heartbeatFrequency, forKey: .heartbeatFrequency)
        }
        if let heartbeatSchema = self.heartbeatSchema {
            try encodeContainer.encode(heartbeatSchema, forKey: .heartbeatSchema)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let pluginName = self.pluginName {
            try encodeContainer.encode(pluginName.rawValue, forKey: .pluginName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let captureDdlsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .captureDdls)
        captureDdls = captureDdlsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ddlArtifactsSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ddlArtifactsSchema)
        ddlArtifactsSchema = ddlArtifactsSchemaDecoded
        let executeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executeTimeout)
        executeTimeout = executeTimeoutDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let heartbeatEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .heartbeatEnable)
        heartbeatEnable = heartbeatEnableDecoded
        let heartbeatSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .heartbeatSchema)
        heartbeatSchema = heartbeatSchemaDecoded
        let heartbeatFrequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heartbeatFrequency)
        heartbeatFrequency = heartbeatFrequencyDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PluginNameValue.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostgreSQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), captureDdls: \(Swift.String(describing: captureDdls)), databaseName: \(Swift.String(describing: databaseName)), ddlArtifactsSchema: \(Swift.String(describing: ddlArtifactsSchema)), executeTimeout: \(Swift.String(describing: executeTimeout)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), heartbeatEnable: \(Swift.String(describing: heartbeatEnable)), heartbeatFrequency: \(Swift.String(describing: heartbeatFrequency)), heartbeatSchema: \(Swift.String(describing: heartbeatSchema)), maxFileSize: \(Swift.String(describing: maxFileSize)), pluginName: \(Swift.String(describing: pluginName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), slotName: \(Swift.String(describing: slotName)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a PostgreSQL endpoint.
    public struct PostgreSQLSettings: Swift.Equatable {
        /// For use with change data capture (CDC) only, this attribute has DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data. Example: afterConnectScript=SET session_replication_role='replica'
        public var afterConnectScript: Swift.String?
        /// To capture DDL events, DMS creates various artifacts in the PostgreSQL database when the task starts. You can later remove these artifacts. If this value is set to N, you don't have to create tables or triggers on the source database.
        public var captureDdls: Swift.Bool?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// The schema in which the operational DDL database artifacts are created. Example: ddlArtifactsSchema=xyzddlschema;
        public var ddlArtifactsSchema: Swift.String?
        /// Sets the client statement timeout for the PostgreSQL instance, in seconds. The default value is 60 seconds. Example: executeTimeout=100;
        public var executeTimeout: Swift.Int?
        /// When set to true, this value causes a task to fail if the actual size of a LOB column is greater than the specified LobMaxSize. If task is set to Limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// The write-ahead log (WAL) heartbeat feature mimics a dummy transaction. By doing this, it prevents idle logical replication slots from holding onto old WAL logs, which can result in storage full situations on the source. This heartbeat keeps restart_lsn moving and prevents storage full scenarios.
        public var heartbeatEnable: Swift.Bool?
        /// Sets the WAL heartbeat frequency (in minutes).
        public var heartbeatFrequency: Swift.Int?
        /// Sets the schema in which the heartbeat artifacts are created.
        public var heartbeatSchema: Swift.String?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Specifies the plugin to use to create a replication slot.
        public var pluginName: DatabaseMigrationClientTypes.PluginNameValue?
        /// Endpoint TCP port. The default is 5432.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the PostgreSQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the PostgreSQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Sets the name of a previously created logical replication slot for a change data capture (CDC) load of the PostgreSQL source instance. When used with the CdcStartPosition request parameter for the DMS API , this attribute also makes it possible to use native CDC start points. DMS verifies that the specified logical replication slot exists before starting the CDC load task. It also verifies that the task was created with a valid setting of CdcStartPosition. If the specified slot doesn't exist or the task doesn't have a valid CdcStartPosition setting, DMS raises an error. For more information about setting the CdcStartPosition request parameter, see [Determining a CDC native start point] in the Database Migration Service User Guide. For more information about using CdcStartPosition, see [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html), [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html), and [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html).
        public var slotName: Swift.String?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            afterConnectScript: Swift.String? = nil,
            captureDdls: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            ddlArtifactsSchema: Swift.String? = nil,
            executeTimeout: Swift.Int? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            heartbeatEnable: Swift.Bool? = nil,
            heartbeatFrequency: Swift.Int? = nil,
            heartbeatSchema: Swift.String? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            pluginName: DatabaseMigrationClientTypes.PluginNameValue? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            slotName: Swift.String? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.captureDdls = captureDdls
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.heartbeatEnable = heartbeatEnable
            self.heartbeatFrequency = heartbeatFrequency
            self.heartbeatSchema = heartbeatSchema
            self.maxFileSize = maxFileSize
            self.password = password
            self.pluginName = pluginName
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.trimSpaceInChar = trimSpaceInChar
            self.username = username
        }
    }

}

extension RebootReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case forcePlannedFailover = "ForcePlannedFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceFailover = self.forceFailover {
            try encodeContainer.encode(forceFailover, forKey: .forceFailover)
        }
        if let forcePlannedFailover = self.forcePlannedFailover {
            try encodeContainer.encode(forcePlannedFailover, forKey: .forcePlannedFailover)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension RebootReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootReplicationInstanceInput: Swift.Equatable {
    /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. If the instance isn't configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forceFailover: Swift.Bool?
    /// If this parameter is true, the reboot is conducted through a planned Multi-AZ failover where resources are released and cleaned up prior to conducting the failover. If the instance isn''t configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forcePlannedFailover: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        forceFailover: Swift.Bool? = nil,
        forcePlannedFailover: Swift.Bool? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.forceFailover = forceFailover
        self.forcePlannedFailover = forcePlannedFailover
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RebootReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let forceFailover: Swift.Bool?
    let forcePlannedFailover: Swift.Bool?
}

extension RebootReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case forcePlannedFailover = "ForcePlannedFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let forceFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceFailover)
        forceFailover = forceFailoverDecoded
        let forcePlannedFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forcePlannedFailover)
        forcePlannedFailover = forcePlannedFailoverDecoded
    }
}

extension RebootReplicationInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootReplicationInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RebootReplicationInstanceOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootReplicationInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RebootReplicationInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

public struct RebootReplicationInstanceOutputResponse: Swift.Equatable {
    /// The replication instance that is being rebooted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init (
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct RebootReplicationInstanceOutputResponseBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension RebootReplicationInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum RedisAuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authRole
        case authToken
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RedisAuthTypeValue] {
            return [
                .authRole,
                .authToken,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authRole: return "auth-role"
            case .authToken: return "auth-token"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RedisAuthTypeValue(rawValue: rawValue) ?? RedisAuthTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.RedisSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authPassword = "AuthPassword"
        case authType = "AuthType"
        case authUserName = "AuthUserName"
        case port = "Port"
        case serverName = "ServerName"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslSecurityProtocol = "SslSecurityProtocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authPassword = self.authPassword {
            try encodeContainer.encode(authPassword, forKey: .authPassword)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let authUserName = self.authUserName {
            try encodeContainer.encode(authUserName, forKey: .authUserName)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslCaCertificateArn = self.sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslSecurityProtocol = self.sslSecurityProtocol {
            try encodeContainer.encode(sslSecurityProtocol.rawValue, forKey: .sslSecurityProtocol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let sslSecurityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SslSecurityProtocolValue.self, forKey: .sslSecurityProtocol)
        sslSecurityProtocol = sslSecurityProtocolDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisAuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authUserName)
        authUserName = authUserNameDecoded
        let authPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authPassword)
        authPassword = authPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes.RedisSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedisSettings(authType: \(Swift.String(describing: authType)), authUserName: \(Swift.String(describing: authUserName)), port: \(Swift.String(describing: port)), serverName: \(Swift.String(describing: serverName)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslSecurityProtocol: \(Swift.String(describing: sslSecurityProtocol)), authPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Redis target endpoint.
    public struct RedisSettings: Swift.Equatable {
        /// The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
        public var authPassword: Swift.String?
        /// The type of authentication to perform when connecting to a Redis target. Options include none, auth-token, and auth-role. The auth-token option requires an AuthPassword value to be provided. The auth-role option requires AuthUserName and AuthPassword values to be provided.
        public var authType: DatabaseMigrationClientTypes.RedisAuthTypeValue?
        /// The user name provided with the auth-role option of the AuthType setting for a Redis target endpoint.
        public var authUserName: Swift.String?
        /// Transmission Control Protocol (TCP) port for the endpoint.
        /// This member is required.
        public var port: Swift.Int
        /// Fully qualified domain name of the endpoint.
        /// This member is required.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The connection to a Redis target endpoint using Transport Layer Security (TLS). Valid values include plaintext and ssl-encryption. The default is ssl-encryption. The ssl-encryption option makes an encrypted connection. Optionally, you can identify an Amazon Resource Name (ARN) for an SSL certificate authority (CA) using the SslCaCertificateArn setting. If an ARN isn't given for a CA, DMS uses the Amazon root CA. The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database.
        public var sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue?

        public init (
            authPassword: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.RedisAuthTypeValue? = nil,
            authUserName: Swift.String? = nil,
            port: Swift.Int = 0,
            serverName: Swift.String? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue? = nil
        )
        {
            self.authPassword = authPassword
            self.authType = authType
            self.authUserName = authUserName
            self.port = port
            self.serverName = serverName
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslSecurityProtocol = sslSecurityProtocol
        }
    }

}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptAnyDate = "AcceptAnyDate"
        case afterConnectScript = "AfterConnectScript"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case caseSensitiveNames = "CaseSensitiveNames"
        case compUpdate = "CompUpdate"
        case connectionTimeout = "ConnectionTimeout"
        case databaseName = "DatabaseName"
        case dateFormat = "DateFormat"
        case emptyAsNull = "EmptyAsNull"
        case encryptionMode = "EncryptionMode"
        case explicitIds = "ExplicitIds"
        case fileTransferUploadStreams = "FileTransferUploadStreams"
        case loadTimeout = "LoadTimeout"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case removeQuotes = "RemoveQuotes"
        case replaceChars = "ReplaceChars"
        case replaceInvalidChars = "ReplaceInvalidChars"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timeFormat = "TimeFormat"
        case trimBlanks = "TrimBlanks"
        case truncateColumns = "TruncateColumns"
        case username = "Username"
        case writeBufferSize = "WriteBufferSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptAnyDate = self.acceptAnyDate {
            try encodeContainer.encode(acceptAnyDate, forKey: .acceptAnyDate)
        }
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let bucketFolder = self.bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let caseSensitiveNames = self.caseSensitiveNames {
            try encodeContainer.encode(caseSensitiveNames, forKey: .caseSensitiveNames)
        }
        if let compUpdate = self.compUpdate {
            try encodeContainer.encode(compUpdate, forKey: .compUpdate)
        }
        if let connectionTimeout = self.connectionTimeout {
            try encodeContainer.encode(connectionTimeout, forKey: .connectionTimeout)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dateFormat = self.dateFormat {
            try encodeContainer.encode(dateFormat, forKey: .dateFormat)
        }
        if let emptyAsNull = self.emptyAsNull {
            try encodeContainer.encode(emptyAsNull, forKey: .emptyAsNull)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let explicitIds = self.explicitIds {
            try encodeContainer.encode(explicitIds, forKey: .explicitIds)
        }
        if let fileTransferUploadStreams = self.fileTransferUploadStreams {
            try encodeContainer.encode(fileTransferUploadStreams, forKey: .fileTransferUploadStreams)
        }
        if let loadTimeout = self.loadTimeout {
            try encodeContainer.encode(loadTimeout, forKey: .loadTimeout)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let removeQuotes = self.removeQuotes {
            try encodeContainer.encode(removeQuotes, forKey: .removeQuotes)
        }
        if let replaceChars = self.replaceChars {
            try encodeContainer.encode(replaceChars, forKey: .replaceChars)
        }
        if let replaceInvalidChars = self.replaceInvalidChars {
            try encodeContainer.encode(replaceInvalidChars, forKey: .replaceInvalidChars)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverSideEncryptionKmsKeyId = self.serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timeFormat = self.timeFormat {
            try encodeContainer.encode(timeFormat, forKey: .timeFormat)
        }
        if let trimBlanks = self.trimBlanks {
            try encodeContainer.encode(trimBlanks, forKey: .trimBlanks)
        }
        if let truncateColumns = self.truncateColumns {
            try encodeContainer.encode(truncateColumns, forKey: .truncateColumns)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let writeBufferSize = self.writeBufferSize {
            try encodeContainer.encode(writeBufferSize, forKey: .writeBufferSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptAnyDateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptAnyDate)
        acceptAnyDate = acceptAnyDateDecoded
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let caseSensitiveNamesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitiveNames)
        caseSensitiveNames = caseSensitiveNamesDecoded
        let compUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compUpdate)
        compUpdate = compUpdateDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dateFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFormat)
        dateFormat = dateFormatDecoded
        let emptyAsNullDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .emptyAsNull)
        emptyAsNull = emptyAsNullDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let explicitIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explicitIds)
        explicitIds = explicitIdsDecoded
        let fileTransferUploadStreamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileTransferUploadStreams)
        fileTransferUploadStreams = fileTransferUploadStreamsDecoded
        let loadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .loadTimeout)
        loadTimeout = loadTimeoutDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let removeQuotesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeQuotes)
        removeQuotes = removeQuotesDecoded
        let replaceInvalidCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceInvalidChars)
        replaceInvalidChars = replaceInvalidCharsDecoded
        let replaceCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceChars)
        replaceChars = replaceCharsDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let timeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeFormat)
        timeFormat = timeFormatDecoded
        let trimBlanksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimBlanks)
        trimBlanks = trimBlanksDecoded
        let truncateColumnsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .truncateColumns)
        truncateColumns = truncateColumnsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let writeBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeBufferSize)
        writeBufferSize = writeBufferSizeDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftSettings(acceptAnyDate: \(Swift.String(describing: acceptAnyDate)), afterConnectScript: \(Swift.String(describing: afterConnectScript)), bucketFolder: \(Swift.String(describing: bucketFolder)), bucketName: \(Swift.String(describing: bucketName)), caseSensitiveNames: \(Swift.String(describing: caseSensitiveNames)), compUpdate: \(Swift.String(describing: compUpdate)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), databaseName: \(Swift.String(describing: databaseName)), dateFormat: \(Swift.String(describing: dateFormat)), emptyAsNull: \(Swift.String(describing: emptyAsNull)), encryptionMode: \(Swift.String(describing: encryptionMode)), explicitIds: \(Swift.String(describing: explicitIds)), fileTransferUploadStreams: \(Swift.String(describing: fileTransferUploadStreams)), loadTimeout: \(Swift.String(describing: loadTimeout)), maxFileSize: \(Swift.String(describing: maxFileSize)), port: \(Swift.String(describing: port)), removeQuotes: \(Swift.String(describing: removeQuotes)), replaceChars: \(Swift.String(describing: replaceChars)), replaceInvalidChars: \(Swift.String(describing: replaceInvalidChars)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverSideEncryptionKmsKeyId: \(Swift.String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), timeFormat: \(Swift.String(describing: timeFormat)), trimBlanks: \(Swift.String(describing: trimBlanks)), truncateColumns: \(Swift.String(describing: truncateColumns)), username: \(Swift.String(describing: username)), writeBufferSize: \(Swift.String(describing: writeBufferSize)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Redshift endpoint.
    public struct RedshiftSettings: Swift.Equatable {
        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field.
        public var acceptAnyDate: Swift.Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public var afterConnectScript: Swift.String?
        /// An S3 folder where the comma-separated-value (.csv) files are stored before being uploaded to the target Redshift cluster. For full load mode, DMS converts source records into .csv files and loads them to the BucketFolder/TableID path. DMS uses the Redshift COPY command to upload the .csv files to the target table. The files are deleted once the COPY operation has finished. For more information, see [COPY](https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html) in the Amazon Redshift Database Developer Guide. For change-data-capture (CDC) mode, DMS creates a NetChanges table, and loads the .csv files to this BucketFolder/NetChangesTableID path.
        public var bucketFolder: Swift.String?
        /// The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.
        public var bucketName: Swift.String?
        /// If Amazon Redshift is configured to support case sensitive schema names, set CaseSensitiveNames to true. The default is false.
        public var caseSensitiveNames: Swift.Bool?
        /// If you set CompUpdate to true Amazon Redshift applies automatic compression if the table is empty. This applies even if the table columns already have encodings other than RAW. If you set CompUpdate to false, automatic compression is disabled and existing column encodings aren't changed. The default is true.
        public var compUpdate: Swift.Bool?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public var connectionTimeout: Swift.Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public var databaseName: Swift.String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string. If your date and time values use formats different from each other, set this to auto.
        public var dateFormat: Swift.String?
        /// A value that specifies whether DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public var emptyAsNull: Swift.Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, create an Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket"
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// This setting is only valid for a full-load migration task. Set ExplicitIds to true to have tables with IDENTITY columns override their auto-generated values with explicit values loaded from the source data files used to populate the tables. The default is false.
        public var explicitIds: Swift.Bool?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10. The number of parallel streams used to upload a single .csv file to an S3 bucket using S3 Multipart Upload. For more information, see [Multipart upload overview](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html). FileTransferUploadStreams accepts a value from 1 through 64. It defaults to 10.
        public var fileTransferUploadStreams: Swift.Int?
        /// The amount of time to wait (in milliseconds) before timing out of operations performed by DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.
        public var loadTimeout: Swift.Int?
        /// The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer data to Amazon Redshift. It defaults to 1048576KB (1 GB).
        public var maxFileSize: Swift.Int?
        /// The password for the user named in the username property.
        public var password: Swift.String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public var port: Swift.Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public var removeQuotes: Swift.Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public var replaceChars: Swift.String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public var replaceInvalidChars: Swift.String?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Amazon Redshift endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Amazon Redshift endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the Amazon Redshift cluster you are using.
        public var serverName: Swift.String?
        /// The KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string. If your date and time values use formats different from each other, set this parameter to auto.
        public var timeFormat: Swift.String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public var trimBlanks: Swift.Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public var truncateColumns: Swift.Bool?
        /// An Amazon Redshift user name for a registered user.
        public var username: Swift.String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk at the DMS replication instance. The default value is 1000 (buffer size is 1000KB).
        public var writeBufferSize: Swift.Int?

        public init (
            acceptAnyDate: Swift.Bool? = nil,
            afterConnectScript: Swift.String? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            caseSensitiveNames: Swift.Bool? = nil,
            compUpdate: Swift.Bool? = nil,
            connectionTimeout: Swift.Int? = nil,
            databaseName: Swift.String? = nil,
            dateFormat: Swift.String? = nil,
            emptyAsNull: Swift.Bool? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            explicitIds: Swift.Bool? = nil,
            fileTransferUploadStreams: Swift.Int? = nil,
            loadTimeout: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            removeQuotes: Swift.Bool? = nil,
            replaceChars: Swift.String? = nil,
            replaceInvalidChars: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timeFormat: Swift.String? = nil,
            trimBlanks: Swift.Bool? = nil,
            truncateColumns: Swift.Bool? = nil,
            username: Swift.String? = nil,
            writeBufferSize: Swift.Int? = nil
        )
        {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }
    }

}

extension RefreshSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension RefreshSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RefreshSchemasInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RefreshSchemasInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
}

extension RefreshSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension RefreshSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RefreshSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RefreshSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

///
public struct RefreshSchemasOutputResponse: Swift.Equatable {
    /// The status of the refreshed schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init (
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct RefreshSchemasOutputResponseBody: Swift.Equatable {
    let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension RefreshSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

extension DatabaseMigrationClientTypes.RefreshSchemasStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case lastFailureMessage = "LastFailureMessage"
        case lastRefreshDate = "LastRefreshDate"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let lastRefreshDate = self.lastRefreshDate {
            try encodeContainer.encodeTimestamp(lastRefreshDate, format: .epochSeconds, forKey: .lastRefreshDate)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue.self, forKey: .status)
        status = statusDecoded
        let lastRefreshDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRefreshDate)
        lastRefreshDate = lastRefreshDateDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes status of a schema at an endpoint specified by the DescribeRefreshSchemaStatus operation.
    public struct RefreshSchemasStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The last failure message for the schema.
        public var lastFailureMessage: Swift.String?
        /// The date the schema was last refreshed.
        public var lastRefreshDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The status of the schema.
        public var status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue?

        public init (
            endpointArn: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastRefreshDate: ClientRuntime.Date? = nil,
            replicationInstanceArn: Swift.String? = nil,
            status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue? = nil
        )
        {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum RefreshSchemasStatusTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case refreshing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [RefreshSchemasStatusTypeValue] {
            return [
                .failed,
                .refreshing,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .refreshing: return "refreshing"
            case .successful: return "successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RefreshSchemasStatusTypeValue(rawValue: rawValue) ?? RefreshSchemasStatusTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReleaseStatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beta
        case sdkUnknown(Swift.String)

        public static var allCases: [ReleaseStatusValues] {
            return [
                .beta,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beta: return "beta"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReleaseStatusValues(rawValue: rawValue) ?? ReleaseStatusValues.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReloadOptionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataReload
        case validateOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReloadOptionValue] {
            return [
                .dataReload,
                .validateOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataReload: return "data-reload"
            case .validateOnly: return "validate-only"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReloadOptionValue(rawValue: rawValue) ?? ReloadOptionValue.sdkUnknown(rawValue)
        }
    }
}

extension ReloadTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reloadOption = self.reloadOption {
            try encodeContainer.encode(reloadOption.rawValue, forKey: .reloadOption)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let tablesToReload = tablesToReload {
            var tablesToReloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToReload)
            for tabletoreload0 in tablesToReload {
                try tablesToReloadContainer.encode(tabletoreload0)
            }
        }
    }
}

extension ReloadTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ReloadTablesInput: Swift.Equatable {
    /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task. Valid values: data-reload, validate-only Default value is data-reload.
    public var reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The name and schema of the table to be reloaded.
    /// This member is required.
    public var tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init (
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationTaskArn = replicationTaskArn
        self.tablesToReload = tablesToReload
    }
}

struct ReloadTablesInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?
    let reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
}

extension ReloadTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tablesToReloadContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableToReload?].self, forKey: .tablesToReload)
        var tablesToReloadDecoded0:[DatabaseMigrationClientTypes.TableToReload]? = nil
        if let tablesToReloadContainer = tablesToReloadContainer {
            tablesToReloadDecoded0 = [DatabaseMigrationClientTypes.TableToReload]()
            for structure0 in tablesToReloadContainer {
                if let structure0 = structure0 {
                    tablesToReloadDecoded0?.append(structure0)
                }
            }
        }
        tablesToReload = tablesToReloadDecoded0
        let reloadOptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReloadOptionValue.self, forKey: .reloadOption)
        reloadOption = reloadOptionDecoded
    }
}

extension ReloadTablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReloadTablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ReloadTablesOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReloadTablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReloadTablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskArn = output.replicationTaskArn
        } else {
            self.replicationTaskArn = nil
        }
    }
}

public struct ReloadTablesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct ReloadTablesOutputResponseBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension ReloadTablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Removes one or more tags from an DMS resource.
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// An DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DatabaseMigrationClientTypes {
    public enum ReplicationEndpointTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationEndpointTypeValue] {
            return [
                .source,
                .target,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source: return "source"
            case .target: return "target"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationEndpointTypeValue(rawValue: rawValue) ?? ReplicationEndpointTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case freeUntil = "FreeUntil"
        case instanceCreateTime = "InstanceCreateTime"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationInstanceIpv6Addresses = "ReplicationInstanceIpv6Addresses"
        case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
        case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
        case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
        case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
        case replicationInstanceStatus = "ReplicationInstanceStatus"
        case replicationSubnetGroup = "ReplicationSubnetGroup"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = self.dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let freeUntil = self.freeUntil {
            try encodeContainer.encodeTimestamp(freeUntil, format: .epochSeconds, forKey: .freeUntil)
        }
        if let instanceCreateTime = self.instanceCreateTime {
            try encodeContainer.encodeTimestamp(instanceCreateTime, format: .epochSeconds, forKey: .instanceCreateTime)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let pendingModifiedValues = self.pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses {
            var replicationInstanceIpv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstanceIpv6Addresses)
            for string0 in replicationInstanceIpv6Addresses {
                try replicationInstanceIpv6AddressesContainer.encode(string0)
            }
        }
        if let replicationInstancePrivateIpAddress = self.replicationInstancePrivateIpAddress {
            try encodeContainer.encode(replicationInstancePrivateIpAddress, forKey: .replicationInstancePrivateIpAddress)
        }
        if let replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses {
            var replicationInstancePrivateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePrivateIpAddresses)
            for string0 in replicationInstancePrivateIpAddresses {
                try replicationInstancePrivateIpAddressesContainer.encode(string0)
            }
        }
        if let replicationInstancePublicIpAddress = self.replicationInstancePublicIpAddress {
            try encodeContainer.encode(replicationInstancePublicIpAddress, forKey: .replicationInstancePublicIpAddress)
        }
        if let replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses {
            var replicationInstancePublicIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePublicIpAddresses)
            for string0 in replicationInstancePublicIpAddresses {
                try replicationInstancePublicIpAddressesContainer.encode(string0)
            }
        }
        if let replicationInstanceStatus = self.replicationInstanceStatus {
            try encodeContainer.encode(replicationInstanceStatus, forKey: .replicationInstanceStatus)
        }
        if let replicationSubnetGroup = self.replicationSubnetGroup {
            try encodeContainer.encode(replicationSubnetGroup, forKey: .replicationSubnetGroup)
        }
        if let secondaryAvailabilityZone = self.secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembership0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let replicationInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceStatus)
        replicationInstanceStatus = replicationInstanceStatusDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ) ?? false
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade) ?? false
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstancePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePublicIpAddress)
        replicationInstancePublicIpAddress = replicationInstancePublicIpAddressDecoded
        let replicationInstancePrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePrivateIpAddress)
        replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddressDecoded
        let replicationInstancePublicIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePublicIpAddresses)
        var replicationInstancePublicIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePublicIpAddressesContainer = replicationInstancePublicIpAddressesContainer {
            replicationInstancePublicIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePublicIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePublicIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePublicIpAddresses = replicationInstancePublicIpAddressesDecoded0
        let replicationInstancePrivateIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePrivateIpAddresses)
        var replicationInstancePrivateIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePrivateIpAddressesContainer = replicationInstancePrivateIpAddressesContainer {
            replicationInstancePrivateIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePrivateIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePrivateIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddressesDecoded0
        let replicationInstanceIpv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstanceIpv6Addresses)
        var replicationInstanceIpv6AddressesDecoded0:[Swift.String]? = nil
        if let replicationInstanceIpv6AddressesContainer = replicationInstanceIpv6AddressesContainer {
            replicationInstanceIpv6AddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstanceIpv6AddressesContainer {
                if let string0 = string0 {
                    replicationInstanceIpv6AddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstanceIpv6Addresses = replicationInstanceIpv6AddressesDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let freeUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freeUntil)
        freeUntil = freeUntilDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a replication instance.
    public struct ReplicationInstance: Swift.Equatable {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The Availability Zone for the instance.
        public var availabilityZone: Swift.String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public var dnsNameServers: Swift.String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public var engineVersion: Swift.String?
        /// The expiration date of the free replication instance that is part of the Free DMS program.
        public var freeUntil: ClientRuntime.Date?
        /// The time the replication instance was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The pending modification values.
        public var pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:
        ///
        /// * Must contain 1-63 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        ///
        ///
        /// Example: myrepinstance
        public var replicationInstanceIdentifier: Swift.String?
        /// One or more IPv6 addresses for the replication instance.
        public var replicationInstanceIpv6Addresses: [Swift.String]?
        /// The private IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePrivateIpAddress: Swift.String?
        /// One or more private IP addresses for the replication instance.
        public var replicationInstancePrivateIpAddresses: [Swift.String]?
        /// The public IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePublicIpAddress: Swift.String?
        /// One or more public IP addresses for the replication instance.
        public var replicationInstancePublicIpAddresses: [Swift.String]?
        /// The status of the replication instance. The possible return values include:
        ///
        /// * "available"
        ///
        /// * "creating"
        ///
        /// * "deleted"
        ///
        /// * "deleting"
        ///
        /// * "failed"
        ///
        /// * "modifying"
        ///
        /// * "upgrading"
        ///
        /// * "rebooting"
        ///
        /// * "resetting-master-credentials"
        ///
        /// * "storage-full"
        ///
        /// * "incompatible-credentials"
        ///
        /// * "incompatible-network"
        ///
        /// * "maintenance"
        public var replicationInstanceStatus: Swift.String?
        /// The subnet group for the replication instance.
        public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public var secondaryAvailabilityZone: Swift.String?
        /// The VPC security group for the instance.
        public var vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]?

        public init (
            allocatedStorage: Swift.Int = 0,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            freeUntil: ClientRuntime.Date? = nil,
            instanceCreateTime: ClientRuntime.Date? = nil,
            kmsKeyId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            networkType: Swift.String? = nil,
            pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            replicationInstanceIpv6Addresses: [Swift.String]? = nil,
            replicationInstancePrivateIpAddress: Swift.String? = nil,
            replicationInstancePrivateIpAddresses: [Swift.String]? = nil,
            replicationInstancePublicIpAddress: Swift.String? = nil,
            replicationInstancePublicIpAddresses: [Swift.String]? = nil,
            replicationInstanceStatus: Swift.String? = nil,
            replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationInstanceTaskLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskName = "ReplicationTaskName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicationInstanceTaskLogSize != 0 {
            try encodeContainer.encode(replicationInstanceTaskLogSize, forKey: .replicationInstanceTaskLogSize)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskName = self.replicationTaskName {
            try encodeContainer.encode(replicationTaskName, forKey: .replicationTaskName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskName)
        replicationTaskName = replicationTaskNameDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceTaskLogSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicationInstanceTaskLogSize) ?? 0
        replicationInstanceTaskLogSize = replicationInstanceTaskLogSizeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Contains metadata for a replication instance task log.
    public struct ReplicationInstanceTaskLog: Swift.Equatable {
        /// The size, in bytes, of the replication task log.
        public var replicationInstanceTaskLogSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The name of the replication task.
        public var replicationTaskName: Swift.String?

        public init (
            replicationInstanceTaskLogSize: Swift.Int = 0,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskName: Swift.String? = nil
        )
        {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationPendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case replicationInstanceClass = "ReplicationInstanceClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the values of pending modifications to a replication instance. This data type is an object of the [ReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_ReplicationInstance.html) user-defined data type.
    public struct ReplicationPendingModifiedValues: Swift.Equatable {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int?
        /// The engine version number of the replication instance.
        public var engineVersion: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?

        public init (
            allocatedStorage: Swift.Int? = nil,
            engineVersion: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            networkType: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.replicationInstanceClass = replicationInstanceClass
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationSubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case supportedNetworkTypes = "SupportedNetworkTypes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetGroupStatus = self.subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
        if let supportedNetworkTypes = supportedNetworkTypes {
            var supportedNetworkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedNetworkTypes)
            for string0 in supportedNetworkTypes {
                try supportedNetworkTypesContainer.encode(string0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DatabaseMigrationClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DatabaseMigrationClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
        let supportedNetworkTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedNetworkTypes)
        var supportedNetworkTypesDecoded0:[Swift.String]? = nil
        if let supportedNetworkTypesContainer = supportedNetworkTypesContainer {
            supportedNetworkTypesDecoded0 = [Swift.String]()
            for string0 in supportedNetworkTypesContainer {
                if let string0 = string0 {
                    supportedNetworkTypesDecoded0?.append(string0)
                }
            }
        }
        supportedNetworkTypes = supportedNetworkTypesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a subnet group in response to a request by the DescribeReplicationSubnetGroups operation.
    public struct ReplicationSubnetGroup: Swift.Equatable {
        /// A description for the replication subnet group.
        public var replicationSubnetGroupDescription: Swift.String?
        /// The identifier of the replication instance subnet group.
        public var replicationSubnetGroupIdentifier: Swift.String?
        /// The status of the subnet group.
        public var subnetGroupStatus: Swift.String?
        /// The subnets that are in the subnet group.
        public var subnets: [DatabaseMigrationClientTypes.Subnet]?
        /// The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var supportedNetworkTypes: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            replicationSubnetGroupDescription: Swift.String? = nil,
            replicationSubnetGroupIdentifier: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [DatabaseMigrationClientTypes.Subnet]? = nil,
            supportedNetworkTypes: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.supportedNetworkTypes = supportedNetworkTypes
            self.vpcId = vpcId
        }
    }

}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReplicationSubnetGroupDoesNotCoverEnoughAZsBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.
public struct ReplicationSubnetGroupDoesNotCoverEnoughAZs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStopPosition = "CdcStopPosition"
        case lastFailureMessage = "LastFailureMessage"
        case migrationType = "MigrationType"
        case recoveryCheckpoint = "RecoveryCheckpoint"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskCreationDate = "ReplicationTaskCreationDate"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case replicationTaskStartDate = "ReplicationTaskStartDate"
        case replicationTaskStats = "ReplicationTaskStats"
        case sourceEndpointArn = "SourceEndpointArn"
        case status = "Status"
        case stopReason = "StopReason"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let recoveryCheckpoint = self.recoveryCheckpoint {
            try encodeContainer.encode(recoveryCheckpoint, forKey: .recoveryCheckpoint)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskCreationDate = self.replicationTaskCreationDate {
            try encodeContainer.encodeTimestamp(replicationTaskCreationDate, format: .epochSeconds, forKey: .replicationTaskCreationDate)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let replicationTaskStartDate = self.replicationTaskStartDate {
            try encodeContainer.encodeTimestamp(replicationTaskStartDate, format: .epochSeconds, forKey: .replicationTaskStartDate)
        }
        if let replicationTaskStats = self.replicationTaskStats {
            try encodeContainer.encode(replicationTaskStats, forKey: .replicationTaskStats)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let stopReason = self.stopReason {
            try encodeContainer.encode(stopReason, forKey: .stopReason)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let targetReplicationInstanceArn = self.targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let stopReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopReason)
        stopReason = stopReasonDecoded
        let replicationTaskCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskCreationDate)
        replicationTaskCreationDate = replicationTaskCreationDateDecoded
        let replicationTaskStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskStartDate)
        replicationTaskStartDate = replicationTaskStartDateDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let recoveryCheckpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryCheckpoint)
        recoveryCheckpoint = recoveryCheckpointDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskStatsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskStats.self, forKey: .replicationTaskStats)
        replicationTaskStats = replicationTaskStatsDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a replication task created by the CreateReplicationTask operation.
    public struct ReplicationTask: Swift.Equatable {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”
        public var cdcStartPosition: Swift.String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public var cdcStopPosition: Swift.String?
        /// The last error (failure) message generated for the replication task.
        public var lastFailureMessage: Swift.String?
        /// The type of migration.
        public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public var recoveryCheckpoint: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The date the replication task was created.
        public var replicationTaskCreationDate: ClientRuntime.Date?
        /// The user-assigned replication task identifier or name. Constraints:
        ///
        /// * Must contain 1-255 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        public var replicationTaskIdentifier: Swift.String?
        /// The settings for the replication task.
        public var replicationTaskSettings: Swift.String?
        /// The date the replication task is scheduled to start.
        public var replicationTaskStartDate: ClientRuntime.Date?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public var replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) that uniquely identifies the endpoint.
        public var sourceEndpointArn: Swift.String?
        /// The status of the replication task. This response parameter can return one of the following values:
        ///
        /// * "moving" – The task is being moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "creating" – The task is being created in response to running the [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html) operation.
        ///
        /// * "deleting" – The task is being deleted in response to running the [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html) operation.
        ///
        /// * "failed" – The task failed to successfully complete the database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "failed-move" – The task failed to move in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "modifying" – The task definition is being modified in response to running the [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html) operation.
        ///
        /// * "ready" – The task is in a ready state where it can respond to other task operations, such as [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) or [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html).
        ///
        /// * "running" – The task is performing a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "starting" – The task is preparing to perform a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "stopped" – The task has stopped in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "stopping" – The task is preparing to stop in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "testing" – The database migration specified for this task is being tested in response to running either the [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) or the [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation. [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) is an improved premigration task assessment operation. The [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation assesses data type compatibility only between the source and target database of a given migration task. In contrast, [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) enables you to specify a variety of premigration task assessments in addition to data type compatibility. These assessments include ones for the validity of primary key definitions and likely issues with database migration performance, among others.
        public var status: Swift.String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:
        ///
        /// * "Stop Reason NORMAL"
        ///
        /// * "Stop Reason RECOVERABLE_ERROR"
        ///
        /// * "Stop Reason FATAL_ERROR"
        ///
        /// * "Stop Reason FULL_LOAD_ONLY_FINISHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_FULL_LOAD" – Full load completed, with cached changes not applied
        ///
        /// * "Stop Reason STOPPED_AFTER_CACHED_EVENTS" – Full load completed, with cached changes applied
        ///
        /// * "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_DDL_APPLY" – User-defined stop task after DDL applied
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_DISK"
        ///
        /// * "Stop Reason STOPPED_AT_SERVER_TIME" – User-defined server time for stopping task
        ///
        /// * "Stop Reason STOPPED_AT_COMMIT_TIME" – User-defined commit time for stopping task
        ///
        /// * "Stop Reason RECONFIGURATION_RESTART"
        ///
        /// * "Stop Reason RECYCLE_TASK"
        public var stopReason: Swift.String?
        /// Table mappings specified in the task.
        public var tableMappings: Swift.String?
        /// The ARN that uniquely identifies the endpoint.
        public var targetEndpointArn: Swift.String?
        /// The ARN of the replication instance to which this task is moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation. Otherwise, this response parameter isn't a member of the ReplicationTask object.
        public var targetReplicationInstanceArn: Swift.String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
        public var taskData: Swift.String?

        public init (
            cdcStartPosition: Swift.String? = nil,
            cdcStopPosition: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskCreationDate: ClientRuntime.Date? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskSettings: Swift.String? = nil,
            replicationTaskStartDate: ClientRuntime.Date? = nil,
            replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats? = nil,
            sourceEndpointArn: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil,
            targetReplicationInstanceArn: Swift.String? = nil,
            taskData: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentResults = "AssessmentResults"
        case assessmentResultsFile = "AssessmentResultsFile"
        case assessmentStatus = "AssessmentStatus"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
        case s3ObjectUrl = "S3ObjectUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentResults = self.assessmentResults {
            try encodeContainer.encode(assessmentResults, forKey: .assessmentResults)
        }
        if let assessmentResultsFile = self.assessmentResultsFile {
            try encodeContainer.encode(assessmentResultsFile, forKey: .assessmentResultsFile)
        }
        if let assessmentStatus = self.assessmentStatus {
            try encodeContainer.encode(assessmentStatus, forKey: .assessmentStatus)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskLastAssessmentDate = self.replicationTaskLastAssessmentDate {
            try encodeContainer.encodeTimestamp(replicationTaskLastAssessmentDate, format: .epochSeconds, forKey: .replicationTaskLastAssessmentDate)
        }
        if let s3ObjectUrl = self.s3ObjectUrl {
            try encodeContainer.encode(s3ObjectUrl, forKey: .s3ObjectUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskLastAssessmentDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskLastAssessmentDate)
        replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDateDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let assessmentResultsFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResultsFile)
        assessmentResultsFile = assessmentResultsFileDecoded
        let assessmentResultsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResults)
        assessmentResults = assessmentResultsDecoded
        let s3ObjectUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectUrl)
        s3ObjectUrl = s3ObjectUrlDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The task assessment report in JSON format.
    public struct ReplicationTaskAssessmentResult: Swift.Equatable {
        /// The task assessment results in JSON format. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var assessmentResults: Swift.String?
        /// The file containing the results of the task assessment.
        public var assessmentResultsFile: Swift.String?
        /// The status of the task assessment.
        public var assessmentStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The replication task identifier of the task on which the task assessment was run.
        public var replicationTaskIdentifier: Swift.String?
        /// The date the task assessment was completed.
        public var replicationTaskLastAssessmentDate: ClientRuntime.Date?
        /// The URL of the S3 object containing the task assessment results. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var s3ObjectUrl: Swift.String?

        public init (
            assessmentResults: Swift.String? = nil,
            assessmentResultsFile: Swift.String? = nil,
            assessmentStatus: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskLastAssessmentDate: ClientRuntime.Date? = nil,
            s3ObjectUrl: Swift.String? = nil
        )
        {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentProgress = "AssessmentProgress"
        case assessmentRunName = "AssessmentRunName"
        case lastFailureMessage = "LastFailureMessage"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentProgress = self.assessmentProgress {
            try encodeContainer.encode(assessmentProgress, forKey: .assessmentProgress)
        }
        if let assessmentRunName = self.assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskAssessmentRunCreationDate = self.replicationTaskAssessmentRunCreationDate {
            try encodeContainer.encodeTimestamp(replicationTaskAssessmentRunCreationDate, format: .epochSeconds, forKey: .replicationTaskAssessmentRunCreationDate)
        }
        if let resultEncryptionMode = self.resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = self.resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = self.resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = self.resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskAssessmentRunCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskAssessmentRunCreationDate)
        replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDateDecoded
        let assessmentProgressDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress.self, forKey: .assessmentProgress)
        assessmentProgress = assessmentProgressDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a premigration assessment run that you have started using the StartReplicationTaskAssessmentRun operation. Some of the information appears based on other operations that can return the ReplicationTaskAssessmentRun object.
    public struct ReplicationTaskAssessmentRun: Swift.Equatable {
        /// Indication of the completion progress for the individual assessments specified to run.
        public var assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public var assessmentRunName: Swift.String?
        /// Last message generated by an individual assessment failure.
        public var lastFailureMessage: Swift.String?
        /// ARN of the migration task associated with this premigration assessment run.
        public var replicationTaskArn: Swift.String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskAssessmentRunCreationDate: ClientRuntime.Date?
        /// Encryption mode used to encrypt the assessment run results.
        public var resultEncryptionMode: Swift.String?
        /// ARN of the KMS encryption key used to encrypt the assessment run results.
        public var resultKmsKeyArn: Swift.String?
        /// Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationBucket: Swift.String?
        /// Folder in an Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationFolder: Swift.String?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// Assessment run status. This status can have one of the following values:
        ///
        /// * "cancelling" – The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.
        ///
        /// * "deleting" – The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.
        ///
        /// * "failed" – At least one individual assessment completed with a failed status.
        ///
        /// * "error-provisioning" – An internal error occurred while resources were provisioned (during provisioning status).
        ///
        /// * "error-executing" – An internal error occurred while individual assessments ran (during running status).
        ///
        /// * "invalid state" – The assessment run is in an unknown state.
        ///
        /// * "passed" – All individual assessments have completed, and none has a failed status.
        ///
        /// * "provisioning" – Resources required to run individual assessments are being provisioned.
        ///
        /// * "running" – Individual assessments are being run.
        ///
        /// * "starting" – The assessment run is starting, but resources are not yet being provisioned for individual assessments.
        public var status: Swift.String?

        public init (
            assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress? = nil,
            assessmentRunName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskAssessmentRunCreationDate: ClientRuntime.Date? = nil,
            resultEncryptionMode: Swift.String? = nil,
            resultKmsKeyArn: Swift.String? = nil,
            resultLocationBucket: Swift.String? = nil,
            resultLocationFolder: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
        case individualAssessmentCount = "IndividualAssessmentCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if individualAssessmentCompletedCount != 0 {
            try encodeContainer.encode(individualAssessmentCompletedCount, forKey: .individualAssessmentCompletedCount)
        }
        if individualAssessmentCount != 0 {
            try encodeContainer.encode(individualAssessmentCount, forKey: .individualAssessmentCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .individualAssessmentCount) ?? 0
        individualAssessmentCount = individualAssessmentCountDecoded
        let individualAssessmentCompletedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .individualAssessmentCompletedCount) ?? 0
        individualAssessmentCompletedCount = individualAssessmentCompletedCountDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The progress values reported by the AssessmentProgress response element.
    public struct ReplicationTaskAssessmentRunProgress: Swift.Equatable {
        /// The number of individual assessments that have completed, successfully or not.
        public var individualAssessmentCompletedCount: Swift.Int
        /// The number of individual assessments that are specified to run.
        public var individualAssessmentCount: Swift.Int

        public init (
            individualAssessmentCompletedCount: Swift.Int = 0,
            individualAssessmentCount: Swift.Int = 0
        )
        {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentName = "IndividualAssessmentName"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
        case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let individualAssessmentName = self.individualAssessmentName {
            try encodeContainer.encode(individualAssessmentName, forKey: .individualAssessmentName)
        }
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskIndividualAssessmentArn = self.replicationTaskIndividualAssessmentArn {
            try encodeContainer.encode(replicationTaskIndividualAssessmentArn, forKey: .replicationTaskIndividualAssessmentArn)
        }
        if let replicationTaskIndividualAssessmentStartDate = self.replicationTaskIndividualAssessmentStartDate {
            try encodeContainer.encodeTimestamp(replicationTaskIndividualAssessmentStartDate, format: .epochSeconds, forKey: .replicationTaskIndividualAssessmentStartDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIndividualAssessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIndividualAssessmentArn)
        replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArnDecoded
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let individualAssessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .individualAssessmentName)
        individualAssessmentName = individualAssessmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskIndividualAssessmentStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskIndividualAssessmentStartDate)
        replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an individual assessment from a premigration assessment run.
    public struct ReplicationTaskIndividualAssessment: Swift.Equatable {
        /// Name of this individual assessment.
        public var individualAssessmentName: Swift.String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public var replicationTaskIndividualAssessmentArn: Swift.String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date?
        /// Individual assessment status. This status can have one of the following values:
        ///
        /// * "cancelled"
        ///
        /// * "error"
        ///
        /// * "failed"
        ///
        /// * "passed"
        ///
        /// * "pending"
        ///
        /// * "running"
        public var status: Swift.String?

        public init (
            individualAssessmentName: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeMillis = "ElapsedTimeMillis"
        case freshStartDate = "FreshStartDate"
        case fullLoadFinishDate = "FullLoadFinishDate"
        case fullLoadProgressPercent = "FullLoadProgressPercent"
        case fullLoadStartDate = "FullLoadStartDate"
        case startDate = "StartDate"
        case stopDate = "StopDate"
        case tablesErrored = "TablesErrored"
        case tablesLoaded = "TablesLoaded"
        case tablesLoading = "TablesLoading"
        case tablesQueued = "TablesQueued"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if elapsedTimeMillis != 0 {
            try encodeContainer.encode(elapsedTimeMillis, forKey: .elapsedTimeMillis)
        }
        if let freshStartDate = self.freshStartDate {
            try encodeContainer.encodeTimestamp(freshStartDate, format: .epochSeconds, forKey: .freshStartDate)
        }
        if let fullLoadFinishDate = self.fullLoadFinishDate {
            try encodeContainer.encodeTimestamp(fullLoadFinishDate, format: .epochSeconds, forKey: .fullLoadFinishDate)
        }
        if fullLoadProgressPercent != 0 {
            try encodeContainer.encode(fullLoadProgressPercent, forKey: .fullLoadProgressPercent)
        }
        if let fullLoadStartDate = self.fullLoadStartDate {
            try encodeContainer.encodeTimestamp(fullLoadStartDate, format: .epochSeconds, forKey: .fullLoadStartDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let stopDate = self.stopDate {
            try encodeContainer.encodeTimestamp(stopDate, format: .epochSeconds, forKey: .stopDate)
        }
        if tablesErrored != 0 {
            try encodeContainer.encode(tablesErrored, forKey: .tablesErrored)
        }
        if tablesLoaded != 0 {
            try encodeContainer.encode(tablesLoaded, forKey: .tablesLoaded)
        }
        if tablesLoading != 0 {
            try encodeContainer.encode(tablesLoading, forKey: .tablesLoading)
        }
        if tablesQueued != 0 {
            try encodeContainer.encode(tablesQueued, forKey: .tablesQueued)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullLoadProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadProgressPercent) ?? 0
        fullLoadProgressPercent = fullLoadProgressPercentDecoded
        let elapsedTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeMillis) ?? 0
        elapsedTimeMillis = elapsedTimeMillisDecoded
        let tablesLoadedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoaded) ?? 0
        tablesLoaded = tablesLoadedDecoded
        let tablesLoadingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoading) ?? 0
        tablesLoading = tablesLoadingDecoded
        let tablesQueuedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesQueued) ?? 0
        tablesQueued = tablesQueuedDecoded
        let tablesErroredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesErrored) ?? 0
        tablesErrored = tablesErroredDecoded
        let freshStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freshStartDate)
        freshStartDate = freshStartDateDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopDate)
        stopDate = stopDateDecoded
        let fullLoadStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadStartDate)
        fullLoadStartDate = fullLoadStartDateDecoded
        let fullLoadFinishDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadFinishDate)
        fullLoadFinishDate = fullLoadFinishDateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationTasks operation, this object provides a collection of statistics about a replication task.
    public struct ReplicationTaskStats: Swift.Equatable {
        /// The elapsed time of the task, in milliseconds.
        public var elapsedTimeMillis: Swift.Int
        /// The date the replication task was started either with a fresh start or a target reload.
        public var freshStartDate: ClientRuntime.Date?
        /// The date the replication task full load was completed.
        public var fullLoadFinishDate: ClientRuntime.Date?
        /// The percent complete for the full load migration task.
        public var fullLoadProgressPercent: Swift.Int
        /// The date the replication task full load was started.
        public var fullLoadStartDate: ClientRuntime.Date?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see [StartReplicationTaskType](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html#DMS-StartReplicationTask-request-StartReplicationTaskType).
        public var startDate: ClientRuntime.Date?
        /// The date the replication task was stopped.
        public var stopDate: ClientRuntime.Date?
        /// The number of errors that have occurred during this task.
        public var tablesErrored: Swift.Int
        /// The number of tables loaded for this task.
        public var tablesLoaded: Swift.Int
        /// The number of tables currently loading for this task.
        public var tablesLoading: Swift.Int
        /// The number of tables queued for this task.
        public var tablesQueued: Swift.Int

        public init (
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: ClientRuntime.Date? = nil,
            fullLoadFinishDate: ClientRuntime.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil,
            stopDate: ClientRuntime.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension ResourceAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
        } else {
            self.message = nil
            self.resourceArn = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource you are attempting to create already exists.
public struct ResourceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?
    public var resourceArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
    }
}

struct ResourceAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingMaintenanceActionDetails)
            for pendingmaintenanceaction0 in pendingMaintenanceActionDetails {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0)
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let pendingMaintenanceActionDetailsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.PendingMaintenanceAction?].self, forKey: .pendingMaintenanceActionDetails)
        var pendingMaintenanceActionDetailsDecoded0:[DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil
        if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
            pendingMaintenanceActionDetailsDecoded0 = [DatabaseMigrationClientTypes.PendingMaintenanceAction]()
            for structure0 in pendingMaintenanceActionDetailsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionDetailsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Identifies an DMS resource and any pending actions for it.
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// Detailed information about the pending maintenance action.
        public var pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see [ Constructing an Amazon Resource Name (ARN) for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.AWS.ARN.html) in the DMS documentation.
        public var resourceIdentifier: Swift.String?

        public init (
            pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension ResourceQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for this resource quota has been exceeded.
public struct ResourceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RunFleetAdvisorLsaAnalysisInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension RunFleetAdvisorLsaAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RunFleetAdvisorLsaAnalysisInput: Swift.Equatable {

    public init () { }
}

struct RunFleetAdvisorLsaAnalysisInputBody: Swift.Equatable {
}

extension RunFleetAdvisorLsaAnalysisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RunFleetAdvisorLsaAnalysisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RunFleetAdvisorLsaAnalysisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RunFleetAdvisorLsaAnalysisOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RunFleetAdvisorLsaAnalysisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RunFleetAdvisorLsaAnalysisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lsaAnalysisId = output.lsaAnalysisId
            self.status = output.status
        } else {
            self.lsaAnalysisId = nil
            self.status = nil
        }
    }
}

public struct RunFleetAdvisorLsaAnalysisOutputResponse: Swift.Equatable {
    /// The ID of the LSA analysis run.
    public var lsaAnalysisId: Swift.String?
    /// The status of the LSA analysis, for example COMPLETED.
    public var status: Swift.String?

    public init (
        lsaAnalysisId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.lsaAnalysisId = lsaAnalysisId
        self.status = status
    }
}

struct RunFleetAdvisorLsaAnalysisOutputResponseBody: Swift.Equatable {
    let lsaAnalysisId: Swift.String?
    let status: Swift.String?
}

extension RunFleetAdvisorLsaAnalysisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lsaAnalysisId = "LsaAnalysisId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lsaAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lsaAnalysisId)
        lsaAnalysisId = lsaAnalysisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3AccessDeniedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: S3AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Insufficient privileges are preventing access to an Amazon S3 object.
public struct S3AccessDeniedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3AccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ResourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: S3ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified Amazon S3 bucket, bucket folder, or other object can't be found.
public struct S3ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3ResourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.S3Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumnName = "AddColumnName"
        case addTrailingPaddingCharacter = "AddTrailingPaddingCharacter"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cannedAclForObjects = "CannedAclForObjects"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcMaxBatchInterval = "CdcMaxBatchInterval"
        case cdcMinFileSize = "CdcMinFileSize"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvNullValue = "CsvNullValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case datePartitionTimezone = "DatePartitionTimezone"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case externalTableDefinition = "ExternalTableDefinition"
        case ignoreHeaderRows = "IgnoreHeaderRows"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case maxFileSize = "MaxFileSize"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rfc4180 = "Rfc4180"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
        case useTaskStartTimeForFullLoadTimestamp = "UseTaskStartTimeForFullLoadTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addColumnName = self.addColumnName {
            try encodeContainer.encode(addColumnName, forKey: .addColumnName)
        }
        if let addTrailingPaddingCharacter = self.addTrailingPaddingCharacter {
            try encodeContainer.encode(addTrailingPaddingCharacter, forKey: .addTrailingPaddingCharacter)
        }
        if let bucketFolder = self.bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedAclForObjects = self.cannedAclForObjects {
            try encodeContainer.encode(cannedAclForObjects.rawValue, forKey: .cannedAclForObjects)
        }
        if let cdcInsertsAndUpdates = self.cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = self.cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcMaxBatchInterval = self.cdcMaxBatchInterval {
            try encodeContainer.encode(cdcMaxBatchInterval, forKey: .cdcMaxBatchInterval)
        }
        if let cdcMinFileSize = self.cdcMinFileSize {
            try encodeContainer.encode(cdcMinFileSize, forKey: .cdcMinFileSize)
        }
        if let cdcPath = self.cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = self.compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = self.csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = self.csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvNullValue = self.csvNullValue {
            try encodeContainer.encode(csvNullValue, forKey: .csvNullValue)
        }
        if let csvRowDelimiter = self.csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = self.dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = self.datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = self.datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = self.datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let datePartitionTimezone = self.datePartitionTimezone {
            try encodeContainer.encode(datePartitionTimezone, forKey: .datePartitionTimezone)
        }
        if let dictPageSizeLimit = self.dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = self.enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = self.encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let ignoreHeaderRows = self.ignoreHeaderRows {
            try encodeContainer.encode(ignoreHeaderRows, forKey: .ignoreHeaderRows)
        }
        if let includeOpForFullLoad = self.includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parquetTimestampInMillisecond = self.parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = self.parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = self.preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rfc4180 = self.rfc4180 {
            try encodeContainer.encode(rfc4180, forKey: .rfc4180)
        }
        if let rowGroupLength = self.rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = self.serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = self.timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = self.useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
        if let useTaskStartTimeForFullLoadTimestamp = self.useTaskStartTimeForFullLoadTimestamp {
            try encodeContainer.encode(useTaskStartTimeForFullLoadTimestamp, forKey: .useTaskStartTimeForFullLoadTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
        let useTaskStartTimeForFullLoadTimestampDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useTaskStartTimeForFullLoadTimestamp)
        useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestampDecoded
        let cannedAclForObjectsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CannedAclForObjectsValue.self, forKey: .cannedAclForObjects)
        cannedAclForObjects = cannedAclForObjectsDecoded
        let addColumnNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addColumnName)
        addColumnName = addColumnNameDecoded
        let cdcMaxBatchIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMaxBatchInterval)
        cdcMaxBatchInterval = cdcMaxBatchIntervalDecoded
        let cdcMinFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMinFileSize)
        cdcMinFileSize = cdcMinFileSizeDecoded
        let csvNullValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNullValue)
        csvNullValue = csvNullValueDecoded
        let ignoreHeaderRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ignoreHeaderRows)
        ignoreHeaderRows = ignoreHeaderRowsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let rfc4180Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rfc4180)
        rfc4180 = rfc4180Decoded
        let datePartitionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datePartitionTimezone)
        datePartitionTimezone = datePartitionTimezoneDecoded
        let addTrailingPaddingCharacterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addTrailingPaddingCharacter)
        addTrailingPaddingCharacter = addTrailingPaddingCharacterDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Settings for exporting data to Amazon S3.
    public struct S3Settings: Swift.Equatable {
        /// An optional parameter that, when set to true or y, you can use to add column name information to the .csv output file. The default value is false. Valid values are true, false, y, and n.
        public var addColumnName: Swift.Bool?
        /// Use the S3 target endpoint setting AddTrailingPaddingCharacter to add padding on string data. The default value is false.
        public var addTrailingPaddingCharacter: Swift.Bool?
        /// An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/.
        public var bucketFolder: Swift.String?
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// A value that enables DMS to specify a predefined (canned) access control list for objects created in an Amazon S3 bucket as .csv or .parquet files. For more information about Amazon S3 canned ACLs, see [Canned ACL](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the Amazon S3 Developer Guide. The default value is NONE. Valid values include NONE, PRIVATE, PUBLIC_READ, PUBLIC_READ_WRITE, AUTHENTICATED_READ, AWS_EXEC_READ, BUCKET_OWNER_READ, and BUCKET_OWNER_FULL_CONTROL.
        public var cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file. For .csv file format only, how these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsAndUpdates: Swift.Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsOnly: Swift.Bool?
        /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. When CdcMaxBatchInterval and CdcMinFileSize are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 60 seconds.
        public var cdcMaxBatchInterval: Swift.Int?
        /// Minimum file size, defined in kilobytes, to reach for a file output to Amazon S3. When CdcMinFileSize and CdcMaxBatchInterval are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 32 MB.
        public var cdcMinFileSize: Swift.Int?
        /// Specifies the folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If CdcPath is set, DMS reads CDC files from this path and replicates the data changes to the target endpoint. For an S3 target if you set [PreserveTransactions](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-PreserveTransactions) to true, DMS verifies that you have set this parameter to a folder path on your S3 target where DMS can save the transaction order for the CDC load. DMS creates this CDC folder path in either your S3 target working directory or the S3 target location specified by [BucketFolder](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketFolder) and [BucketName](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketName). For example, if you specify CdcPath as MyChangedData, and you specify BucketName as MyTargetBucket but do not specify BucketFolder, DMS creates the CDC folder path following: MyTargetBucket/MyChangedData. If you specify the same CdcPath, and you specify BucketName as MyTargetBucket and BucketFolder as MyTargetData, DMS creates the CDC folder path following: MyTargetBucket/MyTargetData/MyChangedData. For more information on CDC including transaction order on an S3 target, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var cdcPath: Swift.String?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats.
        public var compressionType: DatabaseMigrationClientTypes.CompressionTypeValue?
        /// The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        public var csvDelimiter: Swift.String?
        /// This setting only applies if your Amazon S3 output files during a change data capture (CDC) load are written in .csv format. If [UseCsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-UseCsvNoSupValue) is set to true, specify a string value that you want DMS to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of the UseCsvNoSupValue setting. This setting is supported in DMS versions 3.4.1 and later.
        public var csvNoSupValue: Swift.String?
        /// An optional parameter that specifies how DMS treats null values. While handling the null value, you can use this parameter to pass a user-defined string as null when writing to the target. For example, when target columns are not nullable, you can use this option to differentiate between the empty string value and the null value. So, if you set this parameter value to the empty string ("" or ''), DMS treats the empty string as the null value instead of NULL. The default value is NULL. Valid values include any valid string.
        public var csvNullValue: Swift.String?
        /// The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n).
        public var csvRowDelimiter: Swift.String?
        /// The format of the data that you want to use for output. You can choose one of the following:
        ///
        /// * csv : This is a row-based file format with comma-separated values (.csv).
        ///
        /// * parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.
        public var dataFormat: DatabaseMigrationClientTypes.DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only.
        public var dataPageSize: Swift.Int?
        /// Specifies a date separating delimiter to use during folder partitioning. The default value is SLASH. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue?
        /// When set to true, this parameter partitions S3 bucket folders based on transaction commit dates. The default value is false. For more information about date-based folder partitioning, see [Using date-based folder partitioning](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.DatePartitioning).
        public var datePartitionEnabled: Swift.Bool?
        /// Identifies the sequence of the date format to use during folder partitioning. The default value is YYYYMMDD. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue?
        /// When creating an S3 target endpoint, set DatePartitionTimezone to convert the current UTC time into a specified time zone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The time zone format is Area/Location. Use this parameter when DatePartitionedEnabled is set to true, as shown in the following example. s3-settings='{"DatePartitionEnabled": true, "DatePartitionSequence": "YYYYMMDDHH", "DatePartitionDelimiter": "SLASH", "DatePartitionTimezone":"Asia/Seoul", "BucketName": "dms-nattarat-test"}'
        public var datePartitionTimezone: Swift.String?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only.
        public var dictPageSizeLimit: Swift.Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public var enableStatistics: Swift.Bool?
        /// The type of encoding you are using:
        ///
        /// * RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.
        ///
        /// * PLAIN doesn't use encoding at all. Values are stored as they are.
        ///
        /// * PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.
        public var encodingType: DatabaseMigrationClientTypes.EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, you need an Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:
        ///
        /// * s3:CreateBucket
        ///
        /// * s3:ListBucket
        ///
        /// * s3:DeleteBucket
        ///
        /// * s3:GetBucketLocation
        ///
        /// * s3:GetObject
        ///
        /// * s3:PutObject
        ///
        /// * s3:DeleteObject
        ///
        /// * s3:GetObjectVersion
        ///
        /// * s3:GetBucketPolicy
        ///
        /// * s3:PutBucketPolicy
        ///
        /// * s3:DeleteBucketPolicy
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// To specify a bucket owner and prevent sniping, you can use the ExpectedBucketOwner endpoint setting. Example: --s3-settings='{"ExpectedBucketOwner": "AWS_Account_ID"}' When you make a request to test a connection or perform a migration, S3 checks the account ID of the bucket owner against the specified parameter.
        public var expectedBucketOwner: Swift.String?
        /// Specifies how tables are defined in the S3 source files only.
        public var externalTableDefinition: Swift.String?
        /// When this value is set to 1, DMS ignores the first row header in a .csv file. A value of 1 turns on the feature; a value of 0 turns off the feature. The default is 0.
        public var ignoreHeaderRows: Swift.Int?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) output files only to indicate how the rows were added to the source database. DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later. For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load. This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide..
        public var includeOpForFullLoad: Swift.Bool?
        /// A value that specifies the maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. The default value is 1,048,576 KB (1 GB). Valid values include 1 to 1,048,576.
        public var maxFileSize: Swift.Int?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format. DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later. When ParquetTimestampInMillisecond is set to true or y, DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or Glue. DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter.
        public var parquetTimestampInMillisecond: Swift.Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public var parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue?
        /// If set to true, DMS saves the transaction order for a change data capture (CDC) load on the Amazon S3 target specified by [CdcPath](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CdcPath). For more information, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var preserveTransactions: Swift.Bool?
        /// For an S3 source, when this value is set to true or y, each leading double quotation mark has to be followed by an ending double quotation mark. This formatting complies with RFC 4180. When this value is set to false or n, string literals are copied to the target as is. In this case, a delimiter (row or column) signals the end of the field. Thus, you can't use a delimiter as part of the string, because it signals the end of the value. For an S3 target, an optional parameter used to set behavior to comply with RFC 4180 for data migrated to Amazon S3 using .csv file format only. When this value is set to true or y using Amazon S3 as a target, if the data has quotation marks or newline characters in it, DMS encloses the entire column with an additional pair of double quotation marks ("). Every quotation mark within the data is repeated twice. The default value is true. Valid values include true, false, y, and n.
        public var rfc4180: Swift.Bool?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only. If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024).
        public var rowGroupLength: Swift.Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the KMS key ID. The key that you use needs an attached policy that enables Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action. It is a required parameter that enables DMS to write and read objects from an S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// A value that when nonblank causes DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target. DMS supports the TimestampColumnName parameter in versions 3.1.4 and later. DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS. For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public var timestampColumnName: Swift.String?
        /// This setting applies if the S3 output files during a change data capture (CDC) load are written in .csv format. If set to true for columns not included in the supplemental log, DMS uses the value specified by [CsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CsvNoSupValue). If not set or set to false, DMS uses the null value for these columns. This setting is supported in DMS versions 3.4.1 and later.
        public var useCsvNoSupValue: Swift.Bool?
        /// When set to true, this parameter uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when useTaskStartTimeForFullLoadTimestamp is set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When useTaskStartTimeForFullLoadTimestamp is set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target.
        public var useTaskStartTimeForFullLoadTimestamp: Swift.Bool?

        public init (
            addColumnName: Swift.Bool? = nil,
            addTrailingPaddingCharacter: Swift.Bool? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue? = nil,
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            cdcInsertsOnly: Swift.Bool? = nil,
            cdcMaxBatchInterval: Swift.Int? = nil,
            cdcMinFileSize: Swift.Int? = nil,
            cdcPath: Swift.String? = nil,
            compressionType: DatabaseMigrationClientTypes.CompressionTypeValue? = nil,
            csvDelimiter: Swift.String? = nil,
            csvNoSupValue: Swift.String? = nil,
            csvNullValue: Swift.String? = nil,
            csvRowDelimiter: Swift.String? = nil,
            dataFormat: DatabaseMigrationClientTypes.DataFormatValue? = nil,
            dataPageSize: Swift.Int? = nil,
            datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue? = nil,
            datePartitionEnabled: Swift.Bool? = nil,
            datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue? = nil,
            datePartitionTimezone: Swift.String? = nil,
            dictPageSizeLimit: Swift.Int? = nil,
            enableStatistics: Swift.Bool? = nil,
            encodingType: DatabaseMigrationClientTypes.EncodingTypeValue? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            expectedBucketOwner: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            ignoreHeaderRows: Swift.Int? = nil,
            includeOpForFullLoad: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            parquetTimestampInMillisecond: Swift.Bool? = nil,
            parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue? = nil,
            preserveTransactions: Swift.Bool? = nil,
            rfc4180: Swift.Bool? = nil,
            rowGroupLength: Swift.Int? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timestampColumnName: Swift.String? = nil,
            useCsvNoSupValue: Swift.Bool? = nil,
            useTaskStartTimeForFullLoadTimestamp: Swift.Bool? = nil
        )
        {
            self.addColumnName = addColumnName
            self.addTrailingPaddingCharacter = addTrailingPaddingCharacter
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cannedAclForObjects = cannedAclForObjects
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcMaxBatchInterval = cdcMaxBatchInterval
            self.cdcMinFileSize = cdcMinFileSize
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvNullValue = csvNullValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.datePartitionTimezone = datePartitionTimezone
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.expectedBucketOwner = expectedBucketOwner
            self.externalTableDefinition = externalTableDefinition
            self.ignoreHeaderRows = ignoreHeaderRows
            self.includeOpForFullLoad = includeOpForFullLoad
            self.maxFileSize = maxFileSize
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rfc4180 = rfc4180
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
            self.useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestamp
        }
    }

}

extension SNSInvalidTopicFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SNSInvalidTopicFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SNS topic is invalid.
public struct SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SNSNoAuthorizationFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized for the SNS subscription.
public struct SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum SafeguardPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclusiveAutomaticTruncation
        case relyOnSqlServerReplicationAgent
        case sharedAutomaticTruncation
        case sdkUnknown(Swift.String)

        public static var allCases: [SafeguardPolicy] {
            return [
                .exclusiveAutomaticTruncation,
                .relyOnSqlServerReplicationAgent,
                .sharedAutomaticTruncation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclusiveAutomaticTruncation: return "exclusive-automatic-truncation"
            case .relyOnSqlServerReplicationAgent: return "rely-on-sql-server-replication-agent"
            case .sharedAutomaticTruncation: return "shared-automatic-truncation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SafeguardPolicy(rawValue: rawValue) ?? SafeguardPolicy.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.SchemaResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeLineCount = "CodeLineCount"
        case codeSize = "CodeSize"
        case complexity = "Complexity"
        case databaseInstance = "DatabaseInstance"
        case originalSchema = "OriginalSchema"
        case schemaId = "SchemaId"
        case schemaName = "SchemaName"
        case server = "Server"
        case similarity = "Similarity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeLineCount = self.codeLineCount {
            try encodeContainer.encode(codeLineCount, forKey: .codeLineCount)
        }
        if let codeSize = self.codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let complexity = self.complexity {
            try encodeContainer.encode(complexity, forKey: .complexity)
        }
        if let databaseInstance = self.databaseInstance {
            try encodeContainer.encode(databaseInstance, forKey: .databaseInstance)
        }
        if let originalSchema = self.originalSchema {
            try encodeContainer.encode(originalSchema, forKey: .originalSchema)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let similarity = self.similarity {
            try encodeContainer.encode(similarity, forKey: .similarity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeLineCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeLineCount)
        codeLineCount = codeLineCountDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let complexityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complexity)
        complexity = complexityDecoded
        let serverDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ServerShortInfoResponse.self, forKey: .server)
        server = serverDecoded
        let databaseInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatabaseShortInfoResponse.self, forKey: .databaseInstance)
        databaseInstance = databaseInstanceDecoded
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let originalSchemaDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SchemaShortInfoResponse.self, forKey: .originalSchema)
        originalSchema = originalSchemaDecoded
        let similarityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .similarity)
        similarity = similarityDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaResponse: Swift.Equatable {
        /// The number of lines of code in a schema in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The complexity level of the code in a schema in a Fleet Advisor collector inventory.
        public var complexity: Swift.String?
        /// The database for a schema in a Fleet Advisor collector inventory.
        public var databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse?
        /// Describes a schema in a Fleet Advisor collector inventory.
        public var originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?
        /// The database server for a schema in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The similarity value for a schema in a Fleet Advisor collector inventory. A higher similarity value indicates that a schema is likely to be a duplicate.
        public var similarity: Swift.Double?

        public init (
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            complexity: Swift.String? = nil,
            databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse? = nil,
            originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            similarity: Swift.Double? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.complexity = complexity
            self.databaseInstance = databaseInstance
            self.originalSchema = originalSchema
            self.schemaId = schemaId
            self.schemaName = schemaName
            self.server = server
            self.similarity = similarity
        }
    }

}

extension DatabaseMigrationClientTypes.SchemaShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case databaseIpAddress = "DatabaseIpAddress"
        case databaseName = "DatabaseName"
        case schemaId = "SchemaId"
        case schemaName = "SchemaName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseIpAddress = self.databaseIpAddress {
            try encodeContainer.encode(databaseIpAddress, forKey: .databaseIpAddress)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseIpAddress)
        databaseIpAddress = databaseIpAddressDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaShortInfoResponse: Swift.Equatable {
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?

        public init (
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
            self.schemaId = schemaId
            self.schemaName = schemaName
        }
    }

}

extension DatabaseMigrationClientTypes.ServerShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case serverId = "ServerId"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a server in a Fleet Advisor collector inventory.
    public struct ServerShortInfoResponse: Swift.Equatable {
        /// The IP address of a server in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The ID of a server in a Fleet Advisor collector inventory.
        public var serverId: Swift.String?
        /// The name address of a server in a Fleet Advisor collector inventory.
        public var serverName: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            serverId: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.serverId = serverId
            self.serverName = serverName
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replicationInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .replicationInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replicationInstance: return "replication-instance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum SslSecurityProtocolValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [SslSecurityProtocolValue] {
            return [
                .plaintext,
                .sslEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslSecurityProtocolValue(rawValue: rawValue) ?? SslSecurityProtocolValue.sdkUnknown(rawValue)
        }
    }
}

extension StartReplicationTaskAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension StartReplicationTaskAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StartReplicationTaskAssessmentInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension StartReplicationTaskAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StartReplicationTaskAssessmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReplicationTaskAssessmentOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReplicationTaskAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StartReplicationTaskAssessmentOutputResponse: Swift.Equatable {
    /// The assessed replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskAssessmentOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskAssessmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension StartReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = self.assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclude)
            for string0 in exclude {
                try excludeContainer.encode(string0)
            }
        }
        if let includeOnly = includeOnly {
            var includeOnlyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeOnly)
            for string0 in includeOnly {
                try includeOnlyContainer.encode(string0)
            }
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let resultEncryptionMode = self.resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = self.resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = self.resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = self.resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

extension StartReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Unique name to identify the assessment run.
    /// This member is required.
    public var assessmentRunName: Swift.String?
    /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var exclude: [Swift.String]?
    /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var includeOnly: [Swift.String]?
    /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, DMS stores the assessment run results without encryption. You can specify one of the options following:
    ///
    /// * "SSE_S3" – The server-side encryption provided as a default by Amazon S3.
    ///
    /// * "SSE_KMS" – Key Management Service (KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.
    public var resultEncryptionMode: Swift.String?
    /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
    public var resultKmsKeyArn: Swift.String?
    /// Amazon S3 bucket where you want DMS to store the results of this assessment run.
    /// This member is required.
    public var resultLocationBucket: Swift.String?
    /// Folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.
    public var resultLocationFolder: Swift.String?
    /// ARN of the service role needed to start the assessment run. The role must allow the iam:PassRole action.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init (
        assessmentRunName: Swift.String? = nil,
        exclude: [Swift.String]? = nil,
        includeOnly: [Swift.String]? = nil,
        replicationTaskArn: Swift.String? = nil,
        resultEncryptionMode: Swift.String? = nil,
        resultKmsKeyArn: Swift.String? = nil,
        resultLocationBucket: Swift.String? = nil,
        resultLocationFolder: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.exclude = exclude
        self.includeOnly = includeOnly
        self.replicationTaskArn = replicationTaskArn
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct StartReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let resultLocationBucket: Swift.String?
    let resultLocationFolder: Swift.String?
    let resultEncryptionMode: Swift.String?
    let resultKmsKeyArn: Swift.String?
    let assessmentRunName: Swift.String?
    let includeOnly: [Swift.String]?
    let exclude: [Swift.String]?
}

extension StartReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
        let includeOnlyContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeOnly)
        var includeOnlyDecoded0:[Swift.String]? = nil
        if let includeOnlyContainer = includeOnlyContainer {
            includeOnlyDecoded0 = [Swift.String]()
            for string0 in includeOnlyContainer {
                if let string0 = string0 {
                    includeOnlyDecoded0?.append(string0)
                }
            }
        }
        includeOnly = includeOnlyDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclude)
        var excludeDecoded0:[Swift.String]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [Swift.String]()
            for string0 in excludeContainer {
                if let string0 = string0 {
                    excludeDecoded0?.append(string0)
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension StartReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskAssessmentRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedFault" : self = .kMSAccessDeniedFault(try KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledFault" : self = .kMSDisabledFault(try KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSFault" : self = .kMSFault(try KMSFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateFault" : self = .kMSInvalidStateFault(try KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundFault" : self = .kMSNotFoundFault(try KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsFault" : self = .resourceAlreadyExistsFault(try ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3AccessDeniedFault" : self = .s3AccessDeniedFault(try S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3ResourceNotFoundFault" : self = .s3ResourceNotFoundFault(try S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReplicationTaskAssessmentRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSAccessDeniedFault(KMSAccessDeniedFault)
    case kMSDisabledFault(KMSDisabledFault)
    case kMSFault(KMSFault)
    case kMSInvalidStateFault(KMSInvalidStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case kMSNotFoundFault(KMSNotFoundFault)
    case resourceAlreadyExistsFault(ResourceAlreadyExistsFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case s3AccessDeniedFault(S3AccessDeniedFault)
    case s3ResourceNotFoundFault(S3ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskAssessmentRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReplicationTaskAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct StartReplicationTaskAssessmentRunOutputResponse: Swift.Equatable {
    /// The premigration assessment run that was started.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init (
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct StartReplicationTaskAssessmentRunOutputResponseBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension StartReplicationTaskAssessmentRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

extension StartReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let startReplicationTaskType = self.startReplicationTaskType {
            try encodeContainer.encode(startReplicationTaskType.rawValue, forKey: .startReplicationTaskType)
        }
    }
}

extension StartReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373” When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
    public var cdcStopPosition: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task to be started.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The type of replication task to start. When the migration type is full-load or full-load-and-cdc, the only valid value for the first run of the task is start-replication. You use reload-target to restart the task and resume-processing to resume the task. When the migration type is cdc, you use start-replication to start or restart the task, and resume-processing to resume the task. reload-target is not a valid value for a task with migration type of cdc.
    /// This member is required.
    public var startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?

    public init (
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationTaskArn = replicationTaskArn
        self.startReplicationTaskType = startReplicationTaskType
    }
}

struct StartReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
}

extension StartReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let startReplicationTaskTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.StartReplicationTaskTypeValue.self, forKey: .startReplicationTaskType)
        startReplicationTaskType = startReplicationTaskTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
    }
}

extension StartReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StartReplicationTaskOutputResponse: Swift.Equatable {
    /// The replication task started.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum StartReplicationTaskTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reloadTarget
        case resumeProcessing
        case startReplication
        case sdkUnknown(Swift.String)

        public static var allCases: [StartReplicationTaskTypeValue] {
            return [
                .reloadTarget,
                .resumeProcessing,
                .startReplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reloadTarget: return "reload-target"
            case .resumeProcessing: return "resume-processing"
            case .startReplication: return "start-replication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StartReplicationTaskTypeValue(rawValue: rawValue) ?? StartReplicationTaskTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension StopReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension StopReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StopReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN) of the replication task to be stopped.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init (
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StopReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension StopReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StopReplicationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopReplicationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopReplicationTaskOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceStateFault(InvalidResourceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopReplicationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopReplicationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StopReplicationTaskOutputResponse: Swift.Equatable {
    /// The replication task stopped.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init (
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StopReplicationTaskOutputResponseBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StopReplicationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

extension StorageQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StorageQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The storage quota has been exceeded.
public struct StorageQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = self.subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = self.subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationSubnetGroups operation, this object identifies a subnet by its given Availability Zone, subnet identifier, and status.
    public struct Subnet: Swift.Equatable {
        /// The Availability Zone of the subnet.
        public var subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone?
        /// The subnet identifier.
        public var subnetIdentifier: Swift.String?
        /// The status of the subnet.
        public var subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SubnetAlreadyInUseBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified subnet is already in use.
public struct SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.SupportedEndpointType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
        case supportsCDC = "SupportsCDC"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = self.engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let replicationInstanceEngineMinimumVersion = self.replicationInstanceEngineMinimumVersion {
            try encodeContainer.encode(replicationInstanceEngineMinimumVersion, forKey: .replicationInstanceEngineMinimumVersion)
        }
        if supportsCDC != false {
            try encodeContainer.encode(supportsCDC, forKey: .supportsCDC)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let supportsCDCDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsCDC) ?? false
        supportsCDC = supportsCDCDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let replicationInstanceEngineMinimumVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceEngineMinimumVersion)
        replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersionDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about types of supported endpoints in response to a request by the DescribeEndpointTypes operation. This information includes the type of endpoint, the database engine name, and whether change data capture (CDC) is supported.
    public struct SupportedEndpointType: Swift.Equatable {
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// The earliest DMS engine version that supports this endpoint engine. Note that endpoint engines released with DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public var replicationInstanceEngineMinimumVersion: Swift.String?
        /// Indicates if change data capture (CDC) is supported.
        public var supportsCDC: Swift.Bool

        public init (
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            replicationInstanceEngineMinimumVersion: Swift.String? = nil,
            supportsCDC: Swift.Bool = false
        )
        {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }
    }

}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SybaseSettings(databaseName: \(Swift.String(describing: databaseName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a SAP ASE endpoint.
    public struct SybaseSettings: Swift.Equatable {
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default is 5000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SAP ASE endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SAP SAE endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init (
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.TableStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedDdls = "AppliedDdls"
        case appliedDeletes = "AppliedDeletes"
        case appliedInserts = "AppliedInserts"
        case appliedUpdates = "AppliedUpdates"
        case ddls = "Ddls"
        case deletes = "Deletes"
        case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
        case fullLoadEndTime = "FullLoadEndTime"
        case fullLoadErrorRows = "FullLoadErrorRows"
        case fullLoadReloaded = "FullLoadReloaded"
        case fullLoadRows = "FullLoadRows"
        case fullLoadStartTime = "FullLoadStartTime"
        case inserts = "Inserts"
        case lastUpdateTime = "LastUpdateTime"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case tableState = "TableState"
        case updates = "Updates"
        case validationFailedRecords = "ValidationFailedRecords"
        case validationPendingRecords = "ValidationPendingRecords"
        case validationState = "ValidationState"
        case validationStateDetails = "ValidationStateDetails"
        case validationSuspendedRecords = "ValidationSuspendedRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedDdls = self.appliedDdls {
            try encodeContainer.encode(appliedDdls, forKey: .appliedDdls)
        }
        if let appliedDeletes = self.appliedDeletes {
            try encodeContainer.encode(appliedDeletes, forKey: .appliedDeletes)
        }
        if let appliedInserts = self.appliedInserts {
            try encodeContainer.encode(appliedInserts, forKey: .appliedInserts)
        }
        if let appliedUpdates = self.appliedUpdates {
            try encodeContainer.encode(appliedUpdates, forKey: .appliedUpdates)
        }
        if ddls != 0 {
            try encodeContainer.encode(ddls, forKey: .ddls)
        }
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if fullLoadCondtnlChkFailedRows != 0 {
            try encodeContainer.encode(fullLoadCondtnlChkFailedRows, forKey: .fullLoadCondtnlChkFailedRows)
        }
        if let fullLoadEndTime = self.fullLoadEndTime {
            try encodeContainer.encodeTimestamp(fullLoadEndTime, format: .epochSeconds, forKey: .fullLoadEndTime)
        }
        if fullLoadErrorRows != 0 {
            try encodeContainer.encode(fullLoadErrorRows, forKey: .fullLoadErrorRows)
        }
        if let fullLoadReloaded = self.fullLoadReloaded {
            try encodeContainer.encode(fullLoadReloaded, forKey: .fullLoadReloaded)
        }
        if fullLoadRows != 0 {
            try encodeContainer.encode(fullLoadRows, forKey: .fullLoadRows)
        }
        if let fullLoadStartTime = self.fullLoadStartTime {
            try encodeContainer.encodeTimestamp(fullLoadStartTime, format: .epochSeconds, forKey: .fullLoadStartTime)
        }
        if inserts != 0 {
            try encodeContainer.encode(inserts, forKey: .inserts)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableState = self.tableState {
            try encodeContainer.encode(tableState, forKey: .tableState)
        }
        if updates != 0 {
            try encodeContainer.encode(updates, forKey: .updates)
        }
        if validationFailedRecords != 0 {
            try encodeContainer.encode(validationFailedRecords, forKey: .validationFailedRecords)
        }
        if validationPendingRecords != 0 {
            try encodeContainer.encode(validationPendingRecords, forKey: .validationPendingRecords)
        }
        if let validationState = self.validationState {
            try encodeContainer.encode(validationState, forKey: .validationState)
        }
        if let validationStateDetails = self.validationStateDetails {
            try encodeContainer.encode(validationStateDetails, forKey: .validationStateDetails)
        }
        if validationSuspendedRecords != 0 {
            try encodeContainer.encode(validationSuspendedRecords, forKey: .validationSuspendedRecords)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let insertsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inserts) ?? 0
        inserts = insertsDecoded
        let deletesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deletes) ?? 0
        deletes = deletesDecoded
        let updatesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updates) ?? 0
        updates = updatesDecoded
        let ddlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ddls) ?? 0
        ddls = ddlsDecoded
        let appliedInsertsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedInserts)
        appliedInserts = appliedInsertsDecoded
        let appliedDeletesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedDeletes)
        appliedDeletes = appliedDeletesDecoded
        let appliedUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedUpdates)
        appliedUpdates = appliedUpdatesDecoded
        let appliedDdlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedDdls)
        appliedDdls = appliedDdlsDecoded
        let fullLoadRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadRows) ?? 0
        fullLoadRows = fullLoadRowsDecoded
        let fullLoadCondtnlChkFailedRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadCondtnlChkFailedRows) ?? 0
        fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRowsDecoded
        let fullLoadErrorRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadErrorRows) ?? 0
        fullLoadErrorRows = fullLoadErrorRowsDecoded
        let fullLoadStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadStartTime)
        fullLoadStartTime = fullLoadStartTimeDecoded
        let fullLoadEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadEndTime)
        fullLoadEndTime = fullLoadEndTimeDecoded
        let fullLoadReloadedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fullLoadReloaded)
        fullLoadReloaded = fullLoadReloadedDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tableStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableState)
        tableState = tableStateDecoded
        let validationPendingRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationPendingRecords) ?? 0
        validationPendingRecords = validationPendingRecordsDecoded
        let validationFailedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationFailedRecords) ?? 0
        validationFailedRecords = validationFailedRecordsDecoded
        let validationSuspendedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationSuspendedRecords) ?? 0
        validationSuspendedRecords = validationSuspendedRecordsDecoded
        let validationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationState)
        validationState = validationStateDecoded
        let validationStateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationStateDetails)
        validationStateDetails = validationStateDetailsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides a collection of table statistics in response to a request by the DescribeTableStatistics operation.
    public struct TableStatistics: Swift.Equatable {
        /// The number of data definition language (DDL) statements used to build and modify the structure of your tables applied on the target.
        public var appliedDdls: Swift.Int?
        /// The number of delete actions applied on a target table.
        public var appliedDeletes: Swift.Int?
        /// The number of insert actions applied on a target table.
        public var appliedInserts: Swift.Int?
        /// The number of update actions applied on a target table.
        public var appliedUpdates: Swift.Int?
        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public var ddls: Swift.Int
        /// The number of delete actions performed on a table.
        public var deletes: Swift.Int
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadCondtnlChkFailedRows: Swift.Int
        /// The time when the full load operation completed.
        public var fullLoadEndTime: ClientRuntime.Date?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadErrorRows: Swift.Int
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public var fullLoadReloaded: Swift.Bool?
        /// The number of rows added during the full load operation.
        public var fullLoadRows: Swift.Int
        /// The time when the full load operation started.
        public var fullLoadStartTime: ClientRuntime.Date?
        /// The number of insert actions performed on a table.
        public var inserts: Swift.Int
        /// The last time a table was updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The schema name.
        public var schemaName: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table is being reloaded
        public var tableState: Swift.String?
        /// The number of update actions performed on a table.
        public var updates: Swift.Int
        /// The number of records that failed validation.
        public var validationFailedRecords: Swift.Int
        /// The number of records that have yet to be validated.
        public var validationPendingRecords: Swift.Int
        /// The validation state of the table. This parameter can have the following values:
        ///
        /// * Not enabled – Validation isn't enabled for the table in the migration task.
        ///
        /// * Pending records – Some records in the table are waiting for validation.
        ///
        /// * Mismatched records – Some records in the table don't match between the source and target.
        ///
        /// * Suspended records – Some records in the table couldn't be validated.
        ///
        /// * No primary key –The table couldn't be validated because it has no primary key.
        ///
        /// * Table error – The table wasn't validated because it's in an error state and some data wasn't migrated.
        ///
        /// * Validated – All rows in the table are validated. If the table is updated, the status can change from Validated.
        ///
        /// * Error – The table couldn't be validated because of an unexpected error.
        ///
        /// * Pending validation – The table is waiting validation.
        ///
        /// * Preparing table – Preparing the table enabled in the migration task for validation.
        ///
        /// * Pending revalidation – All rows in the table are pending validation after the table was updated.
        public var validationState: Swift.String?
        /// Additional details about the state of validation.
        public var validationStateDetails: Swift.String?
        /// The number of records that couldn't be validated.
        public var validationSuspendedRecords: Swift.Int

        public init (
            appliedDdls: Swift.Int? = nil,
            appliedDeletes: Swift.Int? = nil,
            appliedInserts: Swift.Int? = nil,
            appliedUpdates: Swift.Int? = nil,
            ddls: Swift.Int = 0,
            deletes: Swift.Int = 0,
            fullLoadCondtnlChkFailedRows: Swift.Int = 0,
            fullLoadEndTime: ClientRuntime.Date? = nil,
            fullLoadErrorRows: Swift.Int = 0,
            fullLoadReloaded: Swift.Bool? = nil,
            fullLoadRows: Swift.Int = 0,
            fullLoadStartTime: ClientRuntime.Date? = nil,
            inserts: Swift.Int = 0,
            lastUpdateTime: ClientRuntime.Date? = nil,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableState: Swift.String? = nil,
            updates: Swift.Int = 0,
            validationFailedRecords: Swift.Int = 0,
            validationPendingRecords: Swift.Int = 0,
            validationState: Swift.String? = nil,
            validationStateDetails: Swift.String? = nil,
            validationSuspendedRecords: Swift.Int = 0
        )
        {
            self.appliedDdls = appliedDdls
            self.appliedDeletes = appliedDeletes
            self.appliedInserts = appliedInserts
            self.appliedUpdates = appliedUpdates
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }
    }

}

extension DatabaseMigrationClientTypes.TableToReload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaName = "SchemaName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides the name of the schema and table to be reloaded.
    public struct TableToReload: Swift.Equatable {
        /// The schema name of the table to be reloaded.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The table name of the table to be reloaded.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.schemaName = schemaName
            self.tableName = tableName
        }
    }

}

extension DatabaseMigrationClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case resourceArn = "ResourceArn"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// A user-defined key-value pair that describes metadata added to an DMS resource and that is used by operations such as the following:
    ///
    /// * AddTagsToResource
    ///
    /// * ListTagsForResource
    ///
    /// * RemoveTagsFromResource
    public struct Tag: Swift.Equatable {
        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var key: Swift.String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the resource for which the tag is created.
        public var resourceArn: Swift.String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.resourceArn = resourceArn
            self.value = value
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum TargetDbType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multipleDatabases
        case specificDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDbType] {
            return [
                .multipleDatabases,
                .specificDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multipleDatabases: return "multiple-databases"
            case .specificDatabase: return "specific-database"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDbType(rawValue: rawValue) ?? TargetDbType.sdkUnknown(rawValue)
        }
    }
}

extension TestConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension TestConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct TestConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init (
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct TestConnectionInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let endpointArn: Swift.String?
}

extension TestConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension TestConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceQuotaExceededFault" : self = .resourceQuotaExceededFault(try ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TestConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case resourceQuotaExceededFault(ResourceQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TestConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

///
public struct TestConnectionOutputResponse: Swift.Equatable {
    /// The connection tested.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init (
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct TestConnectionOutputResponseBody: Swift.Equatable {
    let connection: DatabaseMigrationClientTypes.Connection?
}

extension TestConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension UpdateSubscriptionsToEventBridgeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceMove = "ForceMove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceMove = self.forceMove {
            try encodeContainer.encode(forceMove, forKey: .forceMove)
        }
    }
}

extension UpdateSubscriptionsToEventBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct UpdateSubscriptionsToEventBridgeInput: Swift.Equatable {
    /// When set to true, this operation migrates DMS subscriptions for Amazon SNS notifications no matter what your replication instance version is. If not set or set to false, this operation runs only when all your replication instances are from DMS version 3.4.6 or higher.
    public var forceMove: Swift.Bool?

    public init (
        forceMove: Swift.Bool? = nil
    )
    {
        self.forceMove = forceMove
    }
}

struct UpdateSubscriptionsToEventBridgeInputBody: Swift.Equatable {
    let forceMove: Swift.Bool?
}

extension UpdateSubscriptionsToEventBridgeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceMove = "ForceMove"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceMoveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceMove)
        forceMove = forceMoveDecoded
    }
}

extension UpdateSubscriptionsToEventBridgeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionsToEventBridgeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedFault" : self = .accessDeniedFault(try AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateFault" : self = .invalidResourceStateFault(try InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubscriptionsToEventBridgeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedFault(AccessDeniedFault)
    case invalidResourceStateFault(InvalidResourceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionsToEventBridgeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSubscriptionsToEventBridgeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

///
public struct UpdateSubscriptionsToEventBridgeOutputResponse: Swift.Equatable {
    /// A string that indicates how many event subscriptions were migrated and how many remain to be migrated.
    public var result: Swift.String?

    public init (
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct UpdateSubscriptionsToEventBridgeOutputResponseBody: Swift.Equatable {
    let result: Swift.String?
}

extension UpdateSubscriptionsToEventBridgeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension UpgradeDependencyFailureFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpgradeDependencyFailureFaultBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An upgrade dependency is preventing the database migration.
public struct UpgradeDependencyFailureFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UpgradeDependencyFailureFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum VersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case outdated
        case unsupported
        case upToDate
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionStatus] {
            return [
                .outdated,
                .unsupported,
                .upToDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .outdated: return "OUTDATED"
            case .unsupported: return "UNSUPPORTED"
            case .upToDate: return "UP_TO_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionStatus(rawValue: rawValue) ?? VersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.VpcSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes the status of a security group associated with the virtual private cloud (VPC) hosting your replication and DB instances.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The VPC security group ID.
        public var vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}
