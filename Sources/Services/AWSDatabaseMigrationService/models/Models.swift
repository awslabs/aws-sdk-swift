// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// DMS was denied access to the endpoint. Check that the role is correctly configured.
public struct AccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.AccountQuota: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountQuotaName = self.accountQuotaName {
            try encodeContainer.encode(accountQuotaName, forKey: .accountQuotaName)
        }
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if used != 0 {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used) ?? 0
        used = usedDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a quota for an Amazon Web Services account, for example the number of replication instances allowed.
    public struct AccountQuota: Swift.Equatable {
        /// The name of the DMS quota for this Amazon Web Services account.
        public var accountQuotaName: Swift.String?
        /// The maximum allowed value for the quota.
        public var max: Swift.Int
        /// The amount currently used toward the quota maximum.
        public var used: Swift.Int

        public init(
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

extension AddTagsToResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsToResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Associates a set of tags with an DMS resource.
public struct AddTagsToResourceInput: Swift.Equatable {
    /// Identifies the DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DMS, you can tag a replication instance, an endpoint, or a replication task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

///
public struct AddTagsToResourceOutput: Swift.Equatable {

    public init() { }
}

enum AddTagsToResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyAction = self.applyAction {
            try encodeContainer.encode(applyAction, forKey: .applyAction)
        }
        if let optInType = self.optInType {
            try encodeContainer.encode(optInType, forKey: .optInType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension ApplyPendingMaintenanceActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// The pending maintenance action to apply to this resource. Valid values: os-upgrade, system-update, db-upgrade
    /// This member is required.
    public var applyAction: Swift.String?
    /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:
    ///
    /// * immediate - Apply the maintenance action immediately.
    ///
    /// * next-maintenance - Apply the maintenance action during the next maintenance window for the resource.
    ///
    /// * undo-opt-in - Cancel any existing next-maintenance opt-in requests.
    /// This member is required.
    public var optInType: Swift.String?
    /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct ApplyPendingMaintenanceActionInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let applyAction: Swift.String?
    let optInType: Swift.String?
}

extension ApplyPendingMaintenanceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyAction = "ApplyAction"
        case optInType = "OptInType"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let applyActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyAction)
        applyAction = applyActionDecoded
        let optInTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInType)
        optInType = optInTypeDecoded
    }
}

extension ApplyPendingMaintenanceActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApplyPendingMaintenanceActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

///
public struct ApplyPendingMaintenanceActionOutput: Swift.Equatable {
    /// The DMS resource that the pending maintenance action will be applied to.
    public var resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?

    public init(
        resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputBody: Swift.Equatable {
    let resourcePendingMaintenanceActions: DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

enum ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum AssessmentReportType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentReportType] {
            return [
                .csv,
                .pdf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .pdf: return "pdf"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentReportType(rawValue: rawValue) ?? AssessmentReportType.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthMechanismValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case mongodbCr
        case scramSha1
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMechanismValue] {
            return [
                .default,
                .mongodbCr,
                .scramSha1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .mongodbCr: return "mongodb_cr"
            case .scramSha1: return "scram_sha_1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMechanismValue(rawValue: rawValue) ?? AuthMechanismValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum AuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case password
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthTypeValue] {
            return [
                .no,
                .password,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .password: return "password"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthTypeValue(rawValue: rawValue) ?? AuthTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The name of an Availability Zone for use during database migration. AvailabilityZone is an optional parameter to the [CreateReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationInstance.html) operation, and itâ€™s value relates to the Amazon Web Services Region of an endpoint. For example, the availability zone of an endpoint in the us-east-1 region might be us-east-1a, us-east-1b, us-east-1c, or us-east-1d.
    public struct AvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case databaseId = "DatabaseId"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the errors that occurred during the analysis of the source database.
    public struct BatchStartRecommendationsErrorEntry: Swift.Equatable {
        /// The code of an error that occurred during the analysis of the source database.
        public var code: Swift.String?
        /// The identifier of the source database.
        public var databaseId: Swift.String?
        /// The information about the error.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.databaseId = databaseId
            self.message = message
        }
    }

}

extension BatchStartRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for startrecommendationsrequestentry0 in data {
                try dataContainer.encode(startrecommendationsrequestentry0)
            }
        }
    }
}

extension BatchStartRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchStartRecommendationsInput: Swift.Equatable {
    /// Provides information about source databases to analyze. After this analysis, Fleet Advisor recommends target engines for each source database.
    public var data: [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]?

    public init(
        data: [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]? = nil
    )
    {
        self.data = data
    }
}

struct BatchStartRecommendationsInputBody: Swift.Equatable {
    let data: [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]?
}

extension BatchStartRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.StartRecommendationsRequestEntry?].self, forKey: .data)
        var dataDecoded0:[DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [DatabaseMigrationClientTypes.StartRecommendationsRequestEntry]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension BatchStartRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchStartRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchStartRecommendationsOutput: Swift.Equatable {
    /// A list with error details about the analysis of each source database.
    public var errorEntries: [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]?

    public init(
        errorEntries: [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchStartRecommendationsOutputBody: Swift.Equatable {
    let errorEntries: [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]?
}

extension BatchStartRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries = "ErrorEntries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [DatabaseMigrationClientTypes.BatchStartRecommendationsErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchStartRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

extension CancelReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CancelReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init(
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct CancelReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskAssessmentRunArn: Swift.String?
}

extension CancelReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension CancelReplicationTaskAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelReplicationTaskAssessmentRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct CancelReplicationTaskAssessmentRunOutput: Swift.Equatable {
    /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct CancelReplicationTaskAssessmentRunOutputBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension CancelReplicationTaskAssessmentRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

enum CancelReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum CannedAclForObjectsValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticatedRead
        case awsExecRead
        case bucketOwnerFullControl
        case bucketOwnerRead
        case `none`
        case `private`
        case publicRead
        case publicReadWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [CannedAclForObjectsValue] {
            return [
                .authenticatedRead,
                .awsExecRead,
                .bucketOwnerFullControl,
                .bucketOwnerRead,
                .none,
                .private,
                .publicRead,
                .publicReadWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticatedRead: return "authenticated-read"
            case .awsExecRead: return "aws-exec-read"
            case .bucketOwnerFullControl: return "bucket-owner-full-control"
            case .bucketOwnerRead: return "bucket-owner-read"
            case .none: return "none"
            case .private: return "private"
            case .publicRead: return "public-read"
            case .publicReadWrite: return "public-read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CannedAclForObjectsValue(rawValue: rawValue) ?? CannedAclForObjectsValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateCreationDate = "CertificateCreationDate"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateOwner = "CertificateOwner"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case keyLength = "KeyLength"
        case signingAlgorithm = "SigningAlgorithm"
        case validFromDate = "ValidFromDate"
        case validToDate = "ValidToDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateCreationDate = self.certificateCreationDate {
            try encodeContainer.encodeTimestamp(certificateCreationDate, format: .epochSeconds, forKey: .certificateCreationDate)
        }
        if let certificateIdentifier = self.certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificateOwner = self.certificateOwner {
            try encodeContainer.encode(certificateOwner, forKey: .certificateOwner)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = self.certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let keyLength = self.keyLength {
            try encodeContainer.encode(keyLength, forKey: .keyLength)
        }
        if let signingAlgorithm = self.signingAlgorithm {
            try encodeContainer.encode(signingAlgorithm, forKey: .signingAlgorithm)
        }
        if let validFromDate = self.validFromDate {
            try encodeContainer.encodeTimestamp(validFromDate, format: .epochSeconds, forKey: .validFromDate)
        }
        if let validToDate = self.validToDate {
            try encodeContainer.encodeTimestamp(validToDate, format: .epochSeconds, forKey: .validToDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .certificateCreationDate)
        certificateCreationDate = certificateCreationDateDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateOwner)
        certificateOwner = certificateOwnerDecoded
        let validFromDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validFromDate)
        validFromDate = validFromDateDecoded
        let validToDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validToDate)
        validToDate = validToDateDecoded
        let signingAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signingAlgorithm)
        signingAlgorithm = signingAlgorithmDecoded
        let keyLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .keyLength)
        keyLength = keyLengthDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The SSL certificate that can be used to encrypt connections between the endpoints and the replication instance.
    public struct Certificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: Swift.String?
        /// The date that the certificate was created.
        public var certificateCreationDate: ClientRuntime.Date?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var certificateIdentifier: Swift.String?
        /// The owner of the certificate.
        public var certificateOwner: Swift.String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public var certificatePem: Swift.String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
        public var certificateWallet: ClientRuntime.Data?
        /// The key length of the cryptographic algorithm being used.
        public var keyLength: Swift.Int?
        /// The signing algorithm for the certificate.
        public var signingAlgorithm: Swift.String?
        /// The beginning date that the certificate is valid.
        public var validFromDate: ClientRuntime.Date?
        /// The final date that the certificate is valid.
        public var validToDate: ClientRuntime.Date?

        public init(
            certificateArn: Swift.String? = nil,
            certificateCreationDate: ClientRuntime.Date? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateOwner: Swift.String? = nil,
            certificatePem: Swift.String? = nil,
            certificateWallet: ClientRuntime.Data? = nil,
            keyLength: Swift.Int? = nil,
            signingAlgorithm: Swift.String? = nil,
            validFromDate: ClientRuntime.Date? = nil,
            validToDate: ClientRuntime.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum CharLengthSemantics: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byte
        case char
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [CharLengthSemantics] {
            return [
                .byte,
                .char,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byte: return "byte"
            case .char: return "char"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CharLengthSemantics(rawValue: rawValue) ?? CharLengthSemantics.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.CollectorHealthCheck: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorStatus = "CollectorStatus"
        case localCollectorS3Access = "LocalCollectorS3Access"
        case webCollectorGrantedRoleBasedAccess = "WebCollectorGrantedRoleBasedAccess"
        case webCollectorS3Access = "WebCollectorS3Access"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorStatus = self.collectorStatus {
            try encodeContainer.encode(collectorStatus.rawValue, forKey: .collectorStatus)
        }
        if let localCollectorS3Access = self.localCollectorS3Access {
            try encodeContainer.encode(localCollectorS3Access, forKey: .localCollectorS3Access)
        }
        if let webCollectorGrantedRoleBasedAccess = self.webCollectorGrantedRoleBasedAccess {
            try encodeContainer.encode(webCollectorGrantedRoleBasedAccess, forKey: .webCollectorGrantedRoleBasedAccess)
        }
        if let webCollectorS3Access = self.webCollectorS3Access {
            try encodeContainer.encode(webCollectorS3Access, forKey: .webCollectorS3Access)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CollectorStatus.self, forKey: .collectorStatus)
        collectorStatus = collectorStatusDecoded
        let localCollectorS3AccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .localCollectorS3Access)
        localCollectorS3Access = localCollectorS3AccessDecoded
        let webCollectorS3AccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .webCollectorS3Access)
        webCollectorS3Access = webCollectorS3AccessDecoded
        let webCollectorGrantedRoleBasedAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .webCollectorGrantedRoleBasedAccess)
        webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccessDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes the last Fleet Advisor collector health check.
    public struct CollectorHealthCheck: Swift.Equatable {
        /// The status of the Fleet Advisor collector.
        public var collectorStatus: DatabaseMigrationClientTypes.CollectorStatus?
        /// Whether the local collector can access its Amazon S3 bucket.
        public var localCollectorS3Access: Swift.Bool?
        /// Whether the role that you provided when creating the Fleet Advisor collector has sufficient permissions to access the Fleet Advisor web collector.
        public var webCollectorGrantedRoleBasedAccess: Swift.Bool?
        /// Whether the web collector can access its Amazon S3 bucket.
        public var webCollectorS3Access: Swift.Bool?

        public init(
            collectorStatus: DatabaseMigrationClientTypes.CollectorStatus? = nil,
            localCollectorS3Access: Swift.Bool? = nil,
            webCollectorGrantedRoleBasedAccess: Swift.Bool? = nil,
            webCollectorS3Access: Swift.Bool? = nil
        )
        {
            self.collectorStatus = collectorStatus
            self.localCollectorS3Access = localCollectorS3Access
            self.webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccess
            self.webCollectorS3Access = webCollectorS3Access
        }
    }

}

extension CollectorNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CollectorNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified collector doesn't exist.
public struct CollectorNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CollectorNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CollectorNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension CollectorNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.CollectorResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorHealthCheck = "CollectorHealthCheck"
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
        case collectorVersion = "CollectorVersion"
        case createdDate = "CreatedDate"
        case description = "Description"
        case inventoryData = "InventoryData"
        case lastDataReceived = "LastDataReceived"
        case modifiedDate = "ModifiedDate"
        case registeredDate = "RegisteredDate"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case versionStatus = "VersionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorHealthCheck = self.collectorHealthCheck {
            try encodeContainer.encode(collectorHealthCheck, forKey: .collectorHealthCheck)
        }
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
        if let collectorVersion = self.collectorVersion {
            try encodeContainer.encode(collectorVersion, forKey: .collectorVersion)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let inventoryData = self.inventoryData {
            try encodeContainer.encode(inventoryData, forKey: .inventoryData)
        }
        if let lastDataReceived = self.lastDataReceived {
            try encodeContainer.encode(lastDataReceived, forKey: .lastDataReceived)
        }
        if let modifiedDate = self.modifiedDate {
            try encodeContainer.encode(modifiedDate, forKey: .modifiedDate)
        }
        if let registeredDate = self.registeredDate {
            try encodeContainer.encode(registeredDate, forKey: .registeredDate)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let versionStatus = self.versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let collectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorVersion)
        collectorVersion = collectorVersionDecoded
        let versionStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.VersionStatus.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let collectorHealthCheckDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CollectorHealthCheck.self, forKey: .collectorHealthCheck)
        collectorHealthCheck = collectorHealthCheckDecoded
        let lastDataReceivedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDataReceived)
        lastDataReceived = lastDataReceivedDecoded
        let registeredDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredDate)
        registeredDate = registeredDateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let modifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifiedDate)
        modifiedDate = modifiedDateDecoded
        let inventoryDataDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.InventoryData.self, forKey: .inventoryData)
        inventoryData = inventoryDataDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector.
    public struct CollectorResponse: Swift.Equatable {
        /// Describes the last Fleet Advisor collector health check.
        public var collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck?
        /// The name of the Fleet Advisor collector .
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?
        /// The version of your Fleet Advisor collector, in semantic versioning format, for example 1.0.2
        public var collectorVersion: Swift.String?
        /// The timestamp when you created the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var createdDate: Swift.String?
        /// A summary description of the Fleet Advisor collector.
        public var description: Swift.String?
        /// Describes a Fleet Advisor collector inventory.
        public var inventoryData: DatabaseMigrationClientTypes.InventoryData?
        /// The timestamp of the last time the collector received data, in the following format: 2022-01-24T19:04:02.596113Z
        public var lastDataReceived: Swift.String?
        /// The timestamp when DMS last modified the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var modifiedDate: Swift.String?
        /// The timestamp when DMS registered the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public var registeredDate: Swift.String?
        /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
        public var s3BucketName: Swift.String?
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// Whether the collector version is up to date.
        public var versionStatus: DatabaseMigrationClientTypes.VersionStatus?

        public init(
            collectorHealthCheck: DatabaseMigrationClientTypes.CollectorHealthCheck? = nil,
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            inventoryData: DatabaseMigrationClientTypes.InventoryData? = nil,
            lastDataReceived: Swift.String? = nil,
            modifiedDate: Swift.String? = nil,
            registeredDate: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            versionStatus: DatabaseMigrationClientTypes.VersionStatus? = nil
        )
        {
            self.collectorHealthCheck = collectorHealthCheck
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
            self.collectorVersion = collectorVersion
            self.createdDate = createdDate
            self.description = description
            self.inventoryData = inventoryData
            self.lastDataReceived = lastDataReceived
            self.modifiedDate = modifiedDate
            self.registeredDate = registeredDate
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.versionStatus = versionStatus
        }
    }

}

extension DatabaseMigrationClientTypes.CollectorShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Briefly describes a Fleet Advisor collector.
    public struct CollectorShortInfoResponse: Swift.Equatable {
        /// The name of the Fleet Advisor collector.
        public var collectorName: Swift.String?
        /// The reference ID of the Fleet Advisor collector.
        public var collectorReferencedId: Swift.String?

        public init(
            collectorName: Swift.String? = nil,
            collectorReferencedId: Swift.String? = nil
        )
        {
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum CollectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case unregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorStatus] {
            return [
                .active,
                .unregistered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .unregistered: return "UNREGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectorStatus(rawValue: rawValue) ?? CollectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum CompressionTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionTypeValue] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "gzip"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionTypeValue(rawValue: rawValue) ?? CompressionTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.ComputeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case kmsKeyId = "KmsKeyId"
        case maxCapacityUnits = "MaxCapacityUnits"
        case minCapacityUnits = "MinCapacityUnits"
        case multiAZ = "MultiAZ"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationSubnetGroupId = "ReplicationSubnetGroupId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = self.dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let maxCapacityUnits = self.maxCapacityUnits {
            try encodeContainer.encode(maxCapacityUnits, forKey: .maxCapacityUnits)
        }
        if let minCapacityUnits = self.minCapacityUnits {
            try encodeContainer.encode(minCapacityUnits, forKey: .minCapacityUnits)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let replicationSubnetGroupId = self.replicationSubnetGroupId {
            try encodeContainer.encode(replicationSubnetGroupId, forKey: .replicationSubnetGroupId)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let maxCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacityUnits)
        maxCapacityUnits = maxCapacityUnitsDecoded
        let minCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCapacityUnits)
        minCapacityUnits = minCapacityUnitsDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSubnetGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupId)
        replicationSubnetGroupId = replicationSubnetGroupIdDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    public struct ComputeConfig: Swift.Equatable {
        /// The Availability Zone where the DMS Serverless replication using this configuration will run. The default value is a random, system-chosen Availability Zone in the configuration's Amazon Web Services Region, for example, "us-west-2". You can't set this parameter if the MultiAZ parameter is set to true.
        public var availabilityZone: Swift.String?
        /// A list of custom DNS name servers supported for the DMS Serverless replication to access your source or target database. This list overrides the default name servers supported by the DMS Serverless replication. You can specify a comma-separated list of internet addresses for up to four DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
        public var dnsNameServers: Swift.String?
        /// An Key Management Service (KMS) key Amazon Resource Name (ARN) that is used to encrypt the data during DMS Serverless replication. If you don't specify a value for the KmsKeyId parameter, DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies the maximum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the maximum value that you can specify for DMS Serverless is 384. The MaxCapacityUnits parameter is the only DCU parameter you are required to specify.
        public var maxCapacityUnits: Swift.Int?
        /// Specifies the minimum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the minimum DCU value that you can specify for DMS Serverless is 1. You don't have to specify a value for the MinCapacityUnits parameter. If you don't set this value, DMS scans the current activity of available source tables to identify an optimum setting for this parameter. If there is no current source activity or DMS can't otherwise identify a more appropriate value, it sets this parameter to the minimum DCU value allowed, 1.
        public var minCapacityUnits: Swift.Int?
        /// Specifies whether the DMS Serverless replication is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the MultiAZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The weekly time range during which system maintenance can occur for the DMS Serverless replication, in Universal Coordinated Time (UTC). The format is ddd:hh24:mi-ddd:hh24:mi. The default is a 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region. This maintenance occurs on a random day of the week. Valid values for days of the week include Mon, Tue, Wed, Thu, Fri, Sat, and Sun. Constraints include a minimum 30-minute window.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies a subnet group identifier to associate with the DMS Serverless replication.
        public var replicationSubnetGroupId: Swift.String?
        /// Specifies the virtual private cloud (VPC) security group to use with the DMS Serverless replication. The VPC security group must work with the VPC containing the replication.
        public var vpcSecurityGroupIds: [Swift.String]?

        public init(
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            maxCapacityUnits: Swift.Int? = nil,
            minCapacityUnits: Swift.Int? = nil,
            multiAZ: Swift.Bool? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            replicationSubnetGroupId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.kmsKeyId = kmsKeyId
            self.maxCapacityUnits = maxCapacityUnits
            self.minCapacityUnits = minCapacityUnits
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationSubnetGroupId = replicationSubnetGroupId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }
    }

}

extension DatabaseMigrationClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case lastFailureMessage = "LastFailureMessage"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Status of the connection between an endpoint and a replication instance, including Amazon Resource Names (ARNs) and the last error message issued.
    public struct Connection: Swift.Equatable {
        /// The ARN string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The error message when the connection last failed.
        public var lastFailureMessage: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public var replicationInstanceIdentifier: Swift.String?
        /// The connection status. This parameter can return one of the following values:
        ///
        /// * "successful"
        ///
        /// * "testing"
        ///
        /// * "failed"
        ///
        /// * "deleting"
        public var status: Swift.String?

        public init(
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }
    }

}

extension CreateDataProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderName = "DataProviderName"
        case description = "Description"
        case engine = "Engine"
        case settings = "Settings"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderName = self.dataProviderName {
            try encodeContainer.encode(dataProviderName, forKey: .dataProviderName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDataProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDataProviderInput: Swift.Equatable {
    /// A user-friendly name for the data provider.
    public var dataProviderName: Swift.String?
    /// A user-friendly description of the data provider.
    public var description: Swift.String?
    /// The type of database engine for the data provider. Valid values include "aurora", "aurora_postgresql", "mysql", "oracle", "postgres", and "sqlserver". A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
    /// This member is required.
    public var engine: Swift.String?
    /// The settings in JSON format for a data provider.
    /// This member is required.
    public var settings: DatabaseMigrationClientTypes.DataProviderSettings?
    /// One or more tags to be assigned to the data provider.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        dataProviderName: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.dataProviderName = dataProviderName
        self.description = description
        self.engine = engine
        self.settings = settings
        self.tags = tags
    }
}

struct CreateDataProviderInputBody: Swift.Equatable {
    let dataProviderName: Swift.String?
    let description: Swift.String?
    let engine: Swift.String?
    let settings: DatabaseMigrationClientTypes.DataProviderSettings?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateDataProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderName = "DataProviderName"
        case description = "Description"
        case engine = "Engine"
        case settings = "Settings"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderName)
        dataProviderName = dataProviderNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProviderSettings.self, forKey: .settings)
        settings = settingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataProvider = output.dataProvider
        } else {
            self.dataProvider = nil
        }
    }
}

public struct CreateDataProviderOutput: Swift.Equatable {
    /// The data provider that was created.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

struct CreateDataProviderOutputBody: Swift.Equatable {
    let dataProvider: DatabaseMigrationClientTypes.DataProvider?
}

extension CreateDataProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProvider = "DataProvider"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProvider.self, forKey: .dataProvider)
        dataProvider = dataProviderDecoded
    }
}

enum CreateDataProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), tags: \(Swift.String(describing: tags)), timestreamSettings: \(Swift.String(describing: timestreamSettings)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension CreateEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case timestreamSettings = "TimestreamSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timestreamSettings = self.timestreamSettings {
            try encodeContainer.encode(timestreamSettings, forKey: .timestreamSettings)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the certificate.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName. To migrate to a specific database, use this setting and targetDbType.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Possible settings include the following:
    ///
    /// * ServiceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", }
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Provides information that defines a DocumentDB endpoint.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    /// This member is required.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "opensearch", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", "neptune", and "babelfish".
    /// This member is required.
    public var engineName: Swift.String?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see [Working with DMS Endpoints](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Endpoints.html) in the Database Migration Service User Guide.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to log in to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the target Redis endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// One or more tags to be assigned to the endpoint.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Settings in JSON format for the target Amazon Timestream endpoint.
    public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
    /// The user name to be used to log in to the endpoint database.
    public var username: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        kmsKeyId: Swift.String? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        resourceIdentifier: Swift.String? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.kmsKeyId = kmsKeyId
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.resourceIdentifier = resourceIdentifier
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.tags = tags
        self.timestreamSettings = timestreamSettings
        self.username = username
    }
}

struct CreateEndpointInputBody: Swift.Equatable {
    let endpointIdentifier: Swift.String?
    let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    let engineName: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let serverName: Swift.String?
    let port: Swift.Int?
    let databaseName: Swift.String?
    let extraConnectionAttributes: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let certificateArn: Swift.String?
    let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    let serviceAccessRoleArn: Swift.String?
    let externalTableDefinition: Swift.String?
    let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    let ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    let resourceIdentifier: Swift.String?
    let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    let redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    let gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    let timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
}

extension CreateEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case tags = "Tags"
        case timestreamSettings = "TimestreamSettings"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
        let timestreamSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TimestreamSettings.self, forKey: .timestreamSettings)
        timestreamSettings = timestreamSettingsDecoded
    }
}

extension CreateEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct CreateEndpointOutput: Swift.Equatable {
    /// The endpoint that was created.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct CreateEndpointOutputBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension CreateEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum CreateEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIds)
            for string0 in sourceIds {
                try sourceIdsContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateEventSubscriptionInput: Swift.Equatable {
    /// A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. For more information, see [Working with Events and Notifications](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Events.html) in the Database Migration Service User Guide.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    /// This member is required.
    public var snsTopicArn: Swift.String?
    /// A list of identifiers for which DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
    public var sourceIds: [Swift.String]?
    /// The type of DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription. This name must be less than 255 characters.
    /// This member is required.
    public var subscriptionName: Swift.String?
    /// One or more tags to be assigned to the event subscription.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

struct CreateEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let sourceIds: [Swift.String]?
    let enabled: Swift.Bool?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceIds = "SourceIds"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let sourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIds)
        var sourceIdsDecoded0:[Swift.String]? = nil
        if let sourceIdsContainer = sourceIdsContainer {
            sourceIdsDecoded0 = [Swift.String]()
            for string0 in sourceIdsContainer {
                if let string0 = string0 {
                    sourceIdsDecoded0?.append(string0)
                }
            }
        }
        sourceIds = sourceIdsDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct CreateEventSubscriptionOutput: Swift.Equatable {
    /// The event subscription that was created.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

enum CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "KMSAccessDeniedFault": return try await KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSDisabledFault": return try await KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidStateFault": return try await KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSNotFoundFault": return try await KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSThrottlingFault": return try await KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SNSInvalidTopicFault": return try await SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SNSNoAuthorizationFault": return try await SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetAdvisorCollectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorName = self.collectorName {
            try encodeContainer.encode(collectorName, forKey: .collectorName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

extension CreateFleetAdvisorCollectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetAdvisorCollectorInput: Swift.Equatable {
    /// The name of your Fleet Advisor collector (for example, sample-collector).
    /// This member is required.
    public var collectorName: Swift.String?
    /// A summary description of your Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        collectorName: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct CreateFleetAdvisorCollectorInputBody: Swift.Equatable {
    let collectorName: Swift.String?
    let description: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let s3BucketName: Swift.String?
}

extension CreateFleetAdvisorCollectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension CreateFleetAdvisorCollectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetAdvisorCollectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectorName = output.collectorName
            self.collectorReferencedId = output.collectorReferencedId
            self.description = output.description
            self.s3BucketName = output.s3BucketName
            self.serviceAccessRoleArn = output.serviceAccessRoleArn
        } else {
            self.collectorName = nil
            self.collectorReferencedId = nil
            self.description = nil
            self.s3BucketName = nil
            self.serviceAccessRoleArn = nil
        }
    }
}

public struct CreateFleetAdvisorCollectorOutput: Swift.Equatable {
    /// The name of the new Fleet Advisor collector.
    public var collectorName: Swift.String?
    /// The unique ID of the new Fleet Advisor collector, for example: 22fda70c-40d5-4acf-b233-a495bd8eb7f5
    public var collectorReferencedId: Swift.String?
    /// A summary description of the Fleet Advisor collector.
    public var description: Swift.String?
    /// The Amazon S3 bucket that the collector uses to store inventory metadata.
    public var s3BucketName: Swift.String?
    /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        collectorName: Swift.String? = nil,
        collectorReferencedId: Swift.String? = nil,
        description: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.collectorName = collectorName
        self.collectorReferencedId = collectorReferencedId
        self.description = description
        self.s3BucketName = s3BucketName
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct CreateFleetAdvisorCollectorOutputBody: Swift.Equatable {
    let collectorReferencedId: Swift.String?
    let collectorName: Swift.String?
    let description: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let s3BucketName: Swift.String?
}

extension CreateFleetAdvisorCollectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorName = "CollectorName"
        case collectorReferencedId = "CollectorReferencedId"
        case description = "Description"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
        let collectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorName)
        collectorName = collectorNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

enum CreateFleetAdvisorCollectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case description = "Description"
        case instanceProfileName = "InstanceProfileName"
        case kmsKeyArn = "KmsKeyArn"
        case networkType = "NetworkType"
        case publiclyAccessible = "PubliclyAccessible"
        case subnetGroupIdentifier = "SubnetGroupIdentifier"
        case tags = "Tags"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let subnetGroupIdentifier = self.subnetGroupIdentifier {
            try encodeContainer.encode(subnetGroupIdentifier, forKey: .subnetGroupIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for string0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(string0)
            }
        }
    }
}

extension CreateInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceProfileInput: Swift.Equatable {
    /// The Availability Zone where the instance profile will be created. The default value is a random, system-chosen Availability Zone in the Amazon Web Services Region where your data provider is created, for examplem us-east-1d.
    public var availabilityZone: Swift.String?
    /// A user-friendly description of the instance profile.
    public var description: Swift.String?
    /// A user-friendly name for the instance profile.
    public var instanceProfileName: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyArn: Swift.String?
    /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
    public var networkType: Swift.String?
    /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// A subnet group to associate with the instance profile.
    public var subnetGroupIdentifier: Swift.String?
    /// One or more tags to be assigned to the instance profile.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Specifies the VPC security group names to be used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
    public var vpcSecurityGroups: [Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceProfileName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        networkType: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        subnetGroupIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroups: [Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.instanceProfileName = instanceProfileName
        self.kmsKeyArn = kmsKeyArn
        self.networkType = networkType
        self.publiclyAccessible = publiclyAccessible
        self.subnetGroupIdentifier = subnetGroupIdentifier
        self.tags = tags
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct CreateInstanceProfileInputBody: Swift.Equatable {
    let availabilityZone: Swift.String?
    let kmsKeyArn: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let networkType: Swift.String?
    let instanceProfileName: Swift.String?
    let description: Swift.String?
    let subnetGroupIdentifier: Swift.String?
    let vpcSecurityGroups: [Swift.String]?
}

extension CreateInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case description = "Description"
        case instanceProfileName = "InstanceProfileName"
        case kmsKeyArn = "KmsKeyArn"
        case networkType = "NetworkType"
        case publiclyAccessible = "PubliclyAccessible"
        case subnetGroupIdentifier = "SubnetGroupIdentifier"
        case tags = "Tags"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupIdentifier)
        subnetGroupIdentifier = subnetGroupIdentifierDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
    }
}

extension CreateInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInstanceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct CreateInstanceProfileOutput: Swift.Equatable {
    /// The instance profile that was created.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct CreateInstanceProfileOutputBody: Swift.Equatable {
    let instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?
}

extension CreateInstanceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

enum CreateInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMigrationProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case migrationProjectName = "MigrationProjectName"
        case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
        case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
        case tags = "Tags"
        case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
        case transformationRules = "TransformationRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileIdentifier = self.instanceProfileIdentifier {
            try encodeContainer.encode(instanceProfileIdentifier, forKey: .instanceProfileIdentifier)
        }
        if let migrationProjectName = self.migrationProjectName {
            try encodeContainer.encode(migrationProjectName, forKey: .migrationProjectName)
        }
        if let schemaConversionApplicationAttributes = self.schemaConversionApplicationAttributes {
            try encodeContainer.encode(schemaConversionApplicationAttributes, forKey: .schemaConversionApplicationAttributes)
        }
        if let sourceDataProviderDescriptors = sourceDataProviderDescriptors {
            var sourceDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDataProviderDescriptors)
            for dataproviderdescriptordefinition0 in sourceDataProviderDescriptors {
                try sourceDataProviderDescriptorsContainer.encode(dataproviderdescriptordefinition0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetDataProviderDescriptors = targetDataProviderDescriptors {
            var targetDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDataProviderDescriptors)
            for dataproviderdescriptordefinition0 in targetDataProviderDescriptors {
                try targetDataProviderDescriptorsContainer.encode(dataproviderdescriptordefinition0)
            }
        }
        if let transformationRules = self.transformationRules {
            try encodeContainer.encode(transformationRules, forKey: .transformationRules)
        }
    }
}

extension CreateMigrationProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateMigrationProjectInput: Swift.Equatable {
    /// A user-friendly description of the migration project.
    public var description: Swift.String?
    /// The identifier of the associated instance profile. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?
    /// A user-friendly name for the migration project.
    public var migrationProjectName: Swift.String?
    /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
    public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
    /// Information about the source data provider, including the name, ARN, and Secrets Manager parameters.
    /// This member is required.
    public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// One or more tags to be assigned to the migration project.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    /// This member is required.
    public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
    public var transformationRules: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        migrationProjectName: Swift.String? = nil,
        schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
        sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        transformationRules: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.migrationProjectName = migrationProjectName
        self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
        self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
        self.tags = tags
        self.targetDataProviderDescriptors = targetDataProviderDescriptors
        self.transformationRules = transformationRules
    }
}

struct CreateMigrationProjectInputBody: Swift.Equatable {
    let migrationProjectName: Swift.String?
    let sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    let targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    let instanceProfileIdentifier: Swift.String?
    let transformationRules: Swift.String?
    let description: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
}

extension CreateMigrationProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case migrationProjectName = "MigrationProjectName"
        case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
        case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
        case tags = "Tags"
        case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
        case transformationRules = "TransformationRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectName)
        migrationProjectName = migrationProjectNameDecoded
        let sourceDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptorDefinition?].self, forKey: .sourceDataProviderDescriptors)
        var sourceDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil
        if let sourceDataProviderDescriptorsContainer = sourceDataProviderDescriptorsContainer {
            sourceDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]()
            for structure0 in sourceDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    sourceDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        sourceDataProviderDescriptors = sourceDataProviderDescriptorsDecoded0
        let targetDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptorDefinition?].self, forKey: .targetDataProviderDescriptors)
        var targetDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil
        if let targetDataProviderDescriptorsContainer = targetDataProviderDescriptorsContainer {
            targetDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]()
            for structure0 in targetDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    targetDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        targetDataProviderDescriptors = targetDataProviderDescriptorsDecoded0
        let instanceProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileIdentifier)
        instanceProfileIdentifier = instanceProfileIdentifierDecoded
        let transformationRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformationRules)
        transformationRules = transformationRulesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let schemaConversionApplicationAttributesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SCApplicationAttributes.self, forKey: .schemaConversionApplicationAttributes)
        schemaConversionApplicationAttributes = schemaConversionApplicationAttributesDecoded
    }
}

extension CreateMigrationProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMigrationProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationProject = output.migrationProject
        } else {
            self.migrationProject = nil
        }
    }
}

public struct CreateMigrationProjectOutput: Swift.Equatable {
    /// The migration project that was created.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

struct CreateMigrationProjectOutputBody: Swift.Equatable {
    let migrationProject: DatabaseMigrationClientTypes.MigrationProject?
}

extension CreateMigrationProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProject = "MigrationProject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationProject.self, forKey: .migrationProject)
        migrationProject = migrationProjectDecoded
    }
}

enum CreateMigrationProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeConfig = "ComputeConfig"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationSettings = "ReplicationSettings"
        case replicationType = "ReplicationType"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case supplementalSettings = "SupplementalSettings"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeConfig = self.computeConfig {
            try encodeContainer.encode(computeConfig, forKey: .computeConfig)
        }
        if let replicationConfigIdentifier = self.replicationConfigIdentifier {
            try encodeContainer.encode(replicationConfigIdentifier, forKey: .replicationConfigIdentifier)
        }
        if let replicationSettings = self.replicationSettings {
            try encodeContainer.encode(replicationSettings, forKey: .replicationSettings)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let supplementalSettings = self.supplementalSettings {
            try encodeContainer.encode(supplementalSettings, forKey: .supplementalSettings)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
    }
}

extension CreateReplicationConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationConfigInput: Swift.Equatable {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    /// This member is required.
    public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    /// A unique identifier that you want to use to create a ReplicationConfigArn that is returned as part of the output from this action. You can then pass this output ReplicationConfigArn as the value of the ReplicationConfigArn option for other actions to identify both DMS Serverless replications and replication configurations that you want those actions to operate on. For some actions, you can also use either this unique identifier or a corresponding ARN in action filters to identify the specific replication and replication configuration to operate on.
    /// This member is required.
    public var replicationConfigIdentifier: Swift.String?
    /// Optional JSON settings for DMS Serverless replications that are provisioned using this replication configuration. For example, see [ Change processing tuning settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.ChangeProcessingTuning.html).
    public var replicationSettings: Swift.String?
    /// The type of DMS Serverless replication to provision using this replication configuration. Possible values:
    ///
    /// * "full-load"
    ///
    /// * "cdc"
    ///
    /// * "full-load-and-cdc"
    /// This member is required.
    public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// Optional unique value or name that you set for a given resource that can be used to construct an Amazon Resource Name (ARN) for that resource. For more information, see [ Fine-grained access control using resource names and tags](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#CHAP_Security.FineGrainedAccess).
    public var resourceIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the source endpoint for this DMS Serverless replication configuration.
    /// This member is required.
    public var sourceEndpointArn: Swift.String?
    /// Optional JSON settings for specifying supplemental data. For more information, see [ Specifying supplemental data for task settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html).
    public var supplementalSettings: Swift.String?
    /// JSON table mappings for DMS Serverless replications that are provisioned using this replication configuration. For more information, see [ Specifying table selection and transformations rules using JSON](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.SelectionTransformation.html).
    /// This member is required.
    public var tableMappings: Swift.String?
    /// One or more optional tags associated with resources used by the DMS Serverless replication. For more information, see [ Tagging resources in Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tagging.html).
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
    /// This member is required.
    public var targetEndpointArn: Swift.String?

    public init(
        computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
        replicationConfigIdentifier: Swift.String? = nil,
        replicationSettings: Swift.String? = nil,
        replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        supplementalSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil
    )
    {
        self.computeConfig = computeConfig
        self.replicationConfigIdentifier = replicationConfigIdentifier
        self.replicationSettings = replicationSettings
        self.replicationType = replicationType
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.supplementalSettings = supplementalSettings
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
    }
}

struct CreateReplicationConfigInputBody: Swift.Equatable {
    let replicationConfigIdentifier: Swift.String?
    let sourceEndpointArn: Swift.String?
    let targetEndpointArn: Swift.String?
    let computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    let replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationSettings: Swift.String?
    let supplementalSettings: Swift.String?
    let resourceIdentifier: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateReplicationConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeConfig = "ComputeConfig"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationSettings = "ReplicationSettings"
        case replicationType = "ReplicationType"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case supplementalSettings = "SupplementalSettings"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigIdentifier)
        replicationConfigIdentifier = replicationConfigIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let computeConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ComputeConfig.self, forKey: .computeConfig)
        computeConfig = computeConfigDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSettings)
        replicationSettings = replicationSettingsDecoded
        let supplementalSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supplementalSettings)
        supplementalSettings = supplementalSettingsDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfig = output.replicationConfig
        } else {
            self.replicationConfig = nil
        }
    }
}

///
public struct CreateReplicationConfigOutput: Swift.Equatable {
    /// Configuration parameters returned from the DMS Serverless replication after it is created.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

struct CreateReplicationConfigOutputBody: Swift.Equatable {
    let replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?
}

extension CreateReplicationConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfig = "ReplicationConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
    }
}

enum CreateReplicationConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try await ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = self.dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension CreateReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationInstanceInput: Swift.Equatable {
    /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region, for example: us-east-1d.
    public var availabilityZone: Swift.String?
    /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
    public var dnsNameServers: Swift.String?
    /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
    public var engineVersion: Swift.String?
    /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: A 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Choosing the right DMS replication instance](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.Types.html); and, [Selecting the best size for a replication instance](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_BestPractices.SizingReplicationInstance.html).
    /// This member is required.
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain 1-63 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: myrepinstance
    /// This member is required.
    public var replicationInstanceIdentifier: Swift.String?
    /// A subnet group to associate with the replication instance.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// One or more tags to be assigned to the replication instance.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        dnsNameServers: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.dnsNameServers = dnsNameServers
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceIdentifier: Swift.String?
    let allocatedStorage: Swift.Int?
    let replicationInstanceClass: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let availabilityZone: Swift.String?
    let replicationSubnetGroupIdentifier: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let dnsNameServers: Swift.String?
    let resourceIdentifier: Swift.String?
    let networkType: Swift.String?
}

extension CreateReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case resourceIdentifier = "ResourceIdentifier"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension CreateReplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct CreateReplicationInstanceOutput: Swift.Equatable {
    /// The replication instance that was created.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct CreateReplicationInstanceOutputBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension CreateReplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

enum CreateReplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientResourceCapacityFault": return try await InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try await ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StorageQuotaExceededFault": return try await StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationSubnetGroupInput: Swift.Equatable {
    /// The description for the subnet group.
    /// This member is required.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// One or more subnet IDs to be assigned to the subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// One or more tags to be assigned to the subnet group.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
    let replicationSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension CreateReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationSubnetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

///
public struct CreateReplicationSubnetGroupOutput: Swift.Equatable {
    /// The replication subnet group that was created.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init(
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct CreateReplicationSubnetGroupOutputBody: Swift.Equatable {
    let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension CreateReplicationSubnetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

enum CreateReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try await ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

extension CreateReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct CreateReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€ Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€ When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€ Commit time example: --cdc-stop-position â€œcommit_time:2018-02-09T12:12:12â€œ
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    /// This member is required.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of a replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// An identifier for the replication task. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var replicationTaskIdentifier: Swift.String?
    /// Overall settings for the task, in JSON format. For more information, see [Specifying Task Settings for Database Migration Service Tasks](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html) in the Database Migration Service User Guide.
    public var replicationTaskSettings: Swift.String?
    /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
    public var resourceIdentifier: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
    /// This member is required.
    public var sourceEndpointArn: Swift.String?
    /// The table mappings for the task, in JSON format. For more information, see [Using Table Mapping to Specify Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html) in the Database Migration Service User Guide.
    /// This member is required.
    public var tableMappings: Swift.String?
    /// One or more tags to be assigned to the replication task.
    public var tags: [DatabaseMigrationClientTypes.Tag]?
    /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
    /// This member is required.
    public var targetEndpointArn: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        sourceEndpointArn: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil,
        targetEndpointArn: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.resourceIdentifier = resourceIdentifier
        self.sourceEndpointArn = sourceEndpointArn
        self.tableMappings = tableMappings
        self.tags = tags
        self.targetEndpointArn = targetEndpointArn
        self.taskData = taskData
    }
}

struct CreateReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskIdentifier: Swift.String?
    let sourceEndpointArn: Swift.String?
    let targetEndpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationTaskSettings: Swift.String?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
    let tags: [DatabaseMigrationClientTypes.Tag]?
    let taskData: Swift.String?
    let resourceIdentifier: Swift.String?
}

extension CreateReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case resourceIdentifier = "ResourceIdentifier"
        case sourceEndpointArn = "SourceEndpointArn"
        case tableMappings = "TableMappings"
        case tags = "Tags"
        case targetEndpointArn = "TargetEndpointArn"
        case taskData = "TaskData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
    }
}

extension CreateReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct CreateReplicationTaskOutput: Swift.Equatable {
    /// The replication task that was created.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct CreateReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension CreateReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum CreateReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DataFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormatValue] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataFormatValue(rawValue: rawValue) ?? DataFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DataProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderArn = "DataProviderArn"
        case dataProviderCreationTime = "DataProviderCreationTime"
        case dataProviderName = "DataProviderName"
        case description = "Description"
        case engine = "Engine"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderArn = self.dataProviderArn {
            try encodeContainer.encode(dataProviderArn, forKey: .dataProviderArn)
        }
        if let dataProviderCreationTime = self.dataProviderCreationTime {
            try encodeContainer.encodeTimestamp(dataProviderCreationTime, format: .dateTime, forKey: .dataProviderCreationTime)
        }
        if let dataProviderName = self.dataProviderName {
            try encodeContainer.encode(dataProviderName, forKey: .dataProviderName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderName)
        dataProviderName = dataProviderNameDecoded
        let dataProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderArn)
        dataProviderArn = dataProviderArnDecoded
        let dataProviderCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .dataProviderCreationTime)
        dataProviderCreationTime = dataProviderCreationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProviderSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a data provider.
    public struct DataProvider: Swift.Equatable {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the data provider.
        public var dataProviderArn: Swift.String?
        /// The time the data provider was created.
        public var dataProviderCreationTime: ClientRuntime.Date?
        /// The name of the data provider.
        public var dataProviderName: Swift.String?
        /// A description of the data provider. Descriptions can have up to 31 characters. A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public var description: Swift.String?
        /// The type of database engine for the data provider. Valid values include "aurora", "aurora_postgresql", "mysql", "oracle", "postgres", and "sqlserver". A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
        public var engine: Swift.String?
        /// The settings in JSON format for a data provider.
        public var settings: DatabaseMigrationClientTypes.DataProviderSettings?

        public init(
            dataProviderArn: Swift.String? = nil,
            dataProviderCreationTime: ClientRuntime.Date? = nil,
            dataProviderName: Swift.String? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil
        )
        {
            self.dataProviderArn = dataProviderArn
            self.dataProviderCreationTime = dataProviderCreationTime
            self.dataProviderName = dataProviderName
            self.description = description
            self.engine = engine
            self.settings = settings
        }
    }

}

extension DatabaseMigrationClientTypes.DataProviderDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderArn = "DataProviderArn"
        case dataProviderName = "DataProviderName"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderArn = self.dataProviderArn {
            try encodeContainer.encode(dataProviderArn, forKey: .dataProviderArn)
        }
        if let dataProviderName = self.dataProviderName {
            try encodeContainer.encode(dataProviderName, forKey: .dataProviderName)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let dataProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderName)
        dataProviderName = dataProviderNameDecoded
        let dataProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderArn)
        dataProviderArn = dataProviderArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Information about a data provider.
    public struct DataProviderDescriptor: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the data provider.
        public var dataProviderArn: Swift.String?
        /// The user-friendly name of the data provider.
        public var dataProviderName: Swift.String?
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public var secretsManagerSecretId: Swift.String?

        public init(
            dataProviderArn: Swift.String? = nil,
            dataProviderName: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil
        )
        {
            self.dataProviderArn = dataProviderArn
            self.dataProviderName = dataProviderName
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }
    }

}

extension DatabaseMigrationClientTypes.DataProviderDescriptorDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderIdentifier = "DataProviderIdentifier"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderIdentifier = self.dataProviderIdentifier {
            try encodeContainer.encode(dataProviderIdentifier, forKey: .dataProviderIdentifier)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderIdentifier)
        dataProviderIdentifier = dataProviderIdentifierDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Information about a data provider.
    public struct DataProviderDescriptorDefinition: Swift.Equatable {
        /// The name or Amazon Resource Name (ARN) of the data provider.
        /// This member is required.
        public var dataProviderIdentifier: Swift.String?
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public var secretsManagerSecretId: Swift.String?

        public init(
            dataProviderIdentifier: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil
        )
        {
            self.dataProviderIdentifier = dataProviderIdentifier
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }
    }

}

extension DatabaseMigrationClientTypes.DataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case docdbsettings = "DocDbSettings"
        case mariadbsettings = "MariaDbSettings"
        case microsoftsqlserversettings = "MicrosoftSqlServerSettings"
        case mongodbsettings = "MongoDbSettings"
        case mysqlsettings = "MySqlSettings"
        case oraclesettings = "OracleSettings"
        case postgresqlsettings = "PostgreSqlSettings"
        case redshiftsettings = "RedshiftSettings"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .docdbsettings(docdbsettings):
                try container.encode(docdbsettings, forKey: .docdbsettings)
            case let .mariadbsettings(mariadbsettings):
                try container.encode(mariadbsettings, forKey: .mariadbsettings)
            case let .microsoftsqlserversettings(microsoftsqlserversettings):
                try container.encode(microsoftsqlserversettings, forKey: .microsoftsqlserversettings)
            case let .mongodbsettings(mongodbsettings):
                try container.encode(mongodbsettings, forKey: .mongodbsettings)
            case let .mysqlsettings(mysqlsettings):
                try container.encode(mysqlsettings, forKey: .mysqlsettings)
            case let .oraclesettings(oraclesettings):
                try container.encode(oraclesettings, forKey: .oraclesettings)
            case let .postgresqlsettings(postgresqlsettings):
                try container.encode(postgresqlsettings, forKey: .postgresqlsettings)
            case let .redshiftsettings(redshiftsettings):
                try container.encode(redshiftsettings, forKey: .redshiftsettings)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftDataProviderSettings.self, forKey: .redshiftsettings)
        if let redshiftsettings = redshiftsettingsDecoded {
            self = .redshiftsettings(redshiftsettings)
            return
        }
        let postgresqlsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings.self, forKey: .postgresqlsettings)
        if let postgresqlsettings = postgresqlsettingsDecoded {
            self = .postgresqlsettings(postgresqlsettings)
            return
        }
        let mysqlsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.MySqlDataProviderSettings.self, forKey: .mysqlsettings)
        if let mysqlsettings = mysqlsettingsDecoded {
            self = .mysqlsettings(mysqlsettings)
            return
        }
        let oraclesettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.OracleDataProviderSettings.self, forKey: .oraclesettings)
        if let oraclesettings = oraclesettingsDecoded {
            self = .oraclesettings(oraclesettings)
            return
        }
        let microsoftsqlserversettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings.self, forKey: .microsoftsqlserversettings)
        if let microsoftsqlserversettings = microsoftsqlserversettingsDecoded {
            self = .microsoftsqlserversettings(microsoftsqlserversettings)
            return
        }
        let docdbsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.DocDbDataProviderSettings.self, forKey: .docdbsettings)
        if let docdbsettings = docdbsettingsDecoded {
            self = .docdbsettings(docdbsettings)
            return
        }
        let mariadbsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.MariaDbDataProviderSettings.self, forKey: .mariadbsettings)
        if let mariadbsettings = mariadbsettingsDecoded {
            self = .mariadbsettings(mariadbsettings)
            return
        }
        let mongodbsettingsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbDataProviderSettings.self, forKey: .mongodbsettings)
        if let mongodbsettings = mongodbsettingsDecoded {
            self = .mongodbsettings(mongodbsettings)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a data provider.
    public enum DataProviderSettings: Swift.Equatable {
        /// Provides information that defines an Amazon Redshift data provider.
        case redshiftsettings(DatabaseMigrationClientTypes.RedshiftDataProviderSettings)
        /// Provides information that defines a PostgreSQL data provider.
        case postgresqlsettings(DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings)
        /// Provides information that defines a MySQL data provider.
        case mysqlsettings(DatabaseMigrationClientTypes.MySqlDataProviderSettings)
        /// Provides information that defines an Oracle data provider.
        case oraclesettings(DatabaseMigrationClientTypes.OracleDataProviderSettings)
        /// Provides information that defines a Microsoft SQL Server data provider.
        case microsoftsqlserversettings(DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings)
        /// Provides information that defines a DocumentDB data provider.
        case docdbsettings(DatabaseMigrationClientTypes.DocDbDataProviderSettings)
        /// Provides information that defines a MariaDB data provider.
        case mariadbsettings(DatabaseMigrationClientTypes.MariaDbDataProviderSettings)
        /// Provides information that defines a MongoDB data provider.
        case mongodbsettings(DatabaseMigrationClientTypes.MongoDbDataProviderSettings)
        case sdkUnknown(Swift.String)
    }

}

extension DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engine = "Engine"
        case engineEdition = "EngineEdition"
        case engineVersion = "EngineVersion"
        case osArchitecture = "OsArchitecture"
        case servicePack = "ServicePack"
        case supportLevel = "SupportLevel"
        case tooltip = "Tooltip"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineEdition = self.engineEdition {
            try encodeContainer.encode(engineEdition, forKey: .engineEdition)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let osArchitecture = self.osArchitecture {
            try encodeContainer.encode(osArchitecture, forKey: .osArchitecture)
        }
        if let servicePack = self.servicePack {
            try encodeContainer.encode(servicePack, forKey: .servicePack)
        }
        if let supportLevel = self.supportLevel {
            try encodeContainer.encode(supportLevel, forKey: .supportLevel)
        }
        if let tooltip = self.tooltip {
            try encodeContainer.encode(tooltip, forKey: .tooltip)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineEdition)
        engineEdition = engineEditionDecoded
        let servicePackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .servicePack)
        servicePack = servicePackDecoded
        let supportLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportLevel)
        supportLevel = supportLevelDecoded
        let osArchitectureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .osArchitecture)
        osArchitecture = osArchitectureDecoded
        let tooltipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tooltip)
        tooltip = tooltipDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an inventory database instance for a Fleet Advisor collector.
    public struct DatabaseInstanceSoftwareDetailsResponse: Swift.Equatable {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example Microsoft SQL Server.
        public var engine: Swift.String?
        /// The database engine edition of a database in a Fleet Advisor collector inventory, for example Express.
        public var engineEdition: Swift.String?
        /// The database engine version of a database in a Fleet Advisor collector inventory, for example 2019.
        public var engineVersion: Swift.String?
        /// The operating system architecture of the database.
        public var osArchitecture: Swift.Int?
        /// The service pack level of the database.
        public var servicePack: Swift.String?
        /// The support level of the database, for example Mainstream support.
        public var supportLevel: Swift.String?
        /// Information about the database engine software, for example Mainstream support ends on November 14th, 2024.
        public var tooltip: Swift.String?

        public init(
            engine: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            osArchitecture: Swift.Int? = nil,
            servicePack: Swift.String? = nil,
            supportLevel: Swift.String? = nil,
            tooltip: Swift.String? = nil
        )
        {
            self.engine = engine
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.osArchitecture = osArchitecture
            self.servicePack = servicePack
            self.supportLevel = supportLevel
            self.tooltip = tooltip
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum DatabaseMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case babelfish
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseMode] {
            return [
                .babelfish,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .babelfish: return "babelfish"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseMode(rawValue: rawValue) ?? DatabaseMode.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DatabaseResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case databaseId = "DatabaseId"
        case databaseName = "DatabaseName"
        case ipAddress = "IpAddress"
        case numberOfSchemas = "NumberOfSchemas"
        case server = "Server"
        case softwareDetails = "SoftwareDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectors = collectors {
            var collectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .collectors)
            for collectorshortinforesponse0 in collectors {
                try collectorsContainer.encode(collectorshortinforesponse0)
            }
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let numberOfSchemas = self.numberOfSchemas {
            try encodeContainer.encode(numberOfSchemas, forKey: .numberOfSchemas)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let softwareDetails = self.softwareDetails {
            try encodeContainer.encode(softwareDetails, forKey: .softwareDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let numberOfSchemasDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSchemas)
        numberOfSchemas = numberOfSchemasDecoded
        let serverDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ServerShortInfoResponse.self, forKey: .server)
        server = serverDecoded
        let softwareDetailsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse.self, forKey: .softwareDetails)
        softwareDetails = softwareDetailsDecoded
        let collectorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.CollectorShortInfoResponse?].self, forKey: .collectors)
        var collectorsDecoded0:[DatabaseMigrationClientTypes.CollectorShortInfoResponse]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [DatabaseMigrationClientTypes.CollectorShortInfoResponse]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseResponse: Swift.Equatable {
        /// A list of collectors associated with the database.
        public var collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The number of schemas in a Fleet Advisor collector inventory database.
        public var numberOfSchemas: Swift.Int?
        /// The server name of a database in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The software details of a database in a Fleet Advisor collector inventory, such as database engine and version.
        public var softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse?

        public init(
            collectors: [DatabaseMigrationClientTypes.CollectorShortInfoResponse]? = nil,
            databaseId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            numberOfSchemas: Swift.Int? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            softwareDetails: DatabaseMigrationClientTypes.DatabaseInstanceSoftwareDetailsResponse? = nil
        )
        {
            self.collectors = collectors
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.ipAddress = ipAddress
            self.numberOfSchemas = numberOfSchemas
            self.server = server
            self.softwareDetails = softwareDetails
        }
    }

}

extension DatabaseMigrationClientTypes.DatabaseShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseEngine = "DatabaseEngine"
        case databaseId = "DatabaseId"
        case databaseIpAddress = "DatabaseIpAddress"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseEngine = self.databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseIpAddress = self.databaseIpAddress {
            try encodeContainer.encode(databaseIpAddress, forKey: .databaseIpAddress)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseIpAddress)
        databaseIpAddress = databaseIpAddressDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a database in a Fleet Advisor collector inventory.
    public struct DatabaseShortInfoResponse: Swift.Equatable {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example PostgreSQL.
        public var databaseEngine: Swift.String?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?

        public init(
            databaseEngine: Swift.String? = nil,
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil
        )
        {
            self.databaseEngine = databaseEngine
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionDelimiterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dash
        case `none`
        case slash
        case underscore
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionDelimiterValue] {
            return [
                .dash,
                .none,
                .slash,
                .underscore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .none: return "NONE"
            case .slash: return "SLASH"
            case .underscore: return "UNDERSCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionDelimiterValue(rawValue: rawValue) ?? DatePartitionDelimiterValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DatePartitionSequenceValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddmmyyyy
        case mmyyyydd
        case yyyymm
        case yyyymmdd
        case yyyymmddhh
        case sdkUnknown(Swift.String)

        public static var allCases: [DatePartitionSequenceValue] {
            return [
                .ddmmyyyy,
                .mmyyyydd,
                .yyyymm,
                .yyyymmdd,
                .yyyymmddhh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddmmyyyy: return "DDMMYYYY"
            case .mmyyyydd: return "MMYYYYDD"
            case .yyyymm: return "YYYYMM"
            case .yyyymmdd: return "YYYYMMDD"
            case .yyyymmddhh: return "YYYYMMDDHH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatePartitionSequenceValue(rawValue: rawValue) ?? DatePartitionSequenceValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DefaultErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides error information about a schema conversion operation.
    public struct DefaultErrorDetails: Swift.Equatable {
        /// The error message.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension DeleteCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

extension DeleteCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCertificateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate.
    /// This member is required.
    public var certificateArn: Swift.String?

    public init(
        certificateArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

struct DeleteCertificateInputBody: Swift.Equatable {
    let certificateArn: Swift.String?
}

extension DeleteCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DeleteCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct DeleteCertificateOutput: Swift.Equatable {
    /// The Secure Sockets Layer (SSL) certificate.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init(
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct DeleteCertificateOutputBody: Swift.Equatable {
    let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension DeleteCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum DeleteCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

///
public struct DeleteConnectionOutput: Swift.Equatable {
    /// The connection that is being deleted.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init(
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputBody: Swift.Equatable {
    let connection: DatabaseMigrationClientTypes.Connection?
}

extension DeleteConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

enum DeleteConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderIdentifier = "DataProviderIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderIdentifier = self.dataProviderIdentifier {
            try encodeContainer.encode(dataProviderIdentifier, forKey: .dataProviderIdentifier)
        }
    }
}

extension DeleteDataProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDataProviderInput: Swift.Equatable {
    /// The identifier of the data provider to delete.
    /// This member is required.
    public var dataProviderIdentifier: Swift.String?

    public init(
        dataProviderIdentifier: Swift.String? = nil
    )
    {
        self.dataProviderIdentifier = dataProviderIdentifier
    }
}

struct DeleteDataProviderInputBody: Swift.Equatable {
    let dataProviderIdentifier: Swift.String?
}

extension DeleteDataProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderIdentifier = "DataProviderIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderIdentifier)
        dataProviderIdentifier = dataProviderIdentifierDecoded
    }
}

extension DeleteDataProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDataProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataProvider = output.dataProvider
        } else {
            self.dataProvider = nil
        }
    }
}

public struct DeleteDataProviderOutput: Swift.Equatable {
    /// The data provider that was deleted.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

struct DeleteDataProviderOutputBody: Swift.Equatable {
    let dataProvider: DatabaseMigrationClientTypes.DataProvider?
}

extension DeleteDataProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProvider = "DataProvider"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProvider.self, forKey: .dataProvider)
        dataProvider = dataProviderDecoded
    }
}

enum DeleteDataProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

extension DeleteEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DeleteEndpointInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension DeleteEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DeleteEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct DeleteEndpointOutput: Swift.Equatable {
    /// The endpoint that was deleted.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DeleteEndpointOutputBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension DeleteEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum DeleteEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension DeleteEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// The name of the DMS event notification subscription to be deleted.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init(
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

struct DeleteEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
}

extension DeleteEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionName = "SubscriptionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension DeleteEventSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEventSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct DeleteEventSubscriptionOutput: Swift.Equatable {
    /// The event subscription that was deleted.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

enum DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetAdvisorCollectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorReferencedId = "CollectorReferencedId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorReferencedId = self.collectorReferencedId {
            try encodeContainer.encode(collectorReferencedId, forKey: .collectorReferencedId)
        }
    }
}

extension DeleteFleetAdvisorCollectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetAdvisorCollectorInput: Swift.Equatable {
    /// The reference ID of the Fleet Advisor collector to delete.
    /// This member is required.
    public var collectorReferencedId: Swift.String?

    public init(
        collectorReferencedId: Swift.String? = nil
    )
    {
        self.collectorReferencedId = collectorReferencedId
    }
}

struct DeleteFleetAdvisorCollectorInputBody: Swift.Equatable {
    let collectorReferencedId: Swift.String?
}

extension DeleteFleetAdvisorCollectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorReferencedId = "CollectorReferencedId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorReferencedIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorReferencedId)
        collectorReferencedId = collectorReferencedIdDecoded
    }
}

extension DeleteFleetAdvisorCollectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFleetAdvisorCollectorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFleetAdvisorCollectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CollectorNotFoundFault": return try await CollectorNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetAdvisorDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseIds = databaseIds {
            var databaseIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .databaseIds)
            for string0 in databaseIds {
                try databaseIdsContainer.encode(string0)
            }
        }
    }
}

extension DeleteFleetAdvisorDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetAdvisorDatabasesInput: Swift.Equatable {
    /// The IDs of the Fleet Advisor collector databases to delete.
    /// This member is required.
    public var databaseIds: [Swift.String]?

    public init(
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

struct DeleteFleetAdvisorDatabasesInputBody: Swift.Equatable {
    let databaseIds: [Swift.String]?
}

extension DeleteFleetAdvisorDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databaseIds)
        var databaseIdsDecoded0:[Swift.String]? = nil
        if let databaseIdsContainer = databaseIdsContainer {
            databaseIdsDecoded0 = [Swift.String]()
            for string0 in databaseIdsContainer {
                if let string0 = string0 {
                    databaseIdsDecoded0?.append(string0)
                }
            }
        }
        databaseIds = databaseIdsDecoded0
    }
}

extension DeleteFleetAdvisorDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFleetAdvisorDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.databaseIds = output.databaseIds
        } else {
            self.databaseIds = nil
        }
    }
}

public struct DeleteFleetAdvisorDatabasesOutput: Swift.Equatable {
    /// The IDs of the databases that the operation deleted.
    public var databaseIds: [Swift.String]?

    public init(
        databaseIds: [Swift.String]? = nil
    )
    {
        self.databaseIds = databaseIds
    }
}

struct DeleteFleetAdvisorDatabasesOutputBody: Swift.Equatable {
    let databaseIds: [Swift.String]?
}

extension DeleteFleetAdvisorDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseIds = "DatabaseIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .databaseIds)
        var databaseIdsDecoded0:[Swift.String]? = nil
        if let databaseIdsContainer = databaseIdsContainer {
            databaseIdsDecoded0 = [Swift.String]()
            for string0 in databaseIdsContainer {
                if let string0 = string0 {
                    databaseIdsDecoded0?.append(string0)
                }
            }
        }
        databaseIds = databaseIdsDecoded0
    }
}

enum DeleteFleetAdvisorDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidOperationFault": return try await InvalidOperationFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceProfileIdentifier = self.instanceProfileIdentifier {
            try encodeContainer.encode(instanceProfileIdentifier, forKey: .instanceProfileIdentifier)
        }
    }
}

extension DeleteInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceProfileInput: Swift.Equatable {
    /// The identifier of the instance profile to delete.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?

    public init(
        instanceProfileIdentifier: Swift.String? = nil
    )
    {
        self.instanceProfileIdentifier = instanceProfileIdentifier
    }
}

struct DeleteInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileIdentifier: Swift.String?
}

extension DeleteInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileIdentifier)
        instanceProfileIdentifier = instanceProfileIdentifierDecoded
    }
}

extension DeleteInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteInstanceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct DeleteInstanceProfileOutput: Swift.Equatable {
    /// The instance profile that was deleted.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct DeleteInstanceProfileOutputBody: Swift.Equatable {
    let instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?
}

extension DeleteInstanceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

enum DeleteInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMigrationProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DeleteMigrationProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteMigrationProjectInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the migration project to delete.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DeleteMigrationProjectInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
}

extension DeleteMigrationProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
    }
}

extension DeleteMigrationProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMigrationProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationProject = output.migrationProject
        } else {
            self.migrationProject = nil
        }
    }
}

public struct DeleteMigrationProjectOutput: Swift.Equatable {
    /// The migration project that was deleted.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

struct DeleteMigrationProjectOutputBody: Swift.Equatable {
    let migrationProject: DatabaseMigrationClientTypes.MigrationProject?
}

extension DeleteMigrationProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProject = "MigrationProject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationProject.self, forKey: .migrationProject)
        migrationProject = migrationProjectDecoded
    }
}

enum DeleteMigrationProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
    }
}

extension DeleteReplicationConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationConfigInput: Swift.Equatable {
    /// The replication config to delete.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

struct DeleteReplicationConfigInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
}

extension DeleteReplicationConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
    }
}

extension DeleteReplicationConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReplicationConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfig = output.replicationConfig
        } else {
            self.replicationConfig = nil
        }
    }
}

///
public struct DeleteReplicationConfigOutput: Swift.Equatable {
    /// Configuration parameters returned for the DMS Serverless replication after it is deleted.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

struct DeleteReplicationConfigOutputBody: Swift.Equatable {
    let replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?
}

extension DeleteReplicationConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfig = "ReplicationConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
    }
}

enum DeleteReplicationConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DeleteReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationInstanceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DeleteReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
}

extension DeleteReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension DeleteReplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct DeleteReplicationInstanceOutput: Swift.Equatable {
    /// The replication instance that was deleted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct DeleteReplicationInstanceOutputBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension DeleteReplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

enum DeleteReplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
    }
}

extension DeleteReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationSubnetGroupInput: Swift.Equatable {
    /// The subnet group name of the replication instance.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?

    public init(
        replicationSubnetGroupIdentifier: Swift.String? = nil
    )
    {
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
    }
}

struct DeleteReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
}

extension DeleteReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
    }
}

extension DeleteReplicationSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

///
public struct DeleteReplicationSubnetGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
    }
}

extension DeleteReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
    /// This member is required.
    public var replicationTaskAssessmentRunArn: Swift.String?

    public init(
        replicationTaskAssessmentRunArn: Swift.String? = nil
    )
    {
        self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
    }
}

struct DeleteReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskAssessmentRunArn: Swift.String?
}

extension DeleteReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
    }
}

extension DeleteReplicationTaskAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReplicationTaskAssessmentRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct DeleteReplicationTaskAssessmentRunOutput: Swift.Equatable {
    /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct DeleteReplicationTaskAssessmentRunOutputBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension DeleteReplicationTaskAssessmentRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

enum DeleteReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DeleteReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task to be deleted.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DeleteReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension DeleteReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension DeleteReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct DeleteReplicationTaskOutput: Swift.Equatable {
    /// The deleted replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct DeleteReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension DeleteReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum DeleteReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAttributesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init() { }
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountQuotas = output.accountQuotas
            self.uniqueAccountIdentifier = output.uniqueAccountIdentifier
        } else {
            self.accountQuotas = nil
            self.uniqueAccountIdentifier = nil
        }
    }
}

///
public struct DescribeAccountAttributesOutput: Swift.Equatable {
    /// Account quota information.
    public var accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    /// A unique DMS identifier for an account in a particular Amazon Web Services Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given Amazon Web Services Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666. DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later.
    public var uniqueAccountIdentifier: Swift.String?

    public init(
        accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]? = nil,
        uniqueAccountIdentifier: Swift.String? = nil
    )
    {
        self.accountQuotas = accountQuotas
        self.uniqueAccountIdentifier = uniqueAccountIdentifier
    }
}

struct DescribeAccountAttributesOutputBody: Swift.Equatable {
    let accountQuotas: [DatabaseMigrationClientTypes.AccountQuota]?
    let uniqueAccountIdentifier: Swift.String?
}

extension DescribeAccountAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotas = "AccountQuotas"
        case uniqueAccountIdentifier = "UniqueAccountIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotasContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.AccountQuota?].self, forKey: .accountQuotas)
        var accountQuotasDecoded0:[DatabaseMigrationClientTypes.AccountQuota]? = nil
        if let accountQuotasContainer = accountQuotasContainer {
            accountQuotasDecoded0 = [DatabaseMigrationClientTypes.AccountQuota]()
            for structure0 in accountQuotasContainer {
                if let structure0 = structure0 {
                    accountQuotasDecoded0?.append(structure0)
                }
            }
        }
        accountQuotas = accountQuotasDecoded0
        let uniqueAccountIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uniqueAccountIdentifier)
        uniqueAccountIdentifier = uniqueAccountIdentifierDecoded
    }
}

enum DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicableIndividualAssessmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let sourceEngineName = self.sourceEngineName {
            try encodeContainer.encode(sourceEngineName, forKey: .sourceEngineName)
        }
        if let targetEngineName = self.targetEngineName {
            try encodeContainer.encode(targetEngineName, forKey: .targetEngineName)
        }
    }
}

extension DescribeApplicableIndividualAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeApplicableIndividualAssessmentsInput: Swift.Equatable {
    /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?
    /// Name of the migration type that each provided individual assessment must support.
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// ARN of a replication instance on which you want to base the default list of individual assessments.
    public var replicationInstanceArn: Swift.String?
    /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
    public var replicationTaskArn: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a source.
    public var sourceEngineName: Swift.String?
    /// Name of a database engine that the specified replication instance supports as a target.
    public var targetEngineName: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        sourceEngineName: Swift.String? = nil,
        targetEngineName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationType = migrationType
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationTaskArn = replicationTaskArn
        self.sourceEngineName = sourceEngineName
        self.targetEngineName = targetEngineName
    }
}

struct DescribeApplicableIndividualAssessmentsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let replicationInstanceArn: Swift.String?
    let sourceEngineName: Swift.String?
    let targetEngineName: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationType = "MigrationType"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case sourceEngineName = "SourceEngineName"
        case targetEngineName = "TargetEngineName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let sourceEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineName)
        sourceEngineName = sourceEngineNameDecoded
        let targetEngineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEngineName)
        targetEngineName = targetEngineNameDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeApplicableIndividualAssessmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicableIndividualAssessmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.individualAssessmentNames = output.individualAssessmentNames
            self.marker = output.marker
        } else {
            self.individualAssessmentNames = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeApplicableIndividualAssessmentsOutput: Swift.Equatable {
    /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see [Working with premigration assessment runs](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.AssessmentReport.html) in the Database Migration Service User Guide.
    public var individualAssessmentNames: [Swift.String]?
    /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?

    public init(
        individualAssessmentNames: [Swift.String]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.individualAssessmentNames = individualAssessmentNames
        self.marker = marker
    }
}

struct DescribeApplicableIndividualAssessmentsOutputBody: Swift.Equatable {
    let individualAssessmentNames: [Swift.String]?
    let marker: Swift.String?
}

extension DescribeApplicableIndividualAssessmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentNames = "IndividualAssessmentNames"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .individualAssessmentNames)
        var individualAssessmentNamesDecoded0:[Swift.String]? = nil
        if let individualAssessmentNamesContainer = individualAssessmentNamesContainer {
            individualAssessmentNamesDecoded0 = [Swift.String]()
            for string0 in individualAssessmentNamesContainer {
                if let string0 = string0 {
                    individualAssessmentNamesDecoded0?.append(string0)
                }
            }
        }
        individualAssessmentNames = individualAssessmentNamesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeApplicableIndividualAssessmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCertificatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCertificatesInput: Swift.Equatable {
    /// Filters applied to the certificates described in the form of key-value pairs. Valid values are certificate-arn and certificate-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 10
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeCertificatesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeCertificatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCertificatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCertificatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

public struct DescribeCertificatesOutput: Swift.Equatable {
    /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
    public var certificates: [DatabaseMigrationClientTypes.Certificate]?
    /// The pagination token.
    public var marker: Swift.String?

    public init(
        certificates: [DatabaseMigrationClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let certificates: [DatabaseMigrationClientTypes.Certificate]?
}

extension DescribeCertificatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let certificatesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Certificate?].self, forKey: .certificates)
        var certificatesDecoded0:[DatabaseMigrationClientTypes.Certificate]? = nil
        if let certificatesContainer = certificatesContainer {
            certificatesDecoded0 = [DatabaseMigrationClientTypes.Certificate]()
            for structure0 in certificatesContainer {
                if let structure0 = structure0 {
                    certificatesDecoded0?.append(structure0)
                }
            }
        }
        certificates = certificatesDecoded0
    }
}

enum DescribeCertificatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeConnectionsInput: Swift.Equatable {
    /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeConnectionsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeConnectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.marker = output.marker
        } else {
            self.connections = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeConnectionsOutput: Swift.Equatable {
    /// A description of the connections.
    public var connections: [DatabaseMigrationClientTypes.Connection]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        connections: [DatabaseMigrationClientTypes.Connection]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.connections = connections
        self.marker = marker
    }
}

struct DescribeConnectionsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let connections: [DatabaseMigrationClientTypes.Connection]?
}

extension DescribeConnectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let connectionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Connection?].self, forKey: .connections)
        var connectionsDecoded0:[DatabaseMigrationClientTypes.Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [DatabaseMigrationClientTypes.Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
    }
}

enum DescribeConnectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConversionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeConversionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConversionConfigurationInput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) for the schema conversion project to describe.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeConversionConfigurationInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
}

extension DescribeConversionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
    }
}

extension DescribeConversionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConversionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.conversionConfiguration = output.conversionConfiguration
            self.migrationProjectIdentifier = output.migrationProjectIdentifier
        } else {
            self.conversionConfiguration = nil
            self.migrationProjectIdentifier = nil
        }
    }
}

public struct DescribeConversionConfigurationOutput: Swift.Equatable {
    /// The configuration parameters for the schema conversion project.
    public var conversionConfiguration: Swift.String?
    /// The name or Amazon Resource Name (ARN) for the schema conversion project.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        conversionConfiguration: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.conversionConfiguration = conversionConfiguration
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeConversionConfigurationOutputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let conversionConfiguration: Swift.String?
}

extension DescribeConversionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionConfiguration = "ConversionConfiguration"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let conversionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionConfiguration)
        conversionConfiguration = conversionConfigurationDecoded
    }
}

enum DescribeConversionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDataProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeDataProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDataProvidersInput: Swift.Equatable {
    /// Filters applied to the data providers described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeDataProvidersInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeDataProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDataProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDataProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataProviders = output.dataProviders
            self.marker = output.marker
        } else {
            self.dataProviders = nil
            self.marker = nil
        }
    }
}

public struct DescribeDataProvidersOutput: Swift.Equatable {
    /// A description of data providers.
    public var dataProviders: [DatabaseMigrationClientTypes.DataProvider]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?

    public init(
        dataProviders: [DatabaseMigrationClientTypes.DataProvider]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dataProviders = dataProviders
        self.marker = marker
    }
}

struct DescribeDataProvidersOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let dataProviders: [DatabaseMigrationClientTypes.DataProvider]?
}

extension DescribeDataProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviders = "DataProviders"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let dataProvidersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProvider?].self, forKey: .dataProviders)
        var dataProvidersDecoded0:[DatabaseMigrationClientTypes.DataProvider]? = nil
        if let dataProvidersContainer = dataProvidersContainer {
            dataProvidersDecoded0 = [DatabaseMigrationClientTypes.DataProvider]()
            for structure0 in dataProvidersContainer {
                if let structure0 = structure0 {
                    dataProvidersDecoded0?.append(structure0)
                }
            }
        }
        dataProviders = dataProvidersDecoded0
    }
}

enum DescribeDataProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEndpointSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEndpointSettingsInput: Swift.Equatable {
    /// The database engine used for your source or target endpoint.
    /// This member is required.
    public var engineName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        engineName: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointSettingsInputBody: Swift.Equatable {
    let engineName: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineName = "EngineName"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEndpointSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpointSettings = output.endpointSettings
            self.marker = output.marker
        } else {
            self.endpointSettings = nil
            self.marker = nil
        }
    }
}

public struct DescribeEndpointSettingsOutput: Swift.Equatable {
    /// Descriptions of the endpoint settings available for your source or target database engine.
    public var endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpointSettings = endpointSettings
        self.marker = marker
    }
}

struct DescribeEndpointSettingsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let endpointSettings: [DatabaseMigrationClientTypes.EndpointSetting]?
}

extension DescribeEndpointSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointSettings = "EndpointSettings"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointSettingsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EndpointSetting?].self, forKey: .endpointSettings)
        var endpointSettingsDecoded0:[DatabaseMigrationClientTypes.EndpointSetting]? = nil
        if let endpointSettingsContainer = endpointSettingsContainer {
            endpointSettingsDecoded0 = [DatabaseMigrationClientTypes.EndpointSetting]()
            for structure0 in endpointSettingsContainer {
                if let structure0 = structure0 {
                    endpointSettingsDecoded0?.append(structure0)
                }
            }
        }
        endpointSettings = endpointSettingsDecoded0
    }
}

enum DescribeEndpointSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEndpointTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEndpointTypesInput: Swift.Equatable {
    /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointTypesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEndpointTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.supportedEndpointTypes = output.supportedEndpointTypes
        } else {
            self.marker = nil
            self.supportedEndpointTypes = nil
        }
    }
}

///
public struct DescribeEndpointTypesOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The types of endpoints that are supported.
    public var supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?

    public init(
        marker: Swift.String? = nil,
        supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
    )
    {
        self.marker = marker
        self.supportedEndpointTypes = supportedEndpointTypes
    }
}

struct DescribeEndpointTypesOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let supportedEndpointTypes: [DatabaseMigrationClientTypes.SupportedEndpointType]?
}

extension DescribeEndpointTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case supportedEndpointTypes = "SupportedEndpointTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let supportedEndpointTypesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SupportedEndpointType?].self, forKey: .supportedEndpointTypes)
        var supportedEndpointTypesDecoded0:[DatabaseMigrationClientTypes.SupportedEndpointType]? = nil
        if let supportedEndpointTypesContainer = supportedEndpointTypesContainer {
            supportedEndpointTypesDecoded0 = [DatabaseMigrationClientTypes.SupportedEndpointType]()
            for structure0 in supportedEndpointTypesContainer {
                if let structure0 = structure0 {
                    supportedEndpointTypesDecoded0?.append(structure0)
                }
            }
        }
        supportedEndpointTypes = supportedEndpointTypesDecoded0
    }
}

enum DescribeEndpointTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEndpointsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEndpointsInput: Swift.Equatable {
    /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEndpointsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEndpointsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.marker = output.marker
        } else {
            self.endpoints = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEndpointsOutput: Swift.Equatable {
    /// Endpoint description.
    public var endpoints: [DatabaseMigrationClientTypes.Endpoint]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        endpoints: [DatabaseMigrationClientTypes.Endpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.marker = marker
    }
}

struct DescribeEndpointsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let endpoints: [DatabaseMigrationClientTypes.Endpoint]?
}

extension DescribeEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[DatabaseMigrationClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [DatabaseMigrationClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

enum DescribeEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEngineVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEngineVersionsInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeEngineVersionsInputBody: Swift.Equatable {
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEngineVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEngineVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.marker = output.marker
        } else {
            self.engineVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeEngineVersionsOutput: Swift.Equatable {
    /// Returned EngineVersion objects that describe the replication instance engine versions used in the project.
    public var engineVersions: [DatabaseMigrationClientTypes.EngineVersion]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        engineVersions: [DatabaseMigrationClientTypes.EngineVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.marker = marker
    }
}

struct DescribeEngineVersionsOutputBody: Swift.Equatable {
    let engineVersions: [DatabaseMigrationClientTypes.EngineVersion]?
    let marker: Swift.String?
}

extension DescribeEngineVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions = "EngineVersions"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[DatabaseMigrationClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [DatabaseMigrationClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeEngineVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }
}

extension DescribeEventCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// Filters applied to the event categories.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

struct DescribeEventCategoriesInputBody: Swift.Equatable {
    let sourceType: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeEventCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case sourceType = "SourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeEventCategoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventCategoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoryGroupList = output.eventCategoryGroupList
        } else {
            self.eventCategoryGroupList = nil
        }
    }
}

///
public struct DescribeEventCategoriesOutput: Swift.Equatable {
    /// A list of event categories.
    public var eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?

    public init(
        eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
    )
    {
        self.eventCategoryGroupList = eventCategoryGroupList
    }
}

struct DescribeEventCategoriesOutputBody: Swift.Equatable {
    let eventCategoryGroupList: [DatabaseMigrationClientTypes.EventCategoryGroup]?
}

extension DescribeEventCategoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoryGroupList = "EventCategoryGroupList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventCategoryGroupListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventCategoryGroup?].self, forKey: .eventCategoryGroupList)
        var eventCategoryGroupListDecoded0:[DatabaseMigrationClientTypes.EventCategoryGroup]? = nil
        if let eventCategoryGroupListContainer = eventCategoryGroupListContainer {
            eventCategoryGroupListDecoded0 = [DatabaseMigrationClientTypes.EventCategoryGroup]()
            for structure0 in eventCategoryGroupListContainer {
                if let structure0 = structure0 {
                    eventCategoryGroupListDecoded0?.append(structure0)
                }
            }
        }
        eventCategoryGroupList = eventCategoryGroupListDecoded0
    }
}

enum DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// Filters applied to event subscriptions. Valid filter names: event-subscription-arn | event-subscription-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the DMS event subscription to be described.
    public var subscriptionName: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

struct DescribeEventSubscriptionsInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case subscriptionName = "SubscriptionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEventSubscriptionsOutput: Swift.Equatable {
    /// A list of event subscriptions.
    public var eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let eventSubscriptionsList: [DatabaseMigrationClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventSubscriptionsListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.EventSubscription?].self, forKey: .eventSubscriptionsList)
        var eventSubscriptionsListDecoded0:[DatabaseMigrationClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
            eventSubscriptionsListDecoded0 = [DatabaseMigrationClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsListContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsListDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptionsList = eventSubscriptionsListDecoded0
    }
}

enum DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeEventsInput: Swift.Equatable {
    /// The duration of the events to be listed.
    public var duration: Swift.Int?
    /// The end time for the events to be listed.
    public var endTime: ClientRuntime.Date?
    /// A list of event categories for the source type that you've chosen.
    public var eventCategories: [Swift.String]?
    /// Filters applied to events. The only valid filter is replication-instance-id.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of an event source.
    public var sourceIdentifier: Swift.String?
    /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
    public var sourceType: DatabaseMigrationClientTypes.SourceType?
    /// The start time for the events to be listed.
    public var startTime: ClientRuntime.Date?

    public init(
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: DatabaseMigrationClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let sourceIdentifier: Swift.String?
    let sourceType: DatabaseMigrationClientTypes.SourceType?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let duration: Swift.Int?
    let eventCategories: [Swift.String]?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case eventCategories = "EventCategories"
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeEventsOutput: Swift.Equatable {
    /// The events described.
    public var events: [DatabaseMigrationClientTypes.Event]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init(
        events: [DatabaseMigrationClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let events: [DatabaseMigrationClientTypes.Event]?
}

extension DescribeEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let eventsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[DatabaseMigrationClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [DatabaseMigrationClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

enum DescribeEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeExtensionPackAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeExtensionPackAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExtensionPackAssociationsInput: Swift.Equatable {
    /// Filters applied to the extension pack associations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The name or Amazon Resource Name (ARN) for the migration project.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeExtensionPackAssociationsInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeExtensionPackAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeExtensionPackAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeExtensionPackAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeExtensionPackAssociationsOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of extension pack associations for the specified migration project.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeExtensionPackAssociationsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeExtensionPackAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeExtensionPackAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetAdvisorCollectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorCollectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorCollectorsInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those collectors that meet the filter criteria:
    ///
    /// * collector-referenced-id â€“ The ID of the collector agent, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    /// * collector-name â€“ The name of the collector agent.
    ///
    ///
    /// An example is: describe-fleet-advisor-collectors --filter Name="collector-referenced-id",Values="d4610ac5-e323-4ad9-bc50-eaf7249dfe9d"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorCollectorsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorCollectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorCollectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetAdvisorCollectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectors = output.collectors
            self.nextToken = output.nextToken
        } else {
            self.collectors = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorCollectorsOutput: Swift.Equatable {
    /// Provides descriptions of the Fleet Advisor collectors, including the collectors' name and ID, and the latest inventory data.
    public var collectors: [DatabaseMigrationClientTypes.CollectorResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        collectors: [DatabaseMigrationClientTypes.CollectorResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorCollectorsOutputBody: Swift.Equatable {
    let collectors: [DatabaseMigrationClientTypes.CollectorResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorCollectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.CollectorResponse?].self, forKey: .collectors)
        var collectorsDecoded0:[DatabaseMigrationClientTypes.CollectorResponse]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [DatabaseMigrationClientTypes.CollectorResponse]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetAdvisorCollectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetAdvisorDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorDatabasesInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those databases that meet the filter criteria:
    ///
    /// * database-id â€“ The ID of the database.
    ///
    /// * database-name â€“ The name of the database.
    ///
    /// * database-engine â€“ The name of the database engine.
    ///
    /// * server-ip-address â€“ The IP address of the database server.
    ///
    /// * database-ip-address â€“ The IP address of the database.
    ///
    /// * collector-name â€“ The name of the associated Fleet Advisor collector.
    ///
    ///
    /// An example is: describe-fleet-advisor-databases --filter Name="database-id",Values="45"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorDatabasesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetAdvisorDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorDatabasesOutput: Swift.Equatable {
    /// Provides descriptions of the Fleet Advisor collector databases, including the database's collector, ID, and name.
    public var databases: [DatabaseMigrationClientTypes.DatabaseResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        databases: [DatabaseMigrationClientTypes.DatabaseResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorDatabasesOutputBody: Swift.Equatable {
    let databases: [DatabaseMigrationClientTypes.DatabaseResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DatabaseResponse?].self, forKey: .databases)
        var databasesDecoded0:[DatabaseMigrationClientTypes.DatabaseResponse]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [DatabaseMigrationClientTypes.DatabaseResponse]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetAdvisorDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorLsaAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorLsaAnalysisInput: Swift.Equatable {
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorLsaAnalysisInputBody: Swift.Equatable {
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorLsaAnalysisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorLsaAnalysisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetAdvisorLsaAnalysisOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysis = output.analysis
            self.nextToken = output.nextToken
        } else {
            self.analysis = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorLsaAnalysisOutput: Swift.Equatable {
    /// A list of FleetAdvisorLsaAnalysisResponse objects.
    public var analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysis = analysis
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorLsaAnalysisOutputBody: Swift.Equatable {
    let analysis: [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorLsaAnalysisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysis = "Analysis"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse?].self, forKey: .analysis)
        var analysisDecoded0:[DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]? = nil
        if let analysisContainer = analysisContainer {
            analysisDecoded0 = [DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse]()
            for structure0 in analysisContainer {
                if let structure0 = structure0 {
                    analysisDecoded0?.append(structure0)
                }
            }
        }
        analysis = analysisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetAdvisorLsaAnalysisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorSchemaObjectSummaryInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those schema objects that meet the filter criteria:
    ///
    /// * schema-id â€“ The ID of the schema, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.
    ///
    ///
    /// Example: describe-fleet-advisor-schema-object-summary --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemaObjectSummaryInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemaObjectSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetAdvisorSchemaObjectSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetAdvisorSchemaObjects = output.fleetAdvisorSchemaObjects
            self.nextToken = output.nextToken
        } else {
            self.fleetAdvisorSchemaObjects = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorSchemaObjectSummaryOutput: Swift.Equatable {
    /// A collection of FleetAdvisorSchemaObjectResponse objects.
    public var fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjects
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemaObjectSummaryOutputBody: Swift.Equatable {
    let fleetAdvisorSchemaObjects: [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemaObjectSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetAdvisorSchemaObjects = "FleetAdvisorSchemaObjects"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetAdvisorSchemaObjectsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse?].self, forKey: .fleetAdvisorSchemaObjects)
        var fleetAdvisorSchemaObjectsDecoded0:[DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]? = nil
        if let fleetAdvisorSchemaObjectsContainer = fleetAdvisorSchemaObjectsContainer {
            fleetAdvisorSchemaObjectsDecoded0 = [DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse]()
            for structure0 in fleetAdvisorSchemaObjectsContainer {
                if let structure0 = structure0 {
                    fleetAdvisorSchemaObjectsDecoded0?.append(structure0)
                }
            }
        }
        fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetAdvisorSchemaObjectSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFleetAdvisorSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetAdvisorSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetAdvisorSchemasInput: Swift.Equatable {
    /// If you specify any of the following filters, the output includes information for only those schemas that meet the filter criteria:
    ///
    /// * complexity â€“ The schema's complexity, for example Simple.
    ///
    /// * database-id â€“ The ID of the schema's database.
    ///
    /// * database-ip-address â€“ The IP address of the schema's database.
    ///
    /// * database-name â€“ The name of the schema's database.
    ///
    /// * database-engine â€“ The name of the schema database's engine.
    ///
    /// * original-schema-name â€“ The name of the schema's database's main schema.
    ///
    /// * schema-id â€“ The ID of the schema, for example 15.
    ///
    /// * schema-name â€“ The name of the schema.
    ///
    /// * server-ip-address â€“ The IP address of the schema database's server.
    ///
    ///
    /// An example is: describe-fleet-advisor-schemas --filter Name="schema-id",Values="50"
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Sets the maximum number of records returned in the response.
    public var maxRecords: Swift.Int?
    /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemasInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetAdvisorSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFleetAdvisorSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetAdvisorSchemas = output.fleetAdvisorSchemas
            self.nextToken = output.nextToken
        } else {
            self.fleetAdvisorSchemas = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetAdvisorSchemasOutput: Swift.Equatable {
    /// A collection of SchemaResponse objects.
    public var fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetAdvisorSchemas = fleetAdvisorSchemas
        self.nextToken = nextToken
    }
}

struct DescribeFleetAdvisorSchemasOutputBody: Swift.Equatable {
    let fleetAdvisorSchemas: [DatabaseMigrationClientTypes.SchemaResponse]?
    let nextToken: Swift.String?
}

extension DescribeFleetAdvisorSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetAdvisorSchemas = "FleetAdvisorSchemas"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetAdvisorSchemasContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaResponse?].self, forKey: .fleetAdvisorSchemas)
        var fleetAdvisorSchemasDecoded0:[DatabaseMigrationClientTypes.SchemaResponse]? = nil
        if let fleetAdvisorSchemasContainer = fleetAdvisorSchemasContainer {
            fleetAdvisorSchemasDecoded0 = [DatabaseMigrationClientTypes.SchemaResponse]()
            for structure0 in fleetAdvisorSchemasContainer {
                if let structure0 = structure0 {
                    fleetAdvisorSchemasDecoded0?.append(structure0)
                }
            }
        }
        fleetAdvisorSchemas = fleetAdvisorSchemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFleetAdvisorSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeInstanceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceProfilesInput: Swift.Equatable {
    /// Filters applied to the instance profiles described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeInstanceProfilesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeInstanceProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeInstanceProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfiles = output.instanceProfiles
            self.marker = output.marker
        } else {
            self.instanceProfiles = nil
            self.marker = nil
        }
    }
}

public struct DescribeInstanceProfilesOutput: Swift.Equatable {
    /// A description of instance profiles.
    public var instanceProfiles: [DatabaseMigrationClientTypes.InstanceProfile]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?

    public init(
        instanceProfiles: [DatabaseMigrationClientTypes.InstanceProfile]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.marker = marker
    }
}

struct DescribeInstanceProfilesOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let instanceProfiles: [DatabaseMigrationClientTypes.InstanceProfile]?
}

extension DescribeInstanceProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfiles = "InstanceProfiles"
        case marker = "Marker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let instanceProfilesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.InstanceProfile?].self, forKey: .instanceProfiles)
        var instanceProfilesDecoded0:[DatabaseMigrationClientTypes.InstanceProfile]? = nil
        if let instanceProfilesContainer = instanceProfilesContainer {
            instanceProfilesDecoded0 = [DatabaseMigrationClientTypes.InstanceProfile]()
            for structure0 in instanceProfilesContainer {
                if let structure0 = structure0 {
                    instanceProfilesDecoded0?.append(structure0)
                }
            }
        }
        instanceProfiles = instanceProfilesDecoded0
    }
}

enum DescribeInstanceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetadataModelAssessmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeMetadataModelAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetadataModelAssessmentsInput: Swift.Equatable {
    /// Filters applied to the metadata model assessments described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The name or Amazon Resource Name (ARN) of the migration project.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeMetadataModelAssessmentsInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeMetadataModelAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeMetadataModelAssessmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetadataModelAssessmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeMetadataModelAssessmentsOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model assessments for the specified migration project.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeMetadataModelAssessmentsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeMetadataModelAssessmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeMetadataModelAssessmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetadataModelConversionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeMetadataModelConversionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetadataModelConversionsInput: Swift.Equatable {
    /// Filters applied to the metadata model conversions described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeMetadataModelConversionsInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeMetadataModelConversionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeMetadataModelConversionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetadataModelConversionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeMetadataModelConversionsOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model conversions.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeMetadataModelConversionsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeMetadataModelConversionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeMetadataModelConversionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetadataModelExportsAsScriptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeMetadataModelExportsAsScriptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetadataModelExportsAsScriptInput: Swift.Equatable {
    /// Filters applied to the metadata model exports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeMetadataModelExportsAsScriptInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeMetadataModelExportsAsScriptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeMetadataModelExportsAsScriptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetadataModelExportsAsScriptOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeMetadataModelExportsAsScriptOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model exports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeMetadataModelExportsAsScriptOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeMetadataModelExportsAsScriptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeMetadataModelExportsAsScriptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetadataModelExportsToTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeMetadataModelExportsToTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetadataModelExportsToTargetInput: Swift.Equatable {
    /// Filters applied to the metadata model exports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeMetadataModelExportsToTargetInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeMetadataModelExportsToTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeMetadataModelExportsToTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetadataModelExportsToTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeMetadataModelExportsToTargetOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model exports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeMetadataModelExportsToTargetOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeMetadataModelExportsToTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeMetadataModelExportsToTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMetadataModelImportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension DescribeMetadataModelImportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMetadataModelImportsInput: Swift.Equatable {
    /// Filters applied to the metadata model imports described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model imports.
    public var maxRecords: Swift.Int?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct DescribeMetadataModelImportsInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribeMetadataModelImportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribeMetadataModelImportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMetadataModelImportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.requests = output.requests
        } else {
            self.marker = nil
            self.requests = nil
        }
    }
}

public struct DescribeMetadataModelImportsOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A paginated list of metadata model imports.
    public var requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?

    public init(
        marker: Swift.String? = nil,
        requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
    )
    {
        self.marker = marker
        self.requests = requests
    }
}

struct DescribeMetadataModelImportsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let requests: [DatabaseMigrationClientTypes.SchemaConversionRequest]?
}

extension DescribeMetadataModelImportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case requests = "Requests"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let requestsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.SchemaConversionRequest?].self, forKey: .requests)
        var requestsDecoded0:[DatabaseMigrationClientTypes.SchemaConversionRequest]? = nil
        if let requestsContainer = requestsContainer {
            requestsDecoded0 = [DatabaseMigrationClientTypes.SchemaConversionRequest]()
            for structure0 in requestsContainer {
                if let structure0 = structure0 {
                    requestsDecoded0?.append(structure0)
                }
            }
        }
        requests = requestsDecoded0
    }
}

enum DescribeMetadataModelImportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMigrationProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeMigrationProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMigrationProjectsInput: Swift.Equatable {
    /// Filters applied to the migration projects described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, DMS includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeMigrationProjectsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeMigrationProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeMigrationProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMigrationProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.migrationProjects = output.migrationProjects
        } else {
            self.marker = nil
            self.migrationProjects = nil
        }
    }
}

public struct DescribeMigrationProjectsOutput: Swift.Equatable {
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If Marker is returned by a previous response, there are more results available. The value of Marker is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var marker: Swift.String?
    /// A description of migration projects.
    public var migrationProjects: [DatabaseMigrationClientTypes.MigrationProject]?

    public init(
        marker: Swift.String? = nil,
        migrationProjects: [DatabaseMigrationClientTypes.MigrationProject]? = nil
    )
    {
        self.marker = marker
        self.migrationProjects = migrationProjects
    }
}

struct DescribeMigrationProjectsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let migrationProjects: [DatabaseMigrationClientTypes.MigrationProject]?
}

extension DescribeMigrationProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case migrationProjects = "MigrationProjects"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let migrationProjectsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.MigrationProject?].self, forKey: .migrationProjects)
        var migrationProjectsDecoded0:[DatabaseMigrationClientTypes.MigrationProject]? = nil
        if let migrationProjectsContainer = migrationProjectsContainer {
            migrationProjectsDecoded0 = [DatabaseMigrationClientTypes.MigrationProject]()
            for structure0 in migrationProjectsContainer {
                if let structure0 = structure0 {
                    migrationProjectsDecoded0?.append(structure0)
                }
            }
        }
        migrationProjects = migrationProjectsDecoded0
    }
}

enum DescribeMigrationProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrderableReplicationInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeOrderableReplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeOrderableReplicationInstancesInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeOrderableReplicationInstancesInputBody: Swift.Equatable {
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeOrderableReplicationInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrderableReplicationInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableReplicationInstances = output.orderableReplicationInstances
        } else {
            self.marker = nil
            self.orderableReplicationInstances = nil
        }
    }
}

///
public struct DescribeOrderableReplicationInstancesOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The order-able replication instances available.
    public var orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?

    public init(
        marker: Swift.String? = nil,
        orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.orderableReplicationInstances = orderableReplicationInstances
    }
}

struct DescribeOrderableReplicationInstancesOutputBody: Swift.Equatable {
    let orderableReplicationInstances: [DatabaseMigrationClientTypes.OrderableReplicationInstance]?
    let marker: Swift.String?
}

extension DescribeOrderableReplicationInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableReplicationInstances = "OrderableReplicationInstances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderableReplicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.OrderableReplicationInstance?].self, forKey: .orderableReplicationInstances)
        var orderableReplicationInstancesDecoded0:[DatabaseMigrationClientTypes.OrderableReplicationInstance]? = nil
        if let orderableReplicationInstancesContainer = orderableReplicationInstancesContainer {
            orderableReplicationInstancesDecoded0 = [DatabaseMigrationClientTypes.OrderableReplicationInstance]()
            for structure0 in orderableReplicationInstancesContainer {
                if let structure0 = structure0 {
                    orderableReplicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        orderableReplicationInstances = orderableReplicationInstancesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeOrderableReplicationInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    ///
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribePendingMaintenanceActionsInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let marker: Swift.String?
    let maxRecords: Swift.Int?
}

extension DescribePendingMaintenanceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
    }
}

extension DescribePendingMaintenanceActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePendingMaintenanceActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

///
public struct DescribePendingMaintenanceActionsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The pending maintenance action.
    public var pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?

    public init(
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputBody: Swift.Equatable {
    let pendingMaintenanceActions: [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]?
    let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingMaintenanceActionsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions?].self, forKey: .pendingMaintenanceActions)
        var pendingMaintenanceActionsDecoded0:[DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]? = nil
        if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
            pendingMaintenanceActionsDecoded0 = [DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions]()
            for structure0 in pendingMaintenanceActionsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActions = pendingMaintenanceActionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecommendationLimitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeRecommendationLimitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecommendationLimitationsInput: Swift.Equatable {
    /// Filters applied to the limitations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeRecommendationLimitationsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeRecommendationLimitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecommendationLimitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecommendationLimitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.limitations = output.limitations
            self.nextToken = output.nextToken
        } else {
            self.limitations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeRecommendationLimitationsOutput: Swift.Equatable {
    /// The list of limitations for recommendations of target Amazon Web Services engines.
    public var limitations: [DatabaseMigrationClientTypes.Limitation]?
    /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        limitations: [DatabaseMigrationClientTypes.Limitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.limitations = limitations
        self.nextToken = nextToken
    }
}

struct DescribeRecommendationLimitationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let limitations: [DatabaseMigrationClientTypes.Limitation]?
}

extension DescribeRecommendationLimitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitations = "Limitations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitationsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Limitation?].self, forKey: .limitations)
        var limitationsDecoded0:[DatabaseMigrationClientTypes.Limitation]? = nil
        if let limitationsContainer = limitationsContainer {
            limitationsDecoded0 = [DatabaseMigrationClientTypes.Limitation]()
            for structure0 in limitationsContainer {
                if let structure0 = structure0 {
                    limitationsDecoded0?.append(structure0)
                }
            }
        }
        limitations = limitationsDecoded0
    }
}

enum DescribeRecommendationLimitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRecommendationsInput: Swift.Equatable {
    /// Filters applied to the target engine recommendations described in the form of key-value pairs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
    public var maxRecords: Swift.Int?
    /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    public var nextToken: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        maxRecords: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxRecords = maxRecords
        self.nextToken = nextToken
    }
}

struct DescribeRecommendationsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxRecords = "MaxRecords"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct DescribeRecommendationsOutput: Swift.Equatable {
    /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
    public var nextToken: Swift.String?
    /// The list of recommendations of target engines that Fleet Advisor created for the source database.
    public var recommendations: [DatabaseMigrationClientTypes.Recommendation]?

    public init(
        nextToken: Swift.String? = nil,
        recommendations: [DatabaseMigrationClientTypes.Recommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct DescribeRecommendationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recommendations: [DatabaseMigrationClientTypes.Recommendation]?
}

extension DescribeRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recommendations = "Recommendations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[DatabaseMigrationClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [DatabaseMigrationClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
    }
}

enum DescribeRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRefreshSchemasStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
    }
}

extension DescribeRefreshSchemasStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeRefreshSchemasStatusInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

struct DescribeRefreshSchemasStatusInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
}

extension DescribeRefreshSchemasStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension DescribeRefreshSchemasStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRefreshSchemasStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

///
public struct DescribeRefreshSchemasStatusOutput: Swift.Equatable {
    /// The status of the schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init(
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct DescribeRefreshSchemasStatusOutputBody: Swift.Equatable {
    let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension DescribeRefreshSchemasStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

enum DescribeRefreshSchemasStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationConfigsInput: Swift.Equatable {
    /// Filters applied to the replication configs.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationConfigsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationConfigs = output.replicationConfigs
        } else {
            self.marker = nil
            self.replicationConfigs = nil
        }
    }
}

///
public struct DescribeReplicationConfigsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// Returned configuration parameters that describe each provisioned DMS Serverless replication.
    public var replicationConfigs: [DatabaseMigrationClientTypes.ReplicationConfig]?

    public init(
        marker: Swift.String? = nil,
        replicationConfigs: [DatabaseMigrationClientTypes.ReplicationConfig]? = nil
    )
    {
        self.marker = marker
        self.replicationConfigs = replicationConfigs
    }
}

struct DescribeReplicationConfigsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationConfigs: [DatabaseMigrationClientTypes.ReplicationConfig]?
}

extension DescribeReplicationConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationConfigs = "ReplicationConfigs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationConfigsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationConfig?].self, forKey: .replicationConfigs)
        var replicationConfigsDecoded0:[DatabaseMigrationClientTypes.ReplicationConfig]? = nil
        if let replicationConfigsContainer = replicationConfigsContainer {
            replicationConfigsDecoded0 = [DatabaseMigrationClientTypes.ReplicationConfig]()
            for structure0 in replicationConfigsContainer {
                if let structure0 = structure0 {
                    replicationConfigsDecoded0?.append(structure0)
                }
            }
        }
        replicationConfigs = replicationConfigsDecoded0
    }
}

enum DescribeReplicationConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationInstanceTaskLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension DescribeReplicationInstanceTaskLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReplicationInstanceTaskLogsInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct DescribeReplicationInstanceTaskLogsInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstanceTaskLogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationInstanceTaskLogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstanceArn = output.replicationInstanceArn
            self.replicationInstanceTaskLogs = output.replicationInstanceTaskLogs
        } else {
            self.marker = nil
            self.replicationInstanceArn = nil
            self.replicationInstanceTaskLogs = nil
        }
    }
}

public struct DescribeReplicationInstanceTaskLogsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    public var replicationInstanceArn: Swift.String?
    /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes).
    public var replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?

    public init(
        marker: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
    )
    {
        self.marker = marker
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
    }
}

struct DescribeReplicationInstanceTaskLogsOutputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let replicationInstanceTaskLogs: [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]?
    let marker: Swift.String?
}

extension DescribeReplicationInstanceTaskLogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstanceTaskLogsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstanceTaskLog?].self, forKey: .replicationInstanceTaskLogs)
        var replicationInstanceTaskLogsDecoded0:[DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]? = nil
        if let replicationInstanceTaskLogsContainer = replicationInstanceTaskLogsContainer {
            replicationInstanceTaskLogsDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstanceTaskLog]()
            for structure0 in replicationInstanceTaskLogsContainer {
                if let structure0 = structure0 {
                    replicationInstanceTaskLogsDecoded0?.append(structure0)
                }
            }
        }
        replicationInstanceTaskLogs = replicationInstanceTaskLogsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeReplicationInstanceTaskLogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationInstancesInput: Swift.Equatable {
    /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationInstancesInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationInstances = output.replicationInstances
        } else {
            self.marker = nil
            self.replicationInstances = nil
        }
    }
}

///
public struct DescribeReplicationInstancesOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The replication instances described.
    public var replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?

    public init(
        marker: Swift.String? = nil,
        replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]? = nil
    )
    {
        self.marker = marker
        self.replicationInstances = replicationInstances
    }
}

struct DescribeReplicationInstancesOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationInstances: [DatabaseMigrationClientTypes.ReplicationInstance]?
}

extension DescribeReplicationInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationInstances = "ReplicationInstances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationInstancesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationInstance?].self, forKey: .replicationInstances)
        var replicationInstancesDecoded0:[DatabaseMigrationClientTypes.ReplicationInstance]? = nil
        if let replicationInstancesContainer = replicationInstancesContainer {
            replicationInstancesDecoded0 = [DatabaseMigrationClientTypes.ReplicationInstance]()
            for structure0 in replicationInstancesContainer {
                if let structure0 = structure0 {
                    replicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        replicationInstances = replicationInstancesDecoded0
    }
}

enum DescribeReplicationInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationSubnetGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationSubnetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationSubnetGroupsInput: Swift.Equatable {
    /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationSubnetGroupsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationSubnetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationSubnetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationSubnetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationSubnetGroups = output.replicationSubnetGroups
        } else {
            self.marker = nil
            self.replicationSubnetGroups = nil
        }
    }
}

///
public struct DescribeReplicationSubnetGroupsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication subnet groups.
    public var replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?

    public init(
        marker: Swift.String? = nil,
        replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
    )
    {
        self.marker = marker
        self.replicationSubnetGroups = replicationSubnetGroups
    }
}

struct DescribeReplicationSubnetGroupsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationSubnetGroups: [DatabaseMigrationClientTypes.ReplicationSubnetGroup]?
}

extension DescribeReplicationSubnetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationSubnetGroups = "ReplicationSubnetGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationSubnetGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationSubnetGroup?].self, forKey: .replicationSubnetGroups)
        var replicationSubnetGroupsDecoded0:[DatabaseMigrationClientTypes.ReplicationSubnetGroup]? = nil
        if let replicationSubnetGroupsContainer = replicationSubnetGroupsContainer {
            replicationSubnetGroupsDecoded0 = [DatabaseMigrationClientTypes.ReplicationSubnetGroup]()
            for structure0 in replicationSubnetGroupsContainer {
                if let structure0 = structure0 {
                    replicationSubnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        replicationSubnetGroups = replicationSubnetGroupsDecoded0
    }
}

enum DescribeReplicationSubnetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationTableStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
    }
}

extension DescribeReplicationTableStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTableStatisticsInput: Swift.Equatable {
    /// Filters applied to the replication table statistics.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?
    /// The replication config to describe.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationConfigArn = replicationConfigArn
    }
}

struct DescribeReplicationTableStatisticsInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeReplicationTableStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeReplicationTableStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationTableStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationConfigArn = output.replicationConfigArn
            self.replicationTableStatistics = output.replicationTableStatistics
        } else {
            self.marker = nil
            self.replicationConfigArn = nil
            self.replicationTableStatistics = nil
        }
    }
}

///
public struct DescribeReplicationTableStatisticsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name of the replication config.
    public var replicationConfigArn: Swift.String?
    /// Returns table statistics on the replication, including table name, rows inserted, rows updated, and rows deleted.
    public var replicationTableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init(
        marker: Swift.String? = nil,
        replicationConfigArn: Swift.String? = nil,
        replicationTableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationConfigArn = replicationConfigArn
        self.replicationTableStatistics = replicationTableStatistics
    }
}

struct DescribeReplicationTableStatisticsOutputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
    let marker: Swift.String?
    let replicationTableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?
}

extension DescribeReplicationTableStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationConfigArn = "ReplicationConfigArn"
        case replicationTableStatistics = "ReplicationTableStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTableStatisticsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableStatistics?].self, forKey: .replicationTableStatistics)
        var replicationTableStatisticsDecoded0:[DatabaseMigrationClientTypes.TableStatistics]? = nil
        if let replicationTableStatisticsContainer = replicationTableStatisticsContainer {
            replicationTableStatisticsDecoded0 = [DatabaseMigrationClientTypes.TableStatistics]()
            for structure0 in replicationTableStatisticsContainer {
                if let structure0 = structure0 {
                    replicationTableStatisticsDecoded0?.append(structure0)
                }
            }
        }
        replicationTableStatistics = replicationTableStatisticsDecoded0
    }
}

enum DescribeReplicationTableStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationTaskAssessmentResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DescribeReplicationTaskAssessmentResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskAssessmentResultsInput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters.
    public var replicationTaskArn: Swift.String?

    public init(
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeReplicationTaskAssessmentResultsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentResultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskAssessmentResultsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bucketName = output.bucketName
            self.marker = output.marker
            self.replicationTaskAssessmentResults = output.replicationTaskAssessmentResults
        } else {
            self.bucketName = nil
            self.marker = nil
            self.replicationTaskAssessmentResults = nil
        }
    }
}

///
public struct DescribeReplicationTaskAssessmentResultsOutput: Swift.Equatable {
    /// - The Amazon S3 bucket where the task assessment report is located.
    public var bucketName: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The task assessment report.
    public var replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?

    public init(
        bucketName: Swift.String? = nil,
        marker: Swift.String? = nil,
        replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
    )
    {
        self.bucketName = bucketName
        self.marker = marker
        self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
    }
}

struct DescribeReplicationTaskAssessmentResultsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let bucketName: Swift.String?
    let replicationTaskAssessmentResults: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]?
}

extension DescribeReplicationTaskAssessmentResultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case marker = "Marker"
        case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let replicationTaskAssessmentResultsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult?].self, forKey: .replicationTaskAssessmentResults)
        var replicationTaskAssessmentResultsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]? = nil
        if let replicationTaskAssessmentResultsContainer = replicationTaskAssessmentResultsContainer {
            replicationTaskAssessmentResultsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult]()
            for structure0 in replicationTaskAssessmentResultsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentResultsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentResults = replicationTaskAssessmentResultsDecoded0
    }
}

enum DescribeReplicationTaskAssessmentResultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationTaskAssessmentRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationTaskAssessmentRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsInput: Swift.Equatable {
    /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskAssessmentRunsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskAssessmentRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskAssessmentRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskAssessmentRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskAssessmentRuns = output.replicationTaskAssessmentRuns
        } else {
            self.marker = nil
            self.replicationTaskAssessmentRuns = nil
        }
    }
}

///
public struct DescribeReplicationTaskAssessmentRunsOutput: Swift.Equatable {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more premigration assessment runs as specified by Filters.
    public var replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
    }
}

struct DescribeReplicationTaskAssessmentRunsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTaskAssessmentRuns: [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]?
}

extension DescribeReplicationTaskAssessmentRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskAssessmentRunsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?].self, forKey: .replicationTaskAssessmentRuns)
        var replicationTaskAssessmentRunsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]? = nil
        if let replicationTaskAssessmentRunsContainer = replicationTaskAssessmentRunsContainer {
            replicationTaskAssessmentRunsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun]()
            for structure0 in replicationTaskAssessmentRunsContainer {
                if let structure0 = structure0 {
                    replicationTaskAssessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskAssessmentRuns = replicationTaskAssessmentRunsDecoded0
    }
}

enum DescribeReplicationTaskAssessmentRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationTaskIndividualAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTaskIndividualAssessmentsInput: Swift.Equatable {
    /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationTaskIndividualAssessmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationTaskIndividualAssessmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationTaskIndividualAssessmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskIndividualAssessments = output.replicationTaskIndividualAssessments
        } else {
            self.marker = nil
            self.replicationTaskIndividualAssessments = nil
        }
    }
}

///
public struct DescribeReplicationTaskIndividualAssessmentsOutput: Swift.Equatable {
    /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
    public var marker: Swift.String?
    /// One or more individual assessments as specified by Filters.
    public var replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
    }
}

struct DescribeReplicationTaskIndividualAssessmentsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTaskIndividualAssessments: [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]?
}

extension DescribeReplicationTaskIndividualAssessmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTaskIndividualAssessmentsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment?].self, forKey: .replicationTaskIndividualAssessments)
        var replicationTaskIndividualAssessmentsDecoded0:[DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]? = nil
        if let replicationTaskIndividualAssessmentsContainer = replicationTaskIndividualAssessmentsContainer {
            replicationTaskIndividualAssessmentsDecoded0 = [DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment]()
            for structure0 in replicationTaskIndividualAssessmentsContainer {
                if let structure0 = structure0 {
                    replicationTaskIndividualAssessmentsDecoded0?.append(structure0)
                }
            }
        }
        replicationTaskIndividualAssessments = replicationTaskIndividualAssessmentsDecoded0
    }
}

enum DescribeReplicationTaskIndividualAssessmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let withoutSettings = self.withoutSettings {
            try encodeContainer.encode(withoutSettings, forKey: .withoutSettings)
        }
    }
}

extension DescribeReplicationTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationTasksInput: Swift.Equatable {
    /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
    public var withoutSettings: Swift.Bool?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        withoutSettings: Swift.Bool? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.withoutSettings = withoutSettings
    }
}

struct DescribeReplicationTasksInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let withoutSettings: Swift.Bool?
}

extension DescribeReplicationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case withoutSettings = "WithoutSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let withoutSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .withoutSettings)
        withoutSettings = withoutSettingsDecoded
    }
}

extension DescribeReplicationTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTasks = output.replicationTasks
        } else {
            self.marker = nil
            self.replicationTasks = nil
        }
    }
}

///
public struct DescribeReplicationTasksOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// A description of the replication tasks.
    public var replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?

    public init(
        marker: Swift.String? = nil,
        replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]? = nil
    )
    {
        self.marker = marker
        self.replicationTasks = replicationTasks
    }
}

struct DescribeReplicationTasksOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replicationTasks: [DatabaseMigrationClientTypes.ReplicationTask]?
}

extension DescribeReplicationTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTasks = "ReplicationTasks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationTasksContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.ReplicationTask?].self, forKey: .replicationTasks)
        var replicationTasksDecoded0:[DatabaseMigrationClientTypes.ReplicationTask]? = nil
        if let replicationTasksContainer = replicationTasksContainer {
            replicationTasksDecoded0 = [DatabaseMigrationClientTypes.ReplicationTask]()
            for structure0 in replicationTasksContainer {
                if let structure0 = structure0 {
                    replicationTasksDecoded0?.append(structure0)
                }
            }
        }
        replicationTasks = replicationTasksDecoded0
    }
}

enum DescribeReplicationTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeReplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeReplicationsInput: Swift.Equatable {
    /// Filters applied to the replications.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
    public var maxRecords: Swift.Int?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeReplicationsInputBody: Swift.Equatable {
    let filters: [DatabaseMigrationClientTypes.Filter]?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeReplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeReplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replications = output.replications
        } else {
            self.marker = nil
            self.replications = nil
        }
    }
}

///
public struct DescribeReplicationsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The replication descriptions.
    public var replications: [DatabaseMigrationClientTypes.Replication]?

    public init(
        marker: Swift.String? = nil,
        replications: [DatabaseMigrationClientTypes.Replication]? = nil
    )
    {
        self.marker = marker
        self.replications = replications
    }
}

struct DescribeReplicationsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let replications: [DatabaseMigrationClientTypes.Replication]?
}

extension DescribeReplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replications = "Replications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let replicationsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Replication?].self, forKey: .replications)
        var replicationsDecoded0:[DatabaseMigrationClientTypes.Replication]? = nil
        if let replicationsContainer = replicationsContainer {
            replicationsDecoded0 = [DatabaseMigrationClientTypes.Replication]()
            for structure0 in replicationsContainer {
                if let structure0 = structure0 {
                    replicationsDecoded0?.append(structure0)
                }
            }
        }
        replications = replicationsDecoded0
    }
}

enum DescribeReplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
    }
}

extension DescribeSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeSchemasInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init(
        endpointArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.endpointArn = endpointArn
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

struct DescribeSchemasInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
}

extension DescribeSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.schemas = output.schemas
        } else {
            self.marker = nil
            self.schemas = nil
        }
    }
}

///
public struct DescribeSchemasOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The described schema.
    public var schemas: [Swift.String]?

    public init(
        marker: Swift.String? = nil,
        schemas: [Swift.String]? = nil
    )
    {
        self.marker = marker
        self.schemas = schemas
    }
}

struct DescribeSchemasOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let schemas: [Swift.String]?
}

extension DescribeSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case schemas = "Schemas"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let schemasContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemas)
        var schemasDecoded0:[Swift.String]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [Swift.String]()
            for string0 in schemasContainer {
                if let string0 = string0 {
                    schemasDecoded0?.append(string0)
                }
            }
        }
        schemas = schemasDecoded0
    }
}

enum DescribeSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTableStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let marker = self.marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let maxRecords = self.maxRecords {
            try encodeContainer.encode(maxRecords, forKey: .maxRecords)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension DescribeTableStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeTableStatisticsInput: Swift.Equatable {
    /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
    public var filters: [DatabaseMigrationClientTypes.Filter]?
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved. Default: 100 Constraints: Minimum 20, maximum 500.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        filters: [DatabaseMigrationClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.replicationTaskArn = replicationTaskArn
    }
}

struct DescribeTableStatisticsInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let maxRecords: Swift.Int?
    let marker: Swift.String?
    let filters: [DatabaseMigrationClientTypes.Filter]?
}

extension DescribeTableStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case marker = "Marker"
        case maxRecords = "MaxRecords"
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let maxRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRecords)
        maxRecords = maxRecordsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[DatabaseMigrationClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [DatabaseMigrationClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeTableStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTableStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.replicationTaskArn = output.replicationTaskArn
            self.tableStatistics = output.tableStatistics
        } else {
            self.marker = nil
            self.replicationTaskArn = nil
            self.tableStatistics = nil
        }
    }
}

///
public struct DescribeTableStatisticsOutput: Swift.Equatable {
    /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?
    /// The table statistics.
    public var tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?

    public init(
        marker: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]? = nil
    )
    {
        self.marker = marker
        self.replicationTaskArn = replicationTaskArn
        self.tableStatistics = tableStatistics
    }
}

struct DescribeTableStatisticsOutputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let tableStatistics: [DatabaseMigrationClientTypes.TableStatistics]?
    let marker: Swift.String?
}

extension DescribeTableStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case replicationTaskArn = "ReplicationTaskArn"
        case tableStatistics = "TableStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tableStatisticsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableStatistics?].self, forKey: .tableStatistics)
        var tableStatisticsDecoded0:[DatabaseMigrationClientTypes.TableStatistics]? = nil
        if let tableStatisticsContainer = tableStatisticsContainer {
            tableStatisticsDecoded0 = [DatabaseMigrationClientTypes.TableStatistics]()
            for structure0 in tableStatisticsContainer {
                if let structure0 = structure0 {
                    tableStatisticsDecoded0?.append(structure0)
                }
            }
        }
        tableStatistics = tableStatisticsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

enum DescribeTableStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum DmsSslModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case require
        case verifyCa
        case verifyFull
        case sdkUnknown(Swift.String)

        public static var allCases: [DmsSslModeValue] {
            return [
                .none,
                .require,
                .verifyCa,
                .verifyFull,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .require: return "require"
            case .verifyCa: return "verify-ca"
            case .verifyFull: return "verify-full"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DmsSslModeValue(rawValue: rawValue) ?? DmsSslModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.DmsTransferSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The settings in JSON format for the DMS Transfer type source endpoint.
    public struct DmsTransferSettings: Swift.Equatable {
        /// The name of the S3 bucket to use.
        public var bucketName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.DocDbDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a DocumentDB data provider.
    public struct DocDbDataProviderSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the DocumentDB data provider.
        public var databaseName: Swift.String?
        /// The port value for the DocumentDB data provider.
        public var port: Swift.Int?
        /// The name of the source DocumentDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the DocumentDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case replicateShardCollections = "ReplicateShardCollections"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case useUpdateLookUp = "UseUpdateLookUp"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = self.docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = self.extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = self.nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let replicateShardCollections = self.replicateShardCollections {
            try encodeContainer.encode(replicateShardCollections, forKey: .replicateShardCollections)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let useUpdateLookUp = self.useUpdateLookUp {
            try encodeContainer.encode(useUpdateLookUp, forKey: .useUpdateLookUp)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let useUpdateLookUpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useUpdateLookUp)
        useUpdateLookUp = useUpdateLookUpDecoded
        let replicateShardCollectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicateShardCollections)
        replicateShardCollections = replicateShardCollectionsDecoded
    }
}

extension DatabaseMigrationClientTypes.DocDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocDbSettings(databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), replicateShardCollections: \(Swift.String(describing: replicateShardCollections)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), useUpdateLookUp: \(Swift.String(describing: useUpdateLookUp)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a DocumentDB endpoint.
    public struct DocDbSettings: Swift.Equatable {
        /// The database name on the DocumentDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.Int?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.Bool?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the DocumentDB source endpoint.
        public var password: Swift.String?
        /// The port value for the DocumentDB source endpoint.
        public var port: Swift.Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:
        ///
        /// * You must set TargetTablePrepMode to nothing.
        ///
        /// * DMS automatically sets useUpdateLookup to false.
        public var replicateShardCollections: Swift.Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the DocumentDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the DocumentDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the DocumentDB source endpoint.
        public var serverName: Swift.String?
        /// If true, DMS retrieves the entire document from the DocumentDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public var useUpdateLookUp: Swift.Bool?
        /// The user name you use to access the DocumentDB source endpoint.
        public var username: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.Int? = nil,
            extractDocId: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            replicateShardCollections: Swift.Bool? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            useUpdateLookUp: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useUpdateLookUp = useUpdateLookUp
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.DynamoDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides the Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role used to define an Amazon DynamoDB target endpoint.
    public struct DynamoDbSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes.ElasticsearchSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointUri = "EndpointUri"
        case errorRetryDuration = "ErrorRetryDuration"
        case fullLoadErrorPercentage = "FullLoadErrorPercentage"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case useNewMappingType = "UseNewMappingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointUri = self.endpointUri {
            try encodeContainer.encode(endpointUri, forKey: .endpointUri)
        }
        if let errorRetryDuration = self.errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let fullLoadErrorPercentage = self.fullLoadErrorPercentage {
            try encodeContainer.encode(fullLoadErrorPercentage, forKey: .fullLoadErrorPercentage)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let useNewMappingType = self.useNewMappingType {
            try encodeContainer.encode(useNewMappingType, forKey: .useNewMappingType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let endpointUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUri)
        endpointUri = endpointUriDecoded
        let fullLoadErrorPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadErrorPercentage)
        fullLoadErrorPercentage = fullLoadErrorPercentageDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let useNewMappingTypeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useNewMappingType)
        useNewMappingType = useNewMappingTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an OpenSearch endpoint.
    public struct ElasticsearchSettings: Swift.Equatable {
        /// The endpoint for the OpenSearch cluster. DMS uses HTTPS if a transport protocol (http/https) is not specified.
        /// This member is required.
        public var endpointUri: Swift.String?
        /// The maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster.
        public var errorRetryDuration: Swift.Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. To avoid early failure, this counter is only effective after 1000 records are transferred. OpenSearch also has the concept of error monitoring during the last 10 minutes of an Observation Window. If transfer of all records fail in the last 10 minutes, the full load operation stops.
        public var fullLoadErrorPercentage: Swift.Int?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        /// This member is required.
        public var serviceAccessRoleArn: Swift.String?
        /// Set this option to true for DMS to migrate documentation using the documentation type _doc. OpenSearch and an Elasticsearch cluster only support the _doc documentation type in versions 7. x and later. The default value is false.
        public var useNewMappingType: Swift.Bool?

        public init(
            endpointUri: Swift.String? = nil,
            errorRetryDuration: Swift.Int? = nil,
            fullLoadErrorPercentage: Swift.Int? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            useNewMappingType: Swift.Bool? = nil
        )
        {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.useNewMappingType = useNewMappingType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EncodingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plain
        case plainDictionary
        case rleDictionary
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingTypeValue] {
            return [
                .plain,
                .plainDictionary,
                .rleDictionary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .plainDictionary: return "plain-dictionary"
            case .rleDictionary: return "rle-dictionary"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingTypeValue(rawValue: rawValue) ?? EncodingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum EncryptionModeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionModeValue] {
            return [
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sseKms: return "sse-kms"
            case .sseS3: return "sse-s3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionModeValue(rawValue: rawValue) ?? EncryptionModeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case externalId = "ExternalId"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case kmsKeyId = "KmsKeyId"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case status = "Status"
        case sybaseSettings = "SybaseSettings"
        case timestreamSettings = "TimestreamSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = self.engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let timestreamSettings = self.timestreamSettings {
            try encodeContainer.encode(timestreamSettings, forKey: .timestreamSettings)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
        let timestreamSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TimestreamSettings.self, forKey: .timestreamSettings)
        timestreamSettings = timestreamSettingsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an endpoint of a database instance in response to operations such as the following:
    ///
    /// * CreateEndpoint
    ///
    /// * DescribeEndpoint
    ///
    /// * ModifyEndpoint
    public struct Endpoint: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public var certificateArn: Swift.String?
        /// The name of the database at the endpoint.
        public var databaseName: Swift.String?
        /// The settings for the DMS Transfer type source. For more information, see the DmsTransferSettings structure.
        public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
        /// Provides information that defines a DocumentDB endpoint.
        public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
        /// The settings for the OpenSearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public var endpointIdentifier: Swift.String?
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account.
        public var externalId: Swift.String?
        /// The external table definition.
        public var externalTableDefinition: Swift.String?
        /// Additional connection attributes used to connect to the endpoint.
        public var extraConnectionAttributes: Swift.String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure.
        public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
        /// The port value used to access the endpoint.
        public var port: Swift.Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
        /// The settings for the Redis target endpoint. For more information, see the RedisSettings structure.
        public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
        /// Settings for the Amazon Redshift endpoint.
        public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
        /// The name of the server at the endpoint.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
        /// The status of the endpoint.
        public var status: Swift.String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
        /// The settings for the Amazon Timestream target endpoint. For more information, see the TimestreamSettings structure.
        public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
        /// The user name used to connect to the endpoint.
        public var username: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
            docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
            dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
            elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            externalId: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            extraConnectionAttributes: Swift.String? = nil,
            gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
            ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
            kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
            kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
            kmsKeyId: Swift.String? = nil,
            microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
            mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
            mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
            neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
            oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
            port: Swift.Int? = nil,
            postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
            redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
            redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
            s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
            serverName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
            status: Swift.String? = nil,
            sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
            timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
            username: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.timestreamSettings = timestreamSettings
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.EndpointSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicability = "Applicability"
        case defaultValue = "DefaultValue"
        case enumValues = "EnumValues"
        case intValueMax = "IntValueMax"
        case intValueMin = "IntValueMin"
        case name = "Name"
        case sensitive = "Sensitive"
        case type = "Type"
        case units = "Units"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicability = self.applicability {
            try encodeContainer.encode(applicability, forKey: .applicability)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let enumValues = enumValues {
            var enumValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enumValues)
            for string0 in enumValues {
                try enumValuesContainer.encode(string0)
            }
        }
        if let intValueMax = self.intValueMax {
            try encodeContainer.encode(intValueMax, forKey: .intValueMax)
        }
        if let intValueMin = self.intValueMin {
            try encodeContainer.encode(intValueMin, forKey: .intValueMin)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sensitive = self.sensitive {
            try encodeContainer.encode(sensitive, forKey: .sensitive)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let units = self.units {
            try encodeContainer.encode(units, forKey: .units)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EndpointSettingTypeValue.self, forKey: .type)
        type = typeDecoded
        let enumValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enumValues)
        var enumValuesDecoded0:[Swift.String]? = nil
        if let enumValuesContainer = enumValuesContainer {
            enumValuesDecoded0 = [Swift.String]()
            for string0 in enumValuesContainer {
                if let string0 = string0 {
                    enumValuesDecoded0?.append(string0)
                }
            }
        }
        enumValues = enumValuesDecoded0
        let sensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sensitive)
        sensitive = sensitiveDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .units)
        units = unitsDecoded
        let applicabilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicability)
        applicability = applicabilityDecoded
        let intValueMinDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMin)
        intValueMin = intValueMinDecoded
        let intValueMaxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .intValueMax)
        intValueMax = intValueMaxDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Endpoint settings.
    public struct EndpointSetting: Swift.Equatable {
        /// The relevance or validity of an endpoint setting for an engine name and its endpoint type.
        public var applicability: Swift.String?
        /// The default value of the endpoint setting if no value is specified using CreateEndpoint or ModifyEndpoint.
        public var defaultValue: Swift.String?
        /// Enumerated values to use for this endpoint.
        public var enumValues: [Swift.String]?
        /// The maximum value of an endpoint setting that is of type int.
        public var intValueMax: Swift.Int?
        /// The minimum value of an endpoint setting that is of type int.
        public var intValueMin: Swift.Int?
        /// The name that you want to give the endpoint settings.
        public var name: Swift.String?
        /// A value that marks this endpoint setting as sensitive.
        public var sensitive: Swift.Bool?
        /// The type of endpoint. Valid values are source and target.
        public var type: DatabaseMigrationClientTypes.EndpointSettingTypeValue?
        /// The unit of measure for this endpoint setting.
        public var units: Swift.String?

        public init(
            applicability: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            enumValues: [Swift.String]? = nil,
            intValueMax: Swift.Int? = nil,
            intValueMin: Swift.Int? = nil,
            name: Swift.String? = nil,
            sensitive: Swift.Bool? = nil,
            type: DatabaseMigrationClientTypes.EndpointSettingTypeValue? = nil,
            units: Swift.String? = nil
        )
        {
            self.applicability = applicability
            self.defaultValue = defaultValue
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum EndpointSettingTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case `enum`
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointSettingTypeValue] {
            return [
                .boolean,
                .enum,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "boolean"
            case .enum: return "enum"
            case .integer: return "integer"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointSettingTypeValue(rawValue: rawValue) ?? EndpointSettingTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpgradeDate = "AutoUpgradeDate"
        case availableUpgrades = "AvailableUpgrades"
        case deprecationDate = "DeprecationDate"
        case forceUpgradeDate = "ForceUpgradeDate"
        case launchDate = "LaunchDate"
        case lifecycle = "Lifecycle"
        case releaseStatus = "ReleaseStatus"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoUpgradeDate = self.autoUpgradeDate {
            try encodeContainer.encodeTimestamp(autoUpgradeDate, format: .epochSeconds, forKey: .autoUpgradeDate)
        }
        if let availableUpgrades = availableUpgrades {
            var availableUpgradesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availableUpgrades)
            for string0 in availableUpgrades {
                try availableUpgradesContainer.encode(string0)
            }
        }
        if let deprecationDate = self.deprecationDate {
            try encodeContainer.encodeTimestamp(deprecationDate, format: .epochSeconds, forKey: .deprecationDate)
        }
        if let forceUpgradeDate = self.forceUpgradeDate {
            try encodeContainer.encodeTimestamp(forceUpgradeDate, format: .epochSeconds, forKey: .forceUpgradeDate)
        }
        if let launchDate = self.launchDate {
            try encodeContainer.encodeTimestamp(launchDate, format: .epochSeconds, forKey: .launchDate)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let releaseStatus = self.releaseStatus {
            try encodeContainer.encode(releaseStatus.rawValue, forKey: .releaseStatus)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let releaseStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReleaseStatusValues.self, forKey: .releaseStatus)
        releaseStatus = releaseStatusDecoded
        let launchDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .launchDate)
        launchDate = launchDateDecoded
        let autoUpgradeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .autoUpgradeDate)
        autoUpgradeDate = autoUpgradeDateDecoded
        let deprecationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
        let forceUpgradeDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .forceUpgradeDate)
        forceUpgradeDate = forceUpgradeDateDecoded
        let availableUpgradesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availableUpgrades)
        var availableUpgradesDecoded0:[Swift.String]? = nil
        if let availableUpgradesContainer = availableUpgradesContainer {
            availableUpgradesDecoded0 = [Swift.String]()
            for string0 in availableUpgradesContainer {
                if let string0 = string0 {
                    availableUpgradesDecoded0?.append(string0)
                }
            }
        }
        availableUpgrades = availableUpgradesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about a replication instance version.
    public struct EngineVersion: Swift.Equatable {
        /// The date when the replication instance will be automatically upgraded. This setting only applies if the auto-minor-version setting is enabled.
        public var autoUpgradeDate: ClientRuntime.Date?
        /// The list of valid replication instance versions that you can upgrade to.
        public var availableUpgrades: [Swift.String]?
        /// The date when the replication instance version will be deprecated and can no longer be requested.
        public var deprecationDate: ClientRuntime.Date?
        /// The date when the replication instance will have a version upgrade forced.
        public var forceUpgradeDate: ClientRuntime.Date?
        /// The date when the replication instance version became publicly available.
        public var launchDate: ClientRuntime.Date?
        /// The lifecycle status of the replication instance version. Valid values are DEPRECATED, DEFAULT_VERSION, and ACTIVE.
        public var lifecycle: Swift.String?
        /// The release status of the replication instance version.
        public var releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// The version number of the replication instance.
        public var version: Swift.String?

        public init(
            autoUpgradeDate: ClientRuntime.Date? = nil,
            availableUpgrades: [Swift.String]? = nil,
            deprecationDate: ClientRuntime.Date? = nil,
            forceUpgradeDate: ClientRuntime.Date? = nil,
            launchDate: ClientRuntime.Date? = nil,
            lifecycle: Swift.String? = nil,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            version: Swift.String? = nil
        )
        {
            self.autoUpgradeDate = autoUpgradeDate
            self.availableUpgrades = availableUpgrades
            self.deprecationDate = deprecationDate
            self.forceUpgradeDate = forceUpgradeDate
            self.launchDate = launchDate
            self.lifecycle = lifecycle
            self.releaseStatus = releaseStatus
            self.version = version
        }
    }

}

extension DatabaseMigrationClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaulterrordetails = "defaultErrorDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .defaulterrordetails(defaulterrordetails):
                try container.encode(defaulterrordetails, forKey: .defaulterrordetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let defaulterrordetailsDecoded = try values.decodeIfPresent(DatabaseMigrationClientTypes.DefaultErrorDetails.self, forKey: .defaulterrordetails)
        if let defaulterrordetails = defaulterrordetailsDecoded {
            self = .defaulterrordetails(defaulterrordetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides error information about a project.
    public enum ErrorDetails: Swift.Equatable {
        /// Error information about a project.
        case defaulterrordetails(DatabaseMigrationClientTypes.DefaultErrorDetails)
        case sdkUnknown(Swift.String)
    }

}

extension DatabaseMigrationClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceIdentifier = self.sourceIdentifier {
            try encodeContainer.encode(sourceIdentifier, forKey: .sourceIdentifier)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an identifiable significant activity that affects a replication instance or task. This object can provide the message, the available event categories, the date and source of the event, and the DMS resource type.
    public struct Event: Swift.Equatable {
        /// The date of the event.
        public var date: ClientRuntime.Date?
        /// The event categories available for the specified source type.
        public var eventCategories: [Swift.String]?
        /// The event message.
        public var message: Swift.String?
        /// The identifier of an event source.
        public var sourceIdentifier: Swift.String?
        /// The type of DMS resource that generates events. Valid values: replication-instance | endpoint | replication-task
        public var sourceType: DatabaseMigrationClientTypes.SourceType?

        public init(
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: DatabaseMigrationClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventCategoryGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Lists categories of events subscribed to, and generated by, the applicable DMS resource type. This data type appears in response to the [DescribeEventCategories](https://docs.aws.amazon.com/dms/latest/APIReference/API_EventCategoryGroup.html) action.
    public struct EventCategoryGroup: Swift.Equatable {
        /// A list of event categories from a source type that you've chosen.
        public var eventCategories: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?

        public init(
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension DatabaseMigrationClientTypes.EventSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let custSubscriptionId = self.custSubscriptionId {
            try encodeContainer.encode(custSubscriptionId, forKey: .custSubscriptionId)
        }
        if let customerAwsId = self.customerAwsId {
            try encodeContainer.encode(customerAwsId, forKey: .customerAwsId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategoriesList)
            for string0 in eventCategoriesList {
                try eventCategoriesListContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIdsList)
            for string0 in sourceIdsList {
                try sourceIdsListContainer.encode(string0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionCreationTime = self.subscriptionCreationTime {
            try encodeContainer.encode(subscriptionCreationTime, forKey: .subscriptionCreationTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceIdsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIdsList)
        var sourceIdsListDecoded0:[Swift.String]? = nil
        if let sourceIdsListContainer = sourceIdsListContainer {
            sourceIdsListDecoded0 = [Swift.String]()
            for string0 in sourceIdsListContainer {
                if let string0 = string0 {
                    sourceIdsListDecoded0?.append(string0)
                }
            }
        }
        sourceIdsList = sourceIdsListDecoded0
        let eventCategoriesListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategoriesList)
        var eventCategoriesListDecoded0:[Swift.String]? = nil
        if let eventCategoriesListContainer = eventCategoriesListContainer {
            eventCategoriesListDecoded0 = [Swift.String]()
            for string0 in eventCategoriesListContainer {
                if let string0 = string0 {
                    eventCategoriesListDecoded0?.append(string0)
                }
            }
        }
        eventCategoriesList = eventCategoriesListDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes an event notification subscription created by the CreateEventSubscription operation.
    public struct EventSubscription: Swift.Equatable {
        /// The DMS event notification subscription Id.
        public var custSubscriptionId: Swift.String?
        /// The Amazon Web Services customer account associated with the DMS event notification subscription.
        public var customerAwsId: Swift.String?
        /// Boolean value that indicates if the event subscription is enabled.
        public var enabled: Swift.Bool
        /// A lists of event categories.
        public var eventCategoriesList: [Swift.String]?
        /// The topic ARN of the DMS event notification subscription.
        public var snsTopicArn: Swift.String?
        /// A list of source Ids for the event subscription.
        public var sourceIdsList: [Swift.String]?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-server | security-group | replication-task
        public var sourceType: Swift.String?
        /// The status of the DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public var status: Swift.String?
        /// The time the DMS event notification subscription was created.
        public var subscriptionCreationTime: Swift.String?

        public init(
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension ExportMetadataModelAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportTypes = "AssessmentReportTypes"
        case fileName = "FileName"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportTypes = assessmentReportTypes {
            var assessmentReportTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentReportTypes)
            for assessmentreporttype0 in assessmentReportTypes {
                try assessmentReportTypesContainer.encode(assessmentreporttype0.rawValue)
            }
        }
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension ExportMetadataModelAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportMetadataModelAssessmentInput: Swift.Equatable {
    /// The file format of the assessment file.
    public var assessmentReportTypes: [DatabaseMigrationClientTypes.AssessmentReportType]?
    /// The name of the assessment file to create in your Amazon S3 bucket.
    public var fileName: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to assess.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        assessmentReportTypes: [DatabaseMigrationClientTypes.AssessmentReportType]? = nil,
        fileName: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.assessmentReportTypes = assessmentReportTypes
        self.fileName = fileName
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

struct ExportMetadataModelAssessmentInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
    let fileName: Swift.String?
    let assessmentReportTypes: [DatabaseMigrationClientTypes.AssessmentReportType]?
}

extension ExportMetadataModelAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentReportTypes = "AssessmentReportTypes"
        case fileName = "FileName"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let assessmentReportTypesContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.AssessmentReportType?].self, forKey: .assessmentReportTypes)
        var assessmentReportTypesDecoded0:[DatabaseMigrationClientTypes.AssessmentReportType]? = nil
        if let assessmentReportTypesContainer = assessmentReportTypesContainer {
            assessmentReportTypesDecoded0 = [DatabaseMigrationClientTypes.AssessmentReportType]()
            for enum0 in assessmentReportTypesContainer {
                if let enum0 = enum0 {
                    assessmentReportTypesDecoded0?.append(enum0)
                }
            }
        }
        assessmentReportTypes = assessmentReportTypesDecoded0
    }
}

extension ExportMetadataModelAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportMetadataModelAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.csvReport = output.csvReport
            self.pdfReport = output.pdfReport
        } else {
            self.csvReport = nil
            self.pdfReport = nil
        }
    }
}

public struct ExportMetadataModelAssessmentOutput: Swift.Equatable {
    /// The Amazon S3 details for an assessment exported in CSV format.
    public var csvReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?
    /// The Amazon S3 details for an assessment exported in PDF format.
    public var pdfReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?

    public init(
        csvReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry? = nil,
        pdfReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry? = nil
    )
    {
        self.csvReport = csvReport
        self.pdfReport = pdfReport
    }
}

struct ExportMetadataModelAssessmentOutputBody: Swift.Equatable {
    let pdfReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?
    let csvReport: DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry?
}

extension ExportMetadataModelAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvReport = "CsvReport"
        case pdfReport = "PdfReport"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pdfReportDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry.self, forKey: .pdfReport)
        pdfReport = pdfReportDecoded
        let csvReportDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry.self, forKey: .csvReport)
        csvReport = csvReportDecoded
    }
}

enum ExportMetadataModelAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.ExportMetadataModelAssessmentResultEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectURL = "ObjectURL"
        case s3ObjectKey = "S3ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectURL = self.objectURL {
            try encodeContainer.encode(objectURL, forKey: .objectURL)
        }
        if let s3ObjectKey = self.s3ObjectKey {
            try encodeContainer.encode(s3ObjectKey, forKey: .s3ObjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectKey)
        s3ObjectKey = s3ObjectKeyDecoded
        let objectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectURL)
        objectURL = objectURLDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about an exported metadata model assessment.
    public struct ExportMetadataModelAssessmentResultEntry: Swift.Equatable {
        /// The URL for the object containing the exported metadata model assessment.
        public var objectURL: Swift.String?
        /// The object key for the object containing the exported metadata model assessment.
        public var s3ObjectKey: Swift.String?

        public init(
            objectURL: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension DatabaseMigrationClientTypes.ExportSqlDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectURL = "ObjectURL"
        case s3ObjectKey = "S3ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectURL = self.objectURL {
            try encodeContainer.encode(objectURL, forKey: .objectURL)
        }
        if let s3ObjectKey = self.s3ObjectKey {
            try encodeContainer.encode(s3ObjectKey, forKey: .s3ObjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectKey)
        s3ObjectKey = s3ObjectKeyDecoded
        let objectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectURL)
        objectURL = objectURLDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about a metadata model assessment exported to SQL.
    public struct ExportSqlDetails: Swift.Equatable {
        /// The URL for the object containing the exported metadata model assessment.
        public var objectURL: Swift.String?
        /// The Amazon S3 object key for the object containing the exported metadata model assessment.
        public var s3ObjectKey: Swift.String?

        public init(
            objectURL: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension DatabaseMigrationClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Identifies the name and value of a filter object. This filter is used to limit the number and type of DMS objects that are returned for a particular Describe* call or similar operation. Filters are used as an optional parameter for certain API operations.
    public struct Filter: Swift.Equatable {
        /// The name of the filter as specified for a Describe* or similar operation.
        /// This member is required.
        public var name: Swift.String?
        /// The filter value, which can specify one or more values used to narrow the returned results.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension DatabaseMigrationClientTypes.FleetAdvisorLsaAnalysisResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lsaAnalysisId = "LsaAnalysisId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lsaAnalysisId = self.lsaAnalysisId {
            try encodeContainer.encode(lsaAnalysisId, forKey: .lsaAnalysisId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lsaAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lsaAnalysisId)
        lsaAnalysisId = lsaAnalysisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a large-scale assessment (LSA) analysis run by a Fleet Advisor collector.
    public struct FleetAdvisorLsaAnalysisResponse: Swift.Equatable {
        /// The ID of an LSA analysis run by a Fleet Advisor collector.
        public var lsaAnalysisId: Swift.String?
        /// The status of an LSA analysis run by a Fleet Advisor collector.
        public var status: Swift.String?

        public init(
            lsaAnalysisId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.lsaAnalysisId = lsaAnalysisId
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.FleetAdvisorSchemaObjectResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeLineCount = "CodeLineCount"
        case codeSize = "CodeSize"
        case numberOfObjects = "NumberOfObjects"
        case objectType = "ObjectType"
        case schemaId = "SchemaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeLineCount = self.codeLineCount {
            try encodeContainer.encode(codeLineCount, forKey: .codeLineCount)
        }
        if let codeSize = self.codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let numberOfObjects = self.numberOfObjects {
            try encodeContainer.encode(numberOfObjects, forKey: .numberOfObjects)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType, forKey: .objectType)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let objectTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let numberOfObjectsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfObjects)
        numberOfObjects = numberOfObjectsDecoded
        let codeLineCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeLineCount)
        codeLineCount = codeLineCountDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema object in a Fleet Advisor collector inventory.
    public struct FleetAdvisorSchemaObjectResponse: Swift.Equatable {
        /// The number of lines of code in a schema object in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema object in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The number of objects in a schema object in a Fleet Advisor collector inventory.
        public var numberOfObjects: Swift.Int?
        /// The type of the schema object, as reported by the database engine. Examples include the following:
        ///
        /// * function
        ///
        /// * trigger
        ///
        /// * SYSTEM_TABLE
        ///
        /// * QUEUE
        public var objectType: Swift.String?
        /// The ID of a schema object in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?

        public init(
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            numberOfObjects: Swift.Int? = nil,
            objectType: Swift.String? = nil,
            schemaId: Swift.String? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.numberOfObjects = numberOfObjects
            self.objectType = objectType
            self.schemaId = schemaId
        }
    }

}

extension DatabaseMigrationClientTypes.GcpMySQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = self.cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = self.eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = self.parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = self.serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = self.targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.GcpMySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GcpMySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public struct GcpMySQLSettings: Swift.Equatable {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The MySQL host name.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLsn = "CurrentLsn"
        case databaseName = "DatabaseName"
        case maxKBytesPerRead = "MaxKBytesPerRead"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case setDataCaptureChanges = "SetDataCaptureChanges"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLsn = self.currentLsn {
            try encodeContainer.encode(currentLsn, forKey: .currentLsn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxKBytesPerRead = self.maxKBytesPerRead {
            try encodeContainer.encode(maxKBytesPerRead, forKey: .maxKBytesPerRead)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let setDataCaptureChanges = self.setDataCaptureChanges {
            try encodeContainer.encode(setDataCaptureChanges, forKey: .setDataCaptureChanges)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let setDataCaptureChangesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setDataCaptureChanges)
        setDataCaptureChanges = setDataCaptureChangesDecoded
        let currentLsnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLsn)
        currentLsn = currentLsnDecoded
        let maxKBytesPerReadDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxKBytesPerRead)
        maxKBytesPerRead = maxKBytesPerReadDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.IBMDb2Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IBMDb2Settings(currentLsn: \(Swift.String(describing: currentLsn)), databaseName: \(Swift.String(describing: databaseName)), maxKBytesPerRead: \(Swift.String(describing: maxKBytesPerRead)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), setDataCaptureChanges: \(Swift.String(describing: setDataCaptureChanges)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an IBM Db2 LUW endpoint.
    public struct IBMDb2Settings: Swift.Equatable {
        /// For ongoing replication (CDC), use CurrentLSN to specify a log sequence number (LSN) where you want the replication to start.
        public var currentLsn: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Maximum number of bytes per read, as a NUMBER value. The default is 64 KB.
        public var maxKBytesPerRead: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default value is 50000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Db2 LUW endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Db2 LUW endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Enables ongoing replication (CDC) as a BOOLEAN value. The default is true.
        public var setDataCaptureChanges: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            currentLsn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            maxKBytesPerRead: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            setDataCaptureChanges: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
        }
    }

}

extension ImportCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportCertificateInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificateWallet: \(Swift.String(describing: certificateWallet)), tags: \(Swift.String(describing: tags)), certificatePem: \"CONTENT_REDACTED\")"}
}

extension ImportCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateIdentifier = self.certificateIdentifier {
            try encodeContainer.encode(certificateIdentifier, forKey: .certificateIdentifier)
        }
        if let certificatePem = self.certificatePem {
            try encodeContainer.encode(certificatePem, forKey: .certificatePem)
        }
        if let certificateWallet = self.certificateWallet {
            try encodeContainer.encode(certificateWallet.base64EncodedString(), forKey: .certificateWallet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension ImportCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportCertificateInput: Swift.Equatable {
    /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var certificateIdentifier: Swift.String?
    /// The contents of a .pem file, which contains an X.509 certificate.
    public var certificatePem: Swift.String?
    /// The location of an imported Oracle Wallet certificate for use with SSL. Provide the name of a .sso file using the fileb:// prefix. You can't provide the certificate inline. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
    public var certificateWallet: ClientRuntime.Data?
    /// The tags associated with the certificate.
    public var tags: [DatabaseMigrationClientTypes.Tag]?

    public init(
        certificateIdentifier: Swift.String? = nil,
        certificatePem: Swift.String? = nil,
        certificateWallet: ClientRuntime.Data? = nil,
        tags: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.certificatePem = certificatePem
        self.certificateWallet = certificateWallet
        self.tags = tags
    }
}

struct ImportCertificateInputBody: Swift.Equatable {
    let certificateIdentifier: Swift.String?
    let certificatePem: Swift.String?
    let certificateWallet: ClientRuntime.Data?
    let tags: [DatabaseMigrationClientTypes.Tag]?
}

extension ImportCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateIdentifier = "CertificateIdentifier"
        case certificatePem = "CertificatePem"
        case certificateWallet = "CertificateWallet"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificatePemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePem)
        certificatePem = certificatePemDecoded
        let certificateWalletDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificateWallet)
        certificateWallet = certificateWalletDecoded
        let tagsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportCertificateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportCertificateOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ImportCertificateOutput: Swift.Equatable {
    /// The certificate to be uploaded.
    public var certificate: DatabaseMigrationClientTypes.Certificate?

    public init(
        certificate: DatabaseMigrationClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ImportCertificateOutputBody: Swift.Equatable {
    let certificate: DatabaseMigrationClientTypes.Certificate?
}

extension ImportCertificateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

enum ImportCertificateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidCertificateFault": return try await InvalidCertificateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.InstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case description = "Description"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceProfileCreationTime = "InstanceProfileCreationTime"
        case instanceProfileName = "InstanceProfileName"
        case kmsKeyArn = "KmsKeyArn"
        case networkType = "NetworkType"
        case publiclyAccessible = "PubliclyAccessible"
        case subnetGroupIdentifier = "SubnetGroupIdentifier"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceProfileCreationTime = self.instanceProfileCreationTime {
            try encodeContainer.encodeTimestamp(instanceProfileCreationTime, format: .dateTime, forKey: .instanceProfileCreationTime)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let subnetGroupIdentifier = self.subnetGroupIdentifier {
            try encodeContainer.encode(subnetGroupIdentifier, forKey: .subnetGroupIdentifier)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for string0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceProfileCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .instanceProfileCreationTime)
        instanceProfileCreationTime = instanceProfileCreationTimeDecoded
        let subnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupIdentifier)
        subnetGroupIdentifier = subnetGroupIdentifierDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an instance profile.
    public struct InstanceProfile: Swift.Equatable {
        /// The Availability Zone where the instance profile runs.
        public var availabilityZone: Swift.String?
        /// A description of the instance profile. Descriptions can have up to 31 characters. A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the instance profile.
        public var instanceProfileArn: Swift.String?
        /// The time the instance profile was created.
        public var instanceProfileCreationTime: ClientRuntime.Date?
        /// The user-friendly name for the instance profile.
        public var instanceProfileName: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyArn: Swift.String?
        /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
        public var networkType: Swift.String?
        /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool?
        /// The identifier of the subnet group that is associated with the instance profile.
        public var subnetGroupIdentifier: Swift.String?
        /// The VPC security groups that are used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
        public var vpcSecurityGroups: [Swift.String]?

        public init(
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceProfileCreationTime: ClientRuntime.Date? = nil,
            instanceProfileName: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            networkType: Swift.String? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            subnetGroupIdentifier: Swift.String? = nil,
            vpcSecurityGroups: [Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileCreationTime = instanceProfileCreationTime
            self.instanceProfileName = instanceProfileName
            self.kmsKeyArn = kmsKeyArn
            self.networkType = networkType
            self.publiclyAccessible = publiclyAccessible
            self.subnetGroupIdentifier = subnetGroupIdentifier
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension InsufficientResourceCapacityFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientResourceCapacityFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are not enough resources allocated to the database migration.
public struct InsufficientResourceCapacityFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientResourceCapacityFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientResourceCapacityFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientResourceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCertificateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCertificateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The certificate was not valid.
public struct InvalidCertificateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCertificateFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCertificateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidOperationFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The action or operation requested isn't valid.
public struct InvalidOperationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOperationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is in a state that prevents it from being used for database migration.
public struct InvalidResourceStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceStateFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The subnet provided isn't valid.
public struct InvalidSubnet: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.InventoryData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDatabases = "NumberOfDatabases"
        case numberOfSchemas = "NumberOfSchemas"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDatabases = self.numberOfDatabases {
            try encodeContainer.encode(numberOfDatabases, forKey: .numberOfDatabases)
        }
        if let numberOfSchemas = self.numberOfSchemas {
            try encodeContainer.encode(numberOfSchemas, forKey: .numberOfSchemas)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDatabasesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDatabases)
        numberOfDatabases = numberOfDatabasesDecoded
        let numberOfSchemasDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfSchemas)
        numberOfSchemas = numberOfSchemasDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a Fleet Advisor collector inventory.
    public struct InventoryData: Swift.Equatable {
        /// The number of databases in the Fleet Advisor collector inventory.
        public var numberOfDatabases: Swift.Int?
        /// The number of schemas in the Fleet Advisor collector inventory.
        public var numberOfSchemas: Swift.Int?

        public init(
            numberOfDatabases: Swift.Int? = nil,
            numberOfSchemas: Swift.Int? = nil
        )
        {
            self.numberOfDatabases = numberOfDatabases
            self.numberOfSchemas = numberOfSchemas
        }
    }

}

extension KMSAccessDeniedFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSAccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.
public struct KMSAccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDeniedFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSAccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSAccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSDisabledFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified KMS key isn't enabled.
public struct KMSDisabledFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabledFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSDisabledFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSDisabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An Key Management Service (KMS) error is preventing access to KMS.
public struct KMSFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSInvalidStateFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The state of the specified KMS resource isn't valid for this request.
public struct KMSInvalidStateFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidStateFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSInvalidStateFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSInvalidStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSKeyNotAccessibleFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// DMS cannot access the KMS key.
public struct KMSKeyNotAccessibleFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSKeyNotAccessibleFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified KMS entity or resource can't be found.
public struct KMSNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSThrottlingFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSThrottlingFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This request triggered KMS request throttling.
public struct KMSThrottlingFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSThrottlingFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSThrottlingFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSThrottlingFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum KafkaSaslMechanism: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plain
        case scramSha512
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSaslMechanism] {
            return [
                .plain,
                .scramSha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plain: return "plain"
            case .scramSha512: return "scram-sha-512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaSaslMechanism(rawValue: rawValue) ?? KafkaSaslMechanism.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum KafkaSecurityProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case saslSsl
        case sslAuthentication
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSecurityProtocol] {
            return [
                .plaintext,
                .saslSsl,
                .sslAuthentication,
                .sslEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .saslSsl: return "sasl-ssl"
            case .sslAuthentication: return "ssl-authentication"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaSecurityProtocol(rawValue: rawValue) ?? KafkaSecurityProtocol.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case broker = "Broker"
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case messageMaxBytes = "MessageMaxBytes"
        case noHexPrefix = "NoHexPrefix"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case saslMechanism = "SaslMechanism"
        case saslPassword = "SaslPassword"
        case saslUsername = "SaslUsername"
        case securityProtocol = "SecurityProtocol"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslClientCertificateArn = "SslClientCertificateArn"
        case sslClientKeyArn = "SslClientKeyArn"
        case sslClientKeyPassword = "SslClientKeyPassword"
        case sslEndpointIdentificationAlgorithm = "SslEndpointIdentificationAlgorithm"
        case topic = "Topic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let broker = self.broker {
            try encodeContainer.encode(broker, forKey: .broker)
        }
        if let includeControlDetails = self.includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = self.includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = self.includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = self.includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = self.includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let messageMaxBytes = self.messageMaxBytes {
            try encodeContainer.encode(messageMaxBytes, forKey: .messageMaxBytes)
        }
        if let noHexPrefix = self.noHexPrefix {
            try encodeContainer.encode(noHexPrefix, forKey: .noHexPrefix)
        }
        if let partitionIncludeSchemaTable = self.partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let saslMechanism = self.saslMechanism {
            try encodeContainer.encode(saslMechanism.rawValue, forKey: .saslMechanism)
        }
        if let saslPassword = self.saslPassword {
            try encodeContainer.encode(saslPassword, forKey: .saslPassword)
        }
        if let saslUsername = self.saslUsername {
            try encodeContainer.encode(saslUsername, forKey: .saslUsername)
        }
        if let securityProtocol = self.securityProtocol {
            try encodeContainer.encode(securityProtocol.rawValue, forKey: .securityProtocol)
        }
        if let sslCaCertificateArn = self.sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslClientCertificateArn = self.sslClientCertificateArn {
            try encodeContainer.encode(sslClientCertificateArn, forKey: .sslClientCertificateArn)
        }
        if let sslClientKeyArn = self.sslClientKeyArn {
            try encodeContainer.encode(sslClientKeyArn, forKey: .sslClientKeyArn)
        }
        if let sslClientKeyPassword = self.sslClientKeyPassword {
            try encodeContainer.encode(sslClientKeyPassword, forKey: .sslClientKeyPassword)
        }
        if let sslEndpointIdentificationAlgorithm = self.sslEndpointIdentificationAlgorithm {
            try encodeContainer.encode(sslEndpointIdentificationAlgorithm.rawValue, forKey: .sslEndpointIdentificationAlgorithm)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .broker)
        broker = brokerDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let messageMaxBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageMaxBytes)
        messageMaxBytes = messageMaxBytesDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSecurityProtocol.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let sslClientCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientCertificateArn)
        sslClientCertificateArn = sslClientCertificateArnDecoded
        let sslClientKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyArn)
        sslClientKeyArn = sslClientKeyArnDecoded
        let sslClientKeyPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyPassword)
        sslClientKeyPassword = sslClientKeyPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
        let saslUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslUsername)
        saslUsername = saslUsernameDecoded
        let saslPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslPassword)
        saslPassword = saslPasswordDecoded
        let noHexPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noHexPrefix)
        noHexPrefix = noHexPrefixDecoded
        let saslMechanismDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSaslMechanism.self, forKey: .saslMechanism)
        saslMechanism = saslMechanismDecoded
        let sslEndpointIdentificationAlgorithmDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSslEndpointIdentificationAlgorithm.self, forKey: .sslEndpointIdentificationAlgorithm)
        sslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithmDecoded
    }
}

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KafkaSettings(broker: \(Swift.String(describing: broker)), includeControlDetails: \(Swift.String(describing: includeControlDetails)), includeNullAndEmpty: \(Swift.String(describing: includeNullAndEmpty)), includePartitionValue: \(Swift.String(describing: includePartitionValue)), includeTableAlterOperations: \(Swift.String(describing: includeTableAlterOperations)), includeTransactionDetails: \(Swift.String(describing: includeTransactionDetails)), messageFormat: \(Swift.String(describing: messageFormat)), messageMaxBytes: \(Swift.String(describing: messageMaxBytes)), noHexPrefix: \(Swift.String(describing: noHexPrefix)), partitionIncludeSchemaTable: \(Swift.String(describing: partitionIncludeSchemaTable)), saslMechanism: \(Swift.String(describing: saslMechanism)), saslUsername: \(Swift.String(describing: saslUsername)), securityProtocol: \(Swift.String(describing: securityProtocol)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslClientCertificateArn: \(Swift.String(describing: sslClientCertificateArn)), sslClientKeyArn: \(Swift.String(describing: sslClientKeyArn)), sslEndpointIdentificationAlgorithm: \(Swift.String(describing: sslEndpointIdentificationAlgorithm)), topic: \(Swift.String(describing: topic)), saslPassword: \"CONTENT_REDACTED\", sslClientKeyPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Apache Kafka endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KafkaSettings: Swift.Equatable {
        /// A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345". For more information and examples of specifying a list of broker locations, see [Using Apache Kafka as a target for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html) in the Database Migration Service User Guide.
        public var broker: Swift.String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kafka message output unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public var messageMaxBytes: Swift.Int?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// For SASL/SSL authentication, DMS supports the SCRAM-SHA-512 mechanism by default. DMS versions 3.5.0 and later also support the PLAIN mechanism. To use the PLAIN mechanism, set this parameter to PLAIN.
        public var saslMechanism: DatabaseMigrationClientTypes.KafkaSaslMechanism?
        /// The secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslPassword: Swift.String?
        /// The secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public var saslUsername: Swift.String?
        /// Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires SaslUsername and SaslPassword.
        public var securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol?
        /// The Amazon Resource Name (ARN) for the private certificate authority (CA) cert that DMS uses to securely connect to your Kafka target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.
        public var sslClientCertificateArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyArn: Swift.String?
        /// The password for the client private key used to securely connect to a Kafka target endpoint.
        public var sslClientKeyPassword: Swift.String?
        /// Sets hostname verification for the certificate. This setting is supported in DMS version 3.5.1 and later.
        public var sslEndpointIdentificationAlgorithm: DatabaseMigrationClientTypes.KafkaSslEndpointIdentificationAlgorithm?
        /// The topic to which you migrate the data. If you don't specify a topic, DMS specifies "kafka-default-topic" as the migration topic.
        public var topic: Swift.String?

        public init(
            broker: Swift.String? = nil,
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            messageMaxBytes: Swift.Int? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            saslMechanism: DatabaseMigrationClientTypes.KafkaSaslMechanism? = nil,
            saslPassword: Swift.String? = nil,
            saslUsername: Swift.String? = nil,
            securityProtocol: DatabaseMigrationClientTypes.KafkaSecurityProtocol? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslClientCertificateArn: Swift.String? = nil,
            sslClientKeyArn: Swift.String? = nil,
            sslClientKeyPassword: Swift.String? = nil,
            sslEndpointIdentificationAlgorithm: DatabaseMigrationClientTypes.KafkaSslEndpointIdentificationAlgorithm? = nil,
            topic: Swift.String? = nil
        )
        {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslMechanism = saslMechanism
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.sslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithm
            self.topic = topic
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum KafkaSslEndpointIdentificationAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaSslEndpointIdentificationAlgorithm] {
            return [
                .https,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "https"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KafkaSslEndpointIdentificationAlgorithm(rawValue: rawValue) ?? KafkaSslEndpointIdentificationAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.KinesisSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case noHexPrefix = "NoHexPrefix"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeControlDetails = self.includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = self.includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = self.includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = self.includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = self.includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let noHexPrefix = self.noHexPrefix {
            try encodeContainer.encode(noHexPrefix, forKey: .noHexPrefix)
        }
        if let partitionIncludeSchemaTable = self.partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let noHexPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noHexPrefix)
        noHexPrefix = noHexPrefixDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an Amazon Kinesis Data Stream endpoint. This information includes the output format of records applied to the endpoint and details of transaction and control table data information.
    public struct KinesisSettings: Swift.Equatable {
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public var includeControlDetails: Swift.Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public var includeNullAndEmpty: Swift.Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public var includePartitionValue: Swift.Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public var includeTableAlterOperations: Swift.Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public var includeTransactionDetails: Swift.Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public var messageFormat: DatabaseMigrationClientTypes.MessageFormatValue?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public var noHexPrefix: Swift.Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public var partitionIncludeSchemaTable: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public var streamArn: Swift.String?

        public init(
            includeControlDetails: Swift.Bool? = nil,
            includeNullAndEmpty: Swift.Bool? = nil,
            includePartitionValue: Swift.Bool? = nil,
            includeTableAlterOperations: Swift.Bool? = nil,
            includeTransactionDetails: Swift.Bool? = nil,
            messageFormat: DatabaseMigrationClientTypes.MessageFormatValue? = nil,
            noHexPrefix: Swift.Bool? = nil,
            partitionIncludeSchemaTable: Swift.Bool? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }
    }

}

extension DatabaseMigrationClientTypes.Limitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case description = "Description"
        case engineName = "EngineName"
        case impact = "Impact"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .impact)
        impact = impactDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the limitations of target Amazon Web Services engines. Your source database might include features that the target Amazon Web Services engine doesn't support. Fleet Advisor lists these features as limitations. You should consider these limitations during database migration. For each limitation, Fleet Advisor recommends an action that you can take to address or avoid this limitation.
    public struct Limitation: Swift.Equatable {
        /// The identifier of the source database.
        public var databaseId: Swift.String?
        /// A description of the limitation. Provides additional information about the limitation, and includes recommended actions that you can take to address or avoid this limitation.
        public var description: Swift.String?
        /// The name of the target engine that Fleet Advisor should use in the target engine recommendation. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public var engineName: Swift.String?
        /// The impact of the limitation. You can use this parameter to prioritize limitations that you want to address. Valid values include "Blocker", "High", "Medium", and "Low".
        public var impact: Swift.String?
        /// The name of the limitation. Describes unsupported database features, migration action items, and other limitations.
        public var name: Swift.String?
        /// The type of the limitation, such as action required, upgrade required, and limited feature.
        public var type: Swift.String?

        public init(
            databaseId: Swift.String? = nil,
            description: Swift.String? = nil,
            engineName: Swift.String? = nil,
            impact: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.databaseId = databaseId
            self.description = description
            self.engineName = engineName
            self.impact = impact
            self.name = name
            self.type = type
        }
    }

}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceArnList = "ResourceArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceArnList = resourceArnList {
            var resourceArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArnList)
            for string0 in resourceArnList {
                try resourceArnListContainer.encode(string0)
            }
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the DMS resource to list tags for. This returns a list of keys (names of tags) created for the resource and their associated tag values.
    public var resourceArn: Swift.String?
    /// List of ARNs that identify multiple DMS resources that you want to list tags for. This returns a list of keys (tag names) and their associated tag values. It also returns each tag's associated ResourceArn value, which is the ARN of the resource for which each listed tag is created.
    public var resourceArnList: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceArnList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceArnList = resourceArnList
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceArnList: [Swift.String]?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceArnList = "ResourceArnList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArnList)
        var resourceArnListDecoded0:[Swift.String]? = nil
        if let resourceArnListContainer = resourceArnListContainer {
            resourceArnListDecoded0 = [Swift.String]()
            for string0 in resourceArnListContainer {
                if let string0 = string0 {
                    resourceArnListDecoded0?.append(string0)
                }
            }
        }
        resourceArnList = resourceArnListDecoded0
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

///
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags for the resource.
    public var tagList: [DatabaseMigrationClientTypes.Tag]?

    public init(
        tagList: [DatabaseMigrationClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tagList: [DatabaseMigrationClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[DatabaseMigrationClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [DatabaseMigrationClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum LongVarcharMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clob
        case nclob
        case wstring
        case sdkUnknown(Swift.String)

        public static var allCases: [LongVarcharMappingType] {
            return [
                .clob,
                .nclob,
                .wstring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clob: return "clob"
            case .nclob: return "nclob"
            case .wstring: return "wstring"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LongVarcharMappingType(rawValue: rawValue) ?? LongVarcharMappingType.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.MariaDbDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MariaDB data provider.
    public struct MariaDbDataProviderSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The port value for the MariaDB data provider
        public var port: Swift.Int?
        /// The name of the MariaDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MariaDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum MessageFormatValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case jsonUnformatted
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatValue] {
            return [
                .json,
                .jsonUnformatted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .jsonUnformatted: return "json-unformatted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageFormatValue(rawValue: rawValue) ?? MessageFormatValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bcpPacketSize = "BcpPacketSize"
        case controlTablesFileGroup = "ControlTablesFileGroup"
        case databaseName = "DatabaseName"
        case forceLobLookup = "ForceLobLookup"
        case password = "Password"
        case port = "Port"
        case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
        case readBackupOnly = "ReadBackupOnly"
        case safeguardPolicy = "SafeguardPolicy"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case tlogAccessMode = "TlogAccessMode"
        case trimSpaceInChar = "TrimSpaceInChar"
        case useBcpFullLoad = "UseBcpFullLoad"
        case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bcpPacketSize = self.bcpPacketSize {
            try encodeContainer.encode(bcpPacketSize, forKey: .bcpPacketSize)
        }
        if let controlTablesFileGroup = self.controlTablesFileGroup {
            try encodeContainer.encode(controlTablesFileGroup, forKey: .controlTablesFileGroup)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let forceLobLookup = self.forceLobLookup {
            try encodeContainer.encode(forceLobLookup, forKey: .forceLobLookup)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let querySingleAlwaysOnNode = self.querySingleAlwaysOnNode {
            try encodeContainer.encode(querySingleAlwaysOnNode, forKey: .querySingleAlwaysOnNode)
        }
        if let readBackupOnly = self.readBackupOnly {
            try encodeContainer.encode(readBackupOnly, forKey: .readBackupOnly)
        }
        if let safeguardPolicy = self.safeguardPolicy {
            try encodeContainer.encode(safeguardPolicy.rawValue, forKey: .safeguardPolicy)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let tlogAccessMode = self.tlogAccessMode {
            try encodeContainer.encode(tlogAccessMode.rawValue, forKey: .tlogAccessMode)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let useBcpFullLoad = self.useBcpFullLoad {
            try encodeContainer.encode(useBcpFullLoad, forKey: .useBcpFullLoad)
        }
        if let useThirdPartyBackupDevice = self.useThirdPartyBackupDevice {
            try encodeContainer.encode(useThirdPartyBackupDevice, forKey: .useThirdPartyBackupDevice)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let bcpPacketSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bcpPacketSize)
        bcpPacketSize = bcpPacketSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let controlTablesFileGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlTablesFileGroup)
        controlTablesFileGroup = controlTablesFileGroupDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let querySingleAlwaysOnNodeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .querySingleAlwaysOnNode)
        querySingleAlwaysOnNode = querySingleAlwaysOnNodeDecoded
        let readBackupOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readBackupOnly)
        readBackupOnly = readBackupOnlyDecoded
        let safeguardPolicyDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SafeguardPolicy.self, forKey: .safeguardPolicy)
        safeguardPolicy = safeguardPolicyDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let useBcpFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBcpFullLoad)
        useBcpFullLoad = useBcpFullLoadDecoded
        let useThirdPartyBackupDeviceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useThirdPartyBackupDevice)
        useThirdPartyBackupDevice = useThirdPartyBackupDeviceDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
        let tlogAccessModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TlogAccessMode.self, forKey: .tlogAccessMode)
        tlogAccessMode = tlogAccessModeDecoded
        let forceLobLookupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceLobLookup)
        forceLobLookup = forceLobLookupDecoded
    }
}

extension DatabaseMigrationClientTypes.MicrosoftSQLServerSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MicrosoftSQLServerSettings(bcpPacketSize: \(Swift.String(describing: bcpPacketSize)), controlTablesFileGroup: \(Swift.String(describing: controlTablesFileGroup)), databaseName: \(Swift.String(describing: databaseName)), forceLobLookup: \(Swift.String(describing: forceLobLookup)), port: \(Swift.String(describing: port)), querySingleAlwaysOnNode: \(Swift.String(describing: querySingleAlwaysOnNode)), readBackupOnly: \(Swift.String(describing: readBackupOnly)), safeguardPolicy: \(Swift.String(describing: safeguardPolicy)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), tlogAccessMode: \(Swift.String(describing: tlogAccessMode)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useBcpFullLoad: \(Swift.String(describing: useBcpFullLoad)), useThirdPartyBackupDevice: \(Swift.String(describing: useThirdPartyBackupDevice)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Microsoft SQL Server endpoint.
    public struct MicrosoftSQLServerSettings: Swift.Equatable {
        /// The maximum size of the packets (in bytes) used to transfer data using BCP.
        public var bcpPacketSize: Swift.Int?
        /// Specifies a file group for the DMS internal tables. When the replication task starts, all the internal DMS control tables (awsdms_ apply_exception, awsdms_apply, awsdms_changes) are created for the specified file group.
        public var controlTablesFileGroup: Swift.String?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Forces LOB lookup on inline LOB.
        public var forceLobLookup: Swift.Bool?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. An example is a situation where running an alter DDL statement on a table might result in different information about the table cached in the replication instance.
        public var querySingleAlwaysOnNode: Swift.Bool?
        /// When this attribute is set to Y, DMS only reads changes from transaction log backups and doesn't read from the active transaction log file during ongoing replication. Setting this parameter to Y enables you to control active transaction log file growth during full load and ongoing replication tasks. However, it can add some source latency to ongoing replication.
        public var readBackupOnly: Swift.Bool?
        /// Use this attribute to minimize the need to access the backup log and enable DMS to prevent truncation using one of the following two methods. Start transactions in the database: This is the default method. When this method is used, DMS prevents TLOG truncation by mimicking a transaction in the database. As long as such a transaction is open, changes that appear after the transaction started aren't truncated. If you need Microsoft Replication to be enabled in your database, then you must choose this method. Exclusively use sp_repldone within a single task: When this method is used, DMS reads the changes and then uses sp_repldone to mark the TLOG transactions as ready for truncation. Although this method doesn't involve any transactional activities, it can only be used when Microsoft Replication isn't running. Also, when using this method, only one DMS task can access the database at any given time. Therefore, if you need to run parallel DMS tasks against the same database, use the default method.
        public var safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SQL Server endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SQL Server endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS SQL Server instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field.
        public var serverName: Swift.String?
        /// Indicates the mode used to fetch CDC data.
        public var tlogAccessMode: DatabaseMigrationClientTypes.TlogAccessMode?
        /// Use the TrimSpaceInChar source endpoint setting to right-trim data on CHAR and NCHAR data types during migration. Setting TrimSpaceInChar does not left-trim data. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Use this to attribute to transfer data for full-load operations using BCP. When the target table contains an identity column that does not exist in the source table, you must disable the use BCP for loading table option.
        public var useBcpFullLoad: Swift.Bool?
        /// When this attribute is set to Y, DMS processes third-party transaction log backups if they are created in native format.
        public var useThirdPartyBackupDevice: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            bcpPacketSize: Swift.Int? = nil,
            controlTablesFileGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            forceLobLookup: Swift.Bool? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            querySingleAlwaysOnNode: Swift.Bool? = nil,
            readBackupOnly: Swift.Bool? = nil,
            safeguardPolicy: DatabaseMigrationClientTypes.SafeguardPolicy? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            tlogAccessMode: DatabaseMigrationClientTypes.TlogAccessMode? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useBcpFullLoad: Swift.Bool? = nil,
            useThirdPartyBackupDevice: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.forceLobLookup = forceLobLookup
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.tlogAccessMode = tlogAccessMode
            self.trimSpaceInChar = trimSpaceInChar
            self.useBcpFullLoad = useBcpFullLoad
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.MicrosoftSqlServerDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Microsoft SQL Server data provider.
    public struct MicrosoftSqlServerDataProviderSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the Microsoft SQL Server data provider.
        public var databaseName: Swift.String?
        /// The port value for the Microsoft SQL Server data provider.
        public var port: Swift.Int?
        /// The name of the Microsoft SQL Server server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the Microsoft SQL Server data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.MigrationProject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceProfileName = "InstanceProfileName"
        case migrationProjectArn = "MigrationProjectArn"
        case migrationProjectCreationTime = "MigrationProjectCreationTime"
        case migrationProjectName = "MigrationProjectName"
        case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
        case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
        case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
        case transformationRules = "TransformationRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let migrationProjectArn = self.migrationProjectArn {
            try encodeContainer.encode(migrationProjectArn, forKey: .migrationProjectArn)
        }
        if let migrationProjectCreationTime = self.migrationProjectCreationTime {
            try encodeContainer.encodeTimestamp(migrationProjectCreationTime, format: .dateTime, forKey: .migrationProjectCreationTime)
        }
        if let migrationProjectName = self.migrationProjectName {
            try encodeContainer.encode(migrationProjectName, forKey: .migrationProjectName)
        }
        if let schemaConversionApplicationAttributes = self.schemaConversionApplicationAttributes {
            try encodeContainer.encode(schemaConversionApplicationAttributes, forKey: .schemaConversionApplicationAttributes)
        }
        if let sourceDataProviderDescriptors = sourceDataProviderDescriptors {
            var sourceDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDataProviderDescriptors)
            for dataproviderdescriptor0 in sourceDataProviderDescriptors {
                try sourceDataProviderDescriptorsContainer.encode(dataproviderdescriptor0)
            }
        }
        if let targetDataProviderDescriptors = targetDataProviderDescriptors {
            var targetDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDataProviderDescriptors)
            for dataproviderdescriptor0 in targetDataProviderDescriptors {
                try targetDataProviderDescriptorsContainer.encode(dataproviderdescriptor0)
            }
        }
        if let transformationRules = self.transformationRules {
            try encodeContainer.encode(transformationRules, forKey: .transformationRules)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectName)
        migrationProjectName = migrationProjectNameDecoded
        let migrationProjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectArn)
        migrationProjectArn = migrationProjectArnDecoded
        let migrationProjectCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .migrationProjectCreationTime)
        migrationProjectCreationTime = migrationProjectCreationTimeDecoded
        let sourceDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptor?].self, forKey: .sourceDataProviderDescriptors)
        var sourceDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil
        if let sourceDataProviderDescriptorsContainer = sourceDataProviderDescriptorsContainer {
            sourceDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptor]()
            for structure0 in sourceDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    sourceDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        sourceDataProviderDescriptors = sourceDataProviderDescriptorsDecoded0
        let targetDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptor?].self, forKey: .targetDataProviderDescriptors)
        var targetDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil
        if let targetDataProviderDescriptorsContainer = targetDataProviderDescriptorsContainer {
            targetDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptor]()
            for structure0 in targetDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    targetDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        targetDataProviderDescriptors = targetDataProviderDescriptorsDecoded0
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let transformationRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformationRules)
        transformationRules = transformationRulesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaConversionApplicationAttributesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SCApplicationAttributes.self, forKey: .schemaConversionApplicationAttributes)
        schemaConversionApplicationAttributes = schemaConversionApplicationAttributesDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a migration project.
    public struct MigrationProject: Swift.Equatable {
        /// A user-friendly description of the migration project.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the instance profile for your migration project.
        public var instanceProfileArn: Swift.String?
        /// The name of the associated instance profile.
        public var instanceProfileName: Swift.String?
        /// The ARN string that uniquely identifies the migration project.
        public var migrationProjectArn: Swift.String?
        /// The time when the migration project was created.
        public var migrationProjectCreationTime: ClientRuntime.Date?
        /// The name of the migration project.
        public var migrationProjectName: Swift.String?
        /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
        public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
        /// Information about the source data provider, including the name or ARN, and Secrets Manager parameters.
        public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]?
        /// Information about the target data provider, including the name or ARN, and Secrets Manager parameters.
        public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]?
        /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
        public var transformationRules: Swift.String?

        public init(
            description: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            migrationProjectArn: Swift.String? = nil,
            migrationProjectCreationTime: ClientRuntime.Date? = nil,
            migrationProjectName: Swift.String? = nil,
            schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
            sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil,
            targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptor]? = nil,
            transformationRules: Swift.String? = nil
        )
        {
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileName = instanceProfileName
            self.migrationProjectArn = migrationProjectArn
            self.migrationProjectCreationTime = migrationProjectCreationTime
            self.migrationProjectName = migrationProjectName
            self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
            self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
            self.targetDataProviderDescriptors = targetDataProviderDescriptors
            self.transformationRules = transformationRules
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum MigrationTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cdc
        case fullLoad
        case fullLoadAndCdc
        case sdkUnknown(Swift.String)

        public static var allCases: [MigrationTypeValue] {
            return [
                .cdc,
                .fullLoad,
                .fullLoadAndCdc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cdc: return "cdc"
            case .fullLoad: return "full-load"
            case .fullLoadAndCdc: return "full-load-and-cdc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MigrationTypeValue(rawValue: rawValue) ?? MigrationTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension ModifyConversionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionConfiguration = "ConversionConfiguration"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionConfiguration = self.conversionConfiguration {
            try encodeContainer.encode(conversionConfiguration, forKey: .conversionConfiguration)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension ModifyConversionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyConversionConfigurationInput: Swift.Equatable {
    /// The new conversion configuration.
    /// This member is required.
    public var conversionConfiguration: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        conversionConfiguration: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.conversionConfiguration = conversionConfiguration
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct ModifyConversionConfigurationInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let conversionConfiguration: Swift.String?
}

extension ModifyConversionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionConfiguration = "ConversionConfiguration"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let conversionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionConfiguration)
        conversionConfiguration = conversionConfigurationDecoded
    }
}

extension ModifyConversionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyConversionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationProjectIdentifier = output.migrationProjectIdentifier
        } else {
            self.migrationProjectIdentifier = nil
        }
    }
}

public struct ModifyConversionConfigurationOutput: Swift.Equatable {
    /// The name or Amazon Resource Name (ARN) of the modified configuration.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct ModifyConversionConfigurationOutputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
}

extension ModifyConversionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
    }
}

enum ModifyConversionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyDataProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderIdentifier = "DataProviderIdentifier"
        case dataProviderName = "DataProviderName"
        case description = "Description"
        case engine = "Engine"
        case exactSettings = "ExactSettings"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataProviderIdentifier = self.dataProviderIdentifier {
            try encodeContainer.encode(dataProviderIdentifier, forKey: .dataProviderIdentifier)
        }
        if let dataProviderName = self.dataProviderName {
            try encodeContainer.encode(dataProviderName, forKey: .dataProviderName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let exactSettings = self.exactSettings {
            try encodeContainer.encode(exactSettings, forKey: .exactSettings)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }
}

extension ModifyDataProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyDataProviderInput: Swift.Equatable {
    /// The identifier of the data provider. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var dataProviderIdentifier: Swift.String?
    /// The name of the data provider.
    public var dataProviderName: Swift.String?
    /// A user-friendly description of the data provider.
    public var description: Swift.String?
    /// The type of database engine for the data provider. Valid values include "aurora", "aurora_postgresql", "mysql", "oracle", "postgres", and "sqlserver". A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
    public var engine: Swift.String?
    /// If this attribute is Y, the current call to ModifyDataProvider replaces all existing data provider settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyDataProvider does two things:
    ///
    /// * It replaces any data provider settings that already exist with new values, for settings with the same names.
    ///
    /// * It creates new data provider settings that you specify in the call, for settings with different names.
    public var exactSettings: Swift.Bool?
    /// The settings in JSON format for a data provider.
    public var settings: DatabaseMigrationClientTypes.DataProviderSettings?

    public init(
        dataProviderIdentifier: Swift.String? = nil,
        dataProviderName: Swift.String? = nil,
        description: Swift.String? = nil,
        engine: Swift.String? = nil,
        exactSettings: Swift.Bool? = nil,
        settings: DatabaseMigrationClientTypes.DataProviderSettings? = nil
    )
    {
        self.dataProviderIdentifier = dataProviderIdentifier
        self.dataProviderName = dataProviderName
        self.description = description
        self.engine = engine
        self.exactSettings = exactSettings
        self.settings = settings
    }
}

struct ModifyDataProviderInputBody: Swift.Equatable {
    let dataProviderIdentifier: Swift.String?
    let dataProviderName: Swift.String?
    let description: Swift.String?
    let engine: Swift.String?
    let exactSettings: Swift.Bool?
    let settings: DatabaseMigrationClientTypes.DataProviderSettings?
}

extension ModifyDataProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProviderIdentifier = "DataProviderIdentifier"
        case dataProviderName = "DataProviderName"
        case description = "Description"
        case engine = "Engine"
        case exactSettings = "ExactSettings"
        case settings = "Settings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderIdentifier)
        dataProviderIdentifier = dataProviderIdentifierDecoded
        let dataProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataProviderName)
        dataProviderName = dataProviderNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let exactSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exactSettings)
        exactSettings = exactSettingsDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProviderSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension ModifyDataProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyDataProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataProvider = output.dataProvider
        } else {
            self.dataProvider = nil
        }
    }
}

public struct ModifyDataProviderOutput: Swift.Equatable {
    /// The data provider that was modified.
    public var dataProvider: DatabaseMigrationClientTypes.DataProvider?

    public init(
        dataProvider: DatabaseMigrationClientTypes.DataProvider? = nil
    )
    {
        self.dataProvider = dataProvider
    }
}

struct ModifyDataProviderOutputBody: Swift.Equatable {
    let dataProvider: DatabaseMigrationClientTypes.DataProvider?
}

extension ModifyDataProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProvider = "DataProvider"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataProviderDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataProvider.self, forKey: .dataProvider)
        dataProvider = dataProviderDecoded
    }
}

enum ModifyDataProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEndpointInput(certificateArn: \(Swift.String(describing: certificateArn)), databaseName: \(Swift.String(describing: databaseName)), dmsTransferSettings: \(Swift.String(describing: dmsTransferSettings)), docDbSettings: \(Swift.String(describing: docDbSettings)), dynamoDbSettings: \(Swift.String(describing: dynamoDbSettings)), elasticsearchSettings: \(Swift.String(describing: elasticsearchSettings)), endpointArn: \(Swift.String(describing: endpointArn)), endpointIdentifier: \(Swift.String(describing: endpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), engineName: \(Swift.String(describing: engineName)), exactSettings: \(Swift.String(describing: exactSettings)), externalTableDefinition: \(Swift.String(describing: externalTableDefinition)), extraConnectionAttributes: \(Swift.String(describing: extraConnectionAttributes)), gcpMySQLSettings: \(Swift.String(describing: gcpMySQLSettings)), ibmDb2Settings: \(Swift.String(describing: ibmDb2Settings)), kafkaSettings: \(Swift.String(describing: kafkaSettings)), kinesisSettings: \(Swift.String(describing: kinesisSettings)), microsoftSQLServerSettings: \(Swift.String(describing: microsoftSQLServerSettings)), mongoDbSettings: \(Swift.String(describing: mongoDbSettings)), mySQLSettings: \(Swift.String(describing: mySQLSettings)), neptuneSettings: \(Swift.String(describing: neptuneSettings)), oracleSettings: \(Swift.String(describing: oracleSettings)), port: \(Swift.String(describing: port)), postgreSQLSettings: \(Swift.String(describing: postgreSQLSettings)), redisSettings: \(Swift.String(describing: redisSettings)), redshiftSettings: \(Swift.String(describing: redshiftSettings)), s3Settings: \(Swift.String(describing: s3Settings)), serverName: \(Swift.String(describing: serverName)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), sslMode: \(Swift.String(describing: sslMode)), sybaseSettings: \(Swift.String(describing: sybaseSettings)), timestreamSettings: \(Swift.String(describing: timestreamSettings)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension ModifyEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case exactSettings = "ExactSettings"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case timestreamSettings = "TimestreamSettings"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dmsTransferSettings = self.dmsTransferSettings {
            try encodeContainer.encode(dmsTransferSettings, forKey: .dmsTransferSettings)
        }
        if let docDbSettings = self.docDbSettings {
            try encodeContainer.encode(docDbSettings, forKey: .docDbSettings)
        }
        if let dynamoDbSettings = self.dynamoDbSettings {
            try encodeContainer.encode(dynamoDbSettings, forKey: .dynamoDbSettings)
        }
        if let elasticsearchSettings = self.elasticsearchSettings {
            try encodeContainer.encode(elasticsearchSettings, forKey: .elasticsearchSettings)
        }
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let endpointIdentifier = self.endpointIdentifier {
            try encodeContainer.encode(endpointIdentifier, forKey: .endpointIdentifier)
        }
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let exactSettings = self.exactSettings {
            try encodeContainer.encode(exactSettings, forKey: .exactSettings)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let extraConnectionAttributes = self.extraConnectionAttributes {
            try encodeContainer.encode(extraConnectionAttributes, forKey: .extraConnectionAttributes)
        }
        if let gcpMySQLSettings = self.gcpMySQLSettings {
            try encodeContainer.encode(gcpMySQLSettings, forKey: .gcpMySQLSettings)
        }
        if let ibmDb2Settings = self.ibmDb2Settings {
            try encodeContainer.encode(ibmDb2Settings, forKey: .ibmDb2Settings)
        }
        if let kafkaSettings = self.kafkaSettings {
            try encodeContainer.encode(kafkaSettings, forKey: .kafkaSettings)
        }
        if let kinesisSettings = self.kinesisSettings {
            try encodeContainer.encode(kinesisSettings, forKey: .kinesisSettings)
        }
        if let microsoftSQLServerSettings = self.microsoftSQLServerSettings {
            try encodeContainer.encode(microsoftSQLServerSettings, forKey: .microsoftSQLServerSettings)
        }
        if let mongoDbSettings = self.mongoDbSettings {
            try encodeContainer.encode(mongoDbSettings, forKey: .mongoDbSettings)
        }
        if let mySQLSettings = self.mySQLSettings {
            try encodeContainer.encode(mySQLSettings, forKey: .mySQLSettings)
        }
        if let neptuneSettings = self.neptuneSettings {
            try encodeContainer.encode(neptuneSettings, forKey: .neptuneSettings)
        }
        if let oracleSettings = self.oracleSettings {
            try encodeContainer.encode(oracleSettings, forKey: .oracleSettings)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let postgreSQLSettings = self.postgreSQLSettings {
            try encodeContainer.encode(postgreSQLSettings, forKey: .postgreSQLSettings)
        }
        if let redisSettings = self.redisSettings {
            try encodeContainer.encode(redisSettings, forKey: .redisSettings)
        }
        if let redshiftSettings = self.redshiftSettings {
            try encodeContainer.encode(redshiftSettings, forKey: .redshiftSettings)
        }
        if let s3Settings = self.s3Settings {
            try encodeContainer.encode(s3Settings, forKey: .s3Settings)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
        if let sybaseSettings = self.sybaseSettings {
            try encodeContainer.encode(sybaseSettings, forKey: .sybaseSettings)
        }
        if let timestreamSettings = self.timestreamSettings {
            try encodeContainer.encode(timestreamSettings, forKey: .timestreamSettings)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension ModifyEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
    public var certificateArn: Swift.String?
    /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
    public var databaseName: Swift.String?
    /// The settings in JSON format for the DMS transfer type of source endpoint. Attributes include the following:
    ///
    /// * serviceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
    ///
    /// * BucketName - The name of the S3 bucket to use.
    ///
    ///
    /// Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
    public var dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    /// Settings in JSON format for the source DocumentDB endpoint. For more information about the available settings, see the configuration properties section in [ Using DocumentDB as a Target for Database Migration Service ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DocumentDB.html) in the Database Migration Service User Guide.
    public var docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see [Using Object Mapping to Migrate Data to DynamoDB](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.DynamoDB.html#CHAP_Target.DynamoDB.ObjectMapping) in the Database Migration Service User Guide.
    public var dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see [Extra Connection Attributes When Using OpenSearch as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Elasticsearch.html#CHAP_Target.Elasticsearch.Configuration) in the Database Migration Service User Guide.
    public var elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
    public var endpointIdentifier: Swift.String?
    /// The type of endpoint. Valid values are source and target.
    public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
    public var engineName: Swift.String?
    /// If this attribute is Y, the current call to ModifyEndpoint replaces all existing endpoint settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyEndpoint does two things:
    ///
    /// * It replaces any endpoint settings that already exist with new values, for settings with the same names.
    ///
    /// * It creates new endpoint settings that you specify in the call, for settings with different names.
    ///
    ///
    /// For example, if you call create-endpoint ... --endpoint-settings '{"a":1}' ..., the endpoint has the following endpoint settings: '{"a":1}'. If you then call modify-endpoint ... --endpoint-settings '{"b":2}' ... for the same endpoint, the endpoint has the following settings: '{"a":1,"b":2}'. However, suppose that you follow this with a call to modify-endpoint ... --endpoint-settings '{"b":2}' --exact-settings ... for that same endpoint again. Then the endpoint has the following settings: '{"b":2}'. All existing settings are replaced with the exact settings that you specify.
    public var exactSettings: Swift.Bool?
    /// The external table definition.
    public var externalTableDefinition: Swift.String?
    /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
    public var extraConnectionAttributes: Swift.String?
    /// Settings in JSON format for the source GCP MySQL endpoint.
    public var gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see [Extra connection attributes when using Db2 LUW as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.DB2.html#CHAP_Source.DB2.ConnectionAttrib) in the Database Migration Service User Guide.
    public var ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see [Using object mapping to migrate data to a Kafka topic](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kafka.html#CHAP_Target.Kafka.ObjectMapping) in the Database Migration Service User Guide.
    public var kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see [Using object mapping to migrate data to a Kinesis data stream](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Kinesis.html#CHAP_Target.Kinesis.ObjectMapping) in the Database Migration Service User Guide.
    public var kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see [Extra connection attributes when using SQL Server as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html#CHAP_Source.SQLServer.ConnectionAttrib) and [ Extra connection attributes when using SQL Server as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SQLServer.html#CHAP_Target.SQLServer.ConnectionAttrib) in the Database Migration Service User Guide.
    public var microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in [Endpoint configuration settings when using MongoDB as a source for Database Migration Service](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MongoDB.html#CHAP_Source.MongoDB.Configuration) in the Database Migration Service User Guide.
    public var mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see [Extra connection attributes when using MySQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.MySQL.html#CHAP_Source.MySQL.ConnectionAttrib) and [Extra connection attributes when using a MySQL-compatible database as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.MySQL.html#CHAP_Target.MySQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see [Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.EndpointSettings) in the Database Migration Service User Guide.
    public var neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see [Extra connection attributes when using Oracle as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.ConnectionAttrib) and [ Extra connection attributes when using Oracle as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Oracle.html#CHAP_Target.Oracle.ConnectionAttrib) in the Database Migration Service User Guide.
    public var oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    /// The password to be used to login to the endpoint database.
    public var password: Swift.String?
    /// The port used by the endpoint database.
    public var port: Swift.Int?
    /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see [Extra connection attributes when using PostgreSQL as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib) and [ Extra connection attributes when using PostgreSQL as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.PostgreSQL.html#CHAP_Target.PostgreSQL.ConnectionAttrib) in the Database Migration Service User Guide.
    public var postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    /// Settings in JSON format for the Redis target endpoint.
    public var redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    /// Provides information that defines an Amazon Redshift endpoint.
    public var redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see [Extra Connection Attributes When Using Amazon S3 as a Target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring) in the Database Migration Service User Guide.
    public var s3Settings: DatabaseMigrationClientTypes.S3Settings?
    /// The name of the server where the endpoint database resides.
    public var serverName: Swift.String?
    /// The Amazon Resource Name (ARN) for the IAM role you want to use to modify the endpoint. The role must allow the iam:PassRole action.
    public var serviceAccessRoleArn: Swift.String?
    /// The SSL mode used to connect to the endpoint. The default value is none.
    public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see [Extra connection attributes when using SAP ASE as a source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SAP.html#CHAP_Source.SAP.ConnectionAttrib) and [Extra connection attributes when using SAP ASE as a target for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.SAP.html#CHAP_Target.SAP.ConnectionAttrib) in the Database Migration Service User Guide.
    public var sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    /// Settings in JSON format for the target Amazon Timestream endpoint.
    public var timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
    /// The user name to be used to login to the endpoint database.
    public var username: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings? = nil,
        docDbSettings: DatabaseMigrationClientTypes.DocDbSettings? = nil,
        dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings? = nil,
        elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings? = nil,
        endpointArn: Swift.String? = nil,
        endpointIdentifier: Swift.String? = nil,
        endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
        engineName: Swift.String? = nil,
        exactSettings: Swift.Bool? = nil,
        externalTableDefinition: Swift.String? = nil,
        extraConnectionAttributes: Swift.String? = nil,
        gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings? = nil,
        ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings? = nil,
        kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings? = nil,
        kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings? = nil,
        microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings? = nil,
        mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings? = nil,
        mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings? = nil,
        neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings? = nil,
        oracleSettings: DatabaseMigrationClientTypes.OracleSettings? = nil,
        password: Swift.String? = nil,
        port: Swift.Int? = nil,
        postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings? = nil,
        redisSettings: DatabaseMigrationClientTypes.RedisSettings? = nil,
        redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings? = nil,
        s3Settings: DatabaseMigrationClientTypes.S3Settings? = nil,
        serverName: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil,
        sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil,
        sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings? = nil,
        timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings? = nil,
        username: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.databaseName = databaseName
        self.dmsTransferSettings = dmsTransferSettings
        self.docDbSettings = docDbSettings
        self.dynamoDbSettings = dynamoDbSettings
        self.elasticsearchSettings = elasticsearchSettings
        self.endpointArn = endpointArn
        self.endpointIdentifier = endpointIdentifier
        self.endpointType = endpointType
        self.engineName = engineName
        self.exactSettings = exactSettings
        self.externalTableDefinition = externalTableDefinition
        self.extraConnectionAttributes = extraConnectionAttributes
        self.gcpMySQLSettings = gcpMySQLSettings
        self.ibmDb2Settings = ibmDb2Settings
        self.kafkaSettings = kafkaSettings
        self.kinesisSettings = kinesisSettings
        self.microsoftSQLServerSettings = microsoftSQLServerSettings
        self.mongoDbSettings = mongoDbSettings
        self.mySQLSettings = mySQLSettings
        self.neptuneSettings = neptuneSettings
        self.oracleSettings = oracleSettings
        self.password = password
        self.port = port
        self.postgreSQLSettings = postgreSQLSettings
        self.redisSettings = redisSettings
        self.redshiftSettings = redshiftSettings
        self.s3Settings = s3Settings
        self.serverName = serverName
        self.serviceAccessRoleArn = serviceAccessRoleArn
        self.sslMode = sslMode
        self.sybaseSettings = sybaseSettings
        self.timestreamSettings = timestreamSettings
        self.username = username
    }
}

struct ModifyEndpointInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let endpointIdentifier: Swift.String?
    let endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
    let engineName: Swift.String?
    let username: Swift.String?
    let password: Swift.String?
    let serverName: Swift.String?
    let port: Swift.Int?
    let databaseName: Swift.String?
    let extraConnectionAttributes: Swift.String?
    let certificateArn: Swift.String?
    let sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?
    let serviceAccessRoleArn: Swift.String?
    let externalTableDefinition: Swift.String?
    let dynamoDbSettings: DatabaseMigrationClientTypes.DynamoDbSettings?
    let s3Settings: DatabaseMigrationClientTypes.S3Settings?
    let dmsTransferSettings: DatabaseMigrationClientTypes.DmsTransferSettings?
    let mongoDbSettings: DatabaseMigrationClientTypes.MongoDbSettings?
    let kinesisSettings: DatabaseMigrationClientTypes.KinesisSettings?
    let kafkaSettings: DatabaseMigrationClientTypes.KafkaSettings?
    let elasticsearchSettings: DatabaseMigrationClientTypes.ElasticsearchSettings?
    let neptuneSettings: DatabaseMigrationClientTypes.NeptuneSettings?
    let redshiftSettings: DatabaseMigrationClientTypes.RedshiftSettings?
    let postgreSQLSettings: DatabaseMigrationClientTypes.PostgreSQLSettings?
    let mySQLSettings: DatabaseMigrationClientTypes.MySQLSettings?
    let oracleSettings: DatabaseMigrationClientTypes.OracleSettings?
    let sybaseSettings: DatabaseMigrationClientTypes.SybaseSettings?
    let microsoftSQLServerSettings: DatabaseMigrationClientTypes.MicrosoftSQLServerSettings?
    let ibmDb2Settings: DatabaseMigrationClientTypes.IBMDb2Settings?
    let docDbSettings: DatabaseMigrationClientTypes.DocDbSettings?
    let redisSettings: DatabaseMigrationClientTypes.RedisSettings?
    let exactSettings: Swift.Bool?
    let gcpMySQLSettings: DatabaseMigrationClientTypes.GcpMySQLSettings?
    let timestreamSettings: DatabaseMigrationClientTypes.TimestreamSettings?
}

extension ModifyEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case dmsTransferSettings = "DmsTransferSettings"
        case docDbSettings = "DocDbSettings"
        case dynamoDbSettings = "DynamoDbSettings"
        case elasticsearchSettings = "ElasticsearchSettings"
        case endpointArn = "EndpointArn"
        case endpointIdentifier = "EndpointIdentifier"
        case endpointType = "EndpointType"
        case engineName = "EngineName"
        case exactSettings = "ExactSettings"
        case externalTableDefinition = "ExternalTableDefinition"
        case extraConnectionAttributes = "ExtraConnectionAttributes"
        case gcpMySQLSettings = "GcpMySQLSettings"
        case ibmDb2Settings = "IBMDb2Settings"
        case kafkaSettings = "KafkaSettings"
        case kinesisSettings = "KinesisSettings"
        case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
        case mongoDbSettings = "MongoDbSettings"
        case mySQLSettings = "MySQLSettings"
        case neptuneSettings = "NeptuneSettings"
        case oracleSettings = "OracleSettings"
        case password = "Password"
        case port = "Port"
        case postgreSQLSettings = "PostgreSQLSettings"
        case redisSettings = "RedisSettings"
        case redshiftSettings = "RedshiftSettings"
        case s3Settings = "S3Settings"
        case serverName = "ServerName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case sslMode = "SslMode"
        case sybaseSettings = "SybaseSettings"
        case timestreamSettings = "TimestreamSettings"
        case username = "Username"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let endpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointIdentifier)
        endpointIdentifier = endpointIdentifierDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let extraConnectionAttributesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extraConnectionAttributes)
        extraConnectionAttributes = extraConnectionAttributesDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let dynamoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DynamoDbSettings.self, forKey: .dynamoDbSettings)
        dynamoDbSettings = dynamoDbSettingsDecoded
        let s3SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.S3Settings.self, forKey: .s3Settings)
        s3Settings = s3SettingsDecoded
        let dmsTransferSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsTransferSettings.self, forKey: .dmsTransferSettings)
        dmsTransferSettings = dmsTransferSettingsDecoded
        let mongoDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MongoDbSettings.self, forKey: .mongoDbSettings)
        mongoDbSettings = mongoDbSettingsDecoded
        let kinesisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KinesisSettings.self, forKey: .kinesisSettings)
        kinesisSettings = kinesisSettingsDecoded
        let kafkaSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSettings.self, forKey: .kafkaSettings)
        kafkaSettings = kafkaSettingsDecoded
        let elasticsearchSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ElasticsearchSettings.self, forKey: .elasticsearchSettings)
        elasticsearchSettings = elasticsearchSettingsDecoded
        let neptuneSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NeptuneSettings.self, forKey: .neptuneSettings)
        neptuneSettings = neptuneSettingsDecoded
        let redshiftSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedshiftSettings.self, forKey: .redshiftSettings)
        redshiftSettings = redshiftSettingsDecoded
        let postgreSQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PostgreSQLSettings.self, forKey: .postgreSQLSettings)
        postgreSQLSettings = postgreSQLSettingsDecoded
        let mySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MySQLSettings.self, forKey: .mySQLSettings)
        mySQLSettings = mySQLSettingsDecoded
        let oracleSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OracleSettings.self, forKey: .oracleSettings)
        oracleSettings = oracleSettingsDecoded
        let sybaseSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SybaseSettings.self, forKey: .sybaseSettings)
        sybaseSettings = sybaseSettingsDecoded
        let microsoftSQLServerSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MicrosoftSQLServerSettings.self, forKey: .microsoftSQLServerSettings)
        microsoftSQLServerSettings = microsoftSQLServerSettingsDecoded
        let ibmDb2SettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.IBMDb2Settings.self, forKey: .ibmDb2Settings)
        ibmDb2Settings = ibmDb2SettingsDecoded
        let docDbSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DocDbSettings.self, forKey: .docDbSettings)
        docDbSettings = docDbSettingsDecoded
        let redisSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisSettings.self, forKey: .redisSettings)
        redisSettings = redisSettingsDecoded
        let exactSettingsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exactSettings)
        exactSettings = exactSettingsDecoded
        let gcpMySQLSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.GcpMySQLSettings.self, forKey: .gcpMySQLSettings)
        gcpMySQLSettings = gcpMySQLSettingsDecoded
        let timestreamSettingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TimestreamSettings.self, forKey: .timestreamSettings)
        timestreamSettings = timestreamSettingsDecoded
    }
}

extension ModifyEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

///
public struct ModifyEndpointOutput: Swift.Equatable {
    /// The modified endpoint.
    public var endpoint: DatabaseMigrationClientTypes.Endpoint?

    public init(
        endpoint: DatabaseMigrationClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct ModifyEndpointOutputBody: Swift.Equatable {
    let endpoint: DatabaseMigrationClientTypes.Endpoint?
}

extension ModifyEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum ModifyEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyEventSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategories)
            for string0 in eventCategories {
                try eventCategoriesContainer.encode(string0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
    }
}

extension ModifyEventSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    /// A Boolean value; set to true to activate the subscription.
    public var enabled: Swift.Bool?
    /// A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    public var snsTopicArn: Swift.String?
    /// The type of DMS resource that generates the events you want to subscribe to. Valid values: replication-instance | replication-task
    public var sourceType: Swift.String?
    /// The name of the DMS event notification subscription to be modified.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init(
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

struct ModifyEventSubscriptionInputBody: Swift.Equatable {
    let subscriptionName: Swift.String?
    let snsTopicArn: Swift.String?
    let sourceType: Swift.String?
    let eventCategories: [Swift.String]?
    let enabled: Swift.Bool?
}

extension ModifyEventSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case eventCategories = "EventCategories"
        case snsTopicArn = "SnsTopicArn"
        case sourceType = "SourceType"
        case subscriptionName = "SubscriptionName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let eventCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategories)
        var eventCategoriesDecoded0:[Swift.String]? = nil
        if let eventCategoriesContainer = eventCategoriesContainer {
            eventCategoriesDecoded0 = [Swift.String]()
            for string0 in eventCategoriesContainer {
                if let string0 = string0 {
                    eventCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventCategories = eventCategoriesDecoded0
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ModifyEventSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyEventSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

///
public struct ModifyEventSubscriptionOutput: Swift.Equatable {
    /// The modified event subscription.
    public var eventSubscription: DatabaseMigrationClientTypes.EventSubscription?

    public init(
        eventSubscription: DatabaseMigrationClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputBody: Swift.Equatable {
    let eventSubscription: DatabaseMigrationClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

enum ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "KMSAccessDeniedFault": return try await KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSDisabledFault": return try await KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidStateFault": return try await KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSNotFoundFault": return try await KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSThrottlingFault": return try await KMSThrottlingFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SNSInvalidTopicFault": return try await SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SNSNoAuthorizationFault": return try await SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyInstanceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case instanceProfileName = "InstanceProfileName"
        case kmsKeyArn = "KmsKeyArn"
        case networkType = "NetworkType"
        case publiclyAccessible = "PubliclyAccessible"
        case subnetGroupIdentifier = "SubnetGroupIdentifier"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileIdentifier = self.instanceProfileIdentifier {
            try encodeContainer.encode(instanceProfileIdentifier, forKey: .instanceProfileIdentifier)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let publiclyAccessible = self.publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let subnetGroupIdentifier = self.subnetGroupIdentifier {
            try encodeContainer.encode(subnetGroupIdentifier, forKey: .subnetGroupIdentifier)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for string0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(string0)
            }
        }
    }
}

extension ModifyInstanceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyInstanceProfileInput: Swift.Equatable {
    /// The Availability Zone where the instance profile runs.
    public var availabilityZone: Swift.String?
    /// A user-friendly description for the instance profile.
    public var description: Swift.String?
    /// The identifier of the instance profile. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var instanceProfileIdentifier: Swift.String?
    /// A user-friendly name for the instance profile.
    public var instanceProfileName: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
    public var kmsKeyArn: Swift.String?
    /// Specifies the network type for the instance profile. A value of IPV4 represents an instance profile with IPv4 network type and only supports IPv4 addressing. A value of IPV6 represents an instance profile with IPv6 network type and only supports IPv6 addressing. A value of DUAL represents an instance profile with dual network type that supports IPv4 and IPv6 addressing.
    public var networkType: Swift.String?
    /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
    public var publiclyAccessible: Swift.Bool?
    /// A subnet group to associate with the instance profile.
    public var subnetGroupIdentifier: Swift.String?
    /// Specifies the VPC security groups to be used with the instance profile. The VPC security group must work with the VPC containing the instance profile.
    public var vpcSecurityGroups: [Swift.String]?

    public init(
        availabilityZone: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        instanceProfileName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        networkType: Swift.String? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        subnetGroupIdentifier: Swift.String? = nil,
        vpcSecurityGroups: [Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.instanceProfileName = instanceProfileName
        self.kmsKeyArn = kmsKeyArn
        self.networkType = networkType
        self.publiclyAccessible = publiclyAccessible
        self.subnetGroupIdentifier = subnetGroupIdentifier
        self.vpcSecurityGroups = vpcSecurityGroups
    }
}

struct ModifyInstanceProfileInputBody: Swift.Equatable {
    let instanceProfileIdentifier: Swift.String?
    let availabilityZone: Swift.String?
    let kmsKeyArn: Swift.String?
    let publiclyAccessible: Swift.Bool?
    let networkType: Swift.String?
    let instanceProfileName: Swift.String?
    let description: Swift.String?
    let subnetGroupIdentifier: Swift.String?
    let vpcSecurityGroups: [Swift.String]?
}

extension ModifyInstanceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case instanceProfileName = "InstanceProfileName"
        case kmsKeyArn = "KmsKeyArn"
        case networkType = "NetworkType"
        case publiclyAccessible = "PubliclyAccessible"
        case subnetGroupIdentifier = "SubnetGroupIdentifier"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileIdentifier)
        instanceProfileIdentifier = instanceProfileIdentifierDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let subnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupIdentifier)
        subnetGroupIdentifier = subnetGroupIdentifierDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
    }
}

extension ModifyInstanceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyInstanceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceProfile = output.instanceProfile
        } else {
            self.instanceProfile = nil
        }
    }
}

public struct ModifyInstanceProfileOutput: Swift.Equatable {
    /// The instance profile that was modified.
    public var instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?

    public init(
        instanceProfile: DatabaseMigrationClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

struct ModifyInstanceProfileOutputBody: Swift.Equatable {
    let instanceProfile: DatabaseMigrationClientTypes.InstanceProfile?
}

extension ModifyInstanceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceProfile = "InstanceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceProfileDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.InstanceProfile.self, forKey: .instanceProfile)
        instanceProfile = instanceProfileDecoded
    }
}

enum ModifyInstanceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyMigrationProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case migrationProjectName = "MigrationProjectName"
        case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
        case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
        case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
        case transformationRules = "TransformationRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileIdentifier = self.instanceProfileIdentifier {
            try encodeContainer.encode(instanceProfileIdentifier, forKey: .instanceProfileIdentifier)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let migrationProjectName = self.migrationProjectName {
            try encodeContainer.encode(migrationProjectName, forKey: .migrationProjectName)
        }
        if let schemaConversionApplicationAttributes = self.schemaConversionApplicationAttributes {
            try encodeContainer.encode(schemaConversionApplicationAttributes, forKey: .schemaConversionApplicationAttributes)
        }
        if let sourceDataProviderDescriptors = sourceDataProviderDescriptors {
            var sourceDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceDataProviderDescriptors)
            for dataproviderdescriptordefinition0 in sourceDataProviderDescriptors {
                try sourceDataProviderDescriptorsContainer.encode(dataproviderdescriptordefinition0)
            }
        }
        if let targetDataProviderDescriptors = targetDataProviderDescriptors {
            var targetDataProviderDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDataProviderDescriptors)
            for dataproviderdescriptordefinition0 in targetDataProviderDescriptors {
                try targetDataProviderDescriptorsContainer.encode(dataproviderdescriptordefinition0)
            }
        }
        if let transformationRules = self.transformationRules {
            try encodeContainer.encode(transformationRules, forKey: .transformationRules)
        }
    }
}

extension ModifyMigrationProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyMigrationProjectInput: Swift.Equatable {
    /// A user-friendly description of the migration project.
    public var description: Swift.String?
    /// The name or Amazon Resource Name (ARN) for the instance profile.
    public var instanceProfileIdentifier: Swift.String?
    /// The identifier of the migration project. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A user-friendly name for the migration project.
    public var migrationProjectName: Swift.String?
    /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
    public var schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
    /// Information about the source data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    public var sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
    public var targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    /// The settings in JSON format for migration rules. Migration rules make it possible for you to change the object names according to the rules that you specify. For example, you can change an object name to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
    public var transformationRules: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceProfileIdentifier: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        migrationProjectName: Swift.String? = nil,
        schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes? = nil,
        sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil,
        transformationRules: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceProfileIdentifier = instanceProfileIdentifier
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.migrationProjectName = migrationProjectName
        self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
        self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
        self.targetDataProviderDescriptors = targetDataProviderDescriptors
        self.transformationRules = transformationRules
    }
}

struct ModifyMigrationProjectInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let migrationProjectName: Swift.String?
    let sourceDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    let targetDataProviderDescriptors: [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]?
    let instanceProfileIdentifier: Swift.String?
    let transformationRules: Swift.String?
    let description: Swift.String?
    let schemaConversionApplicationAttributes: DatabaseMigrationClientTypes.SCApplicationAttributes?
}

extension ModifyMigrationProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceProfileIdentifier = "InstanceProfileIdentifier"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case migrationProjectName = "MigrationProjectName"
        case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
        case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
        case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
        case transformationRules = "TransformationRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let migrationProjectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectName)
        migrationProjectName = migrationProjectNameDecoded
        let sourceDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptorDefinition?].self, forKey: .sourceDataProviderDescriptors)
        var sourceDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil
        if let sourceDataProviderDescriptorsContainer = sourceDataProviderDescriptorsContainer {
            sourceDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]()
            for structure0 in sourceDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    sourceDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        sourceDataProviderDescriptors = sourceDataProviderDescriptorsDecoded0
        let targetDataProviderDescriptorsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.DataProviderDescriptorDefinition?].self, forKey: .targetDataProviderDescriptors)
        var targetDataProviderDescriptorsDecoded0:[DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]? = nil
        if let targetDataProviderDescriptorsContainer = targetDataProviderDescriptorsContainer {
            targetDataProviderDescriptorsDecoded0 = [DatabaseMigrationClientTypes.DataProviderDescriptorDefinition]()
            for structure0 in targetDataProviderDescriptorsContainer {
                if let structure0 = structure0 {
                    targetDataProviderDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        targetDataProviderDescriptors = targetDataProviderDescriptorsDecoded0
        let instanceProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileIdentifier)
        instanceProfileIdentifier = instanceProfileIdentifierDecoded
        let transformationRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformationRules)
        transformationRules = transformationRulesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaConversionApplicationAttributesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SCApplicationAttributes.self, forKey: .schemaConversionApplicationAttributes)
        schemaConversionApplicationAttributes = schemaConversionApplicationAttributesDecoded
    }
}

extension ModifyMigrationProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyMigrationProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationProject = output.migrationProject
        } else {
            self.migrationProject = nil
        }
    }
}

public struct ModifyMigrationProjectOutput: Swift.Equatable {
    /// The migration project that was modified.
    public var migrationProject: DatabaseMigrationClientTypes.MigrationProject?

    public init(
        migrationProject: DatabaseMigrationClientTypes.MigrationProject? = nil
    )
    {
        self.migrationProject = migrationProject
    }
}

struct ModifyMigrationProjectOutputBody: Swift.Equatable {
    let migrationProject: DatabaseMigrationClientTypes.MigrationProject?
}

extension ModifyMigrationProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProject = "MigrationProject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationProject.self, forKey: .migrationProject)
        migrationProject = migrationProjectDecoded
    }
}

enum ModifyMigrationProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyReplicationConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeConfig = "ComputeConfig"
        case replicationConfigArn = "ReplicationConfigArn"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationSettings = "ReplicationSettings"
        case replicationType = "ReplicationType"
        case sourceEndpointArn = "SourceEndpointArn"
        case supplementalSettings = "SupplementalSettings"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeConfig = self.computeConfig {
            try encodeContainer.encode(computeConfig, forKey: .computeConfig)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
        if let replicationConfigIdentifier = self.replicationConfigIdentifier {
            try encodeContainer.encode(replicationConfigIdentifier, forKey: .replicationConfigIdentifier)
        }
        if let replicationSettings = self.replicationSettings {
            try encodeContainer.encode(replicationSettings, forKey: .replicationSettings)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let supplementalSettings = self.supplementalSettings {
            try encodeContainer.encode(supplementalSettings, forKey: .supplementalSettings)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
    }
}

extension ModifyReplicationConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationConfigInput: Swift.Equatable {
    /// Configuration parameters for provisioning an DMS Serverless replication.
    public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    /// The Amazon Resource Name of the replication to modify.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The new replication config to apply to the replication.
    public var replicationConfigIdentifier: Swift.String?
    /// The settings for the replication.
    public var replicationSettings: Swift.String?
    /// The type of replication.
    public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
    public var sourceEndpointArn: Swift.String?
    /// Additional settings for the replication.
    public var supplementalSettings: Swift.String?
    /// Table mappings specified in the replication.
    public var tableMappings: Swift.String?
    /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
    public var targetEndpointArn: Swift.String?

    public init(
        computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
        replicationConfigArn: Swift.String? = nil,
        replicationConfigIdentifier: Swift.String? = nil,
        replicationSettings: Swift.String? = nil,
        replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        sourceEndpointArn: Swift.String? = nil,
        supplementalSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        targetEndpointArn: Swift.String? = nil
    )
    {
        self.computeConfig = computeConfig
        self.replicationConfigArn = replicationConfigArn
        self.replicationConfigIdentifier = replicationConfigIdentifier
        self.replicationSettings = replicationSettings
        self.replicationType = replicationType
        self.sourceEndpointArn = sourceEndpointArn
        self.supplementalSettings = supplementalSettings
        self.tableMappings = tableMappings
        self.targetEndpointArn = targetEndpointArn
    }
}

struct ModifyReplicationConfigInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
    let replicationConfigIdentifier: Swift.String?
    let replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationSettings: Swift.String?
    let supplementalSettings: Swift.String?
    let computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
    let sourceEndpointArn: Swift.String?
    let targetEndpointArn: Swift.String?
}

extension ModifyReplicationConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeConfig = "ComputeConfig"
        case replicationConfigArn = "ReplicationConfigArn"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationSettings = "ReplicationSettings"
        case replicationType = "ReplicationType"
        case sourceEndpointArn = "SourceEndpointArn"
        case supplementalSettings = "SupplementalSettings"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let replicationConfigIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigIdentifier)
        replicationConfigIdentifier = replicationConfigIdentifierDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSettings)
        replicationSettings = replicationSettingsDecoded
        let supplementalSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supplementalSettings)
        supplementalSettings = supplementalSettingsDecoded
        let computeConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ComputeConfig.self, forKey: .computeConfig)
        computeConfig = computeConfigDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
    }
}

extension ModifyReplicationConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyReplicationConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfig = output.replicationConfig
        } else {
            self.replicationConfig = nil
        }
    }
}

public struct ModifyReplicationConfigOutput: Swift.Equatable {
    /// Information about the serverless replication config that was modified.
    public var replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?

    public init(
        replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig? = nil
    )
    {
        self.replicationConfig = replicationConfig
    }
}

struct ModifyReplicationConfigOutputBody: Swift.Equatable {
    let replicationConfig: DatabaseMigrationClientTypes.ReplicationConfig?
}

extension ModifyReplicationConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfig = "ReplicationConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationConfig.self, forKey: .replicationConfig)
        replicationConfig = replicationConfigDecoded
    }
}

enum ModifyReplicationConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try await ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let allowMajorVersionUpgrade = self.allowMajorVersionUpgrade {
            try encodeContainer.encode(allowMajorVersionUpgrade, forKey: .allowMajorVersionUpgrade)
        }
        if let applyImmediately = self.applyImmediately {
            try encodeContainer.encode(applyImmediately, forKey: .applyImmediately)
        }
        if let autoMinorVersionUpgrade = self.autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension ModifyReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationInstanceInput: Swift.Equatable {
    /// The amount of storage (in gigabytes) to be allocated for the replication instance.
    public var allocatedStorage: Swift.Int?
    /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
    public var allowMajorVersionUpgrade: Swift.Bool?
    /// Indicates whether the changes should be applied immediately or during the next maintenance window.
    public var applyImmediately: Swift.Bool?
    /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case described following. The change is asynchronously applied as soon as possible. An outage does result if these factors apply:
    ///
    /// * This parameter is set to true during the maintenance window.
    ///
    /// * A newer minor version is available.
    ///
    /// * DMS has enabled automatic patching for the given engine version.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
    public var engineVersion: Swift.String?
    /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
    public var multiAZ: Swift.Bool?
    /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
    public var networkType: Swift.String?
    /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
    public var preferredMaintenanceWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?
    /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
    public var replicationInstanceClass: Swift.String?
    /// The replication instance identifier. This parameter is stored as a lowercase string.
    public var replicationInstanceIdentifier: Swift.String?
    /// Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool? = nil,
        applyImmediately: Swift.Bool? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        networkType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil,
        replicationInstanceClass: Swift.String? = nil,
        replicationInstanceIdentifier: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.engineVersion = engineVersion
        self.multiAZ = multiAZ
        self.networkType = networkType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationInstanceArn = replicationInstanceArn
        self.replicationInstanceClass = replicationInstanceClass
        self.replicationInstanceIdentifier = replicationInstanceIdentifier
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct ModifyReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let allocatedStorage: Swift.Int?
    let applyImmediately: Swift.Bool?
    let replicationInstanceClass: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let preferredMaintenanceWindow: Swift.String?
    let multiAZ: Swift.Bool?
    let engineVersion: Swift.String?
    let allowMajorVersionUpgrade: Swift.Bool?
    let autoMinorVersionUpgrade: Swift.Bool?
    let replicationInstanceIdentifier: Swift.String?
    let networkType: Swift.String?
}

extension ModifyReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
        case applyImmediately = "ApplyImmediately"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let applyImmediatelyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let allowMajorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowMajorVersionUpgrade)
        allowMajorVersionUpgrade = allowMajorVersionUpgradeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension ModifyReplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyReplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

///
public struct ModifyReplicationInstanceOutput: Swift.Equatable {
    /// The modified replication instance.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct ModifyReplicationInstanceOutputBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension ModifyReplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

enum ModifyReplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientResourceCapacityFault": return try await InsufficientResourceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StorageQuotaExceededFault": return try await StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UpgradeDependencyFailureFault": return try await UpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyReplicationSubnetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }
}

extension ModifyReplicationSubnetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationSubnetGroupInput: Swift.Equatable {
    /// A description for the replication instance subnet group.
    public var replicationSubnetGroupDescription: Swift.String?
    /// The name of the replication instance subnet group.
    /// This member is required.
    public var replicationSubnetGroupIdentifier: Swift.String?
    /// A list of subnet IDs.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init(
        replicationSubnetGroupDescription: Swift.String? = nil,
        replicationSubnetGroupIdentifier: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
        self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        self.subnetIds = subnetIds
    }
}

struct ModifyReplicationSubnetGroupInputBody: Swift.Equatable {
    let replicationSubnetGroupIdentifier: Swift.String?
    let replicationSubnetGroupDescription: Swift.String?
    let subnetIds: [Swift.String]?
}

extension ModifyReplicationSubnetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetIds = "SubnetIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension ModifyReplicationSubnetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyReplicationSubnetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationSubnetGroup = output.replicationSubnetGroup
        } else {
            self.replicationSubnetGroup = nil
        }
    }
}

///
public struct ModifyReplicationSubnetGroupOutput: Swift.Equatable {
    /// The modified replication subnet group.
    public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?

    public init(
        replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil
    )
    {
        self.replicationSubnetGroup = replicationSubnetGroup
    }
}

struct ModifyReplicationSubnetGroupOutputBody: Swift.Equatable {
    let replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
}

extension ModifyReplicationSubnetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroup = "ReplicationSubnetGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
    }
}

enum ModifyReplicationSubnetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSubnet": return try await InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationSubnetGroupDoesNotCoverEnoughAZs": return try await ReplicationSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetAlreadyInUse": return try await SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }
}

extension ModifyReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ModifyReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€ Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€ When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€ Commit time example: --cdc-stop-position â€œcommit_time:2018-02-09T12:12:12â€œ
    public var cdcStopPosition: Swift.String?
    /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
    public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The replication task identifier. Constraints:
    ///
    /// * Must contain 1-255 alphanumeric characters or hyphens.
    ///
    /// * First character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    public var replicationTaskIdentifier: Swift.String?
    /// JSON file that contains settings for the task, such as task metadata settings.
    public var replicationTaskSettings: Swift.String?
    /// When using the CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. For example, --table-mappings file://mappingfile.json. When working with the DMS API, provide the JSON as the parameter value.
    public var tableMappings: Swift.String?
    /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
    public var taskData: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        replicationTaskIdentifier: Swift.String? = nil,
        replicationTaskSettings: Swift.String? = nil,
        tableMappings: Swift.String? = nil,
        taskData: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.migrationType = migrationType
        self.replicationTaskArn = replicationTaskArn
        self.replicationTaskIdentifier = replicationTaskIdentifier
        self.replicationTaskSettings = replicationTaskSettings
        self.tableMappings = tableMappings
        self.taskData = taskData
    }
}

struct ModifyReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let replicationTaskIdentifier: Swift.String?
    let migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
    let tableMappings: Swift.String?
    let replicationTaskSettings: Swift.String?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
    let taskData: Swift.String?
}

extension ModifyReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case migrationType = "MigrationType"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case tableMappings = "TableMappings"
        case taskData = "TaskData"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
    }
}

extension ModifyReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ModifyReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct ModifyReplicationTaskOutput: Swift.Equatable {
    /// The replication task that was modified.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct ModifyReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension ModifyReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum ModifyReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.MongoDbDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authMechanism = "AuthMechanism"
        case authSource = "AuthSource"
        case authType = "AuthType"
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authMechanism = self.authMechanism {
            try encodeContainer.encode(authMechanism.rawValue, forKey: .authMechanism)
        }
        if let authSource = self.authSource {
            try encodeContainer.encode(authSource, forKey: .authSource)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authSource)
        authSource = authSourceDecoded
        let authMechanismDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthMechanismValue.self, forKey: .authMechanism)
        authMechanism = authMechanismDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MongoDB data provider.
    public struct MongoDbDataProviderSettings: Swift.Equatable {
        /// The authentication method for connecting to the data provider. Valid values are DEFAULT, MONGODB_CR, or SCRAM_SHA_1.
        public var authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// The MongoDB database name. This setting isn't used when AuthType is set to "no". The default is "admin".
        public var authSource: Swift.String?
        /// The authentication type for the database connection. Valid values are PASSWORD or NO.
        public var authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the MongoDB data provider.
        public var databaseName: Swift.String?
        /// The port value for the MongoDB data provider.
        public var port: Swift.Int?
        /// The name of the MongoDB server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MongoDB data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authMechanism = "AuthMechanism"
        case authSource = "AuthSource"
        case authType = "AuthType"
        case databaseName = "DatabaseName"
        case docsToInvestigate = "DocsToInvestigate"
        case extractDocId = "ExtractDocId"
        case kmsKeyId = "KmsKeyId"
        case nestingLevel = "NestingLevel"
        case password = "Password"
        case port = "Port"
        case replicateShardCollections = "ReplicateShardCollections"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case useUpdateLookUp = "UseUpdateLookUp"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authMechanism = self.authMechanism {
            try encodeContainer.encode(authMechanism.rawValue, forKey: .authMechanism)
        }
        if let authSource = self.authSource {
            try encodeContainer.encode(authSource, forKey: .authSource)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let docsToInvestigate = self.docsToInvestigate {
            try encodeContainer.encode(docsToInvestigate, forKey: .docsToInvestigate)
        }
        if let extractDocId = self.extractDocId {
            try encodeContainer.encode(extractDocId, forKey: .extractDocId)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let nestingLevel = self.nestingLevel {
            try encodeContainer.encode(nestingLevel.rawValue, forKey: .nestingLevel)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let replicateShardCollections = self.replicateShardCollections {
            try encodeContainer.encode(replicateShardCollections, forKey: .replicateShardCollections)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let useUpdateLookUp = self.useUpdateLookUp {
            try encodeContainer.encode(useUpdateLookUp, forKey: .useUpdateLookUp)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authMechanismDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AuthMechanismValue.self, forKey: .authMechanism)
        authMechanism = authMechanismDecoded
        let nestingLevelDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.NestingLevelValue.self, forKey: .nestingLevel)
        nestingLevel = nestingLevelDecoded
        let extractDocIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extractDocId)
        extractDocId = extractDocIdDecoded
        let docsToInvestigateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .docsToInvestigate)
        docsToInvestigate = docsToInvestigateDecoded
        let authSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authSource)
        authSource = authSourceDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let useUpdateLookUpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useUpdateLookUp)
        useUpdateLookUp = useUpdateLookUpDecoded
        let replicateShardCollectionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicateShardCollections)
        replicateShardCollections = replicateShardCollectionsDecoded
    }
}

extension DatabaseMigrationClientTypes.MongoDbSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MongoDbSettings(authMechanism: \(Swift.String(describing: authMechanism)), authSource: \(Swift.String(describing: authSource)), authType: \(Swift.String(describing: authType)), databaseName: \(Swift.String(describing: databaseName)), docsToInvestigate: \(Swift.String(describing: docsToInvestigate)), extractDocId: \(Swift.String(describing: extractDocId)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), nestingLevel: \(Swift.String(describing: nestingLevel)), port: \(Swift.String(describing: port)), replicateShardCollections: \(Swift.String(describing: replicateShardCollections)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), useUpdateLookUp: \(Swift.String(describing: useUpdateLookUp)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MongoDB endpoint.
    public struct MongoDbSettings: Swift.Equatable {
        /// The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public var authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue?
        /// The MongoDB database name. This setting isn't used when AuthType is set to "no". The default is "admin".
        public var authSource: Swift.String?
        /// The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty.
        public var authType: DatabaseMigrationClientTypes.AuthTypeValue?
        /// The database name on the MongoDB source endpoint.
        public var databaseName: Swift.String?
        /// Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one". Must be a positive value greater than 0. Default value is 1000.
        public var docsToInvestigate: Swift.String?
        /// Specifies the document ID. Use this setting when NestingLevel is set to "none". Default value is "false".
        public var extractDocId: Swift.String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies either document or table mode. Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public var nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue?
        /// The password for the user account you use to access the MongoDB source endpoint.
        public var password: Swift.String?
        /// The port value for the MongoDB source endpoint.
        public var port: Swift.Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:
        ///
        /// * You must set TargetTablePrepMode to nothing.
        ///
        /// * DMS automatically sets useUpdateLookup to false.
        public var replicateShardCollections: Swift.Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MongoDB endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MongoDB endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the server on the MongoDB source endpoint. For MongoDB Atlas, provide the server name for any of the servers in the replication set.
        public var serverName: Swift.String?
        /// If true, DMS retrieves the entire document from the MongoDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public var useUpdateLookUp: Swift.Bool?
        /// The user name you use to access the MongoDB source endpoint.
        public var username: Swift.String?

        public init(
            authMechanism: DatabaseMigrationClientTypes.AuthMechanismValue? = nil,
            authSource: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.AuthTypeValue? = nil,
            databaseName: Swift.String? = nil,
            docsToInvestigate: Swift.String? = nil,
            extractDocId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            nestingLevel: DatabaseMigrationClientTypes.NestingLevelValue? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            replicateShardCollections: Swift.Bool? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            useUpdateLookUp: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useUpdateLookUp = useUpdateLookUp
            self.username = username
        }
    }

}

extension MoveReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let targetReplicationInstanceArn = self.targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
    }
}

extension MoveReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct MoveReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the task that you want to move.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The ARN of the replication instance where you want to move the task to.
    /// This member is required.
    public var targetReplicationInstanceArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil,
        targetReplicationInstanceArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
        self.targetReplicationInstanceArn = targetReplicationInstanceArn
    }
}

struct MoveReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let targetReplicationInstanceArn: Swift.String?
}

extension MoveReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension MoveReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MoveReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct MoveReplicationTaskOutput: Swift.Equatable {
    /// The replication task that was moved.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct MoveReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension MoveReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum MoveReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
        case databaseName = "DatabaseName"
        case eventsPollInterval = "EventsPollInterval"
        case maxFileSize = "MaxFileSize"
        case parallelLoadThreads = "ParallelLoadThreads"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverTimezone = "ServerTimezone"
        case targetDbType = "TargetDbType"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let cleanSourceMetadataOnMismatch = self.cleanSourceMetadataOnMismatch {
            try encodeContainer.encode(cleanSourceMetadataOnMismatch, forKey: .cleanSourceMetadataOnMismatch)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let eventsPollInterval = self.eventsPollInterval {
            try encodeContainer.encode(eventsPollInterval, forKey: .eventsPollInterval)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parallelLoadThreads = self.parallelLoadThreads {
            try encodeContainer.encode(parallelLoadThreads, forKey: .parallelLoadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverTimezone = self.serverTimezone {
            try encodeContainer.encode(serverTimezone, forKey: .serverTimezone)
        }
        if let targetDbType = self.targetDbType {
            try encodeContainer.encode(targetDbType.rawValue, forKey: .targetDbType)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let cleanSourceMetadataOnMismatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanSourceMetadataOnMismatch)
        cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatchDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let eventsPollIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsPollInterval)
        eventsPollInterval = eventsPollIntervalDecoded
        let targetDbTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.TargetDbType.self, forKey: .targetDbType)
        targetDbType = targetDbTypeDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let parallelLoadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelLoadThreads)
        parallelLoadThreads = parallelLoadThreadsDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serverTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverTimezone)
        serverTimezone = serverTimezoneDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.MySQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MySQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), cleanSourceMetadataOnMismatch: \(Swift.String(describing: cleanSourceMetadataOnMismatch)), databaseName: \(Swift.String(describing: databaseName)), eventsPollInterval: \(Swift.String(describing: eventsPollInterval)), maxFileSize: \(Swift.String(describing: maxFileSize)), parallelLoadThreads: \(Swift.String(describing: parallelLoadThreads)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverTimezone: \(Swift.String(describing: serverTimezone)), targetDbType: \(Swift.String(describing: targetDbType)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MySQL endpoint.
    public struct MySQLSettings: Swift.Equatable {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public var afterConnectScript: Swift.String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public var cleanSourceMetadataOnMismatch: Swift.Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public var databaseName: Swift.String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5; In the example, DMS checks for changes in the binary logs every five seconds.
        public var eventsPollInterval: Swift.Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public var parallelLoadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The host name of the endpoint database. For an Amazon RDS MySQL instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field. For an Aurora MySQL instance, this is the output of [DescribeDBClusters](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html), in the Endpoint field.
        public var serverName: Swift.String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific; Note: Do not enclose time zones in single quotes.
        public var serverTimezone: Swift.String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. If you specify SPECIFIC_DATABASE, specify the database name using the DatabaseName parameter of the Endpoint object. Example: targetDbType=MULTIPLE_DATABASES
        public var targetDbType: DatabaseMigrationClientTypes.TargetDbType?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            cleanSourceMetadataOnMismatch: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            eventsPollInterval: Swift.Int? = nil,
            maxFileSize: Swift.Int? = nil,
            parallelLoadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverTimezone: Swift.String? = nil,
            targetDbType: DatabaseMigrationClientTypes.TargetDbType? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.MySqlDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a MySQL data provider.
    public struct MySqlDataProviderSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The port value for the MySQL data provider.
        public var port: Swift.Int?
        /// The name of the MySQL server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the MySQL data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.NeptuneSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorRetryDuration = "ErrorRetryDuration"
        case iamAuthEnabled = "IamAuthEnabled"
        case maxFileSize = "MaxFileSize"
        case maxRetryCount = "MaxRetryCount"
        case s3BucketFolder = "S3BucketFolder"
        case s3BucketName = "S3BucketName"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorRetryDuration = self.errorRetryDuration {
            try encodeContainer.encode(errorRetryDuration, forKey: .errorRetryDuration)
        }
        if let iamAuthEnabled = self.iamAuthEnabled {
            try encodeContainer.encode(iamAuthEnabled, forKey: .iamAuthEnabled)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let maxRetryCount = self.maxRetryCount {
            try encodeContainer.encode(maxRetryCount, forKey: .maxRetryCount)
        }
        if let s3BucketFolder = self.s3BucketFolder {
            try encodeContainer.encode(s3BucketFolder, forKey: .s3BucketFolder)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketFolder)
        s3BucketFolder = s3BucketFolderDecoded
        let errorRetryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorRetryDuration)
        errorRetryDuration = errorRetryDurationDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let maxRetryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetryCount)
        maxRetryCount = maxRetryCountDecoded
        let iamAuthEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamAuthEnabled)
        iamAuthEnabled = iamAuthEnabledDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Neptune endpoint.
    public struct NeptuneSettings: Swift.Equatable {
        /// The number of milliseconds for DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public var errorRetryDuration: Swift.Int?
        /// If you want Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public var iamAuthEnabled: Swift.Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, DMS clears the bucket, ready to store the next batch of migrated graph data.
        public var maxFileSize: Swift.Int?
        /// The number of times for DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public var maxRetryCount: Swift.Int?
        /// A folder path where you want DMS to store migrated graph data in the S3 bucket specified by S3BucketName
        /// This member is required.
        public var s3BucketFolder: Swift.String?
        /// The name of the Amazon S3 bucket where DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. DMS maps the SQL source data to graph data before storing it in these .csv files.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. The role must allow the iam:PassRole action. For more information, see [Creating an IAM Service Role for Accessing Amazon Neptune as a Target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.Neptune.html#CHAP_Target.Neptune.ServiceRole) in the Database Migration Service User Guide.
        public var serviceAccessRoleArn: Swift.String?

        public init(
            errorRetryDuration: Swift.Int? = nil,
            iamAuthEnabled: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            maxRetryCount: Swift.Int? = nil,
            s3BucketFolder: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil
        )
        {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum NestingLevelValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case one
        case sdkUnknown(Swift.String)

        public static var allCases: [NestingLevelValue] {
            return [
                .none,
                .one,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .one: return "one"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NestingLevelValue(rawValue: rawValue) ?? NestingLevelValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.OracleDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asmServer = "AsmServer"
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case port = "Port"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecurityDbEncryptionAccessRoleArn = "SecretsManagerSecurityDbEncryptionAccessRoleArn"
        case secretsManagerSecurityDbEncryptionSecretId = "SecretsManagerSecurityDbEncryptionSecretId"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asmServer = self.asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerOracleAsmAccessRoleArn = self.secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = self.secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecurityDbEncryptionAccessRoleArn = self.secretsManagerSecurityDbEncryptionAccessRoleArn {
            try encodeContainer.encode(secretsManagerSecurityDbEncryptionAccessRoleArn, forKey: .secretsManagerSecurityDbEncryptionAccessRoleArn)
        }
        if let secretsManagerSecurityDbEncryptionSecretId = self.secretsManagerSecurityDbEncryptionSecretId {
            try encodeContainer.encode(secretsManagerSecurityDbEncryptionSecretId, forKey: .secretsManagerSecurityDbEncryptionSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerSecurityDbEncryptionSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecurityDbEncryptionSecretId)
        secretsManagerSecurityDbEncryptionSecretId = secretsManagerSecurityDbEncryptionSecretIdDecoded
        let secretsManagerSecurityDbEncryptionAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecurityDbEncryptionAccessRoleArn)
        secretsManagerSecurityDbEncryptionAccessRoleArn = secretsManagerSecurityDbEncryptionAccessRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Oracle data provider.
    public struct OracleDataProviderSettings: Swift.Equatable {
        /// The address of your Oracle Automatic Storage Management (ASM) server. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmServer: Swift.String?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the Oracle data provider.
        public var databaseName: Swift.String?
        /// The port value for the Oracle data provider.
        public var port: Swift.Int?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager that contains the Oracle ASM connection details.
        public var secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// The identifier of the secret in Secrets Manager that contains the Oracle ASM connection details. Required only if your data provider uses the Oracle ASM server.
        public var secretsManagerOracleAsmSecretId: Swift.String?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager that contains the TDE password.
        public var secretsManagerSecurityDbEncryptionAccessRoleArn: Swift.String?
        /// The identifier of the secret in Secrets Manager that contains the transparent data encryption (TDE) password. DMS requires this password to access Oracle redo logs encrypted by TDE using Binary Reader.
        public var secretsManagerSecurityDbEncryptionSecretId: Swift.String?
        /// The name of the Oracle server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the Oracle data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            asmServer: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecurityDbEncryptionAccessRoleArn: Swift.String? = nil,
            secretsManagerSecurityDbEncryptionSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.asmServer = asmServer
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecurityDbEncryptionAccessRoleArn = secretsManagerSecurityDbEncryptionAccessRoleArn
            self.secretsManagerSecurityDbEncryptionSecretId = secretsManagerSecurityDbEncryptionSecretId
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessAlternateDirectly = "AccessAlternateDirectly"
        case addSupplementalLogging = "AddSupplementalLogging"
        case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
        case allowSelectNestedTables = "AllowSelectNestedTables"
        case archivedLogDestId = "ArchivedLogDestId"
        case archivedLogsOnly = "ArchivedLogsOnly"
        case asmPassword = "AsmPassword"
        case asmServer = "AsmServer"
        case asmUser = "AsmUser"
        case charLengthSemantics = "CharLengthSemantics"
        case convertTimestampWithZoneToUTC = "ConvertTimestampWithZoneToUTC"
        case databaseName = "DatabaseName"
        case directPathNoLog = "DirectPathNoLog"
        case directPathParallelLoad = "DirectPathParallelLoad"
        case enableHomogenousTablespace = "EnableHomogenousTablespace"
        case extraArchivedLogDestIds = "ExtraArchivedLogDestIds"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case numberDatatypeScale = "NumberDatatypeScale"
        case openTransactionWindow = "OpenTransactionWindow"
        case oraclePathPrefix = "OraclePathPrefix"
        case parallelAsmReadThreads = "ParallelAsmReadThreads"
        case password = "Password"
        case port = "Port"
        case readAheadBlocks = "ReadAheadBlocks"
        case readTableSpaceName = "ReadTableSpaceName"
        case replacePathPrefix = "ReplacePathPrefix"
        case retryInterval = "RetryInterval"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
        case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case securityDbEncryption = "SecurityDbEncryption"
        case securityDbEncryptionName = "SecurityDbEncryptionName"
        case serverName = "ServerName"
        case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
        case standbyDelayTime = "StandbyDelayTime"
        case trimSpaceInChar = "TrimSpaceInChar"
        case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
        case useBFile = "UseBFile"
        case useDirectPathFullLoad = "UseDirectPathFullLoad"
        case useLogminerReader = "UseLogminerReader"
        case usePathPrefix = "UsePathPrefix"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessAlternateDirectly = self.accessAlternateDirectly {
            try encodeContainer.encode(accessAlternateDirectly, forKey: .accessAlternateDirectly)
        }
        if let addSupplementalLogging = self.addSupplementalLogging {
            try encodeContainer.encode(addSupplementalLogging, forKey: .addSupplementalLogging)
        }
        if let additionalArchivedLogDestId = self.additionalArchivedLogDestId {
            try encodeContainer.encode(additionalArchivedLogDestId, forKey: .additionalArchivedLogDestId)
        }
        if let allowSelectNestedTables = self.allowSelectNestedTables {
            try encodeContainer.encode(allowSelectNestedTables, forKey: .allowSelectNestedTables)
        }
        if let archivedLogDestId = self.archivedLogDestId {
            try encodeContainer.encode(archivedLogDestId, forKey: .archivedLogDestId)
        }
        if let archivedLogsOnly = self.archivedLogsOnly {
            try encodeContainer.encode(archivedLogsOnly, forKey: .archivedLogsOnly)
        }
        if let asmPassword = self.asmPassword {
            try encodeContainer.encode(asmPassword, forKey: .asmPassword)
        }
        if let asmServer = self.asmServer {
            try encodeContainer.encode(asmServer, forKey: .asmServer)
        }
        if let asmUser = self.asmUser {
            try encodeContainer.encode(asmUser, forKey: .asmUser)
        }
        if let charLengthSemantics = self.charLengthSemantics {
            try encodeContainer.encode(charLengthSemantics.rawValue, forKey: .charLengthSemantics)
        }
        if let convertTimestampWithZoneToUTC = self.convertTimestampWithZoneToUTC {
            try encodeContainer.encode(convertTimestampWithZoneToUTC, forKey: .convertTimestampWithZoneToUTC)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let directPathNoLog = self.directPathNoLog {
            try encodeContainer.encode(directPathNoLog, forKey: .directPathNoLog)
        }
        if let directPathParallelLoad = self.directPathParallelLoad {
            try encodeContainer.encode(directPathParallelLoad, forKey: .directPathParallelLoad)
        }
        if let enableHomogenousTablespace = self.enableHomogenousTablespace {
            try encodeContainer.encode(enableHomogenousTablespace, forKey: .enableHomogenousTablespace)
        }
        if let extraArchivedLogDestIds = extraArchivedLogDestIds {
            var extraArchivedLogDestIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extraArchivedLogDestIds)
            for integer0 in extraArchivedLogDestIds {
                try extraArchivedLogDestIdsContainer.encode(integer0)
            }
        }
        if let failTasksOnLobTruncation = self.failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let numberDatatypeScale = self.numberDatatypeScale {
            try encodeContainer.encode(numberDatatypeScale, forKey: .numberDatatypeScale)
        }
        if let openTransactionWindow = self.openTransactionWindow {
            try encodeContainer.encode(openTransactionWindow, forKey: .openTransactionWindow)
        }
        if let oraclePathPrefix = self.oraclePathPrefix {
            try encodeContainer.encode(oraclePathPrefix, forKey: .oraclePathPrefix)
        }
        if let parallelAsmReadThreads = self.parallelAsmReadThreads {
            try encodeContainer.encode(parallelAsmReadThreads, forKey: .parallelAsmReadThreads)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let readAheadBlocks = self.readAheadBlocks {
            try encodeContainer.encode(readAheadBlocks, forKey: .readAheadBlocks)
        }
        if let readTableSpaceName = self.readTableSpaceName {
            try encodeContainer.encode(readTableSpaceName, forKey: .readTableSpaceName)
        }
        if let replacePathPrefix = self.replacePathPrefix {
            try encodeContainer.encode(replacePathPrefix, forKey: .replacePathPrefix)
        }
        if let retryInterval = self.retryInterval {
            try encodeContainer.encode(retryInterval, forKey: .retryInterval)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerOracleAsmAccessRoleArn = self.secretsManagerOracleAsmAccessRoleArn {
            try encodeContainer.encode(secretsManagerOracleAsmAccessRoleArn, forKey: .secretsManagerOracleAsmAccessRoleArn)
        }
        if let secretsManagerOracleAsmSecretId = self.secretsManagerOracleAsmSecretId {
            try encodeContainer.encode(secretsManagerOracleAsmSecretId, forKey: .secretsManagerOracleAsmSecretId)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let securityDbEncryption = self.securityDbEncryption {
            try encodeContainer.encode(securityDbEncryption, forKey: .securityDbEncryption)
        }
        if let securityDbEncryptionName = self.securityDbEncryptionName {
            try encodeContainer.encode(securityDbEncryptionName, forKey: .securityDbEncryptionName)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let spatialDataOptionToGeoJsonFunctionName = self.spatialDataOptionToGeoJsonFunctionName {
            try encodeContainer.encode(spatialDataOptionToGeoJsonFunctionName, forKey: .spatialDataOptionToGeoJsonFunctionName)
        }
        if let standbyDelayTime = self.standbyDelayTime {
            try encodeContainer.encode(standbyDelayTime, forKey: .standbyDelayTime)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let useAlternateFolderForOnline = self.useAlternateFolderForOnline {
            try encodeContainer.encode(useAlternateFolderForOnline, forKey: .useAlternateFolderForOnline)
        }
        if let useBFile = self.useBFile {
            try encodeContainer.encode(useBFile, forKey: .useBFile)
        }
        if let useDirectPathFullLoad = self.useDirectPathFullLoad {
            try encodeContainer.encode(useDirectPathFullLoad, forKey: .useDirectPathFullLoad)
        }
        if let useLogminerReader = self.useLogminerReader {
            try encodeContainer.encode(useLogminerReader, forKey: .useLogminerReader)
        }
        if let usePathPrefix = self.usePathPrefix {
            try encodeContainer.encode(usePathPrefix, forKey: .usePathPrefix)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addSupplementalLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addSupplementalLogging)
        addSupplementalLogging = addSupplementalLoggingDecoded
        let archivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .archivedLogDestId)
        archivedLogDestId = archivedLogDestIdDecoded
        let additionalArchivedLogDestIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .additionalArchivedLogDestId)
        additionalArchivedLogDestId = additionalArchivedLogDestIdDecoded
        let extraArchivedLogDestIdsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .extraArchivedLogDestIds)
        var extraArchivedLogDestIdsDecoded0:[Swift.Int]? = nil
        if let extraArchivedLogDestIdsContainer = extraArchivedLogDestIdsContainer {
            extraArchivedLogDestIdsDecoded0 = [Swift.Int]()
            for integer0 in extraArchivedLogDestIdsContainer {
                if let integer0 = integer0 {
                    extraArchivedLogDestIdsDecoded0?.append(integer0)
                }
            }
        }
        extraArchivedLogDestIds = extraArchivedLogDestIdsDecoded0
        let allowSelectNestedTablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelectNestedTables)
        allowSelectNestedTables = allowSelectNestedTablesDecoded
        let parallelAsmReadThreadsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parallelAsmReadThreads)
        parallelAsmReadThreads = parallelAsmReadThreadsDecoded
        let readAheadBlocksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readAheadBlocks)
        readAheadBlocks = readAheadBlocksDecoded
        let accessAlternateDirectlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessAlternateDirectly)
        accessAlternateDirectly = accessAlternateDirectlyDecoded
        let useAlternateFolderForOnlineDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAlternateFolderForOnline)
        useAlternateFolderForOnline = useAlternateFolderForOnlineDecoded
        let oraclePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oraclePathPrefix)
        oraclePathPrefix = oraclePathPrefixDecoded
        let usePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usePathPrefix)
        usePathPrefix = usePathPrefixDecoded
        let replacePathPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replacePathPrefix)
        replacePathPrefix = replacePathPrefixDecoded
        let enableHomogenousTablespaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableHomogenousTablespace)
        enableHomogenousTablespace = enableHomogenousTablespaceDecoded
        let directPathNoLogDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathNoLog)
        directPathNoLog = directPathNoLogDecoded
        let archivedLogsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archivedLogsOnly)
        archivedLogsOnly = archivedLogsOnlyDecoded
        let asmPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmPassword)
        asmPassword = asmPasswordDecoded
        let asmServerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmServer)
        asmServer = asmServerDecoded
        let asmUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asmUser)
        asmUser = asmUserDecoded
        let charLengthSemanticsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CharLengthSemantics.self, forKey: .charLengthSemantics)
        charLengthSemantics = charLengthSemanticsDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let directPathParallelLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .directPathParallelLoad)
        directPathParallelLoad = directPathParallelLoadDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let numberDatatypeScaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberDatatypeScale)
        numberDatatypeScale = numberDatatypeScaleDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let readTableSpaceNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readTableSpaceName)
        readTableSpaceName = readTableSpaceNameDecoded
        let retryIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryInterval)
        retryInterval = retryIntervalDecoded
        let securityDbEncryptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryption)
        securityDbEncryption = securityDbEncryptionDecoded
        let securityDbEncryptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityDbEncryptionName)
        securityDbEncryptionName = securityDbEncryptionNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let spatialDataOptionToGeoJsonFunctionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spatialDataOptionToGeoJsonFunctionName)
        spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionNameDecoded
        let standbyDelayTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .standbyDelayTime)
        standbyDelayTime = standbyDelayTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let useBFileDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBFile)
        useBFile = useBFileDecoded
        let useDirectPathFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDirectPathFullLoad)
        useDirectPathFullLoad = useDirectPathFullLoadDecoded
        let useLogminerReaderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useLogminerReader)
        useLogminerReader = useLogminerReaderDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let secretsManagerOracleAsmAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmAccessRoleArn)
        secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArnDecoded
        let secretsManagerOracleAsmSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerOracleAsmSecretId)
        secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
        let convertTimestampWithZoneToUTCDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .convertTimestampWithZoneToUTC)
        convertTimestampWithZoneToUTC = convertTimestampWithZoneToUTCDecoded
        let openTransactionWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .openTransactionWindow)
        openTransactionWindow = openTransactionWindowDecoded
    }
}

extension DatabaseMigrationClientTypes.OracleSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OracleSettings(accessAlternateDirectly: \(Swift.String(describing: accessAlternateDirectly)), addSupplementalLogging: \(Swift.String(describing: addSupplementalLogging)), additionalArchivedLogDestId: \(Swift.String(describing: additionalArchivedLogDestId)), allowSelectNestedTables: \(Swift.String(describing: allowSelectNestedTables)), archivedLogDestId: \(Swift.String(describing: archivedLogDestId)), archivedLogsOnly: \(Swift.String(describing: archivedLogsOnly)), asmServer: \(Swift.String(describing: asmServer)), asmUser: \(Swift.String(describing: asmUser)), charLengthSemantics: \(Swift.String(describing: charLengthSemantics)), convertTimestampWithZoneToUTC: \(Swift.String(describing: convertTimestampWithZoneToUTC)), databaseName: \(Swift.String(describing: databaseName)), directPathNoLog: \(Swift.String(describing: directPathNoLog)), directPathParallelLoad: \(Swift.String(describing: directPathParallelLoad)), enableHomogenousTablespace: \(Swift.String(describing: enableHomogenousTablespace)), extraArchivedLogDestIds: \(Swift.String(describing: extraArchivedLogDestIds)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), numberDatatypeScale: \(Swift.String(describing: numberDatatypeScale)), openTransactionWindow: \(Swift.String(describing: openTransactionWindow)), oraclePathPrefix: \(Swift.String(describing: oraclePathPrefix)), parallelAsmReadThreads: \(Swift.String(describing: parallelAsmReadThreads)), port: \(Swift.String(describing: port)), readAheadBlocks: \(Swift.String(describing: readAheadBlocks)), readTableSpaceName: \(Swift.String(describing: readTableSpaceName)), replacePathPrefix: \(Swift.String(describing: replacePathPrefix)), retryInterval: \(Swift.String(describing: retryInterval)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerOracleAsmAccessRoleArn: \(Swift.String(describing: secretsManagerOracleAsmAccessRoleArn)), secretsManagerOracleAsmSecretId: \(Swift.String(describing: secretsManagerOracleAsmSecretId)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), securityDbEncryptionName: \(Swift.String(describing: securityDbEncryptionName)), serverName: \(Swift.String(describing: serverName)), spatialDataOptionToGeoJsonFunctionName: \(Swift.String(describing: spatialDataOptionToGeoJsonFunctionName)), standbyDelayTime: \(Swift.String(describing: standbyDelayTime)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), useAlternateFolderForOnline: \(Swift.String(describing: useAlternateFolderForOnline)), useBFile: \(Swift.String(describing: useBFile)), useDirectPathFullLoad: \(Swift.String(describing: useDirectPathFullLoad)), useLogminerReader: \(Swift.String(describing: useLogminerReader)), usePathPrefix: \(Swift.String(describing: usePathPrefix)), username: \(Swift.String(describing: username)), asmPassword: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\", securityDbEncryption: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Oracle endpoint.
    public struct OracleSettings: Swift.Equatable {
        /// Set this attribute to false in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to not access redo logs through any specified path prefix replacement using direct file access.
        public var accessAlternateDirectly: Swift.Bool?
        /// Set this attribute to set up table-level supplemental logging for the Oracle database. This attribute enables PRIMARY KEY supplemental logging on all tables selected for a migration task. If you use this option, you still need to enable database-level supplemental logging.
        public var addSupplementalLogging: Swift.Bool?
        /// Set this attribute with ArchivedLogDestId in a primary/ standby setup. This attribute is useful in the case of a switchover. In this case, DMS needs to know which destination to get archive redo logs from to read changes. This need arises because the previous primary instance is now a standby instance after switchover. Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless necessary. For additional information about RESETLOGS, see [RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var additionalArchivedLogDestId: Swift.Int?
        /// Set this attribute to true to enable replication of Oracle tables containing columns that are nested tables or defined types.
        public var allowSelectNestedTables: Swift.Bool?
        /// Specifies the ID of the destination for the archived redo logs. This value should be the same as a number in the dest_id column of the v$archived_log view. If you work with an additional redo log destination, use the AdditionalArchivedLogDestId option to specify the additional destination ID. Doing this improves performance by ensuring that the correct logs are accessed from the outset.
        public var archivedLogDestId: Swift.Int?
        /// When this field is set to Y, DMS only accesses the archived redo logs. If the archived redo logs are stored on Automatic Storage Management (ASM) only, the DMS user account needs to be granted ASM privileges.
        public var archivedLogsOnly: Swift.Bool?
        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password  value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmPassword: Swift.String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmServer: Swift.String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see [Configuration for change data capture (CDC) on an Oracle source database](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC.Configuration).
        public var asmUser: Swift.String?
        /// Specifies whether the length of a character column is in bytes or in characters. To indicate that the character column length is in characters, set this attribute to CHAR. Otherwise, the character column length is in bytes. Example: charLengthSemantics=CHAR;
        public var charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics?
        /// When true, converts timestamps with the timezone datatype to their UTC value.
        public var convertTimestampWithZoneToUTC: Swift.Bool?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// When set to true, this attribute helps to increase the commit rate on the Oracle target database by writing directly to tables and not writing a trail to database logs.
        public var directPathNoLog: Swift.Bool?
        /// When set to true, this attribute specifies a parallel load when useDirectPathFullLoad is set to Y. This attribute also only applies when you use the DMS parallel load feature. Note that the target table cannot have any constraints or indexes.
        public var directPathParallelLoad: Swift.Bool?
        /// Set this attribute to enable homogenous tablespace replication and create existing tables or indexes under the same tablespace on the target.
        public var enableHomogenousTablespace: Swift.Bool?
        /// Specifies the IDs of one more destinations for one or more archived redo logs. These IDs are the values of the dest_id column in the v$archived_log view. Use this setting with the archivedLogDestId extra connection attribute in a primary-to-single setup or a primary-to-multiple-standby setup. This setting is useful in a switchover when you use an Oracle Data Guard database as a source. In this case, DMS needs information about what destination to get archive redo logs from to read changes. DMS needs this because after the switchover the previous primary is a standby instance. For example, in a primary-to-single standby setup you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2] In a primary-to-multiple-standby setup, you might apply the following settings. archivedLogDestId=1; ExtraArchivedLogDestIds=[2,3,4] Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless it's necessary. For more information about RESETLOGS, see [ RMAN Data Repair Concepts](https://docs.oracle.com/en/database/oracle/oracle-database/19/bradv/rman-data-repair-concepts.html#GUID-1805CCF7-4AF2-482D-B65A-998192F89C2B) in the Oracle Database Backup and Recovery User's Guide.
        public var extraArchivedLogDestIds: [Swift.Int]?
        /// When set to true, this attribute causes a task to fail if the actual size of an LOB column is greater than the specified LobMaxSize. If a task is set to limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// Specifies the number scale. You can select a scale up to 38, or you can select FLOAT. By default, the NUMBER data type is converted to precision 38, scale 10. Example: numberDataTypeScale=12
        public var numberDatatypeScale: Swift.Int?
        /// The timeframe in minutes to check for open transactions for a CDC-only task. You can specify an integer value between 0 (the default) and 240 (the maximum). This parameter is only valid in DMS version 3.5.0 and later. DMS supports a window of up to 9.5 hours including the value for OpenTransactionWindow.
        public var openTransactionWindow: Swift.Int?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the default Oracle root used to access the redo logs.
        public var oraclePathPrefix: Swift.String?
        /// Set this attribute to change the number of threads that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 2 (the default) and 8 (the maximum). Use this attribute together with the readAheadBlocks attribute.
        public var parallelAsmReadThreads: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port.
        public var port: Swift.Int?
        /// Set this attribute to change the number of read-ahead blocks that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 1000 (the default) and 200,000 (the maximum).
        public var readAheadBlocks: Swift.Int?
        /// When set to true, this attribute supports tablespace replication.
        public var readTableSpaceName: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This setting tells DMS instance to replace the default Oracle root with the specified usePathPrefix setting to access the redo logs.
        public var replacePathPrefix: Swift.Bool?
        /// Specifies the number of seconds that the system waits before resending a query. Example: retryInterval=6;
        public var retryInterval: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Oracle endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the SecretsManagerOracleAsmSecret. This SecretsManagerOracleAsmSecret has the secret value that allows access to the Oracle ASM of the endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerOracleAsmSecretId. Or you can specify clear-text values for AsmUser, AsmPassword, and AsmServerName. You can't specify both. For more information on creating this SecretsManagerOracleAsmSecret and the SecretsManagerOracleAsmAccessRoleArn and SecretsManagerOracleAsmSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerOracleAsmAccessRoleArn: Swift.String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN, partial ARN, or friendly name of the SecretsManagerOracleAsmSecret that contains the Oracle ASM connection details for the Oracle endpoint.
        public var secretsManagerOracleAsmSecretId: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Oracle endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password  part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryption: Swift.String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in [ Supported encryption methods for using Oracle as a source for DMS ](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.Encryption) in the Database Migration Service User Guide.
        public var securityDbEncryptionName: Swift.String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS Oracle instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field.
        public var serverName: Swift.String?
        /// Use this attribute to convert SDO_GEOMETRY to GEOJSON format. By default, DMS calls the SDO2GEOJSON custom function if present and accessible. Or you can create your own custom function that mimics the operation of SDOGEOJSON and set SpatialDataOptionToGeoJsonFunctionName to call it instead.
        public var spatialDataOptionToGeoJsonFunctionName: Swift.String?
        /// Use this attribute to specify a time in minutes for the delay in standby sync. If the source is an Oracle Active Data Guard standby database, use this attribute to specify the time lag between primary and standby databases. In DMS, you can create an Oracle CDC task that uses an Active Data Guard standby instance as a source for replicating ongoing changes. Doing this eliminates the need to connect to an active database that might be in production.
        public var standbyDelayTime: Swift.Int?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to use any specified prefix replacement to access all online redo logs.
        public var useAlternateFolderForOnline: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Binary Reader utility. Set UseLogminerReader to N to set this attribute to Y. To use Binary Reader with Amazon RDS for Oracle as the source, you set additional attributes. For more information about using this setting with Oracle Automatic Storage Management (ASM), see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC).
        public var useBFile: Swift.Bool?
        /// Set this attribute to Y to have DMS use a direct path full load. Specify this value to use the direct path protocol in the Oracle Call Interface (OCI). By using this OCI protocol, you can bulk-load Oracle target tables during a full load.
        public var useDirectPathFullLoad: Swift.Bool?
        /// Set this attribute to Y to capture change data using the Oracle LogMiner utility (the default). Set this attribute to N if you want to access the redo logs as a binary file. When you set UseLogminerReader to N, also set UseBfile to Y. For more information on this setting and using Oracle ASM, see [ Using Oracle LogMiner or DMS Binary Reader for CDC](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.Oracle.html#CHAP_Source.Oracle.CDC) in the DMS User Guide.
        public var useLogminerReader: Swift.Bool?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the path prefix used to replace the default Oracle root to access the redo logs.
        public var usePathPrefix: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            accessAlternateDirectly: Swift.Bool? = nil,
            addSupplementalLogging: Swift.Bool? = nil,
            additionalArchivedLogDestId: Swift.Int? = nil,
            allowSelectNestedTables: Swift.Bool? = nil,
            archivedLogDestId: Swift.Int? = nil,
            archivedLogsOnly: Swift.Bool? = nil,
            asmPassword: Swift.String? = nil,
            asmServer: Swift.String? = nil,
            asmUser: Swift.String? = nil,
            charLengthSemantics: DatabaseMigrationClientTypes.CharLengthSemantics? = nil,
            convertTimestampWithZoneToUTC: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            directPathNoLog: Swift.Bool? = nil,
            directPathParallelLoad: Swift.Bool? = nil,
            enableHomogenousTablespace: Swift.Bool? = nil,
            extraArchivedLogDestIds: [Swift.Int]? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            numberDatatypeScale: Swift.Int? = nil,
            openTransactionWindow: Swift.Int? = nil,
            oraclePathPrefix: Swift.String? = nil,
            parallelAsmReadThreads: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            readAheadBlocks: Swift.Int? = nil,
            readTableSpaceName: Swift.Bool? = nil,
            replacePathPrefix: Swift.Bool? = nil,
            retryInterval: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmAccessRoleArn: Swift.String? = nil,
            secretsManagerOracleAsmSecretId: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            securityDbEncryption: Swift.String? = nil,
            securityDbEncryptionName: Swift.String? = nil,
            serverName: Swift.String? = nil,
            spatialDataOptionToGeoJsonFunctionName: Swift.String? = nil,
            standbyDelayTime: Swift.Int? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            useAlternateFolderForOnline: Swift.Bool? = nil,
            useBFile: Swift.Bool? = nil,
            useDirectPathFullLoad: Swift.Bool? = nil,
            useLogminerReader: Swift.Bool? = nil,
            usePathPrefix: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.addSupplementalLogging = addSupplementalLogging
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.charLengthSemantics = charLengthSemantics
            self.convertTimestampWithZoneToUTC = convertTimestampWithZoneToUTC
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.extraArchivedLogDestIds = extraArchivedLogDestIds
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.openTransactionWindow = openTransactionWindow
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.standbyDelayTime = standbyDelayTime
            self.trimSpaceInChar = trimSpaceInChar
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.useBFile = useBFile
            self.useDirectPathFullLoad = useDirectPathFullLoad
            self.useLogminerReader = useLogminerReader
            self.usePathPrefix = usePathPrefix
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.OrderableReplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case defaultAllocatedStorage = "DefaultAllocatedStorage"
        case engineVersion = "EngineVersion"
        case includedAllocatedStorage = "IncludedAllocatedStorage"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case minAllocatedStorage = "MinAllocatedStorage"
        case releaseStatus = "ReleaseStatus"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if defaultAllocatedStorage != 0 {
            try encodeContainer.encode(defaultAllocatedStorage, forKey: .defaultAllocatedStorage)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if includedAllocatedStorage != 0 {
            try encodeContainer.encode(includedAllocatedStorage, forKey: .includedAllocatedStorage)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if minAllocatedStorage != 0 {
            try encodeContainer.encode(minAllocatedStorage, forKey: .minAllocatedStorage)
        }
        if let releaseStatus = self.releaseStatus {
            try encodeContainer.encode(releaseStatus.rawValue, forKey: .releaseStatus)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let minAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minAllocatedStorage) ?? 0
        minAllocatedStorage = minAllocatedStorageDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage) ?? 0
        maxAllocatedStorage = maxAllocatedStorageDecoded
        let defaultAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultAllocatedStorage) ?? 0
        defaultAllocatedStorage = defaultAllocatedStorageDecoded
        let includedAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .includedAllocatedStorage) ?? 0
        includedAllocatedStorage = includedAllocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let releaseStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReleaseStatusValues.self, forKey: .releaseStatus)
        releaseStatus = releaseStatusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to the DescribeOrderableReplicationInstances operation, this object describes an available replication instance. This description includes the replication instance's type, engine version, and allocated storage.
    public struct OrderableReplicationInstance: Swift.Equatable {
        /// List of Availability Zones for this replication instance.
        public var availabilityZones: [Swift.String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public var defaultAllocatedStorage: Swift.Int
        /// The version of the replication engine.
        public var engineVersion: Swift.String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var includedAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var maxAllocatedStorage: Swift.Int
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public var minAllocatedStorage: Swift.Int
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected. DMS supports the ReleaseStatus parameter in versions 3.1.4 and later.
        public var releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The type of storage used by the replication instance.
        public var storageType: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            defaultAllocatedStorage: Swift.Int = 0,
            engineVersion: Swift.String? = nil,
            includedAllocatedStorage: Swift.Int = 0,
            maxAllocatedStorage: Swift.Int = 0,
            minAllocatedStorage: Swift.Int = 0,
            releaseStatus: DatabaseMigrationClientTypes.ReleaseStatusValues? = nil,
            replicationInstanceClass: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum OriginTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginTypeValue] {
            return [
                .source,
                .target,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginTypeValue(rawValue: rawValue) ?? OriginTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ParquetVersionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parquet10
        case parquet20
        case sdkUnknown(Swift.String)

        public static var allCases: [ParquetVersionValue] {
            return [
                .parquet10,
                .parquet20,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parquet10: return "parquet-1-0"
            case .parquet20: return "parquet-2-0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParquetVersionValue(rawValue: rawValue) ?? ParquetVersionValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.PendingMaintenanceAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let autoAppliedAfterDate = self.autoAppliedAfterDate {
            try encodeContainer.encodeTimestamp(autoAppliedAfterDate, format: .epochSeconds, forKey: .autoAppliedAfterDate)
        }
        if let currentApplyDate = self.currentApplyDate {
            try encodeContainer.encodeTimestamp(currentApplyDate, format: .epochSeconds, forKey: .currentApplyDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forcedApplyDate = self.forcedApplyDate {
            try encodeContainer.encodeTimestamp(forcedApplyDate, format: .epochSeconds, forKey: .forcedApplyDate)
        }
        if let optInStatus = self.optInStatus {
            try encodeContainer.encode(optInStatus, forKey: .optInStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .autoAppliedAfterDate)
        autoAppliedAfterDate = autoAppliedAfterDateDecoded
        let forcedApplyDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .forcedApplyDate)
        forcedApplyDate = forcedApplyDateDecoded
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .currentApplyDate)
        currentApplyDate = currentApplyDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a maintenance action pending for an DMS resource, including when and how it will be applied. This data type is a response element to the DescribePendingMaintenanceActions operation.
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// The type of pending maintenance action that is available for the resource.
        public var action: Swift.String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public var autoAppliedAfterDate: ClientRuntime.Date?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public var currentApplyDate: ClientRuntime.Date?
        /// A description providing more detail about the maintenance action.
        public var description: Swift.String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public var forcedApplyDate: ClientRuntime.Date?
        /// The type of opt-in request that has been received for the resource.
        public var optInStatus: Swift.String?

        public init(
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum PluginNameValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noPreference
        case pglogical
        case testDecoding
        case sdkUnknown(Swift.String)

        public static var allCases: [PluginNameValue] {
            return [
                .noPreference,
                .pglogical,
                .testDecoding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "no-preference"
            case .pglogical: return "pglogical"
            case .testDecoding: return "test-decoding"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PluginNameValue(rawValue: rawValue) ?? PluginNameValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterConnectScript = "AfterConnectScript"
        case babelfishDatabaseName = "BabelfishDatabaseName"
        case captureDdls = "CaptureDdls"
        case databaseMode = "DatabaseMode"
        case databaseName = "DatabaseName"
        case ddlArtifactsSchema = "DdlArtifactsSchema"
        case executeTimeout = "ExecuteTimeout"
        case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
        case heartbeatEnable = "HeartbeatEnable"
        case heartbeatFrequency = "HeartbeatFrequency"
        case heartbeatSchema = "HeartbeatSchema"
        case mapBooleanAsBoolean = "MapBooleanAsBoolean"
        case mapJsonbAsClob = "MapJsonbAsClob"
        case mapLongVarcharAs = "MapLongVarcharAs"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case pluginName = "PluginName"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case slotName = "SlotName"
        case trimSpaceInChar = "TrimSpaceInChar"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let babelfishDatabaseName = self.babelfishDatabaseName {
            try encodeContainer.encode(babelfishDatabaseName, forKey: .babelfishDatabaseName)
        }
        if let captureDdls = self.captureDdls {
            try encodeContainer.encode(captureDdls, forKey: .captureDdls)
        }
        if let databaseMode = self.databaseMode {
            try encodeContainer.encode(databaseMode.rawValue, forKey: .databaseMode)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let ddlArtifactsSchema = self.ddlArtifactsSchema {
            try encodeContainer.encode(ddlArtifactsSchema, forKey: .ddlArtifactsSchema)
        }
        if let executeTimeout = self.executeTimeout {
            try encodeContainer.encode(executeTimeout, forKey: .executeTimeout)
        }
        if let failTasksOnLobTruncation = self.failTasksOnLobTruncation {
            try encodeContainer.encode(failTasksOnLobTruncation, forKey: .failTasksOnLobTruncation)
        }
        if let heartbeatEnable = self.heartbeatEnable {
            try encodeContainer.encode(heartbeatEnable, forKey: .heartbeatEnable)
        }
        if let heartbeatFrequency = self.heartbeatFrequency {
            try encodeContainer.encode(heartbeatFrequency, forKey: .heartbeatFrequency)
        }
        if let heartbeatSchema = self.heartbeatSchema {
            try encodeContainer.encode(heartbeatSchema, forKey: .heartbeatSchema)
        }
        if let mapBooleanAsBoolean = self.mapBooleanAsBoolean {
            try encodeContainer.encode(mapBooleanAsBoolean, forKey: .mapBooleanAsBoolean)
        }
        if let mapJsonbAsClob = self.mapJsonbAsClob {
            try encodeContainer.encode(mapJsonbAsClob, forKey: .mapJsonbAsClob)
        }
        if let mapLongVarcharAs = self.mapLongVarcharAs {
            try encodeContainer.encode(mapLongVarcharAs.rawValue, forKey: .mapLongVarcharAs)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let pluginName = self.pluginName {
            try encodeContainer.encode(pluginName.rawValue, forKey: .pluginName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let trimSpaceInChar = self.trimSpaceInChar {
            try encodeContainer.encode(trimSpaceInChar, forKey: .trimSpaceInChar)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let captureDdlsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .captureDdls)
        captureDdls = captureDdlsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let ddlArtifactsSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ddlArtifactsSchema)
        ddlArtifactsSchema = ddlArtifactsSchemaDecoded
        let executeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executeTimeout)
        executeTimeout = executeTimeoutDecoded
        let failTasksOnLobTruncationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failTasksOnLobTruncation)
        failTasksOnLobTruncation = failTasksOnLobTruncationDecoded
        let heartbeatEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .heartbeatEnable)
        heartbeatEnable = heartbeatEnableDecoded
        let heartbeatSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .heartbeatSchema)
        heartbeatSchema = heartbeatSchemaDecoded
        let heartbeatFrequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heartbeatFrequency)
        heartbeatFrequency = heartbeatFrequencyDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
        let pluginNameDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.PluginNameValue.self, forKey: .pluginName)
        pluginName = pluginNameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let trimSpaceInCharDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimSpaceInChar)
        trimSpaceInChar = trimSpaceInCharDecoded
        let mapBooleanAsBooleanDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapBooleanAsBoolean)
        mapBooleanAsBoolean = mapBooleanAsBooleanDecoded
        let mapJsonbAsClobDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapJsonbAsClob)
        mapJsonbAsClob = mapJsonbAsClobDecoded
        let mapLongVarcharAsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.LongVarcharMappingType.self, forKey: .mapLongVarcharAs)
        mapLongVarcharAs = mapLongVarcharAsDecoded
        let databaseModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatabaseMode.self, forKey: .databaseMode)
        databaseMode = databaseModeDecoded
        let babelfishDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .babelfishDatabaseName)
        babelfishDatabaseName = babelfishDatabaseNameDecoded
    }
}

extension DatabaseMigrationClientTypes.PostgreSQLSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostgreSQLSettings(afterConnectScript: \(Swift.String(describing: afterConnectScript)), babelfishDatabaseName: \(Swift.String(describing: babelfishDatabaseName)), captureDdls: \(Swift.String(describing: captureDdls)), databaseMode: \(Swift.String(describing: databaseMode)), databaseName: \(Swift.String(describing: databaseName)), ddlArtifactsSchema: \(Swift.String(describing: ddlArtifactsSchema)), executeTimeout: \(Swift.String(describing: executeTimeout)), failTasksOnLobTruncation: \(Swift.String(describing: failTasksOnLobTruncation)), heartbeatEnable: \(Swift.String(describing: heartbeatEnable)), heartbeatFrequency: \(Swift.String(describing: heartbeatFrequency)), heartbeatSchema: \(Swift.String(describing: heartbeatSchema)), mapBooleanAsBoolean: \(Swift.String(describing: mapBooleanAsBoolean)), mapJsonbAsClob: \(Swift.String(describing: mapJsonbAsClob)), mapLongVarcharAs: \(Swift.String(describing: mapLongVarcharAs)), maxFileSize: \(Swift.String(describing: maxFileSize)), pluginName: \(Swift.String(describing: pluginName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), slotName: \(Swift.String(describing: slotName)), trimSpaceInChar: \(Swift.String(describing: trimSpaceInChar)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a PostgreSQL endpoint.
    public struct PostgreSQLSettings: Swift.Equatable {
        /// For use with change data capture (CDC) only, this attribute has DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data. Example: afterConnectScript=SET session_replication_role='replica'
        public var afterConnectScript: Swift.String?
        /// The Babelfish for Aurora PostgreSQL database name for the endpoint.
        public var babelfishDatabaseName: Swift.String?
        /// To capture DDL events, DMS creates various artifacts in the PostgreSQL database when the task starts. You can later remove these artifacts. If this value is set to N, you don't have to create tables or triggers on the source database.
        public var captureDdls: Swift.Bool?
        /// Specifies the default behavior of the replication's handling of PostgreSQL- compatible endpoints that require some additional configuration, such as Babelfish endpoints.
        public var databaseMode: DatabaseMigrationClientTypes.DatabaseMode?
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// The schema in which the operational DDL database artifacts are created. Example: ddlArtifactsSchema=xyzddlschema;
        public var ddlArtifactsSchema: Swift.String?
        /// Sets the client statement timeout for the PostgreSQL instance, in seconds. The default value is 60 seconds. Example: executeTimeout=100;
        public var executeTimeout: Swift.Int?
        /// When set to true, this value causes a task to fail if the actual size of a LOB column is greater than the specified LobMaxSize. If task is set to Limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public var failTasksOnLobTruncation: Swift.Bool?
        /// The write-ahead log (WAL) heartbeat feature mimics a dummy transaction. By doing this, it prevents idle logical replication slots from holding onto old WAL logs, which can result in storage full situations on the source. This heartbeat keeps restart_lsn moving and prevents storage full scenarios.
        public var heartbeatEnable: Swift.Bool?
        /// Sets the WAL heartbeat frequency (in minutes).
        public var heartbeatFrequency: Swift.Int?
        /// Sets the schema in which the heartbeat artifacts are created.
        public var heartbeatSchema: Swift.String?
        /// When true, lets PostgreSQL migrate the boolean type as boolean. By default, PostgreSQL migrates booleans as varchar(5). You must set this setting on both the source and target endpoints for it to take effect.
        public var mapBooleanAsBoolean: Swift.Bool?
        /// When true, DMS migrates JSONB values as CLOB.
        public var mapJsonbAsClob: Swift.Bool?
        /// When true, DMS migrates LONG values as VARCHAR.
        public var mapLongVarcharAs: DatabaseMigrationClientTypes.LongVarcharMappingType?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. Example: maxFileSize=512
        public var maxFileSize: Swift.Int?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Specifies the plugin to use to create a replication slot.
        public var pluginName: DatabaseMigrationClientTypes.PluginNameValue?
        /// Endpoint TCP port. The default is 5432.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the PostgreSQL endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the PostgreSQL endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The host name of the endpoint database. For an Amazon RDS PostgreSQL instance, this is the output of [DescribeDBInstances](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html), in the [Endpoint](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_Endpoint.html).Address field. For an Aurora PostgreSQL instance, this is the output of [DescribeDBClusters](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBClusters.html), in the Endpoint field.
        public var serverName: Swift.String?
        /// Sets the name of a previously created logical replication slot for a change data capture (CDC) load of the PostgreSQL source instance. When used with the CdcStartPosition request parameter for the DMS API , this attribute also makes it possible to use native CDC start points. DMS verifies that the specified logical replication slot exists before starting the CDC load task. It also verifies that the task was created with a valid setting of CdcStartPosition. If the specified slot doesn't exist or the task doesn't have a valid CdcStartPosition setting, DMS raises an error. For more information about setting the CdcStartPosition request parameter, see [Determining a CDC native start point](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Task.CDC.html#CHAP_Task.CDC.StartPoint.Native) in the Database Migration Service User Guide. For more information about using CdcStartPosition, see [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html), [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html), and [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html).
        public var slotName: Swift.String?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public var trimSpaceInChar: Swift.Bool?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            afterConnectScript: Swift.String? = nil,
            babelfishDatabaseName: Swift.String? = nil,
            captureDdls: Swift.Bool? = nil,
            databaseMode: DatabaseMigrationClientTypes.DatabaseMode? = nil,
            databaseName: Swift.String? = nil,
            ddlArtifactsSchema: Swift.String? = nil,
            executeTimeout: Swift.Int? = nil,
            failTasksOnLobTruncation: Swift.Bool? = nil,
            heartbeatEnable: Swift.Bool? = nil,
            heartbeatFrequency: Swift.Int? = nil,
            heartbeatSchema: Swift.String? = nil,
            mapBooleanAsBoolean: Swift.Bool? = nil,
            mapJsonbAsClob: Swift.Bool? = nil,
            mapLongVarcharAs: DatabaseMigrationClientTypes.LongVarcharMappingType? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            pluginName: DatabaseMigrationClientTypes.PluginNameValue? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            slotName: Swift.String? = nil,
            trimSpaceInChar: Swift.Bool? = nil,
            username: Swift.String? = nil
        )
        {
            self.afterConnectScript = afterConnectScript
            self.babelfishDatabaseName = babelfishDatabaseName
            self.captureDdls = captureDdls
            self.databaseMode = databaseMode
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.heartbeatEnable = heartbeatEnable
            self.heartbeatFrequency = heartbeatFrequency
            self.heartbeatSchema = heartbeatSchema
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.mapJsonbAsClob = mapJsonbAsClob
            self.mapLongVarcharAs = mapLongVarcharAs
            self.maxFileSize = maxFileSize
            self.password = password
            self.pluginName = pluginName
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.trimSpaceInChar = trimSpaceInChar
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.PostgreSqlDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case databaseName = "DatabaseName"
        case port = "Port"
        case serverName = "ServerName"
        case sslMode = "SslMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslMode = self.sslMode {
            try encodeContainer.encode(sslMode.rawValue, forKey: .sslMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let sslModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DmsSslModeValue.self, forKey: .sslMode)
        sslMode = sslModeDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a PostgreSQL data provider.
    public struct PostgreSqlDataProviderSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public var certificateArn: Swift.String?
        /// The database name on the PostgreSQL data provider.
        public var databaseName: Swift.String?
        /// The port value for the PostgreSQL data provider.
        public var port: Swift.Int?
        /// The name of the PostgreSQL server.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the PostgreSQL data provider. The default value is none.
        public var sslMode: DatabaseMigrationClientTypes.DmsSslModeValue?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: DatabaseMigrationClientTypes.DmsSslModeValue? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }
    }

}

extension DatabaseMigrationClientTypes.ProvisionData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateNewProvisioningDataAvailable = "DateNewProvisioningDataAvailable"
        case dateProvisioned = "DateProvisioned"
        case isNewProvisioningAvailable = "IsNewProvisioningAvailable"
        case provisionState = "ProvisionState"
        case provisionedCapacityUnits = "ProvisionedCapacityUnits"
        case reasonForNewProvisioningData = "ReasonForNewProvisioningData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateNewProvisioningDataAvailable = self.dateNewProvisioningDataAvailable {
            try encodeContainer.encodeTimestamp(dateNewProvisioningDataAvailable, format: .epochSeconds, forKey: .dateNewProvisioningDataAvailable)
        }
        if let dateProvisioned = self.dateProvisioned {
            try encodeContainer.encodeTimestamp(dateProvisioned, format: .epochSeconds, forKey: .dateProvisioned)
        }
        if isNewProvisioningAvailable != false {
            try encodeContainer.encode(isNewProvisioningAvailable, forKey: .isNewProvisioningAvailable)
        }
        if let provisionState = self.provisionState {
            try encodeContainer.encode(provisionState, forKey: .provisionState)
        }
        if provisionedCapacityUnits != 0 {
            try encodeContainer.encode(provisionedCapacityUnits, forKey: .provisionedCapacityUnits)
        }
        if let reasonForNewProvisioningData = self.reasonForNewProvisioningData {
            try encodeContainer.encode(reasonForNewProvisioningData, forKey: .reasonForNewProvisioningData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionState)
        provisionState = provisionStateDecoded
        let provisionedCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .provisionedCapacityUnits) ?? 0
        provisionedCapacityUnits = provisionedCapacityUnitsDecoded
        let dateProvisionedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateProvisioned)
        dateProvisioned = dateProvisionedDecoded
        let isNewProvisioningAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNewProvisioningAvailable) ?? false
        isNewProvisioningAvailable = isNewProvisioningAvailableDecoded
        let dateNewProvisioningDataAvailableDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dateNewProvisioningDataAvailable)
        dateNewProvisioningDataAvailable = dateNewProvisioningDataAvailableDecoded
        let reasonForNewProvisioningDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonForNewProvisioningData)
        reasonForNewProvisioningData = reasonForNewProvisioningDataDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Information about provisioning resources for an DMS serverless replication.
    public struct ProvisionData: Swift.Equatable {
        /// The timestamp when provisioning became available.
        public var dateNewProvisioningDataAvailable: ClientRuntime.Date?
        /// The timestamp when DMS provisioned replication resources.
        public var dateProvisioned: ClientRuntime.Date?
        /// Whether the new provisioning is available to the replication.
        public var isNewProvisioningAvailable: Swift.Bool
        /// The current provisioning state
        public var provisionState: Swift.String?
        /// The number of capacity units the replication is using.
        public var provisionedCapacityUnits: Swift.Int
        /// A message describing the reason that DMS provisioned new resources for the serverless replication.
        public var reasonForNewProvisioningData: Swift.String?

        public init(
            dateNewProvisioningDataAvailable: ClientRuntime.Date? = nil,
            dateProvisioned: ClientRuntime.Date? = nil,
            isNewProvisioningAvailable: Swift.Bool = false,
            provisionState: Swift.String? = nil,
            provisionedCapacityUnits: Swift.Int = 0,
            reasonForNewProvisioningData: Swift.String? = nil
        )
        {
            self.dateNewProvisioningDataAvailable = dateNewProvisioningDataAvailable
            self.dateProvisioned = dateProvisioned
            self.isNewProvisioningAvailable = isNewProvisioningAvailable
            self.provisionState = provisionState
            self.provisionedCapacityUnits = provisionedCapacityUnits
            self.reasonForNewProvisioningData = reasonForNewProvisioningData
        }
    }

}

extension DatabaseMigrationClientTypes.RdsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentOption = "DeploymentOption"
        case engineEdition = "EngineEdition"
        case engineVersion = "EngineVersion"
        case instanceMemory = "InstanceMemory"
        case instanceType = "InstanceType"
        case instanceVcpu = "InstanceVcpu"
        case storageIops = "StorageIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentOption = self.deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let engineEdition = self.engineEdition {
            try encodeContainer.encode(engineEdition, forKey: .engineEdition)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceMemory = self.instanceMemory {
            try encodeContainer.encode(instanceMemory, forKey: .instanceMemory)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let instanceVcpu = self.instanceVcpu {
            try encodeContainer.encode(instanceVcpu, forKey: .instanceVcpu)
        }
        if let storageIops = self.storageIops {
            try encodeContainer.encode(storageIops, forKey: .storageIops)
        }
        if let storageSize = self.storageSize {
            try encodeContainer.encode(storageSize, forKey: .storageSize)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineEdition)
        engineEdition = engineEditionDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let instanceVcpuDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .instanceVcpu)
        instanceVcpu = instanceVcpuDecoded
        let instanceMemoryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .instanceMemory)
        instanceMemory = instanceMemoryDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let storageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageSize)
        storageSize = storageSizeDecoded
        let storageIopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageIops)
        storageIops = storageIopsDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes the configuration of the recommended target engine on Amazon RDS.
    public struct RdsConfiguration: Swift.Equatable {
        /// Describes the deployment option for the recommended Amazon RDS DB instance. The deployment options include Multi-AZ and Single-AZ deployments. Valid values include "MULTI_AZ" and "SINGLE_AZ".
        public var deploymentOption: Swift.String?
        /// Describes the recommended target Amazon RDS engine edition.
        public var engineEdition: Swift.String?
        /// Describes the recommended target Amazon RDS engine version.
        public var engineVersion: Swift.String?
        /// Describes the memory on the recommended Amazon RDS DB instance that meets your requirements.
        public var instanceMemory: Swift.Double?
        /// Describes the recommended target Amazon RDS instance type.
        public var instanceType: Swift.String?
        /// Describes the number of virtual CPUs (vCPU) on the recommended Amazon RDS DB instance that meets your requirements.
        public var instanceVcpu: Swift.Double?
        /// Describes the number of I/O operations completed each second (IOPS) on the recommended Amazon RDS DB instance that meets your requirements.
        public var storageIops: Swift.Int?
        /// Describes the storage size of the recommended Amazon RDS DB instance that meets your requirements.
        public var storageSize: Swift.Int?
        /// Describes the storage type of the recommended Amazon RDS DB instance that meets your requirements. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2 and gp3), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard).
        public var storageType: Swift.String?

        public init(
            deploymentOption: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceMemory: Swift.Double? = nil,
            instanceType: Swift.String? = nil,
            instanceVcpu: Swift.Double? = nil,
            storageIops: Swift.Int? = nil,
            storageSize: Swift.Int? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceType = instanceType
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
            self.storageType = storageType
        }
    }

}

extension DatabaseMigrationClientTypes.RdsRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requirementsToTarget = "RequirementsToTarget"
        case targetConfiguration = "TargetConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requirementsToTarget = self.requirementsToTarget {
            try encodeContainer.encode(requirementsToTarget, forKey: .requirementsToTarget)
        }
        if let targetConfiguration = self.targetConfiguration {
            try encodeContainer.encode(targetConfiguration, forKey: .targetConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requirementsToTargetDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RdsRequirements.self, forKey: .requirementsToTarget)
        requirementsToTarget = requirementsToTargetDecoded
        let targetConfigurationDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RdsConfiguration.self, forKey: .targetConfiguration)
        targetConfiguration = targetConfigurationDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a recommendation of a target engine on Amazon RDS.
    public struct RdsRecommendation: Swift.Equatable {
        /// Supplemental information about the requirements to the recommended target database on Amazon RDS.
        public var requirementsToTarget: DatabaseMigrationClientTypes.RdsRequirements?
        /// Supplemental information about the configuration of the recommended target database on Amazon RDS.
        public var targetConfiguration: DatabaseMigrationClientTypes.RdsConfiguration?

        public init(
            requirementsToTarget: DatabaseMigrationClientTypes.RdsRequirements? = nil,
            targetConfiguration: DatabaseMigrationClientTypes.RdsConfiguration? = nil
        )
        {
            self.requirementsToTarget = requirementsToTarget
            self.targetConfiguration = targetConfiguration
        }
    }

}

extension DatabaseMigrationClientTypes.RdsRequirements: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentOption = "DeploymentOption"
        case engineEdition = "EngineEdition"
        case engineVersion = "EngineVersion"
        case instanceMemory = "InstanceMemory"
        case instanceVcpu = "InstanceVcpu"
        case storageIops = "StorageIops"
        case storageSize = "StorageSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentOption = self.deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let engineEdition = self.engineEdition {
            try encodeContainer.encode(engineEdition, forKey: .engineEdition)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceMemory = self.instanceMemory {
            try encodeContainer.encode(instanceMemory, forKey: .instanceMemory)
        }
        if let instanceVcpu = self.instanceVcpu {
            try encodeContainer.encode(instanceVcpu, forKey: .instanceVcpu)
        }
        if let storageIops = self.storageIops {
            try encodeContainer.encode(storageIops, forKey: .storageIops)
        }
        if let storageSize = self.storageSize {
            try encodeContainer.encode(storageSize, forKey: .storageSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineEdition)
        engineEdition = engineEditionDecoded
        let instanceVcpuDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .instanceVcpu)
        instanceVcpu = instanceVcpuDecoded
        let instanceMemoryDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .instanceMemory)
        instanceMemory = instanceMemoryDecoded
        let storageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageSize)
        storageSize = storageSizeDecoded
        let storageIopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageIops)
        storageIops = storageIopsDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes the requirements to the target engine on Amazon RDS.
    public struct RdsRequirements: Swift.Equatable {
        /// The required deployment option for the Amazon RDS DB instance. Valid values include "MULTI_AZ" for Multi-AZ deployments and "SINGLE_AZ" for Single-AZ deployments.
        public var deploymentOption: Swift.String?
        /// The required target Amazon RDS engine edition.
        public var engineEdition: Swift.String?
        /// The required target Amazon RDS engine version.
        public var engineVersion: Swift.String?
        /// The required memory on the Amazon RDS DB instance.
        public var instanceMemory: Swift.Double?
        /// The required number of virtual CPUs (vCPU) on the Amazon RDS DB instance.
        public var instanceVcpu: Swift.Double?
        /// The required number of I/O operations completed each second (IOPS) on your Amazon RDS DB instance.
        public var storageIops: Swift.Int?
        /// The required Amazon RDS DB instance storage size.
        public var storageSize: Swift.Int?

        public init(
            deploymentOption: Swift.String? = nil,
            engineEdition: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceMemory: Swift.Double? = nil,
            instanceVcpu: Swift.Double? = nil,
            storageIops: Swift.Int? = nil,
            storageSize: Swift.Int? = nil
        )
        {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
        }
    }

}

extension RebootReplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case forcePlannedFailover = "ForcePlannedFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceFailover = self.forceFailover {
            try encodeContainer.encode(forceFailover, forKey: .forceFailover)
        }
        if let forcePlannedFailover = self.forcePlannedFailover {
            try encodeContainer.encode(forcePlannedFailover, forKey: .forcePlannedFailover)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension RebootReplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootReplicationInstanceInput: Swift.Equatable {
    /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. If the instance isn't configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forceFailover: Swift.Bool?
    /// If this parameter is true, the reboot is conducted through a planned Multi-AZ failover where resources are released and cleaned up prior to conducting the failover. If the instance isn''t configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
    public var forcePlannedFailover: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        forceFailover: Swift.Bool? = nil,
        forcePlannedFailover: Swift.Bool? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.forceFailover = forceFailover
        self.forcePlannedFailover = forcePlannedFailover
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RebootReplicationInstanceInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let forceFailover: Swift.Bool?
    let forcePlannedFailover: Swift.Bool?
}

extension RebootReplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceFailover = "ForceFailover"
        case forcePlannedFailover = "ForcePlannedFailover"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let forceFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceFailover)
        forceFailover = forceFailoverDecoded
        let forcePlannedFailoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forcePlannedFailover)
        forcePlannedFailover = forcePlannedFailoverDecoded
    }
}

extension RebootReplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RebootReplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationInstance = output.replicationInstance
        } else {
            self.replicationInstance = nil
        }
    }
}

public struct RebootReplicationInstanceOutput: Swift.Equatable {
    /// The replication instance that is being rebooted.
    public var replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?

    public init(
        replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance? = nil
    )
    {
        self.replicationInstance = replicationInstance
    }
}

struct RebootReplicationInstanceOutputBody: Swift.Equatable {
    let replicationInstance: DatabaseMigrationClientTypes.ReplicationInstance?
}

extension RebootReplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstance = "ReplicationInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationInstance.self, forKey: .replicationInstance)
        replicationInstance = replicationInstanceDecoded
    }
}

enum RebootReplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case data = "Data"
        case databaseId = "DatabaseId"
        case engineName = "EngineName"
        case preferred = "Preferred"
        case settings = "Settings"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let preferred = self.preferred {
            try encodeContainer.encode(preferred, forKey: .preferred)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let preferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preferred)
        preferred = preferredDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RecommendationSettings.self, forKey: .settings)
        settings = settingsDecoded
        let dataDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RecommendationData.self, forKey: .data)
        data = dataDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a recommendation of a target engine. A recommendation is a set of possible Amazon Web Services target engines that you can choose to migrate your source on-premises database. In this set, Fleet Advisor suggests a single target engine as the right sized migration destination. To determine this rightsized migration destination, Fleet Advisor uses the inventory metadata and metrics from data collector. You can use recommendations before the start of migration to save costs and reduce risks. With recommendations, you can explore different target options and compare metrics, so you can make an informed decision when you choose the migration target.
    public struct Recommendation: Swift.Equatable {
        /// The date when Fleet Advisor created the target engine recommendation.
        public var createdDate: Swift.String?
        /// The recommendation of a target engine for the specified source database.
        public var data: DatabaseMigrationClientTypes.RecommendationData?
        /// The identifier of the source database for which Fleet Advisor provided this recommendation.
        public var databaseId: Swift.String?
        /// The name of the target engine. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public var engineName: Swift.String?
        /// Indicates that this target is the rightsized migration destination.
        public var preferred: Swift.Bool?
        /// The settings in JSON format for the preferred target engine parameters. These parameters include capacity, resource utilization, and the usage type (production, development, or testing).
        public var settings: DatabaseMigrationClientTypes.RecommendationSettings?
        /// The status of the target engine recommendation. Valid values include "alternate", "in-progress", "not-viable", and "recommended".
        public var status: Swift.String?

        public init(
            createdDate: Swift.String? = nil,
            data: DatabaseMigrationClientTypes.RecommendationData? = nil,
            databaseId: Swift.String? = nil,
            engineName: Swift.String? = nil,
            preferred: Swift.Bool? = nil,
            settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.data = data
            self.databaseId = databaseId
            self.engineName = engineName
            self.preferred = preferred
            self.settings = settings
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.RecommendationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsEngine = "RdsEngine"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsEngine = self.rdsEngine {
            try encodeContainer.encode(rdsEngine, forKey: .rdsEngine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsEngineDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RdsRecommendation.self, forKey: .rdsEngine)
        rdsEngine = rdsEngineDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the target engine for the specified source database.
    public struct RecommendationData: Swift.Equatable {
        /// The recommendation of a target Amazon RDS database engine.
        public var rdsEngine: DatabaseMigrationClientTypes.RdsRecommendation?

        public init(
            rdsEngine: DatabaseMigrationClientTypes.RdsRecommendation? = nil
        )
        {
            self.rdsEngine = rdsEngine
        }
    }

}

extension DatabaseMigrationClientTypes.RecommendationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceSizingType = "InstanceSizingType"
        case workloadType = "WorkloadType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceSizingType = self.instanceSizingType {
            try encodeContainer.encode(instanceSizingType, forKey: .instanceSizingType)
        }
        if let workloadType = self.workloadType {
            try encodeContainer.encode(workloadType, forKey: .workloadType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceSizingTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceSizingType)
        instanceSizingType = instanceSizingTypeDecoded
        let workloadTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadType)
        workloadType = workloadTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the required target engine settings.
    public struct RecommendationSettings: Swift.Equatable {
        /// The size of your target instance. Fleet Advisor calculates this value based on your data collection type, such as total capacity and resource utilization. Valid values include "total-capacity" and "utilization".
        /// This member is required.
        public var instanceSizingType: Swift.String?
        /// The deployment option for your target engine. For production databases, Fleet Advisor chooses Multi-AZ deployment. For development or test databases, Fleet Advisor chooses Single-AZ deployment. Valid values include "development" and "production".
        /// This member is required.
        public var workloadType: Swift.String?

        public init(
            instanceSizingType: Swift.String? = nil,
            workloadType: Swift.String? = nil
        )
        {
            self.instanceSizingType = instanceSizingType
            self.workloadType = workloadType
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum RedisAuthTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authRole
        case authToken
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RedisAuthTypeValue] {
            return [
                .authRole,
                .authToken,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authRole: return "auth-role"
            case .authToken: return "auth-token"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RedisAuthTypeValue(rawValue: rawValue) ?? RedisAuthTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.RedisSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authPassword = "AuthPassword"
        case authType = "AuthType"
        case authUserName = "AuthUserName"
        case port = "Port"
        case serverName = "ServerName"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslSecurityProtocol = "SslSecurityProtocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authPassword = self.authPassword {
            try encodeContainer.encode(authPassword, forKey: .authPassword)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let authUserName = self.authUserName {
            try encodeContainer.encode(authUserName, forKey: .authUserName)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let sslCaCertificateArn = self.sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslSecurityProtocol = self.sslSecurityProtocol {
            try encodeContainer.encode(sslSecurityProtocol.rawValue, forKey: .sslSecurityProtocol)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let sslSecurityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SslSecurityProtocolValue.self, forKey: .sslSecurityProtocol)
        sslSecurityProtocol = sslSecurityProtocolDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RedisAuthTypeValue.self, forKey: .authType)
        authType = authTypeDecoded
        let authUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authUserName)
        authUserName = authUserNameDecoded
        let authPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authPassword)
        authPassword = authPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
    }
}

extension DatabaseMigrationClientTypes.RedisSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedisSettings(authType: \(Swift.String(describing: authType)), authUserName: \(Swift.String(describing: authUserName)), port: \(Swift.String(describing: port)), serverName: \(Swift.String(describing: serverName)), sslCaCertificateArn: \(Swift.String(describing: sslCaCertificateArn)), sslSecurityProtocol: \(Swift.String(describing: sslSecurityProtocol)), authPassword: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a Redis target endpoint.
    public struct RedisSettings: Swift.Equatable {
        /// The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
        public var authPassword: Swift.String?
        /// The type of authentication to perform when connecting to a Redis target. Options include none, auth-token, and auth-role. The auth-token option requires an AuthPassword value to be provided. The auth-role option requires AuthUserName and AuthPassword values to be provided.
        public var authType: DatabaseMigrationClientTypes.RedisAuthTypeValue?
        /// The user name provided with the auth-role option of the AuthType setting for a Redis target endpoint.
        public var authUserName: Swift.String?
        /// Transmission Control Protocol (TCP) port for the endpoint.
        /// This member is required.
        public var port: Swift.Int
        /// Fully qualified domain name of the endpoint.
        /// This member is required.
        public var serverName: Swift.String?
        /// The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
        public var sslCaCertificateArn: Swift.String?
        /// The connection to a Redis target endpoint using Transport Layer Security (TLS). Valid values include plaintext and ssl-encryption. The default is ssl-encryption. The ssl-encryption option makes an encrypted connection. Optionally, you can identify an Amazon Resource Name (ARN) for an SSL certificate authority (CA) using the SslCaCertificateArn setting. If an ARN isn't given for a CA, DMS uses the Amazon root CA. The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database.
        public var sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue?

        public init(
            authPassword: Swift.String? = nil,
            authType: DatabaseMigrationClientTypes.RedisAuthTypeValue? = nil,
            authUserName: Swift.String? = nil,
            port: Swift.Int = 0,
            serverName: Swift.String? = nil,
            sslCaCertificateArn: Swift.String? = nil,
            sslSecurityProtocol: DatabaseMigrationClientTypes.SslSecurityProtocolValue? = nil
        )
        {
            self.authPassword = authPassword
            self.authType = authType
            self.authUserName = authUserName
            self.port = port
            self.serverName = serverName
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslSecurityProtocol = sslSecurityProtocol
        }
    }

}

extension DatabaseMigrationClientTypes.RedshiftDataProviderSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case port = "Port"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Redshift data provider.
    public struct RedshiftDataProviderSettings: Swift.Equatable {
        /// The database name on the Amazon Redshift data provider.
        public var databaseName: Swift.String?
        /// The port value for the Amazon Redshift data provider.
        public var port: Swift.Int?
        /// The name of the Amazon Redshift server.
        public var serverName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
        }
    }

}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptAnyDate = "AcceptAnyDate"
        case afterConnectScript = "AfterConnectScript"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case caseSensitiveNames = "CaseSensitiveNames"
        case compUpdate = "CompUpdate"
        case connectionTimeout = "ConnectionTimeout"
        case databaseName = "DatabaseName"
        case dateFormat = "DateFormat"
        case emptyAsNull = "EmptyAsNull"
        case encryptionMode = "EncryptionMode"
        case explicitIds = "ExplicitIds"
        case fileTransferUploadStreams = "FileTransferUploadStreams"
        case loadTimeout = "LoadTimeout"
        case mapBooleanAsBoolean = "MapBooleanAsBoolean"
        case maxFileSize = "MaxFileSize"
        case password = "Password"
        case port = "Port"
        case removeQuotes = "RemoveQuotes"
        case replaceChars = "ReplaceChars"
        case replaceInvalidChars = "ReplaceInvalidChars"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timeFormat = "TimeFormat"
        case trimBlanks = "TrimBlanks"
        case truncateColumns = "TruncateColumns"
        case username = "Username"
        case writeBufferSize = "WriteBufferSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptAnyDate = self.acceptAnyDate {
            try encodeContainer.encode(acceptAnyDate, forKey: .acceptAnyDate)
        }
        if let afterConnectScript = self.afterConnectScript {
            try encodeContainer.encode(afterConnectScript, forKey: .afterConnectScript)
        }
        if let bucketFolder = self.bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let caseSensitiveNames = self.caseSensitiveNames {
            try encodeContainer.encode(caseSensitiveNames, forKey: .caseSensitiveNames)
        }
        if let compUpdate = self.compUpdate {
            try encodeContainer.encode(compUpdate, forKey: .compUpdate)
        }
        if let connectionTimeout = self.connectionTimeout {
            try encodeContainer.encode(connectionTimeout, forKey: .connectionTimeout)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dateFormat = self.dateFormat {
            try encodeContainer.encode(dateFormat, forKey: .dateFormat)
        }
        if let emptyAsNull = self.emptyAsNull {
            try encodeContainer.encode(emptyAsNull, forKey: .emptyAsNull)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let explicitIds = self.explicitIds {
            try encodeContainer.encode(explicitIds, forKey: .explicitIds)
        }
        if let fileTransferUploadStreams = self.fileTransferUploadStreams {
            try encodeContainer.encode(fileTransferUploadStreams, forKey: .fileTransferUploadStreams)
        }
        if let loadTimeout = self.loadTimeout {
            try encodeContainer.encode(loadTimeout, forKey: .loadTimeout)
        }
        if let mapBooleanAsBoolean = self.mapBooleanAsBoolean {
            try encodeContainer.encode(mapBooleanAsBoolean, forKey: .mapBooleanAsBoolean)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let removeQuotes = self.removeQuotes {
            try encodeContainer.encode(removeQuotes, forKey: .removeQuotes)
        }
        if let replaceChars = self.replaceChars {
            try encodeContainer.encode(replaceChars, forKey: .replaceChars)
        }
        if let replaceInvalidChars = self.replaceInvalidChars {
            try encodeContainer.encode(replaceInvalidChars, forKey: .replaceInvalidChars)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serverSideEncryptionKmsKeyId = self.serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timeFormat = self.timeFormat {
            try encodeContainer.encode(timeFormat, forKey: .timeFormat)
        }
        if let trimBlanks = self.trimBlanks {
            try encodeContainer.encode(trimBlanks, forKey: .trimBlanks)
        }
        if let truncateColumns = self.truncateColumns {
            try encodeContainer.encode(truncateColumns, forKey: .truncateColumns)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let writeBufferSize = self.writeBufferSize {
            try encodeContainer.encode(writeBufferSize, forKey: .writeBufferSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptAnyDateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptAnyDate)
        acceptAnyDate = acceptAnyDateDecoded
        let afterConnectScriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterConnectScript)
        afterConnectScript = afterConnectScriptDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let caseSensitiveNamesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitiveNames)
        caseSensitiveNames = caseSensitiveNamesDecoded
        let compUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compUpdate)
        compUpdate = compUpdateDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dateFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateFormat)
        dateFormat = dateFormatDecoded
        let emptyAsNullDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .emptyAsNull)
        emptyAsNull = emptyAsNullDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let explicitIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .explicitIds)
        explicitIds = explicitIdsDecoded
        let fileTransferUploadStreamsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileTransferUploadStreams)
        fileTransferUploadStreams = fileTransferUploadStreamsDecoded
        let loadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .loadTimeout)
        loadTimeout = loadTimeoutDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let removeQuotesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeQuotes)
        removeQuotes = removeQuotesDecoded
        let replaceInvalidCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceInvalidChars)
        replaceInvalidChars = replaceInvalidCharsDecoded
        let replaceCharsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceChars)
        replaceChars = replaceCharsDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let timeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeFormat)
        timeFormat = timeFormatDecoded
        let trimBlanksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .trimBlanks)
        trimBlanks = trimBlanksDecoded
        let truncateColumnsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .truncateColumns)
        truncateColumns = truncateColumnsDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let writeBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeBufferSize)
        writeBufferSize = writeBufferSizeDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
        let mapBooleanAsBooleanDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapBooleanAsBoolean)
        mapBooleanAsBoolean = mapBooleanAsBooleanDecoded
    }
}

extension DatabaseMigrationClientTypes.RedshiftSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftSettings(acceptAnyDate: \(Swift.String(describing: acceptAnyDate)), afterConnectScript: \(Swift.String(describing: afterConnectScript)), bucketFolder: \(Swift.String(describing: bucketFolder)), bucketName: \(Swift.String(describing: bucketName)), caseSensitiveNames: \(Swift.String(describing: caseSensitiveNames)), compUpdate: \(Swift.String(describing: compUpdate)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), databaseName: \(Swift.String(describing: databaseName)), dateFormat: \(Swift.String(describing: dateFormat)), emptyAsNull: \(Swift.String(describing: emptyAsNull)), encryptionMode: \(Swift.String(describing: encryptionMode)), explicitIds: \(Swift.String(describing: explicitIds)), fileTransferUploadStreams: \(Swift.String(describing: fileTransferUploadStreams)), loadTimeout: \(Swift.String(describing: loadTimeout)), mapBooleanAsBoolean: \(Swift.String(describing: mapBooleanAsBoolean)), maxFileSize: \(Swift.String(describing: maxFileSize)), port: \(Swift.String(describing: port)), removeQuotes: \(Swift.String(describing: removeQuotes)), replaceChars: \(Swift.String(describing: replaceChars)), replaceInvalidChars: \(Swift.String(describing: replaceInvalidChars)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), serverSideEncryptionKmsKeyId: \(Swift.String(describing: serverSideEncryptionKmsKeyId)), serviceAccessRoleArn: \(Swift.String(describing: serviceAccessRoleArn)), timeFormat: \(Swift.String(describing: timeFormat)), trimBlanks: \(Swift.String(describing: trimBlanks)), truncateColumns: \(Swift.String(describing: truncateColumns)), username: \(Swift.String(describing: username)), writeBufferSize: \(Swift.String(describing: writeBufferSize)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Redshift endpoint.
    public struct RedshiftSettings: Swift.Equatable {
        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field.
        public var acceptAnyDate: Swift.Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public var afterConnectScript: Swift.String?
        /// An S3 folder where the comma-separated-value (.csv) files are stored before being uploaded to the target Redshift cluster. For full load mode, DMS converts source records into .csv files and loads them to the BucketFolder/TableID path. DMS uses the Redshift COPY command to upload the .csv files to the target table. The files are deleted once the COPY operation has finished. For more information, see [COPY](https://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html) in the Amazon Redshift Database Developer Guide. For change-data-capture (CDC) mode, DMS creates a NetChanges table, and loads the .csv files to this BucketFolder/NetChangesTableID path.
        public var bucketFolder: Swift.String?
        /// The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.
        public var bucketName: Swift.String?
        /// If Amazon Redshift is configured to support case sensitive schema names, set CaseSensitiveNames to true. The default is false.
        public var caseSensitiveNames: Swift.Bool?
        /// If you set CompUpdate to true Amazon Redshift applies automatic compression if the table is empty. This applies even if the table columns already have encodings other than RAW. If you set CompUpdate to false, automatic compression is disabled and existing column encodings aren't changed. The default is true.
        public var compUpdate: Swift.Bool?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public var connectionTimeout: Swift.Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public var databaseName: Swift.String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string. If your date and time values use formats different from each other, set this to auto.
        public var dateFormat: Swift.String?
        /// A value that specifies whether DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public var emptyAsNull: Swift.Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you canâ€™t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, create an Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket"
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// This setting is only valid for a full-load migration task. Set ExplicitIds to true to have tables with IDENTITY columns override their auto-generated values with explicit values loaded from the source data files used to populate the tables. The default is false.
        public var explicitIds: Swift.Bool?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10. The number of parallel streams used to upload a single .csv file to an S3 bucket using S3 Multipart Upload. For more information, see [Multipart upload overview](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html). FileTransferUploadStreams accepts a value from 1 through 64. It defaults to 10.
        public var fileTransferUploadStreams: Swift.Int?
        /// The amount of time to wait (in milliseconds) before timing out of operations performed by DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.
        public var loadTimeout: Swift.Int?
        /// When true, lets Redshift migrate the boolean type as boolean. By default, Redshift migrates booleans as varchar(1). You must set this setting on both the source and target endpoints for it to take effect.
        public var mapBooleanAsBoolean: Swift.Bool?
        /// The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer data to Amazon Redshift. It defaults to 1048576KB (1 GB).
        public var maxFileSize: Swift.Int?
        /// The password for the user named in the username property.
        public var password: Swift.String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public var port: Swift.Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public var removeQuotes: Swift.Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public var replaceChars: Swift.String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public var replaceInvalidChars: Swift.String?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Amazon Redshift endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Amazon Redshift endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// The name of the Amazon Redshift cluster you are using.
        public var serverName: Swift.String?
        /// The KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string. If your date and time values use formats different from each other, set this parameter to auto.
        public var timeFormat: Swift.String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public var trimBlanks: Swift.Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public var truncateColumns: Swift.Bool?
        /// An Amazon Redshift user name for a registered user.
        public var username: Swift.String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk at the DMS replication instance. The default value is 1000 (buffer size is 1000KB).
        public var writeBufferSize: Swift.Int?

        public init(
            acceptAnyDate: Swift.Bool? = nil,
            afterConnectScript: Swift.String? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            caseSensitiveNames: Swift.Bool? = nil,
            compUpdate: Swift.Bool? = nil,
            connectionTimeout: Swift.Int? = nil,
            databaseName: Swift.String? = nil,
            dateFormat: Swift.String? = nil,
            emptyAsNull: Swift.Bool? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            explicitIds: Swift.Bool? = nil,
            fileTransferUploadStreams: Swift.Int? = nil,
            loadTimeout: Swift.Int? = nil,
            mapBooleanAsBoolean: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            removeQuotes: Swift.Bool? = nil,
            replaceChars: Swift.String? = nil,
            replaceInvalidChars: Swift.String? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timeFormat: Swift.String? = nil,
            trimBlanks: Swift.Bool? = nil,
            truncateColumns: Swift.Bool? = nil,
            username: Swift.String? = nil,
            writeBufferSize: Swift.Int? = nil
        )
        {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }
    }

}

extension RefreshSchemasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension RefreshSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct RefreshSchemasInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct RefreshSchemasInputBody: Swift.Equatable {
    let endpointArn: Swift.String?
    let replicationInstanceArn: Swift.String?
}

extension RefreshSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
    }
}

extension RefreshSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RefreshSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.refreshSchemasStatus = output.refreshSchemasStatus
        } else {
            self.refreshSchemasStatus = nil
        }
    }
}

///
public struct RefreshSchemasOutput: Swift.Equatable {
    /// The status of the refreshed schema.
    public var refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?

    public init(
        refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus? = nil
    )
    {
        self.refreshSchemasStatus = refreshSchemasStatus
    }
}

struct RefreshSchemasOutputBody: Swift.Equatable {
    let refreshSchemasStatus: DatabaseMigrationClientTypes.RefreshSchemasStatus?
}

extension RefreshSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshSchemasStatus = "RefreshSchemasStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshSchemasStatusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatus.self, forKey: .refreshSchemasStatus)
        refreshSchemasStatus = refreshSchemasStatusDecoded
    }
}

enum RefreshSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.RefreshSchemasStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case lastFailureMessage = "LastFailureMessage"
        case lastRefreshDate = "LastRefreshDate"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let lastRefreshDate = self.lastRefreshDate {
            try encodeContainer.encodeTimestamp(lastRefreshDate, format: .epochSeconds, forKey: .lastRefreshDate)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue.self, forKey: .status)
        status = statusDecoded
        let lastRefreshDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRefreshDate)
        lastRefreshDate = lastRefreshDateDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes status of a schema at an endpoint specified by the DescribeRefreshSchemaStatus operation.
    public struct RefreshSchemasStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public var endpointArn: Swift.String?
        /// The last failure message for the schema.
        public var lastFailureMessage: Swift.String?
        /// The date the schema was last refreshed.
        public var lastRefreshDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The status of the schema.
        public var status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue?

        public init(
            endpointArn: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastRefreshDate: ClientRuntime.Date? = nil,
            replicationInstanceArn: Swift.String? = nil,
            status: DatabaseMigrationClientTypes.RefreshSchemasStatusTypeValue? = nil
        )
        {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum RefreshSchemasStatusTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case refreshing
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [RefreshSchemasStatusTypeValue] {
            return [
                .failed,
                .refreshing,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .refreshing: return "refreshing"
            case .successful: return "successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RefreshSchemasStatusTypeValue(rawValue: rawValue) ?? RefreshSchemasStatusTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReleaseStatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beta
        case prod
        case sdkUnknown(Swift.String)

        public static var allCases: [ReleaseStatusValues] {
            return [
                .beta,
                .prod,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beta: return "beta"
            case .prod: return "prod"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReleaseStatusValues(rawValue: rawValue) ?? ReleaseStatusValues.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum ReloadOptionValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataReload
        case validateOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReloadOptionValue] {
            return [
                .dataReload,
                .validateOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataReload: return "data-reload"
            case .validateOnly: return "validate-only"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReloadOptionValue(rawValue: rawValue) ?? ReloadOptionValue.sdkUnknown(rawValue)
        }
    }
}

extension ReloadReplicationTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationConfigArn = "ReplicationConfigArn"
        case tablesToReload = "TablesToReload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reloadOption = self.reloadOption {
            try encodeContainer.encode(reloadOption.rawValue, forKey: .reloadOption)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
        if let tablesToReload = tablesToReload {
            var tablesToReloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToReload)
            for tabletoreload0 in tablesToReload {
                try tablesToReloadContainer.encode(tabletoreload0)
            }
        }
    }
}

extension ReloadReplicationTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ReloadReplicationTablesInput: Swift.Equatable {
    /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the replication.
    public var reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// The Amazon Resource Name of the replication config for which to reload tables.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The list of tables to reload.
    /// This member is required.
    public var tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init(
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationConfigArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationConfigArn = replicationConfigArn
        self.tablesToReload = tablesToReload
    }
}

struct ReloadReplicationTablesInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
    let tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?
    let reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
}

extension ReloadReplicationTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationConfigArn = "ReplicationConfigArn"
        case tablesToReload = "TablesToReload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let tablesToReloadContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableToReload?].self, forKey: .tablesToReload)
        var tablesToReloadDecoded0:[DatabaseMigrationClientTypes.TableToReload]? = nil
        if let tablesToReloadContainer = tablesToReloadContainer {
            tablesToReloadDecoded0 = [DatabaseMigrationClientTypes.TableToReload]()
            for structure0 in tablesToReloadContainer {
                if let structure0 = structure0 {
                    tablesToReloadDecoded0?.append(structure0)
                }
            }
        }
        tablesToReload = tablesToReloadDecoded0
        let reloadOptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReloadOptionValue.self, forKey: .reloadOption)
        reloadOption = reloadOptionDecoded
    }
}

extension ReloadReplicationTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReloadReplicationTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfigArn = output.replicationConfigArn
        } else {
            self.replicationConfigArn = nil
        }
    }
}

///
public struct ReloadReplicationTablesOutput: Swift.Equatable {
    /// The Amazon Resource Name of the replication config for which to reload tables.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

struct ReloadReplicationTablesOutputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
}

extension ReloadReplicationTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
    }
}

enum ReloadReplicationTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReloadTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reloadOption = self.reloadOption {
            try encodeContainer.encode(reloadOption.rawValue, forKey: .reloadOption)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let tablesToReload = tablesToReload {
            var tablesToReloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tablesToReload)
            for tabletoreload0 in tablesToReload {
                try tablesToReloadContainer.encode(tabletoreload0)
            }
        }
    }
}

extension ReloadTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ReloadTablesInput: Swift.Equatable {
    /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task. Valid values: data-reload, validate-only Default value is data-reload.
    public var reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The name and schema of the table to be reloaded.
    /// This member is required.
    public var tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?

    public init(
        reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue? = nil,
        replicationTaskArn: Swift.String? = nil,
        tablesToReload: [DatabaseMigrationClientTypes.TableToReload]? = nil
    )
    {
        self.reloadOption = reloadOption
        self.replicationTaskArn = replicationTaskArn
        self.tablesToReload = tablesToReload
    }
}

struct ReloadTablesInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let tablesToReload: [DatabaseMigrationClientTypes.TableToReload]?
    let reloadOption: DatabaseMigrationClientTypes.ReloadOptionValue?
}

extension ReloadTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reloadOption = "ReloadOption"
        case replicationTaskArn = "ReplicationTaskArn"
        case tablesToReload = "TablesToReload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let tablesToReloadContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.TableToReload?].self, forKey: .tablesToReload)
        var tablesToReloadDecoded0:[DatabaseMigrationClientTypes.TableToReload]? = nil
        if let tablesToReloadContainer = tablesToReloadContainer {
            tablesToReloadDecoded0 = [DatabaseMigrationClientTypes.TableToReload]()
            for structure0 in tablesToReloadContainer {
                if let structure0 = structure0 {
                    tablesToReloadDecoded0?.append(structure0)
                }
            }
        }
        tablesToReload = tablesToReloadDecoded0
        let reloadOptionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReloadOptionValue.self, forKey: .reloadOption)
        reloadOption = reloadOptionDecoded
    }
}

extension ReloadTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReloadTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskArn = output.replicationTaskArn
        } else {
            self.replicationTaskArn = nil
        }
    }
}

public struct ReloadTablesOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct ReloadTablesOutputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension ReloadTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

enum ReloadTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTagsFromResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for string0 in tagKeys {
                try tagKeysContainer.encode(string0)
            }
        }
    }
}

extension RemoveTagsFromResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Removes one or more tags from an DMS resource.
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// An DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

///
public struct RemoveTagsFromResourceOutput: Swift.Equatable {

    public init() { }
}

enum RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.Replication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case failureMessages = "FailureMessages"
        case provisionData = "ProvisionData"
        case recoveryCheckpoint = "RecoveryCheckpoint"
        case replicationConfigArn = "ReplicationConfigArn"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationCreateTime = "ReplicationCreateTime"
        case replicationLastStopTime = "ReplicationLastStopTime"
        case replicationStats = "ReplicationStats"
        case replicationType = "ReplicationType"
        case replicationUpdateTime = "ReplicationUpdateTime"
        case sourceEndpointArn = "SourceEndpointArn"
        case startReplicationType = "StartReplicationType"
        case status = "Status"
        case stopReason = "StopReason"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let failureMessages = failureMessages {
            var failureMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureMessages)
            for string0 in failureMessages {
                try failureMessagesContainer.encode(string0)
            }
        }
        if let provisionData = self.provisionData {
            try encodeContainer.encode(provisionData, forKey: .provisionData)
        }
        if let recoveryCheckpoint = self.recoveryCheckpoint {
            try encodeContainer.encode(recoveryCheckpoint, forKey: .recoveryCheckpoint)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
        if let replicationConfigIdentifier = self.replicationConfigIdentifier {
            try encodeContainer.encode(replicationConfigIdentifier, forKey: .replicationConfigIdentifier)
        }
        if let replicationCreateTime = self.replicationCreateTime {
            try encodeContainer.encodeTimestamp(replicationCreateTime, format: .epochSeconds, forKey: .replicationCreateTime)
        }
        if let replicationLastStopTime = self.replicationLastStopTime {
            try encodeContainer.encodeTimestamp(replicationLastStopTime, format: .epochSeconds, forKey: .replicationLastStopTime)
        }
        if let replicationStats = self.replicationStats {
            try encodeContainer.encode(replicationStats, forKey: .replicationStats)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let replicationUpdateTime = self.replicationUpdateTime {
            try encodeContainer.encodeTimestamp(replicationUpdateTime, format: .epochSeconds, forKey: .replicationUpdateTime)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let startReplicationType = self.startReplicationType {
            try encodeContainer.encode(startReplicationType, forKey: .startReplicationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let stopReason = self.stopReason {
            try encodeContainer.encode(stopReason, forKey: .stopReason)
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigIdentifier)
        replicationConfigIdentifier = replicationConfigIdentifierDecoded
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let provisionDataDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ProvisionData.self, forKey: .provisionData)
        provisionData = provisionDataDecoded
        let stopReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopReason)
        stopReason = stopReasonDecoded
        let failureMessagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureMessages)
        var failureMessagesDecoded0:[Swift.String]? = nil
        if let failureMessagesContainer = failureMessagesContainer {
            failureMessagesDecoded0 = [Swift.String]()
            for string0 in failureMessagesContainer {
                if let string0 = string0 {
                    failureMessagesDecoded0?.append(string0)
                }
            }
        }
        failureMessages = failureMessagesDecoded0
        let replicationStatsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationStats.self, forKey: .replicationStats)
        replicationStats = replicationStatsDecoded
        let startReplicationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startReplicationType)
        startReplicationType = startReplicationTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let recoveryCheckpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryCheckpoint)
        recoveryCheckpoint = recoveryCheckpointDecoded
        let replicationCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationCreateTime)
        replicationCreateTime = replicationCreateTimeDecoded
        let replicationUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationUpdateTime)
        replicationUpdateTime = replicationUpdateTimeDecoded
        let replicationLastStopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationLastStopTime)
        replicationLastStopTime = replicationLastStopTimeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a serverless replication created by the CreateReplication operation.
    public struct Replication: Swift.Equatable {
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public var cdcStartPosition: Swift.String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public var cdcStartTime: ClientRuntime.Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
        public var cdcStopPosition: Swift.String?
        /// Error and other information about why a serverless replication failed.
        public var failureMessages: [Swift.String]?
        /// Information about provisioning resources for an DMS serverless replication.
        public var provisionData: DatabaseMigrationClientTypes.ProvisionData?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public var recoveryCheckpoint: Swift.String?
        /// The Amazon Resource Name for the ReplicationConfig associated with the replication.
        public var replicationConfigArn: Swift.String?
        /// The identifier for the ReplicationConfig associated with the replication.
        public var replicationConfigIdentifier: Swift.String?
        /// The time the serverless replication was created.
        public var replicationCreateTime: ClientRuntime.Date?
        /// The timestamp when replication was last stopped.
        public var replicationLastStopTime: ClientRuntime.Date?
        /// This object provides a collection of statistics about a serverless replication.
        public var replicationStats: DatabaseMigrationClientTypes.ReplicationStats?
        /// The type of the serverless replication.
        public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// The time the serverless replication was updated.
        public var replicationUpdateTime: ClientRuntime.Date?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data source.
        public var sourceEndpointArn: Swift.String?
        /// The replication type.
        public var startReplicationType: Swift.String?
        /// The current status of the serverless replication.
        public var status: Swift.String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:
        ///
        /// * "Stop Reason NORMAL"
        ///
        /// * "Stop Reason RECOVERABLE_ERROR"
        ///
        /// * "Stop Reason FATAL_ERROR"
        ///
        /// * "Stop Reason FULL_LOAD_ONLY_FINISHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_FULL_LOAD" â€“ Full load completed, with cached changes not applied
        ///
        /// * "Stop Reason STOPPED_AFTER_CACHED_EVENTS" â€“ Full load completed, with cached changes applied
        ///
        /// * "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_DDL_APPLY" â€“ User-defined stop task after DDL applied
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_DISK"
        ///
        /// * "Stop Reason STOPPED_AT_SERVER_TIME" â€“ User-defined server time for stopping task
        ///
        /// * "Stop Reason STOPPED_AT_COMMIT_TIME" â€“ User-defined commit time for stopping task
        ///
        /// * "Stop Reason RECONFIGURATION_RESTART"
        ///
        /// * "Stop Reason RECYCLE_TASK"
        public var stopReason: Swift.String?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data target.
        public var targetEndpointArn: Swift.String?

        public init(
            cdcStartPosition: Swift.String? = nil,
            cdcStartTime: ClientRuntime.Date? = nil,
            cdcStopPosition: Swift.String? = nil,
            failureMessages: [Swift.String]? = nil,
            provisionData: DatabaseMigrationClientTypes.ProvisionData? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationConfigArn: Swift.String? = nil,
            replicationConfigIdentifier: Swift.String? = nil,
            replicationCreateTime: ClientRuntime.Date? = nil,
            replicationLastStopTime: ClientRuntime.Date? = nil,
            replicationStats: DatabaseMigrationClientTypes.ReplicationStats? = nil,
            replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            replicationUpdateTime: ClientRuntime.Date? = nil,
            sourceEndpointArn: Swift.String? = nil,
            startReplicationType: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.failureMessages = failureMessages
            self.provisionData = provisionData
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationCreateTime = replicationCreateTime
            self.replicationLastStopTime = replicationLastStopTime
            self.replicationStats = replicationStats
            self.replicationType = replicationType
            self.replicationUpdateTime = replicationUpdateTime
            self.sourceEndpointArn = sourceEndpointArn
            self.startReplicationType = startReplicationType
            self.status = status
            self.stopReason = stopReason
            self.targetEndpointArn = targetEndpointArn
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeConfig = "ComputeConfig"
        case replicationConfigArn = "ReplicationConfigArn"
        case replicationConfigCreateTime = "ReplicationConfigCreateTime"
        case replicationConfigIdentifier = "ReplicationConfigIdentifier"
        case replicationConfigUpdateTime = "ReplicationConfigUpdateTime"
        case replicationSettings = "ReplicationSettings"
        case replicationType = "ReplicationType"
        case sourceEndpointArn = "SourceEndpointArn"
        case supplementalSettings = "SupplementalSettings"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeConfig = self.computeConfig {
            try encodeContainer.encode(computeConfig, forKey: .computeConfig)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
        if let replicationConfigCreateTime = self.replicationConfigCreateTime {
            try encodeContainer.encodeTimestamp(replicationConfigCreateTime, format: .epochSeconds, forKey: .replicationConfigCreateTime)
        }
        if let replicationConfigIdentifier = self.replicationConfigIdentifier {
            try encodeContainer.encode(replicationConfigIdentifier, forKey: .replicationConfigIdentifier)
        }
        if let replicationConfigUpdateTime = self.replicationConfigUpdateTime {
            try encodeContainer.encodeTimestamp(replicationConfigUpdateTime, format: .epochSeconds, forKey: .replicationConfigUpdateTime)
        }
        if let replicationSettings = self.replicationSettings {
            try encodeContainer.encode(replicationSettings, forKey: .replicationSettings)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let supplementalSettings = self.supplementalSettings {
            try encodeContainer.encode(supplementalSettings, forKey: .supplementalSettings)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigIdentifier)
        replicationConfigIdentifier = replicationConfigIdentifierDecoded
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let computeConfigDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ComputeConfig.self, forKey: .computeConfig)
        computeConfig = computeConfigDecoded
        let replicationSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSettings)
        replicationSettings = replicationSettingsDecoded
        let supplementalSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supplementalSettings)
        supplementalSettings = supplementalSettingsDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationConfigCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationConfigCreateTime)
        replicationConfigCreateTime = replicationConfigCreateTimeDecoded
        let replicationConfigUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationConfigUpdateTime)
        replicationConfigUpdateTime = replicationConfigUpdateTimeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// This object provides configuration information about a serverless replication.
    public struct ReplicationConfig: Swift.Equatable {
        /// Configuration parameters for provisioning an DMS serverless replication.
        public var computeConfig: DatabaseMigrationClientTypes.ComputeConfig?
        /// The Amazon Resource Name (ARN) of this DMS Serverless replication configuration.
        public var replicationConfigArn: Swift.String?
        /// The time the serverless replication config was created.
        public var replicationConfigCreateTime: ClientRuntime.Date?
        /// The identifier for the ReplicationConfig associated with the replication.
        public var replicationConfigIdentifier: Swift.String?
        /// The time the serverless replication config was updated.
        public var replicationConfigUpdateTime: ClientRuntime.Date?
        /// Configuration parameters for an DMS serverless replication.
        public var replicationSettings: Swift.String?
        /// The type of the replication.
        public var replicationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
        public var sourceEndpointArn: Swift.String?
        /// Additional parameters for an DMS serverless replication.
        public var supplementalSettings: Swift.String?
        /// Table mappings specified in the replication.
        public var tableMappings: Swift.String?
        /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
        public var targetEndpointArn: Swift.String?

        public init(
            computeConfig: DatabaseMigrationClientTypes.ComputeConfig? = nil,
            replicationConfigArn: Swift.String? = nil,
            replicationConfigCreateTime: ClientRuntime.Date? = nil,
            replicationConfigIdentifier: Swift.String? = nil,
            replicationConfigUpdateTime: ClientRuntime.Date? = nil,
            replicationSettings: Swift.String? = nil,
            replicationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            sourceEndpointArn: Swift.String? = nil,
            supplementalSettings: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil
        )
        {
            self.computeConfig = computeConfig
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigCreateTime = replicationConfigCreateTime
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationConfigUpdateTime = replicationConfigUpdateTime
            self.replicationSettings = replicationSettings
            self.replicationType = replicationType
            self.sourceEndpointArn = sourceEndpointArn
            self.supplementalSettings = supplementalSettings
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum ReplicationEndpointTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationEndpointTypeValue] {
            return [
                .source,
                .target,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .source: return "source"
            case .target: return "target"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationEndpointTypeValue(rawValue: rawValue) ?? ReplicationEndpointTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.ReplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case dnsNameServers = "DnsNameServers"
        case engineVersion = "EngineVersion"
        case freeUntil = "FreeUntil"
        case instanceCreateTime = "InstanceCreateTime"
        case kmsKeyId = "KmsKeyId"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationInstanceClass = "ReplicationInstanceClass"
        case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
        case replicationInstanceIpv6Addresses = "ReplicationInstanceIpv6Addresses"
        case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
        case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
        case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
        case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
        case replicationInstanceStatus = "ReplicationInstanceStatus"
        case replicationSubnetGroup = "ReplicationSubnetGroup"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dnsNameServers = self.dnsNameServers {
            try encodeContainer.encode(dnsNameServers, forKey: .dnsNameServers)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let freeUntil = self.freeUntil {
            try encodeContainer.encodeTimestamp(freeUntil, format: .epochSeconds, forKey: .freeUntil)
        }
        if let instanceCreateTime = self.instanceCreateTime {
            try encodeContainer.encodeTimestamp(instanceCreateTime, format: .epochSeconds, forKey: .instanceCreateTime)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let pendingModifiedValues = self.pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
        if let replicationInstanceIdentifier = self.replicationInstanceIdentifier {
            try encodeContainer.encode(replicationInstanceIdentifier, forKey: .replicationInstanceIdentifier)
        }
        if let replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses {
            var replicationInstanceIpv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstanceIpv6Addresses)
            for string0 in replicationInstanceIpv6Addresses {
                try replicationInstanceIpv6AddressesContainer.encode(string0)
            }
        }
        if let replicationInstancePrivateIpAddress = self.replicationInstancePrivateIpAddress {
            try encodeContainer.encode(replicationInstancePrivateIpAddress, forKey: .replicationInstancePrivateIpAddress)
        }
        if let replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses {
            var replicationInstancePrivateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePrivateIpAddresses)
            for string0 in replicationInstancePrivateIpAddresses {
                try replicationInstancePrivateIpAddressesContainer.encode(string0)
            }
        }
        if let replicationInstancePublicIpAddress = self.replicationInstancePublicIpAddress {
            try encodeContainer.encode(replicationInstancePublicIpAddress, forKey: .replicationInstancePublicIpAddress)
        }
        if let replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses {
            var replicationInstancePublicIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationInstancePublicIpAddresses)
            for string0 in replicationInstancePublicIpAddresses {
                try replicationInstancePublicIpAddressesContainer.encode(string0)
            }
        }
        if let replicationInstanceStatus = self.replicationInstanceStatus {
            try encodeContainer.encode(replicationInstanceStatus, forKey: .replicationInstanceStatus)
        }
        if let replicationSubnetGroup = self.replicationSubnetGroup {
            try encodeContainer.encode(replicationSubnetGroup, forKey: .replicationSubnetGroup)
        }
        if let secondaryAvailabilityZone = self.secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for vpcsecuritygroupmembership0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceIdentifier)
        replicationInstanceIdentifier = replicationInstanceIdentifierDecoded
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let replicationInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceStatus)
        replicationInstanceStatus = replicationInstanceStatusDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.VpcSecurityGroupMembership?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let replicationSubnetGroupDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationSubnetGroup.self, forKey: .replicationSubnetGroup)
        replicationSubnetGroup = replicationSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ) ?? false
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade) ?? false
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let replicationInstancePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePublicIpAddress)
        replicationInstancePublicIpAddress = replicationInstancePublicIpAddressDecoded
        let replicationInstancePrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstancePrivateIpAddress)
        replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddressDecoded
        let replicationInstancePublicIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePublicIpAddresses)
        var replicationInstancePublicIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePublicIpAddressesContainer = replicationInstancePublicIpAddressesContainer {
            replicationInstancePublicIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePublicIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePublicIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePublicIpAddresses = replicationInstancePublicIpAddressesDecoded0
        let replicationInstancePrivateIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstancePrivateIpAddresses)
        var replicationInstancePrivateIpAddressesDecoded0:[Swift.String]? = nil
        if let replicationInstancePrivateIpAddressesContainer = replicationInstancePrivateIpAddressesContainer {
            replicationInstancePrivateIpAddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstancePrivateIpAddressesContainer {
                if let string0 = string0 {
                    replicationInstancePrivateIpAddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddressesDecoded0
        let replicationInstanceIpv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationInstanceIpv6Addresses)
        var replicationInstanceIpv6AddressesDecoded0:[Swift.String]? = nil
        if let replicationInstanceIpv6AddressesContainer = replicationInstanceIpv6AddressesContainer {
            replicationInstanceIpv6AddressesDecoded0 = [Swift.String]()
            for string0 in replicationInstanceIpv6AddressesContainer {
                if let string0 = string0 {
                    replicationInstanceIpv6AddressesDecoded0?.append(string0)
                }
            }
        }
        replicationInstanceIpv6Addresses = replicationInstanceIpv6AddressesDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let freeUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freeUntil)
        freeUntil = freeUntilDecoded
        let dnsNameServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsNameServers)
        dnsNameServers = dnsNameServersDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a replication instance.
    public struct ReplicationInstance: Swift.Equatable {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The Availability Zone for the instance.
        public var availabilityZone: Swift.String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public var dnsNameServers: Swift.String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public var engineVersion: Swift.String?
        /// The expiration date of the free replication instance that is part of the Free DMS program.
        public var freeUntil: ClientRuntime.Date?
        /// The time the replication instance was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The pending modification values.
        public var pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool
        /// The Amazon Resource Name (ARN) of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:
        ///
        /// * Must contain 1-63 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        ///
        ///
        /// Example: myrepinstance
        public var replicationInstanceIdentifier: Swift.String?
        /// One or more IPv6 addresses for the replication instance.
        public var replicationInstanceIpv6Addresses: [Swift.String]?
        /// The private IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePrivateIpAddress: Swift.String?
        /// One or more private IP addresses for the replication instance.
        public var replicationInstancePrivateIpAddresses: [Swift.String]?
        /// The public IP address of the replication instance.
        @available(*, deprecated)
        public var replicationInstancePublicIpAddress: Swift.String?
        /// One or more public IP addresses for the replication instance.
        public var replicationInstancePublicIpAddresses: [Swift.String]?
        /// The status of the replication instance. The possible return values include:
        ///
        /// * "available"
        ///
        /// * "creating"
        ///
        /// * "deleted"
        ///
        /// * "deleting"
        ///
        /// * "failed"
        ///
        /// * "modifying"
        ///
        /// * "upgrading"
        ///
        /// * "rebooting"
        ///
        /// * "resetting-master-credentials"
        ///
        /// * "storage-full"
        ///
        /// * "incompatible-credentials"
        ///
        /// * "incompatible-network"
        ///
        /// * "maintenance"
        public var replicationInstanceStatus: Swift.String?
        /// The subnet group for the replication instance.
        public var replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public var secondaryAvailabilityZone: Swift.String?
        /// The VPC security group for the instance.
        public var vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]?

        public init(
            allocatedStorage: Swift.Int = 0,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            dnsNameServers: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            freeUntil: ClientRuntime.Date? = nil,
            instanceCreateTime: ClientRuntime.Date? = nil,
            kmsKeyId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            networkType: Swift.String? = nil,
            pendingModifiedValues: DatabaseMigrationClientTypes.ReplicationPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            replicationInstanceArn: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            replicationInstanceIpv6Addresses: [Swift.String]? = nil,
            replicationInstancePrivateIpAddress: Swift.String? = nil,
            replicationInstancePrivateIpAddresses: [Swift.String]? = nil,
            replicationInstancePublicIpAddress: Swift.String? = nil,
            replicationInstancePublicIpAddresses: [Swift.String]? = nil,
            replicationInstanceStatus: Swift.String? = nil,
            replicationSubnetGroup: DatabaseMigrationClientTypes.ReplicationSubnetGroup? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            vpcSecurityGroups: [DatabaseMigrationClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationInstanceTaskLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskName = "ReplicationTaskName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if replicationInstanceTaskLogSize != 0 {
            try encodeContainer.encode(replicationInstanceTaskLogSize, forKey: .replicationInstanceTaskLogSize)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskName = self.replicationTaskName {
            try encodeContainer.encode(replicationTaskName, forKey: .replicationTaskName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskName)
        replicationTaskName = replicationTaskNameDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationInstanceTaskLogSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicationInstanceTaskLogSize) ?? 0
        replicationInstanceTaskLogSize = replicationInstanceTaskLogSizeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Contains metadata for a replication instance task log.
    public struct ReplicationInstanceTaskLog: Swift.Equatable {
        /// The size, in bytes, of the replication task log.
        public var replicationInstanceTaskLogSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The name of the replication task.
        public var replicationTaskName: Swift.String?

        public init(
            replicationInstanceTaskLogSize: Swift.Int = 0,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskName: Swift.String? = nil
        )
        {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationPendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case engineVersion = "EngineVersion"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case replicationInstanceClass = "ReplicationInstanceClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedStorage = self.allocatedStorage {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let multiAZ = self.multiAZ {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let networkType = self.networkType {
            try encodeContainer.encode(networkType, forKey: .networkType)
        }
        if let replicationInstanceClass = self.replicationInstanceClass {
            try encodeContainer.encode(replicationInstanceClass, forKey: .replicationInstanceClass)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceClass)
        replicationInstanceClass = replicationInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the values of pending modifications to a replication instance. This data type is an object of the [ReplicationInstance](https://docs.aws.amazon.com/dms/latest/APIReference/API_ReplicationInstance.html) user-defined data type.
    public struct ReplicationPendingModifiedValues: Swift.Equatable {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int?
        /// The engine version number of the replication instance.
        public var engineVersion: Swift.String?
        /// Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var networkType: Swift.String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see [ Selecting the right DMS replication instance for your migration](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth).
        public var replicationInstanceClass: Swift.String?

        public init(
            allocatedStorage: Swift.Int? = nil,
            engineVersion: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            networkType: Swift.String? = nil,
            replicationInstanceClass: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.replicationInstanceClass = replicationInstanceClass
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeMillis = "ElapsedTimeMillis"
        case freshStartDate = "FreshStartDate"
        case fullLoadFinishDate = "FullLoadFinishDate"
        case fullLoadProgressPercent = "FullLoadProgressPercent"
        case fullLoadStartDate = "FullLoadStartDate"
        case startDate = "StartDate"
        case stopDate = "StopDate"
        case tablesErrored = "TablesErrored"
        case tablesLoaded = "TablesLoaded"
        case tablesLoading = "TablesLoading"
        case tablesQueued = "TablesQueued"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if elapsedTimeMillis != 0 {
            try encodeContainer.encode(elapsedTimeMillis, forKey: .elapsedTimeMillis)
        }
        if let freshStartDate = self.freshStartDate {
            try encodeContainer.encodeTimestamp(freshStartDate, format: .epochSeconds, forKey: .freshStartDate)
        }
        if let fullLoadFinishDate = self.fullLoadFinishDate {
            try encodeContainer.encodeTimestamp(fullLoadFinishDate, format: .epochSeconds, forKey: .fullLoadFinishDate)
        }
        if fullLoadProgressPercent != 0 {
            try encodeContainer.encode(fullLoadProgressPercent, forKey: .fullLoadProgressPercent)
        }
        if let fullLoadStartDate = self.fullLoadStartDate {
            try encodeContainer.encodeTimestamp(fullLoadStartDate, format: .epochSeconds, forKey: .fullLoadStartDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let stopDate = self.stopDate {
            try encodeContainer.encodeTimestamp(stopDate, format: .epochSeconds, forKey: .stopDate)
        }
        if tablesErrored != 0 {
            try encodeContainer.encode(tablesErrored, forKey: .tablesErrored)
        }
        if tablesLoaded != 0 {
            try encodeContainer.encode(tablesLoaded, forKey: .tablesLoaded)
        }
        if tablesLoading != 0 {
            try encodeContainer.encode(tablesLoading, forKey: .tablesLoading)
        }
        if tablesQueued != 0 {
            try encodeContainer.encode(tablesQueued, forKey: .tablesQueued)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullLoadProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadProgressPercent) ?? 0
        fullLoadProgressPercent = fullLoadProgressPercentDecoded
        let elapsedTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeMillis) ?? 0
        elapsedTimeMillis = elapsedTimeMillisDecoded
        let tablesLoadedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoaded) ?? 0
        tablesLoaded = tablesLoadedDecoded
        let tablesLoadingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoading) ?? 0
        tablesLoading = tablesLoadingDecoded
        let tablesQueuedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesQueued) ?? 0
        tablesQueued = tablesQueuedDecoded
        let tablesErroredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesErrored) ?? 0
        tablesErrored = tablesErroredDecoded
        let freshStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freshStartDate)
        freshStartDate = freshStartDateDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopDate)
        stopDate = stopDateDecoded
        let fullLoadStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadStartDate)
        fullLoadStartDate = fullLoadStartDateDecoded
        let fullLoadFinishDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadFinishDate)
        fullLoadFinishDate = fullLoadFinishDateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// This object provides a collection of statistics about a serverless replication.
    public struct ReplicationStats: Swift.Equatable {
        /// The elapsed time of the replication, in milliseconds.
        public var elapsedTimeMillis: Swift.Int
        /// The date the replication was started either with a fresh start or a target reload.
        public var freshStartDate: ClientRuntime.Date?
        /// The date the replication full load was finished.
        public var fullLoadFinishDate: ClientRuntime.Date?
        /// The percent complete for the full load serverless replication.
        public var fullLoadProgressPercent: Swift.Int
        /// The date the replication full load was started.
        public var fullLoadStartDate: ClientRuntime.Date?
        /// The date the replication is scheduled to start.
        public var startDate: ClientRuntime.Date?
        /// The date the replication was stopped.
        public var stopDate: ClientRuntime.Date?
        /// The number of errors that have occured for this replication.
        public var tablesErrored: Swift.Int
        /// The number of tables loaded for this replication.
        public var tablesLoaded: Swift.Int
        /// The number of tables currently loading for this replication.
        public var tablesLoading: Swift.Int
        /// The number of tables queued for this replication.
        public var tablesQueued: Swift.Int

        public init(
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: ClientRuntime.Date? = nil,
            fullLoadFinishDate: ClientRuntime.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil,
            stopDate: ClientRuntime.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationSubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
        case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case supportedNetworkTypes = "SupportedNetworkTypes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationSubnetGroupDescription = self.replicationSubnetGroupDescription {
            try encodeContainer.encode(replicationSubnetGroupDescription, forKey: .replicationSubnetGroupDescription)
        }
        if let replicationSubnetGroupIdentifier = self.replicationSubnetGroupIdentifier {
            try encodeContainer.encode(replicationSubnetGroupIdentifier, forKey: .replicationSubnetGroupIdentifier)
        }
        if let subnetGroupStatus = self.subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnet0 in subnets {
                try subnetsContainer.encode(subnet0)
            }
        }
        if let supportedNetworkTypes = supportedNetworkTypes {
            var supportedNetworkTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedNetworkTypes)
            for string0 in supportedNetworkTypes {
                try supportedNetworkTypesContainer.encode(string0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSubnetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupIdentifier)
        replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifierDecoded
        let replicationSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSubnetGroupDescription)
        replicationSubnetGroupDescription = replicationSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[DatabaseMigrationClientTypes.Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [DatabaseMigrationClientTypes.Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
        let supportedNetworkTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedNetworkTypes)
        var supportedNetworkTypesDecoded0:[Swift.String]? = nil
        if let supportedNetworkTypesContainer = supportedNetworkTypesContainer {
            supportedNetworkTypesDecoded0 = [Swift.String]()
            for string0 in supportedNetworkTypesContainer {
                if let string0 = string0 {
                    supportedNetworkTypesDecoded0?.append(string0)
                }
            }
        }
        supportedNetworkTypes = supportedNetworkTypesDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a subnet group in response to a request by the DescribeReplicationSubnetGroups operation.
    public struct ReplicationSubnetGroup: Swift.Equatable {
        /// A description for the replication subnet group.
        public var replicationSubnetGroupDescription: Swift.String?
        /// The identifier of the replication instance subnet group.
        public var replicationSubnetGroupIdentifier: Swift.String?
        /// The status of the subnet group.
        public var subnetGroupStatus: Swift.String?
        /// The subnets that are in the subnet group.
        public var subnets: [DatabaseMigrationClientTypes.Subnet]?
        /// The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public var supportedNetworkTypes: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            replicationSubnetGroupDescription: Swift.String? = nil,
            replicationSubnetGroupIdentifier: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [DatabaseMigrationClientTypes.Subnet]? = nil,
            supportedNetworkTypes: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.supportedNetworkTypes = supportedNetworkTypes
            self.vpcId = vpcId
        }
    }

}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZs {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicationSubnetGroupDoesNotCoverEnoughAZsBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.
public struct ReplicationSubnetGroupDoesNotCoverEnoughAZs: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationSubnetGroupDoesNotCoverEnoughAZs" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplicationSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ReplicationTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStopPosition = "CdcStopPosition"
        case lastFailureMessage = "LastFailureMessage"
        case migrationType = "MigrationType"
        case recoveryCheckpoint = "RecoveryCheckpoint"
        case replicationInstanceArn = "ReplicationInstanceArn"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskCreationDate = "ReplicationTaskCreationDate"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskSettings = "ReplicationTaskSettings"
        case replicationTaskStartDate = "ReplicationTaskStartDate"
        case replicationTaskStats = "ReplicationTaskStats"
        case sourceEndpointArn = "SourceEndpointArn"
        case status = "Status"
        case stopReason = "StopReason"
        case tableMappings = "TableMappings"
        case targetEndpointArn = "TargetEndpointArn"
        case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        case taskData = "TaskData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let migrationType = self.migrationType {
            try encodeContainer.encode(migrationType.rawValue, forKey: .migrationType)
        }
        if let recoveryCheckpoint = self.recoveryCheckpoint {
            try encodeContainer.encode(recoveryCheckpoint, forKey: .recoveryCheckpoint)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskCreationDate = self.replicationTaskCreationDate {
            try encodeContainer.encodeTimestamp(replicationTaskCreationDate, format: .epochSeconds, forKey: .replicationTaskCreationDate)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskSettings = self.replicationTaskSettings {
            try encodeContainer.encode(replicationTaskSettings, forKey: .replicationTaskSettings)
        }
        if let replicationTaskStartDate = self.replicationTaskStartDate {
            try encodeContainer.encodeTimestamp(replicationTaskStartDate, format: .epochSeconds, forKey: .replicationTaskStartDate)
        }
        if let replicationTaskStats = self.replicationTaskStats {
            try encodeContainer.encode(replicationTaskStats, forKey: .replicationTaskStats)
        }
        if let sourceEndpointArn = self.sourceEndpointArn {
            try encodeContainer.encode(sourceEndpointArn, forKey: .sourceEndpointArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let stopReason = self.stopReason {
            try encodeContainer.encode(stopReason, forKey: .stopReason)
        }
        if let tableMappings = self.tableMappings {
            try encodeContainer.encode(tableMappings, forKey: .tableMappings)
        }
        if let targetEndpointArn = self.targetEndpointArn {
            try encodeContainer.encode(targetEndpointArn, forKey: .targetEndpointArn)
        }
        if let targetReplicationInstanceArn = self.targetReplicationInstanceArn {
            try encodeContainer.encode(targetReplicationInstanceArn, forKey: .targetReplicationInstanceArn)
        }
        if let taskData = self.taskData {
            try encodeContainer.encode(taskData, forKey: .taskData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let sourceEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEndpointArn)
        sourceEndpointArn = sourceEndpointArnDecoded
        let targetEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEndpointArn)
        targetEndpointArn = targetEndpointArnDecoded
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let migrationTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MigrationTypeValue.self, forKey: .migrationType)
        migrationType = migrationTypeDecoded
        let tableMappingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableMappings)
        tableMappings = tableMappingsDecoded
        let replicationTaskSettingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskSettings)
        replicationTaskSettings = replicationTaskSettingsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let stopReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stopReason)
        stopReason = stopReasonDecoded
        let replicationTaskCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskCreationDate)
        replicationTaskCreationDate = replicationTaskCreationDateDecoded
        let replicationTaskStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskStartDate)
        replicationTaskStartDate = replicationTaskStartDateDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
        let recoveryCheckpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryCheckpoint)
        recoveryCheckpoint = recoveryCheckpointDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskStatsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskStats.self, forKey: .replicationTaskStats)
        replicationTaskStats = replicationTaskStatsDecoded
        let taskDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskData)
        taskData = taskDataDecoded
        let targetReplicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetReplicationInstanceArn)
        targetReplicationInstanceArn = targetReplicationInstanceArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a replication task created by the CreateReplicationTask operation.
    public struct ReplicationTask: Swift.Equatable {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€ Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€
        public var cdcStartPosition: Swift.String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€ Commit time example: --cdc-stop-position â€œcommit_time:2018-02-09T12:12:12â€œ
        public var cdcStopPosition: Swift.String?
        /// The last error (failure) message generated for the replication task.
        public var lastFailureMessage: Swift.String?
        /// The type of migration.
        public var migrationType: DatabaseMigrationClientTypes.MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public var recoveryCheckpoint: Swift.String?
        /// The ARN of the replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The date the replication task was created.
        public var replicationTaskCreationDate: ClientRuntime.Date?
        /// The user-assigned replication task identifier or name. Constraints:
        ///
        /// * Must contain 1-255 alphanumeric characters or hyphens.
        ///
        /// * First character must be a letter.
        ///
        /// * Cannot end with a hyphen or contain two consecutive hyphens.
        public var replicationTaskIdentifier: Swift.String?
        /// The settings for the replication task.
        public var replicationTaskSettings: Swift.String?
        /// The date the replication task is scheduled to start.
        public var replicationTaskStartDate: ClientRuntime.Date?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public var replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) that uniquely identifies the endpoint.
        public var sourceEndpointArn: Swift.String?
        /// The status of the replication task. This response parameter can return one of the following values:
        ///
        /// * "moving" â€“ The task is being moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "creating" â€“ The task is being created in response to running the [CreateReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_CreateReplicationTask.html) operation.
        ///
        /// * "deleting" â€“ The task is being deleted in response to running the [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html) operation.
        ///
        /// * "failed" â€“ The task failed to successfully complete the database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "failed-move" â€“ The task failed to move in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation.
        ///
        /// * "modifying" â€“ The task definition is being modified in response to running the [ModifyReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_ModifyReplicationTask.html) operation.
        ///
        /// * "ready" â€“ The task is in a ready state where it can respond to other task operations, such as [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) or [DeleteReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_DeleteReplicationTask.html).
        ///
        /// * "running" â€“ The task is performing a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "starting" â€“ The task is preparing to perform a database migration in response to running the [StartReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html) operation.
        ///
        /// * "stopped" â€“ The task has stopped in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "stopping" â€“ The task is preparing to stop in response to running the [StopReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_StopReplicationTask.html) operation.
        ///
        /// * "testing" â€“ The database migration specified for this task is being tested in response to running either the [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) or the [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation. [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) is an improved premigration task assessment operation. The [StartReplicationTaskAssessment](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessment.html) operation assesses data type compatibility only between the source and target database of a given migration task. In contrast, [StartReplicationTaskAssessmentRun](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTaskAssessmentRun.html) enables you to specify a variety of premigration task assessments in addition to data type compatibility. These assessments include ones for the validity of primary key definitions and likely issues with database migration performance, among others.
        public var status: Swift.String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:
        ///
        /// * "Stop Reason NORMAL"
        ///
        /// * "Stop Reason RECOVERABLE_ERROR"
        ///
        /// * "Stop Reason FATAL_ERROR"
        ///
        /// * "Stop Reason FULL_LOAD_ONLY_FINISHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_FULL_LOAD" â€“ Full load completed, with cached changes not applied
        ///
        /// * "Stop Reason STOPPED_AFTER_CACHED_EVENTS" â€“ Full load completed, with cached changes applied
        ///
        /// * "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"
        ///
        /// * "Stop Reason STOPPED_AFTER_DDL_APPLY" â€“ User-defined stop task after DDL applied
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"
        ///
        /// * "Stop Reason STOPPED_DUE_TO_LOW_DISK"
        ///
        /// * "Stop Reason STOPPED_AT_SERVER_TIME" â€“ User-defined server time for stopping task
        ///
        /// * "Stop Reason STOPPED_AT_COMMIT_TIME" â€“ User-defined commit time for stopping task
        ///
        /// * "Stop Reason RECONFIGURATION_RESTART"
        ///
        /// * "Stop Reason RECYCLE_TASK"
        public var stopReason: Swift.String?
        /// Table mappings specified in the task.
        public var tableMappings: Swift.String?
        /// The ARN that uniquely identifies the endpoint.
        public var targetEndpointArn: Swift.String?
        /// The ARN of the replication instance to which this task is moved in response to running the [MoveReplicationTask](https://docs.aws.amazon.com/dms/latest/APIReference/API_MoveReplicationTask.html) operation. Otherwise, this response parameter isn't a member of the ReplicationTask object.
        public var targetReplicationInstanceArn: Swift.String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see [Specifying Supplemental Data for Task Settings](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html) in the Database Migration Service User Guide.
        public var taskData: Swift.String?

        public init(
            cdcStartPosition: Swift.String? = nil,
            cdcStopPosition: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            migrationType: DatabaseMigrationClientTypes.MigrationTypeValue? = nil,
            recoveryCheckpoint: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskCreationDate: ClientRuntime.Date? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskSettings: Swift.String? = nil,
            replicationTaskStartDate: ClientRuntime.Date? = nil,
            replicationTaskStats: DatabaseMigrationClientTypes.ReplicationTaskStats? = nil,
            sourceEndpointArn: Swift.String? = nil,
            status: Swift.String? = nil,
            stopReason: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil,
            targetReplicationInstanceArn: Swift.String? = nil,
            taskData: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentResults = "AssessmentResults"
        case assessmentResultsFile = "AssessmentResultsFile"
        case assessmentStatus = "AssessmentStatus"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskIdentifier = "ReplicationTaskIdentifier"
        case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
        case s3ObjectUrl = "S3ObjectUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentResults = self.assessmentResults {
            try encodeContainer.encode(assessmentResults, forKey: .assessmentResults)
        }
        if let assessmentResultsFile = self.assessmentResultsFile {
            try encodeContainer.encode(assessmentResultsFile, forKey: .assessmentResultsFile)
        }
        if let assessmentStatus = self.assessmentStatus {
            try encodeContainer.encode(assessmentStatus, forKey: .assessmentStatus)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskIdentifier = self.replicationTaskIdentifier {
            try encodeContainer.encode(replicationTaskIdentifier, forKey: .replicationTaskIdentifier)
        }
        if let replicationTaskLastAssessmentDate = self.replicationTaskLastAssessmentDate {
            try encodeContainer.encodeTimestamp(replicationTaskLastAssessmentDate, format: .epochSeconds, forKey: .replicationTaskLastAssessmentDate)
        }
        if let s3ObjectUrl = self.s3ObjectUrl {
            try encodeContainer.encode(s3ObjectUrl, forKey: .s3ObjectUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIdentifier)
        replicationTaskIdentifier = replicationTaskIdentifierDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let replicationTaskLastAssessmentDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskLastAssessmentDate)
        replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDateDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let assessmentResultsFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResultsFile)
        assessmentResultsFile = assessmentResultsFileDecoded
        let assessmentResultsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentResults)
        assessmentResults = assessmentResultsDecoded
        let s3ObjectUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectUrl)
        s3ObjectUrl = s3ObjectUrlDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The task assessment report in JSON format.
    public struct ReplicationTaskAssessmentResult: Swift.Equatable {
        /// The task assessment results in JSON format. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var assessmentResults: Swift.String?
        /// The file containing the results of the task assessment.
        public var assessmentResultsFile: Swift.String?
        /// The status of the task assessment.
        public var assessmentStatus: Swift.String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public var replicationTaskArn: Swift.String?
        /// The replication task identifier of the task on which the task assessment was run.
        public var replicationTaskIdentifier: Swift.String?
        /// The date the task assessment was completed.
        public var replicationTaskLastAssessmentDate: ClientRuntime.Date?
        /// The URL of the S3 object containing the task assessment results. The response object only contains this field if you provide [DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn] in the request.
        public var s3ObjectUrl: Swift.String?

        public init(
            assessmentResults: Swift.String? = nil,
            assessmentResultsFile: Swift.String? = nil,
            assessmentStatus: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskLastAssessmentDate: ClientRuntime.Date? = nil,
            s3ObjectUrl: Swift.String? = nil
        )
        {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentProgress = "AssessmentProgress"
        case assessmentRunName = "AssessmentRunName"
        case lastFailureMessage = "LastFailureMessage"
        case replicationTaskArn = "ReplicationTaskArn"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentProgress = self.assessmentProgress {
            try encodeContainer.encode(assessmentProgress, forKey: .assessmentProgress)
        }
        if let assessmentRunName = self.assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskAssessmentRunCreationDate = self.replicationTaskAssessmentRunCreationDate {
            try encodeContainer.encodeTimestamp(replicationTaskAssessmentRunCreationDate, format: .epochSeconds, forKey: .replicationTaskAssessmentRunCreationDate)
        }
        if let resultEncryptionMode = self.resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = self.resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = self.resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = self.resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskAssessmentRunCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskAssessmentRunCreationDate)
        replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDateDecoded
        let assessmentProgressDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress.self, forKey: .assessmentProgress)
        assessmentProgress = assessmentProgressDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes a premigration assessment run that you have started using the StartReplicationTaskAssessmentRun operation. Some of the information appears based on other operations that can return the ReplicationTaskAssessmentRun object.
    public struct ReplicationTaskAssessmentRun: Swift.Equatable {
        /// Indication of the completion progress for the individual assessments specified to run.
        public var assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public var assessmentRunName: Swift.String?
        /// Last message generated by an individual assessment failure.
        public var lastFailureMessage: Swift.String?
        /// ARN of the migration task associated with this premigration assessment run.
        public var replicationTaskArn: Swift.String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskAssessmentRunCreationDate: ClientRuntime.Date?
        /// Encryption mode used to encrypt the assessment run results.
        public var resultEncryptionMode: Swift.String?
        /// ARN of the KMS encryption key used to encrypt the assessment run results.
        public var resultKmsKeyArn: Swift.String?
        /// Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationBucket: Swift.String?
        /// Folder in an Amazon S3 bucket where DMS stores the results of this assessment run.
        public var resultLocationFolder: Swift.String?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation. The role must allow the iam:PassRole action.
        public var serviceAccessRoleArn: Swift.String?
        /// Assessment run status. This status can have one of the following values:
        ///
        /// * "cancelling" â€“ The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.
        ///
        /// * "deleting" â€“ The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.
        ///
        /// * "failed" â€“ At least one individual assessment completed with a failed status.
        ///
        /// * "error-provisioning" â€“ An internal error occurred while resources were provisioned (during provisioning status).
        ///
        /// * "error-executing" â€“ An internal error occurred while individual assessments ran (during running status).
        ///
        /// * "invalid state" â€“ The assessment run is in an unknown state.
        ///
        /// * "passed" â€“ All individual assessments have completed, and none has a failed status.
        ///
        /// * "provisioning" â€“ Resources required to run individual assessments are being provisioned.
        ///
        /// * "running" â€“ Individual assessments are being run.
        ///
        /// * "starting" â€“ The assessment run is starting, but resources are not yet being provisioned for individual assessments.
        public var status: Swift.String?

        public init(
            assessmentProgress: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress? = nil,
            assessmentRunName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            replicationTaskArn: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskAssessmentRunCreationDate: ClientRuntime.Date? = nil,
            resultEncryptionMode: Swift.String? = nil,
            resultKmsKeyArn: Swift.String? = nil,
            resultLocationBucket: Swift.String? = nil,
            resultLocationFolder: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskAssessmentRunProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
        case individualAssessmentCount = "IndividualAssessmentCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if individualAssessmentCompletedCount != 0 {
            try encodeContainer.encode(individualAssessmentCompletedCount, forKey: .individualAssessmentCompletedCount)
        }
        if individualAssessmentCount != 0 {
            try encodeContainer.encode(individualAssessmentCount, forKey: .individualAssessmentCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let individualAssessmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .individualAssessmentCount) ?? 0
        individualAssessmentCount = individualAssessmentCountDecoded
        let individualAssessmentCompletedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .individualAssessmentCompletedCount) ?? 0
        individualAssessmentCompletedCount = individualAssessmentCompletedCountDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// The progress values reported by the AssessmentProgress response element.
    public struct ReplicationTaskAssessmentRunProgress: Swift.Equatable {
        /// The number of individual assessments that have completed, successfully or not.
        public var individualAssessmentCompletedCount: Swift.Int
        /// The number of individual assessments that are specified to run.
        public var individualAssessmentCount: Swift.Int

        public init(
            individualAssessmentCompletedCount: Swift.Int = 0,
            individualAssessmentCount: Swift.Int = 0
        )
        {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskIndividualAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case individualAssessmentName = "IndividualAssessmentName"
        case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
        case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let individualAssessmentName = self.individualAssessmentName {
            try encodeContainer.encode(individualAssessmentName, forKey: .individualAssessmentName)
        }
        if let replicationTaskAssessmentRunArn = self.replicationTaskAssessmentRunArn {
            try encodeContainer.encode(replicationTaskAssessmentRunArn, forKey: .replicationTaskAssessmentRunArn)
        }
        if let replicationTaskIndividualAssessmentArn = self.replicationTaskIndividualAssessmentArn {
            try encodeContainer.encode(replicationTaskIndividualAssessmentArn, forKey: .replicationTaskIndividualAssessmentArn)
        }
        if let replicationTaskIndividualAssessmentStartDate = self.replicationTaskIndividualAssessmentStartDate {
            try encodeContainer.encodeTimestamp(replicationTaskIndividualAssessmentStartDate, format: .epochSeconds, forKey: .replicationTaskIndividualAssessmentStartDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskIndividualAssessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskIndividualAssessmentArn)
        replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArnDecoded
        let replicationTaskAssessmentRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskAssessmentRunArn)
        replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArnDecoded
        let individualAssessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .individualAssessmentName)
        individualAssessmentName = individualAssessmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let replicationTaskIndividualAssessmentStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .replicationTaskIndividualAssessmentStartDate)
        replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that describes an individual assessment from a premigration assessment run.
    public struct ReplicationTaskIndividualAssessment: Swift.Equatable {
        /// Name of this individual assessment.
        public var individualAssessmentName: Swift.String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public var replicationTaskAssessmentRunArn: Swift.String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public var replicationTaskIndividualAssessmentArn: Swift.String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public var replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date?
        /// Individual assessment status. This status can have one of the following values:
        ///
        /// * "cancelled"
        ///
        /// * "error"
        ///
        /// * "failed"
        ///
        /// * "passed"
        ///
        /// * "pending"
        ///
        /// * "running"
        public var status: Swift.String?

        public init(
            individualAssessmentName: Swift.String? = nil,
            replicationTaskAssessmentRunArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentArn: Swift.String? = nil,
            replicationTaskIndividualAssessmentStartDate: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.ReplicationTaskStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elapsedTimeMillis = "ElapsedTimeMillis"
        case freshStartDate = "FreshStartDate"
        case fullLoadFinishDate = "FullLoadFinishDate"
        case fullLoadProgressPercent = "FullLoadProgressPercent"
        case fullLoadStartDate = "FullLoadStartDate"
        case startDate = "StartDate"
        case stopDate = "StopDate"
        case tablesErrored = "TablesErrored"
        case tablesLoaded = "TablesLoaded"
        case tablesLoading = "TablesLoading"
        case tablesQueued = "TablesQueued"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if elapsedTimeMillis != 0 {
            try encodeContainer.encode(elapsedTimeMillis, forKey: .elapsedTimeMillis)
        }
        if let freshStartDate = self.freshStartDate {
            try encodeContainer.encodeTimestamp(freshStartDate, format: .epochSeconds, forKey: .freshStartDate)
        }
        if let fullLoadFinishDate = self.fullLoadFinishDate {
            try encodeContainer.encodeTimestamp(fullLoadFinishDate, format: .epochSeconds, forKey: .fullLoadFinishDate)
        }
        if fullLoadProgressPercent != 0 {
            try encodeContainer.encode(fullLoadProgressPercent, forKey: .fullLoadProgressPercent)
        }
        if let fullLoadStartDate = self.fullLoadStartDate {
            try encodeContainer.encodeTimestamp(fullLoadStartDate, format: .epochSeconds, forKey: .fullLoadStartDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let stopDate = self.stopDate {
            try encodeContainer.encodeTimestamp(stopDate, format: .epochSeconds, forKey: .stopDate)
        }
        if tablesErrored != 0 {
            try encodeContainer.encode(tablesErrored, forKey: .tablesErrored)
        }
        if tablesLoaded != 0 {
            try encodeContainer.encode(tablesLoaded, forKey: .tablesLoaded)
        }
        if tablesLoading != 0 {
            try encodeContainer.encode(tablesLoading, forKey: .tablesLoading)
        }
        if tablesQueued != 0 {
            try encodeContainer.encode(tablesQueued, forKey: .tablesQueued)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullLoadProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadProgressPercent) ?? 0
        fullLoadProgressPercent = fullLoadProgressPercentDecoded
        let elapsedTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeMillis) ?? 0
        elapsedTimeMillis = elapsedTimeMillisDecoded
        let tablesLoadedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoaded) ?? 0
        tablesLoaded = tablesLoadedDecoded
        let tablesLoadingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesLoading) ?? 0
        tablesLoading = tablesLoadingDecoded
        let tablesQueuedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesQueued) ?? 0
        tablesQueued = tablesQueuedDecoded
        let tablesErroredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tablesErrored) ?? 0
        tablesErrored = tablesErroredDecoded
        let freshStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .freshStartDate)
        freshStartDate = freshStartDateDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let stopDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopDate)
        stopDate = stopDateDecoded
        let fullLoadStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadStartDate)
        fullLoadStartDate = fullLoadStartDateDecoded
        let fullLoadFinishDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadFinishDate)
        fullLoadFinishDate = fullLoadFinishDateDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationTasks operation, this object provides a collection of statistics about a replication task.
    public struct ReplicationTaskStats: Swift.Equatable {
        /// The elapsed time of the task, in milliseconds.
        public var elapsedTimeMillis: Swift.Int
        /// The date the replication task was started either with a fresh start or a target reload.
        public var freshStartDate: ClientRuntime.Date?
        /// The date the replication task full load was completed.
        public var fullLoadFinishDate: ClientRuntime.Date?
        /// The percent complete for the full load migration task.
        public var fullLoadProgressPercent: Swift.Int
        /// The date the replication task full load was started.
        public var fullLoadStartDate: ClientRuntime.Date?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see [StartReplicationTaskType](https://docs.aws.amazon.com/dms/latest/APIReference/API_StartReplicationTask.html#DMS-StartReplicationTask-request-StartReplicationTaskType).
        public var startDate: ClientRuntime.Date?
        /// The date the replication task was stopped.
        public var stopDate: ClientRuntime.Date?
        /// The number of errors that have occurred during this task.
        public var tablesErrored: Swift.Int
        /// The number of tables loaded for this task.
        public var tablesLoaded: Swift.Int
        /// The number of tables currently loading for this task.
        public var tablesLoading: Swift.Int
        /// The number of tables queued for this task.
        public var tablesQueued: Swift.Int

        public init(
            elapsedTimeMillis: Swift.Int = 0,
            freshStartDate: ClientRuntime.Date? = nil,
            fullLoadFinishDate: ClientRuntime.Date? = nil,
            fullLoadProgressPercent: Swift.Int = 0,
            fullLoadStartDate: ClientRuntime.Date? = nil,
            startDate: ClientRuntime.Date? = nil,
            stopDate: ClientRuntime.Date? = nil,
            tablesErrored: Swift.Int = 0,
            tablesLoaded: Swift.Int = 0,
            tablesLoading: Swift.Int = 0,
            tablesQueued: Swift.Int = 0
        )
        {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }
    }

}

extension ResourceAlreadyExistsFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceArn = output.resourceArn
        } else {
            self.properties.message = nil
            self.properties.resourceArn = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource you are attempting to create already exists.
public struct ResourceAlreadyExistsFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var resourceArn: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
    }
}

struct ResourceAlreadyExistsFaultBody: Swift.Equatable {
    let message: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.ResourcePendingMaintenanceActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingMaintenanceActionDetails)
            for pendingmaintenanceaction0 in pendingMaintenanceActionDetails {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0)
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let pendingMaintenanceActionDetailsContainer = try containerValues.decodeIfPresent([DatabaseMigrationClientTypes.PendingMaintenanceAction?].self, forKey: .pendingMaintenanceActionDetails)
        var pendingMaintenanceActionDetailsDecoded0:[DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil
        if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
            pendingMaintenanceActionDetailsDecoded0 = [DatabaseMigrationClientTypes.PendingMaintenanceAction]()
            for structure0 in pendingMaintenanceActionDetailsContainer {
                if let structure0 = structure0 {
                    pendingMaintenanceActionDetailsDecoded0?.append(structure0)
                }
            }
        }
        pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsDecoded0
    }
}

extension DatabaseMigrationClientTypes {
    /// Identifies an DMS resource and any pending actions for it.
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// Detailed information about the pending maintenance action.
        public var pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see [ Constructing an Amazon Resource Name (ARN) for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Introduction.AWS.ARN.html) in the DMS documentation.
        public var resourceIdentifier: Swift.String?

        public init(
            pendingMaintenanceActionDetails: [DatabaseMigrationClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension ResourceQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The quota for this resource quota has been exceeded.
public struct ResourceQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceQuotaExceededFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RunFleetAdvisorLsaAnalysisInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension RunFleetAdvisorLsaAnalysisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RunFleetAdvisorLsaAnalysisInput: Swift.Equatable {

    public init() { }
}

struct RunFleetAdvisorLsaAnalysisInputBody: Swift.Equatable {
}

extension RunFleetAdvisorLsaAnalysisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RunFleetAdvisorLsaAnalysisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RunFleetAdvisorLsaAnalysisOutputBody = try responseDecoder.decode(responseBody: data)
            self.lsaAnalysisId = output.lsaAnalysisId
            self.status = output.status
        } else {
            self.lsaAnalysisId = nil
            self.status = nil
        }
    }
}

public struct RunFleetAdvisorLsaAnalysisOutput: Swift.Equatable {
    /// The ID of the LSA analysis run.
    public var lsaAnalysisId: Swift.String?
    /// The status of the LSA analysis, for example COMPLETED.
    public var status: Swift.String?

    public init(
        lsaAnalysisId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.lsaAnalysisId = lsaAnalysisId
        self.status = status
    }
}

struct RunFleetAdvisorLsaAnalysisOutputBody: Swift.Equatable {
    let lsaAnalysisId: Swift.String?
    let status: Swift.String?
}

extension RunFleetAdvisorLsaAnalysisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lsaAnalysisId = "LsaAnalysisId"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lsaAnalysisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lsaAnalysisId)
        lsaAnalysisId = lsaAnalysisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum RunFleetAdvisorLsaAnalysisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension S3AccessDeniedFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: S3AccessDeniedFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Insufficient privileges are preventing access to an Amazon S3 object.
public struct S3AccessDeniedFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3AccessDeniedFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct S3AccessDeniedFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3AccessDeniedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3ResourceNotFoundFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: S3ResourceNotFoundFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified Amazon S3 bucket, bucket folder, or other object can't be found.
public struct S3ResourceNotFoundFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3ResourceNotFoundFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct S3ResourceNotFoundFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.S3Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumnName = "AddColumnName"
        case addTrailingPaddingCharacter = "AddTrailingPaddingCharacter"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cannedAclForObjects = "CannedAclForObjects"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcMaxBatchInterval = "CdcMaxBatchInterval"
        case cdcMinFileSize = "CdcMinFileSize"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvNullValue = "CsvNullValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case datePartitionTimezone = "DatePartitionTimezone"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case externalTableDefinition = "ExternalTableDefinition"
        case glueCatalogGeneration = "GlueCatalogGeneration"
        case ignoreHeaderRows = "IgnoreHeaderRows"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case maxFileSize = "MaxFileSize"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rfc4180 = "Rfc4180"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
        case useTaskStartTimeForFullLoadTimestamp = "UseTaskStartTimeForFullLoadTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addColumnName = self.addColumnName {
            try encodeContainer.encode(addColumnName, forKey: .addColumnName)
        }
        if let addTrailingPaddingCharacter = self.addTrailingPaddingCharacter {
            try encodeContainer.encode(addTrailingPaddingCharacter, forKey: .addTrailingPaddingCharacter)
        }
        if let bucketFolder = self.bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedAclForObjects = self.cannedAclForObjects {
            try encodeContainer.encode(cannedAclForObjects.rawValue, forKey: .cannedAclForObjects)
        }
        if let cdcInsertsAndUpdates = self.cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = self.cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcMaxBatchInterval = self.cdcMaxBatchInterval {
            try encodeContainer.encode(cdcMaxBatchInterval, forKey: .cdcMaxBatchInterval)
        }
        if let cdcMinFileSize = self.cdcMinFileSize {
            try encodeContainer.encode(cdcMinFileSize, forKey: .cdcMinFileSize)
        }
        if let cdcPath = self.cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = self.compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = self.csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = self.csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvNullValue = self.csvNullValue {
            try encodeContainer.encode(csvNullValue, forKey: .csvNullValue)
        }
        if let csvRowDelimiter = self.csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = self.dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = self.datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = self.datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = self.datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let datePartitionTimezone = self.datePartitionTimezone {
            try encodeContainer.encode(datePartitionTimezone, forKey: .datePartitionTimezone)
        }
        if let dictPageSizeLimit = self.dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = self.enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = self.encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let glueCatalogGeneration = self.glueCatalogGeneration {
            try encodeContainer.encode(glueCatalogGeneration, forKey: .glueCatalogGeneration)
        }
        if let ignoreHeaderRows = self.ignoreHeaderRows {
            try encodeContainer.encode(ignoreHeaderRows, forKey: .ignoreHeaderRows)
        }
        if let includeOpForFullLoad = self.includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parquetTimestampInMillisecond = self.parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = self.parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = self.preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rfc4180 = self.rfc4180 {
            try encodeContainer.encode(rfc4180, forKey: .rfc4180)
        }
        if let rowGroupLength = self.rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = self.serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = self.timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = self.useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
        if let useTaskStartTimeForFullLoadTimestamp = self.useTaskStartTimeForFullLoadTimestamp {
            try encodeContainer.encode(useTaskStartTimeForFullLoadTimestamp, forKey: .useTaskStartTimeForFullLoadTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
        let useTaskStartTimeForFullLoadTimestampDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useTaskStartTimeForFullLoadTimestamp)
        useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestampDecoded
        let cannedAclForObjectsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CannedAclForObjectsValue.self, forKey: .cannedAclForObjects)
        cannedAclForObjects = cannedAclForObjectsDecoded
        let addColumnNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addColumnName)
        addColumnName = addColumnNameDecoded
        let cdcMaxBatchIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMaxBatchInterval)
        cdcMaxBatchInterval = cdcMaxBatchIntervalDecoded
        let cdcMinFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMinFileSize)
        cdcMinFileSize = cdcMinFileSizeDecoded
        let csvNullValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNullValue)
        csvNullValue = csvNullValueDecoded
        let ignoreHeaderRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ignoreHeaderRows)
        ignoreHeaderRows = ignoreHeaderRowsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let rfc4180Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rfc4180)
        rfc4180 = rfc4180Decoded
        let datePartitionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datePartitionTimezone)
        datePartitionTimezone = datePartitionTimezoneDecoded
        let addTrailingPaddingCharacterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addTrailingPaddingCharacter)
        addTrailingPaddingCharacter = addTrailingPaddingCharacterDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let glueCatalogGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .glueCatalogGeneration)
        glueCatalogGeneration = glueCatalogGenerationDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Settings for exporting data to Amazon S3.
    public struct S3Settings: Swift.Equatable {
        /// An optional parameter that, when set to true or y, you can use to add column name information to the .csv output file. The default value is false. Valid values are true, false, y, and n.
        public var addColumnName: Swift.Bool?
        /// Use the S3 target endpoint setting AddTrailingPaddingCharacter to add padding on string data. The default value is false.
        public var addTrailingPaddingCharacter: Swift.Bool?
        /// An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/.
        public var bucketFolder: Swift.String?
        /// The name of the S3 bucket.
        public var bucketName: Swift.String?
        /// A value that enables DMS to specify a predefined (canned) access control list for objects created in an Amazon S3 bucket as .csv or .parquet files. For more information about Amazon S3 canned ACLs, see [Canned ACL](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the Amazon S3 Developer Guide. The default value is NONE. Valid values include NONE, PRIVATE, PUBLIC_READ, PUBLIC_READ_WRITE, AUTHENTICATED_READ, AWS_EXEC_READ, BUCKET_OWNER_READ, and BUCKET_OWNER_FULL_CONTROL.
        public var cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file. DMS supports the use of the .parquet files in versions 3.4.7 and later. How these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsAndUpdates: Swift.Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide.. DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later. CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public var cdcInsertsOnly: Swift.Bool?
        /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. When CdcMaxBatchInterval and CdcMinFileSize are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 60 seconds.
        public var cdcMaxBatchInterval: Swift.Int?
        /// Minimum file size, defined in kilobytes, to reach for a file output to Amazon S3. When CdcMinFileSize and CdcMaxBatchInterval are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 32 MB.
        public var cdcMinFileSize: Swift.Int?
        /// Specifies the folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If CdcPath is set, DMS reads CDC files from this path and replicates the data changes to the target endpoint. For an S3 target if you set [PreserveTransactions](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-PreserveTransactions) to true, DMS verifies that you have set this parameter to a folder path on your S3 target where DMS can save the transaction order for the CDC load. DMS creates this CDC folder path in either your S3 target working directory or the S3 target location specified by [BucketFolder](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketFolder) and [BucketName](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-BucketName). For example, if you specify CdcPath as MyChangedData, and you specify BucketName as MyTargetBucket but do not specify BucketFolder, DMS creates the CDC folder path following: MyTargetBucket/MyChangedData. If you specify the same CdcPath, and you specify BucketName as MyTargetBucket and BucketFolder as MyTargetData, DMS creates the CDC folder path following: MyTargetBucket/MyTargetData/MyChangedData. For more information on CDC including transaction order on an S3 target, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var cdcPath: Swift.String?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats.
        public var compressionType: DatabaseMigrationClientTypes.CompressionTypeValue?
        /// The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        public var csvDelimiter: Swift.String?
        /// This setting only applies if your Amazon S3 output files during a change data capture (CDC) load are written in .csv format. If [UseCsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-UseCsvNoSupValue) is set to true, specify a string value that you want DMS to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of the UseCsvNoSupValue setting. This setting is supported in DMS versions 3.4.1 and later.
        public var csvNoSupValue: Swift.String?
        /// An optional parameter that specifies how DMS treats null values. While handling the null value, you can use this parameter to pass a user-defined string as null when writing to the target. For example, when target columns are nullable, you can use this option to differentiate between the empty string value and the null value. So, if you set this parameter value to the empty string ("" or ''), DMS treats the empty string as the null value instead of NULL. The default value is NULL. Valid values include any valid string.
        public var csvNullValue: Swift.String?
        /// The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n).
        public var csvRowDelimiter: Swift.String?
        /// The format of the data that you want to use for output. You can choose one of the following:
        ///
        /// * csv : This is a row-based file format with comma-separated values (.csv).
        ///
        /// * parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.
        public var dataFormat: DatabaseMigrationClientTypes.DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only.
        public var dataPageSize: Swift.Int?
        /// Specifies a date separating delimiter to use during folder partitioning. The default value is SLASH. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue?
        /// When set to true, this parameter partitions S3 bucket folders based on transaction commit dates. The default value is false. For more information about date-based folder partitioning, see [Using date-based folder partitioning](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.DatePartitioning).
        public var datePartitionEnabled: Swift.Bool?
        /// Identifies the sequence of the date format to use during folder partitioning. The default value is YYYYMMDD. Use this parameter when DatePartitionedEnabled is set to true.
        public var datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue?
        /// When creating an S3 target endpoint, set DatePartitionTimezone to convert the current UTC time into a specified time zone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The time zone format is Area/Location. Use this parameter when DatePartitionedEnabled is set to true, as shown in the following example. s3-settings='{"DatePartitionEnabled": true, "DatePartitionSequence": "YYYYMMDDHH", "DatePartitionDelimiter": "SLASH", "DatePartitionTimezone":"Asia/Seoul", "BucketName": "dms-nattarat-test"}'
        public var datePartitionTimezone: Swift.String?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only.
        public var dictPageSizeLimit: Swift.Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public var enableStatistics: Swift.Bool?
        /// The type of encoding you are using:
        ///
        /// * RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.
        ///
        /// * PLAIN doesn't use encoding at all. Values are stored as they are.
        ///
        /// * PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.
        public var encodingType: DatabaseMigrationClientTypes.EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS. For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you canâ€™t change the existing value from SSE_S3 to SSE_KMS. To use SSE_S3, you need an Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:
        ///
        /// * s3:CreateBucket
        ///
        /// * s3:ListBucket
        ///
        /// * s3:DeleteBucket
        ///
        /// * s3:GetBucketLocation
        ///
        /// * s3:GetObject
        ///
        /// * s3:PutObject
        ///
        /// * s3:DeleteObject
        ///
        /// * s3:GetObjectVersion
        ///
        /// * s3:GetBucketPolicy
        ///
        /// * s3:PutBucketPolicy
        ///
        /// * s3:DeleteBucketPolicy
        public var encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue?
        /// To specify a bucket owner and prevent sniping, you can use the ExpectedBucketOwner endpoint setting. Example: --s3-settings='{"ExpectedBucketOwner": "AWS_Account_ID"}' When you make a request to test a connection or perform a migration, S3 checks the account ID of the bucket owner against the specified parameter.
        public var expectedBucketOwner: Swift.String?
        /// Specifies how tables are defined in the S3 source files only.
        public var externalTableDefinition: Swift.String?
        /// When true, allows Glue to catalog your S3 bucket. Creating an Glue catalog lets you use Athena to query your data.
        public var glueCatalogGeneration: Swift.Bool?
        /// When this value is set to 1, DMS ignores the first row header in a .csv file. A value of 1 turns on the feature; a value of 0 turns off the feature. The default is 0.
        public var ignoreHeaderRows: Swift.Int?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) or .parquet output files only to indicate how the rows were added to the source database. DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later. DMS supports the use of the .parquet files with the IncludeOpForFullLoad parameter in versions 3.4.7 and later. For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load. This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see [Indicating Source DB Operations in Migrated S3 Data](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.Configuring.InsertOps) in the Database Migration Service User Guide..
        public var includeOpForFullLoad: Swift.Bool?
        /// A value that specifies the maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. The default value is 1,048,576 KB (1 GB). Valid values include 1 to 1,048,576.
        public var maxFileSize: Swift.Int?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format. DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later. When ParquetTimestampInMillisecond is set to true or y, DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or Glue. DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter.
        public var parquetTimestampInMillisecond: Swift.Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public var parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue?
        /// If set to true, DMS saves the transaction order for a change data capture (CDC) load on the Amazon S3 target specified by [CdcPath](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CdcPath). For more information, see [Capturing data changes (CDC) including transaction order on the S3 target](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Target.S3.html#CHAP_Target.S3.EndpointSettings.CdcPath). This setting is supported in DMS versions 3.4.2 and later.
        public var preserveTransactions: Swift.Bool?
        /// For an S3 source, when this value is set to true or y, each leading double quotation mark has to be followed by an ending double quotation mark. This formatting complies with RFC 4180. When this value is set to false or n, string literals are copied to the target as is. In this case, a delimiter (row or column) signals the end of the field. Thus, you can't use a delimiter as part of the string, because it signals the end of the value. For an S3 target, an optional parameter used to set behavior to comply with RFC 4180 for data migrated to Amazon S3 using .csv file format only. When this value is set to true or y using Amazon S3 as a target, if the data has quotation marks or newline characters in it, DMS encloses the entire column with an additional pair of double quotation marks ("). Every quotation mark within the data is repeated twice. The default value is true. Valid values include true, false, y, and n.
        public var rfc4180: Swift.Bool?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only. If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024).
        public var rowGroupLength: Swift.Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the KMS key ID. The key that you use needs an attached policy that enables Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value
        public var serverSideEncryptionKmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action. It is a required parameter that enables DMS to write and read objects from an S3 bucket.
        public var serviceAccessRoleArn: Swift.String?
        /// A value that when nonblank causes DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target. DMS supports the TimestampColumnName parameter in versions 3.1.4 and later. DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS. For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public var timestampColumnName: Swift.String?
        /// This setting applies if the S3 output files during a change data capture (CDC) load are written in .csv format. If set to true for columns not included in the supplemental log, DMS uses the value specified by [CsvNoSupValue](https://docs.aws.amazon.com/dms/latest/APIReference/API_S3Settings.html#DMS-Type-S3Settings-CsvNoSupValue). If not set or set to false, DMS uses the null value for these columns. This setting is supported in DMS versions 3.4.1 and later.
        public var useCsvNoSupValue: Swift.Bool?
        /// When set to true, this parameter uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when useTaskStartTimeForFullLoadTimestamp is set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When useTaskStartTimeForFullLoadTimestamp is set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target.
        public var useTaskStartTimeForFullLoadTimestamp: Swift.Bool?

        public init(
            addColumnName: Swift.Bool? = nil,
            addTrailingPaddingCharacter: Swift.Bool? = nil,
            bucketFolder: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            cannedAclForObjects: DatabaseMigrationClientTypes.CannedAclForObjectsValue? = nil,
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            cdcInsertsOnly: Swift.Bool? = nil,
            cdcMaxBatchInterval: Swift.Int? = nil,
            cdcMinFileSize: Swift.Int? = nil,
            cdcPath: Swift.String? = nil,
            compressionType: DatabaseMigrationClientTypes.CompressionTypeValue? = nil,
            csvDelimiter: Swift.String? = nil,
            csvNoSupValue: Swift.String? = nil,
            csvNullValue: Swift.String? = nil,
            csvRowDelimiter: Swift.String? = nil,
            dataFormat: DatabaseMigrationClientTypes.DataFormatValue? = nil,
            dataPageSize: Swift.Int? = nil,
            datePartitionDelimiter: DatabaseMigrationClientTypes.DatePartitionDelimiterValue? = nil,
            datePartitionEnabled: Swift.Bool? = nil,
            datePartitionSequence: DatabaseMigrationClientTypes.DatePartitionSequenceValue? = nil,
            datePartitionTimezone: Swift.String? = nil,
            dictPageSizeLimit: Swift.Int? = nil,
            enableStatistics: Swift.Bool? = nil,
            encodingType: DatabaseMigrationClientTypes.EncodingTypeValue? = nil,
            encryptionMode: DatabaseMigrationClientTypes.EncryptionModeValue? = nil,
            expectedBucketOwner: Swift.String? = nil,
            externalTableDefinition: Swift.String? = nil,
            glueCatalogGeneration: Swift.Bool? = nil,
            ignoreHeaderRows: Swift.Int? = nil,
            includeOpForFullLoad: Swift.Bool? = nil,
            maxFileSize: Swift.Int? = nil,
            parquetTimestampInMillisecond: Swift.Bool? = nil,
            parquetVersion: DatabaseMigrationClientTypes.ParquetVersionValue? = nil,
            preserveTransactions: Swift.Bool? = nil,
            rfc4180: Swift.Bool? = nil,
            rowGroupLength: Swift.Int? = nil,
            serverSideEncryptionKmsKeyId: Swift.String? = nil,
            serviceAccessRoleArn: Swift.String? = nil,
            timestampColumnName: Swift.String? = nil,
            useCsvNoSupValue: Swift.Bool? = nil,
            useTaskStartTimeForFullLoadTimestamp: Swift.Bool? = nil
        )
        {
            self.addColumnName = addColumnName
            self.addTrailingPaddingCharacter = addTrailingPaddingCharacter
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cannedAclForObjects = cannedAclForObjects
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcMaxBatchInterval = cdcMaxBatchInterval
            self.cdcMinFileSize = cdcMinFileSize
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvNullValue = csvNullValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.datePartitionTimezone = datePartitionTimezone
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.expectedBucketOwner = expectedBucketOwner
            self.externalTableDefinition = externalTableDefinition
            self.glueCatalogGeneration = glueCatalogGeneration
            self.ignoreHeaderRows = ignoreHeaderRows
            self.includeOpForFullLoad = includeOpForFullLoad
            self.maxFileSize = maxFileSize
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rfc4180 = rfc4180
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
            self.useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestamp
        }
    }

}

extension DatabaseMigrationClientTypes.SCApplicationAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketPath = "S3BucketPath"
        case s3BucketRoleArn = "S3BucketRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketPath = self.s3BucketPath {
            try encodeContainer.encode(s3BucketPath, forKey: .s3BucketPath)
        }
        if let s3BucketRoleArn = self.s3BucketRoleArn {
            try encodeContainer.encode(s3BucketRoleArn, forKey: .s3BucketRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketPath)
        s3BucketPath = s3BucketPathDecoded
        let s3BucketRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketRoleArn)
        s3BucketRoleArn = s3BucketRoleArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a schema conversion application.
    public struct SCApplicationAttributes: Swift.Equatable {
        /// The path for the Amazon S3 bucket that the application uses for exporting assessment reports.
        public var s3BucketPath: Swift.String?
        /// The ARN for the role the application uses to access its Amazon S3 bucket.
        public var s3BucketRoleArn: Swift.String?

        public init(
            s3BucketPath: Swift.String? = nil,
            s3BucketRoleArn: Swift.String? = nil
        )
        {
            self.s3BucketPath = s3BucketPath
            self.s3BucketRoleArn = s3BucketRoleArn
        }
    }

}

extension SNSInvalidTopicFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SNSInvalidTopicFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The SNS topic is invalid.
public struct SNSInvalidTopicFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SNSInvalidTopicFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SNSNoAuthorizationFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized for the SNS subscription.
public struct SNSNoAuthorizationFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SNSNoAuthorizationFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum SafeguardPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclusiveAutomaticTruncation
        case relyOnSqlServerReplicationAgent
        case sharedAutomaticTruncation
        case sdkUnknown(Swift.String)

        public static var allCases: [SafeguardPolicy] {
            return [
                .exclusiveAutomaticTruncation,
                .relyOnSqlServerReplicationAgent,
                .sharedAutomaticTruncation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclusiveAutomaticTruncation: return "exclusive-automatic-truncation"
            case .relyOnSqlServerReplicationAgent: return "rely-on-sql-server-replication-agent"
            case .sharedAutomaticTruncation: return "shared-automatic-truncation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SafeguardPolicy(rawValue: rawValue) ?? SafeguardPolicy.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.SchemaConversionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case exportSqlDetails = "ExportSqlDetails"
        case migrationProjectArn = "MigrationProjectArn"
        case requestIdentifier = "RequestIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let exportSqlDetails = self.exportSqlDetails {
            try encodeContainer.encode(exportSqlDetails, forKey: .exportSqlDetails)
        }
        if let migrationProjectArn = self.migrationProjectArn {
            try encodeContainer.encode(migrationProjectArn, forKey: .migrationProjectArn)
        }
        if let requestIdentifier = self.requestIdentifier {
            try encodeContainer.encode(requestIdentifier, forKey: .requestIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
        let migrationProjectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectArn)
        migrationProjectArn = migrationProjectArnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
        let exportSqlDetailsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ExportSqlDetails.self, forKey: .exportSqlDetails)
        exportSqlDetails = exportSqlDetailsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about a schema conversion action.
    public struct SchemaConversionRequest: Swift.Equatable {
        /// Provides error information about a project.
        public var error: DatabaseMigrationClientTypes.ErrorDetails?
        /// Provides information about a metadata model assessment exported to SQL.
        public var exportSqlDetails: DatabaseMigrationClientTypes.ExportSqlDetails?
        /// The migration project ARN.
        public var migrationProjectArn: Swift.String?
        /// The identifier for the schema conversion action.
        public var requestIdentifier: Swift.String?
        /// The schema conversion action status.
        public var status: Swift.String?

        public init(
            error: DatabaseMigrationClientTypes.ErrorDetails? = nil,
            exportSqlDetails: DatabaseMigrationClientTypes.ExportSqlDetails? = nil,
            migrationProjectArn: Swift.String? = nil,
            requestIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.error = error
            self.exportSqlDetails = exportSqlDetails
            self.migrationProjectArn = migrationProjectArn
            self.requestIdentifier = requestIdentifier
            self.status = status
        }
    }

}

extension DatabaseMigrationClientTypes.SchemaResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeLineCount = "CodeLineCount"
        case codeSize = "CodeSize"
        case complexity = "Complexity"
        case databaseInstance = "DatabaseInstance"
        case originalSchema = "OriginalSchema"
        case schemaId = "SchemaId"
        case schemaName = "SchemaName"
        case server = "Server"
        case similarity = "Similarity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeLineCount = self.codeLineCount {
            try encodeContainer.encode(codeLineCount, forKey: .codeLineCount)
        }
        if let codeSize = self.codeSize {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let complexity = self.complexity {
            try encodeContainer.encode(complexity, forKey: .complexity)
        }
        if let databaseInstance = self.databaseInstance {
            try encodeContainer.encode(databaseInstance, forKey: .databaseInstance)
        }
        if let originalSchema = self.originalSchema {
            try encodeContainer.encode(originalSchema, forKey: .originalSchema)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let similarity = self.similarity {
            try encodeContainer.encode(similarity, forKey: .similarity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeLineCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeLineCount)
        codeLineCount = codeLineCountDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let complexityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complexity)
        complexity = complexityDecoded
        let serverDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ServerShortInfoResponse.self, forKey: .server)
        server = serverDecoded
        let databaseInstanceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatabaseShortInfoResponse.self, forKey: .databaseInstance)
        databaseInstance = databaseInstanceDecoded
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let originalSchemaDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.SchemaShortInfoResponse.self, forKey: .originalSchema)
        originalSchema = originalSchemaDecoded
        let similarityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .similarity)
        similarity = similarityDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaResponse: Swift.Equatable {
        /// The number of lines of code in a schema in a Fleet Advisor collector inventory.
        public var codeLineCount: Swift.Int?
        /// The size level of the code in a schema in a Fleet Advisor collector inventory.
        public var codeSize: Swift.Int?
        /// The complexity level of the code in a schema in a Fleet Advisor collector inventory.
        public var complexity: Swift.String?
        /// The database for a schema in a Fleet Advisor collector inventory.
        public var databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse?
        /// Describes a schema in a Fleet Advisor collector inventory.
        public var originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?
        /// The database server for a schema in a Fleet Advisor collector inventory.
        public var server: DatabaseMigrationClientTypes.ServerShortInfoResponse?
        /// The similarity value for a schema in a Fleet Advisor collector inventory. A higher similarity value indicates that a schema is likely to be a duplicate.
        public var similarity: Swift.Double?

        public init(
            codeLineCount: Swift.Int? = nil,
            codeSize: Swift.Int? = nil,
            complexity: Swift.String? = nil,
            databaseInstance: DatabaseMigrationClientTypes.DatabaseShortInfoResponse? = nil,
            originalSchema: DatabaseMigrationClientTypes.SchemaShortInfoResponse? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil,
            server: DatabaseMigrationClientTypes.ServerShortInfoResponse? = nil,
            similarity: Swift.Double? = nil
        )
        {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.complexity = complexity
            self.databaseInstance = databaseInstance
            self.originalSchema = originalSchema
            self.schemaId = schemaId
            self.schemaName = schemaName
            self.server = server
            self.similarity = similarity
        }
    }

}

extension DatabaseMigrationClientTypes.SchemaShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case databaseIpAddress = "DatabaseIpAddress"
        case databaseName = "DatabaseName"
        case schemaId = "SchemaId"
        case schemaName = "SchemaName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let databaseIpAddress = self.databaseIpAddress {
            try encodeContainer.encode(databaseIpAddress, forKey: .databaseIpAddress)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let schemaId = self.schemaId {
            try encodeContainer.encode(schemaId, forKey: .schemaId)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaId)
        schemaId = schemaIdDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let databaseIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseIpAddress)
        databaseIpAddress = databaseIpAddressDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a schema in a Fleet Advisor collector inventory.
    public struct SchemaShortInfoResponse: Swift.Equatable {
        /// The ID of a database in a Fleet Advisor collector inventory.
        public var databaseId: Swift.String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public var databaseIpAddress: Swift.String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public var databaseName: Swift.String?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public var schemaId: Swift.String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public var schemaName: Swift.String?

        public init(
            databaseId: Swift.String? = nil,
            databaseIpAddress: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            schemaId: Swift.String? = nil,
            schemaName: Swift.String? = nil
        )
        {
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
            self.schemaId = schemaId
            self.schemaName = schemaName
        }
    }

}

extension DatabaseMigrationClientTypes.ServerShortInfoResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress = "IpAddress"
        case serverId = "ServerId"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes a server in a Fleet Advisor collector inventory.
    public struct ServerShortInfoResponse: Swift.Equatable {
        /// The IP address of a server in a Fleet Advisor collector inventory.
        public var ipAddress: Swift.String?
        /// The ID of a server in a Fleet Advisor collector inventory.
        public var serverId: Swift.String?
        /// The name address of a server in a Fleet Advisor collector inventory.
        public var serverName: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            serverId: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.serverId = serverId
            self.serverName = serverName
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case replicationInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .replicationInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .replicationInstance: return "replication-instance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum SslSecurityProtocolValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case sslEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [SslSecurityProtocolValue] {
            return [
                .plaintext,
                .sslEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "plaintext"
            case .sslEncryption: return "ssl-encryption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslSecurityProtocolValue(rawValue: rawValue) ?? SslSecurityProtocolValue.sdkUnknown(rawValue)
        }
    }
}

extension StartExtensionPackAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
    }
}

extension StartExtensionPackAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartExtensionPackAssociationInput: Swift.Equatable {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
    }
}

struct StartExtensionPackAssociationInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
}

extension StartExtensionPackAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
    }
}

extension StartExtensionPackAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartExtensionPackAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartExtensionPackAssociationOutput: Swift.Equatable {
    /// The identifier for the request operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartExtensionPackAssociationOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartExtensionPackAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartExtensionPackAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMetadataModelAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension StartMetadataModelAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMetadataModelAssessmentInput: Swift.Equatable {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to assess.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

struct StartMetadataModelAssessmentInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
}

extension StartMetadataModelAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
    }
}

extension StartMetadataModelAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMetadataModelAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartMetadataModelAssessmentOutput: Swift.Equatable {
    /// The identifier for the assessment operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartMetadataModelAssessmentOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartMetadataModelAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartMetadataModelAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMetadataModelConversionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension StartMetadataModelConversionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMetadataModelConversionInput: Swift.Equatable {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// A value that specifies the database objects to convert.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.selectionRules = selectionRules
    }
}

struct StartMetadataModelConversionInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
}

extension StartMetadataModelConversionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
    }
}

extension StartMetadataModelConversionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMetadataModelConversionOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartMetadataModelConversionOutput: Swift.Equatable {
    /// The identifier for the conversion operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartMetadataModelConversionOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartMetadataModelConversionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartMetadataModelConversionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMetadataModelExportAsScriptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName = "FileName"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case origin = "Origin"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension StartMetadataModelExportAsScriptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMetadataModelExportAsScriptInput: Swift.Equatable {
    /// The name of the model file to create in the Amazon S3 bucket.
    public var fileName: Swift.String?
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to export the metadata model from the source or the target.
    /// This member is required.
    public var origin: DatabaseMigrationClientTypes.OriginTypeValue?
    /// A value that specifies the database objects to export.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        fileName: Swift.String? = nil,
        migrationProjectIdentifier: Swift.String? = nil,
        origin: DatabaseMigrationClientTypes.OriginTypeValue? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.fileName = fileName
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.origin = origin
        self.selectionRules = selectionRules
    }
}

struct StartMetadataModelExportAsScriptInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
    let origin: DatabaseMigrationClientTypes.OriginTypeValue?
    let fileName: Swift.String?
}

extension StartMetadataModelExportAsScriptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName = "FileName"
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case origin = "Origin"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
        let originDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OriginTypeValue.self, forKey: .origin)
        origin = originDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension StartMetadataModelExportAsScriptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMetadataModelExportAsScriptOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartMetadataModelExportAsScriptOutput: Swift.Equatable {
    /// The identifier for the export operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartMetadataModelExportAsScriptOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartMetadataModelExportAsScriptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartMetadataModelExportAsScriptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMetadataModelExportToTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case overwriteExtensionPack = "OverwriteExtensionPack"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let overwriteExtensionPack = self.overwriteExtensionPack {
            try encodeContainer.encode(overwriteExtensionPack, forKey: .overwriteExtensionPack)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension StartMetadataModelExportToTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMetadataModelExportToTargetInput: Swift.Equatable {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to overwrite the migration project extension pack. An extension pack is an add-on module that emulates functions present in a source database that are required when converting objects to the target database.
    public var overwriteExtensionPack: Swift.Bool?
    /// A value that specifies the database objects to export.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        overwriteExtensionPack: Swift.Bool? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.overwriteExtensionPack = overwriteExtensionPack
        self.selectionRules = selectionRules
    }
}

struct StartMetadataModelExportToTargetInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
    let overwriteExtensionPack: Swift.Bool?
}

extension StartMetadataModelExportToTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case overwriteExtensionPack = "OverwriteExtensionPack"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
        let overwriteExtensionPackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overwriteExtensionPack)
        overwriteExtensionPack = overwriteExtensionPackDecoded
    }
}

extension StartMetadataModelExportToTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMetadataModelExportToTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartMetadataModelExportToTargetOutput: Swift.Equatable {
    /// The identifier for the export operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartMetadataModelExportToTargetOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartMetadataModelExportToTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartMetadataModelExportToTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMetadataModelImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case origin = "Origin"
        case refresh = "Refresh"
        case selectionRules = "SelectionRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationProjectIdentifier = self.migrationProjectIdentifier {
            try encodeContainer.encode(migrationProjectIdentifier, forKey: .migrationProjectIdentifier)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
        if let refresh = self.refresh {
            try encodeContainer.encode(refresh, forKey: .refresh)
        }
        if let selectionRules = self.selectionRules {
            try encodeContainer.encode(selectionRules, forKey: .selectionRules)
        }
    }
}

extension StartMetadataModelImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartMetadataModelImportInput: Swift.Equatable {
    /// The migration project name or Amazon Resource Name (ARN).
    /// This member is required.
    public var migrationProjectIdentifier: Swift.String?
    /// Whether to load metadata to the source or target database.
    /// This member is required.
    public var origin: DatabaseMigrationClientTypes.OriginTypeValue?
    /// If true, DMS loads metadata for the specified objects from the source database.
    public var refresh: Swift.Bool?
    /// A value that specifies the database objects to import.
    /// This member is required.
    public var selectionRules: Swift.String?

    public init(
        migrationProjectIdentifier: Swift.String? = nil,
        origin: DatabaseMigrationClientTypes.OriginTypeValue? = nil,
        refresh: Swift.Bool? = nil,
        selectionRules: Swift.String? = nil
    )
    {
        self.migrationProjectIdentifier = migrationProjectIdentifier
        self.origin = origin
        self.refresh = refresh
        self.selectionRules = selectionRules
    }
}

struct StartMetadataModelImportInputBody: Swift.Equatable {
    let migrationProjectIdentifier: Swift.String?
    let selectionRules: Swift.String?
    let origin: DatabaseMigrationClientTypes.OriginTypeValue?
    let refresh: Swift.Bool?
}

extension StartMetadataModelImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationProjectIdentifier = "MigrationProjectIdentifier"
        case origin = "Origin"
        case refresh = "Refresh"
        case selectionRules = "SelectionRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationProjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationProjectIdentifier)
        migrationProjectIdentifier = migrationProjectIdentifierDecoded
        let selectionRulesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionRules)
        selectionRules = selectionRulesDecoded
        let originDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.OriginTypeValue.self, forKey: .origin)
        origin = originDecoded
        let refreshDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .refresh)
        refresh = refreshDecoded
    }
}

extension StartMetadataModelImportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMetadataModelImportOutputBody = try responseDecoder.decode(responseBody: data)
            self.requestIdentifier = output.requestIdentifier
        } else {
            self.requestIdentifier = nil
        }
    }
}

public struct StartMetadataModelImportOutput: Swift.Equatable {
    /// The identifier for the import operation.
    public var requestIdentifier: Swift.String?

    public init(
        requestIdentifier: Swift.String? = nil
    )
    {
        self.requestIdentifier = requestIdentifier
    }
}

struct StartMetadataModelImportOutputBody: Swift.Equatable {
    let requestIdentifier: Swift.String?
}

extension StartMetadataModelImportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestIdentifier = "RequestIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestIdentifier)
        requestIdentifier = requestIdentifierDecoded
    }
}

enum StartMetadataModelImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }
}

extension StartRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRecommendationsInput: Swift.Equatable {
    /// The identifier of the source database to analyze and provide recommendations for.
    /// This member is required.
    public var databaseId: Swift.String?
    /// The settings in JSON format that Fleet Advisor uses to determine target engine recommendations. These parameters include target instance sizing and availability and durability settings. For target instance sizing, Fleet Advisor supports the following two options: total capacity and resource utilization. For availability and durability, Fleet Advisor supports the following two options: production (Multi-AZ deployments) and Dev/Test (Single-AZ deployments).
    /// This member is required.
    public var settings: DatabaseMigrationClientTypes.RecommendationSettings?

    public init(
        databaseId: Swift.String? = nil,
        settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil
    )
    {
        self.databaseId = databaseId
        self.settings = settings
    }
}

struct StartRecommendationsInputBody: Swift.Equatable {
    let databaseId: Swift.String?
    let settings: DatabaseMigrationClientTypes.RecommendationSettings?
}

extension StartRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case settings = "Settings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RecommendationSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension StartRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartRecommendationsOutput: Swift.Equatable {

    public init() { }
}

enum StartRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.StartRecommendationsRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseId = "DatabaseId"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseId = self.databaseId {
            try encodeContainer.encode(databaseId, forKey: .databaseId)
        }
        if let settings = self.settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseId)
        databaseId = databaseIdDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.RecommendationSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about the source database to analyze and provide target recommendations according to the specified requirements.
    public struct StartRecommendationsRequestEntry: Swift.Equatable {
        /// The identifier of the source database.
        /// This member is required.
        public var databaseId: Swift.String?
        /// The required target engine settings.
        /// This member is required.
        public var settings: DatabaseMigrationClientTypes.RecommendationSettings?

        public init(
            databaseId: Swift.String? = nil,
            settings: DatabaseMigrationClientTypes.RecommendationSettings? = nil
        )
        {
            self.databaseId = databaseId
            self.settings = settings
        }
    }

}

extension StartReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationConfigArn = "ReplicationConfigArn"
        case startReplicationType = "StartReplicationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
        if let startReplicationType = self.startReplicationType {
            try encodeContainer.encode(startReplicationType, forKey: .startReplicationType)
        }
    }
}

extension StartReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format.
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
    public var cdcStopPosition: Swift.String?
    /// The Amazon Resource Name of the replication for which to start replication.
    /// This member is required.
    public var replicationConfigArn: Swift.String?
    /// The replication type.
    /// This member is required.
    public var startReplicationType: Swift.String?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationConfigArn: Swift.String? = nil,
        startReplicationType: Swift.String? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationConfigArn = replicationConfigArn
        self.startReplicationType = startReplicationType
    }
}

struct StartReplicationInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
    let startReplicationType: Swift.String?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
}

extension StartReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationConfigArn = "ReplicationConfigArn"
        case startReplicationType = "StartReplicationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
        let startReplicationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startReplicationType)
        startReplicationType = startReplicationTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
    }
}

extension StartReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.replication = output.replication
        } else {
            self.replication = nil
        }
    }
}

///
public struct StartReplicationOutput: Swift.Equatable {
    /// The replication that DMS started.
    public var replication: DatabaseMigrationClientTypes.Replication?

    public init(
        replication: DatabaseMigrationClientTypes.Replication? = nil
    )
    {
        self.replication = replication
    }
}

struct StartReplicationOutputBody: Swift.Equatable {
    let replication: DatabaseMigrationClientTypes.Replication?
}

extension StartReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replication = "Replication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Replication.self, forKey: .replication)
        replication = replicationDecoded
    }
}

enum StartReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReplicationTaskAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension StartReplicationTaskAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskAssessmentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replication task.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StartReplicationTaskAssessmentInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension StartReplicationTaskAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StartReplicationTaskAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationTaskAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StartReplicationTaskAssessmentOutput: Swift.Equatable {
    /// The assessed replication task.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskAssessmentOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum StartReplicationTaskAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReplicationTaskAssessmentRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = self.assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclude)
            for string0 in exclude {
                try excludeContainer.encode(string0)
            }
        }
        if let includeOnly = includeOnly {
            var includeOnlyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .includeOnly)
            for string0 in includeOnly {
                try includeOnlyContainer.encode(string0)
            }
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let resultEncryptionMode = self.resultEncryptionMode {
            try encodeContainer.encode(resultEncryptionMode, forKey: .resultEncryptionMode)
        }
        if let resultKmsKeyArn = self.resultKmsKeyArn {
            try encodeContainer.encode(resultKmsKeyArn, forKey: .resultKmsKeyArn)
        }
        if let resultLocationBucket = self.resultLocationBucket {
            try encodeContainer.encode(resultLocationBucket, forKey: .resultLocationBucket)
        }
        if let resultLocationFolder = self.resultLocationFolder {
            try encodeContainer.encode(resultLocationFolder, forKey: .resultLocationFolder)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
    }
}

extension StartReplicationTaskAssessmentRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskAssessmentRunInput: Swift.Equatable {
    /// Unique name to identify the assessment run.
    /// This member is required.
    public var assessmentRunName: Swift.String?
    /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var exclude: [Swift.String]?
    /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn. You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
    public var includeOnly: [Swift.String]?
    /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, DMS stores the assessment run results without encryption. You can specify one of the options following:
    ///
    /// * "SSE_S3" â€“ The server-side encryption provided as a default by Amazon S3.
    ///
    /// * "SSE_KMS" â€“ Key Management Service (KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.
    public var resultEncryptionMode: Swift.String?
    /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
    public var resultKmsKeyArn: Swift.String?
    /// Amazon S3 bucket where you want DMS to store the results of this assessment run.
    /// This member is required.
    public var resultLocationBucket: Swift.String?
    /// Folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.
    public var resultLocationFolder: Swift.String?
    /// ARN of the service role needed to start the assessment run. The role must allow the iam:PassRole action.
    /// This member is required.
    public var serviceAccessRoleArn: Swift.String?

    public init(
        assessmentRunName: Swift.String? = nil,
        exclude: [Swift.String]? = nil,
        includeOnly: [Swift.String]? = nil,
        replicationTaskArn: Swift.String? = nil,
        resultEncryptionMode: Swift.String? = nil,
        resultKmsKeyArn: Swift.String? = nil,
        resultLocationBucket: Swift.String? = nil,
        resultLocationFolder: Swift.String? = nil,
        serviceAccessRoleArn: Swift.String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.exclude = exclude
        self.includeOnly = includeOnly
        self.replicationTaskArn = replicationTaskArn
        self.resultEncryptionMode = resultEncryptionMode
        self.resultKmsKeyArn = resultKmsKeyArn
        self.resultLocationBucket = resultLocationBucket
        self.resultLocationFolder = resultLocationFolder
        self.serviceAccessRoleArn = serviceAccessRoleArn
    }
}

struct StartReplicationTaskAssessmentRunInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let serviceAccessRoleArn: Swift.String?
    let resultLocationBucket: Swift.String?
    let resultLocationFolder: Swift.String?
    let resultEncryptionMode: Swift.String?
    let resultKmsKeyArn: Swift.String?
    let assessmentRunName: Swift.String?
    let includeOnly: [Swift.String]?
    let exclude: [Swift.String]?
}

extension StartReplicationTaskAssessmentRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentRunName = "AssessmentRunName"
        case exclude = "Exclude"
        case includeOnly = "IncludeOnly"
        case replicationTaskArn = "ReplicationTaskArn"
        case resultEncryptionMode = "ResultEncryptionMode"
        case resultKmsKeyArn = "ResultKmsKeyArn"
        case resultLocationBucket = "ResultLocationBucket"
        case resultLocationFolder = "ResultLocationFolder"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let resultLocationBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationBucket)
        resultLocationBucket = resultLocationBucketDecoded
        let resultLocationFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultLocationFolder)
        resultLocationFolder = resultLocationFolderDecoded
        let resultEncryptionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultEncryptionMode)
        resultEncryptionMode = resultEncryptionModeDecoded
        let resultKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultKmsKeyArn)
        resultKmsKeyArn = resultKmsKeyArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
        let includeOnlyContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .includeOnly)
        var includeOnlyDecoded0:[Swift.String]? = nil
        if let includeOnlyContainer = includeOnlyContainer {
            includeOnlyDecoded0 = [Swift.String]()
            for string0 in includeOnlyContainer {
                if let string0 = string0 {
                    includeOnlyDecoded0?.append(string0)
                }
            }
        }
        includeOnly = includeOnlyDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exclude)
        var excludeDecoded0:[Swift.String]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [Swift.String]()
            for string0 in excludeContainer {
                if let string0 = string0 {
                    excludeDecoded0?.append(string0)
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension StartReplicationTaskAssessmentRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationTaskAssessmentRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTaskAssessmentRun = output.replicationTaskAssessmentRun
        } else {
            self.replicationTaskAssessmentRun = nil
        }
    }
}

///
public struct StartReplicationTaskAssessmentRunOutput: Swift.Equatable {
    /// The premigration assessment run that was started.
    public var replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?

    public init(
        replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun? = nil
    )
    {
        self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
    }
}

struct StartReplicationTaskAssessmentRunOutputBody: Swift.Equatable {
    let replicationTaskAssessmentRun: DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun?
}

extension StartReplicationTaskAssessmentRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskAssessmentRunDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTaskAssessmentRun.self, forKey: .replicationTaskAssessmentRun)
        replicationTaskAssessmentRun = replicationTaskAssessmentRunDecoded
    }
}

enum StartReplicationTaskAssessmentRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSAccessDeniedFault": return try await KMSAccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSDisabledFault": return try await KMSDisabledFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSFault": return try await KMSFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSInvalidStateFault": return try await KMSInvalidStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSNotFoundFault": return try await KMSNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsFault": return try await ResourceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3AccessDeniedFault": return try await S3AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3ResourceNotFoundFault": return try await S3ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcStartPosition = self.cdcStartPosition {
            try encodeContainer.encode(cdcStartPosition, forKey: .cdcStartPosition)
        }
        if let cdcStartTime = self.cdcStartTime {
            try encodeContainer.encodeTimestamp(cdcStartTime, format: .epochSeconds, forKey: .cdcStartTime)
        }
        if let cdcStopPosition = self.cdcStopPosition {
            try encodeContainer.encode(cdcStopPosition, forKey: .cdcStopPosition)
        }
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
        if let startReplicationTaskType = self.startReplicationTaskType {
            try encodeContainer.encode(startReplicationTaskType.rawValue, forKey: .startReplicationTaskType)
        }
    }
}

extension StartReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartReplicationTaskInput: Swift.Equatable {
    /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position â€œ2018-03-08T12:12:12â€ Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position â€œmysql-bin-changelog.000024:373â€ When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see [Extra Connection Attributes When Using PostgreSQL as a Source for DMS](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib).
    public var cdcStartPosition: Swift.String?
    /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time â€œ2018-03-08T12:12:12â€
    public var cdcStartTime: ClientRuntime.Date?
    /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position â€œserver_time:2018-02-09T12:12:12â€ Commit time example: --cdc-stop-position â€œcommit_time:2018-02-09T12:12:12â€œ
    public var cdcStopPosition: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication task to be started.
    /// This member is required.
    public var replicationTaskArn: Swift.String?
    /// The type of replication task to start. When the migration type is full-load or full-load-and-cdc, the only valid value for the first run of the task is start-replication. This option will start the migration. You can also use [ReloadTables] to reload specific tables that failed during migration instead of restarting the task. The resume-processing option isn't applicable for a full-load task, because you can't resume partially loaded tables during the full load phase. For a full-load-and-cdc task, DMS migrates table data, and then applies data changes that occur on the source. To load all the tables again, and start capturing source changes, use reload-target. Otherwise use resume-processing, to replicate the changes from the last stop position.
    /// This member is required.
    public var startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?

    public init(
        cdcStartPosition: Swift.String? = nil,
        cdcStartTime: ClientRuntime.Date? = nil,
        cdcStopPosition: Swift.String? = nil,
        replicationTaskArn: Swift.String? = nil,
        startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue? = nil
    )
    {
        self.cdcStartPosition = cdcStartPosition
        self.cdcStartTime = cdcStartTime
        self.cdcStopPosition = cdcStopPosition
        self.replicationTaskArn = replicationTaskArn
        self.startReplicationTaskType = startReplicationTaskType
    }
}

struct StartReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
    let startReplicationTaskType: DatabaseMigrationClientTypes.StartReplicationTaskTypeValue?
    let cdcStartTime: ClientRuntime.Date?
    let cdcStartPosition: Swift.String?
    let cdcStopPosition: Swift.String?
}

extension StartReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcStartPosition = "CdcStartPosition"
        case cdcStartTime = "CdcStartTime"
        case cdcStopPosition = "CdcStopPosition"
        case replicationTaskArn = "ReplicationTaskArn"
        case startReplicationTaskType = "StartReplicationTaskType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
        let startReplicationTaskTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.StartReplicationTaskTypeValue.self, forKey: .startReplicationTaskType)
        startReplicationTaskType = startReplicationTaskTypeDecoded
        let cdcStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .cdcStartTime)
        cdcStartTime = cdcStartTimeDecoded
        let cdcStartPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStartPosition)
        cdcStartPosition = cdcStartPositionDecoded
        let cdcStopPositionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcStopPosition)
        cdcStopPosition = cdcStopPositionDecoded
    }
}

extension StartReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StartReplicationTaskOutput: Swift.Equatable {
    /// The replication task started.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StartReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StartReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum StartReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes {
    public enum StartReplicationTaskTypeValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reloadTarget
        case resumeProcessing
        case startReplication
        case sdkUnknown(Swift.String)

        public static var allCases: [StartReplicationTaskTypeValue] {
            return [
                .reloadTarget,
                .resumeProcessing,
                .startReplication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reloadTarget: return "reload-target"
            case .resumeProcessing: return "resume-processing"
            case .startReplication: return "start-replication"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StartReplicationTaskTypeValue(rawValue: rawValue) ?? StartReplicationTaskTypeValue.sdkUnknown(rawValue)
        }
    }
}

extension StopReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigArn = self.replicationConfigArn {
            try encodeContainer.encode(replicationConfigArn, forKey: .replicationConfigArn)
        }
    }
}

extension StopReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StopReplicationInput: Swift.Equatable {
    /// The Amazon Resource Name of the replication to stop.
    /// This member is required.
    public var replicationConfigArn: Swift.String?

    public init(
        replicationConfigArn: Swift.String? = nil
    )
    {
        self.replicationConfigArn = replicationConfigArn
    }
}

struct StopReplicationInputBody: Swift.Equatable {
    let replicationConfigArn: Swift.String?
}

extension StopReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigArn = "ReplicationConfigArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigArn)
        replicationConfigArn = replicationConfigArnDecoded
    }
}

extension StopReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.replication = output.replication
        } else {
            self.replication = nil
        }
    }
}

public struct StopReplicationOutput: Swift.Equatable {
    /// The replication that DMS stopped.
    public var replication: DatabaseMigrationClientTypes.Replication?

    public init(
        replication: DatabaseMigrationClientTypes.Replication? = nil
    )
    {
        self.replication = replication
    }
}

struct StopReplicationOutputBody: Swift.Equatable {
    let replication: DatabaseMigrationClientTypes.Replication?
}

extension StopReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replication = "Replication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Replication.self, forKey: .replication)
        replication = replicationDecoded
    }
}

enum StopReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopReplicationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationTaskArn = self.replicationTaskArn {
            try encodeContainer.encode(replicationTaskArn, forKey: .replicationTaskArn)
        }
    }
}

extension StopReplicationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StopReplicationTaskInput: Swift.Equatable {
    /// The Amazon Resource Name(ARN) of the replication task to be stopped.
    /// This member is required.
    public var replicationTaskArn: Swift.String?

    public init(
        replicationTaskArn: Swift.String? = nil
    )
    {
        self.replicationTaskArn = replicationTaskArn
    }
}

struct StopReplicationTaskInputBody: Swift.Equatable {
    let replicationTaskArn: Swift.String?
}

extension StopReplicationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTaskArn = "ReplicationTaskArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationTaskArn)
        replicationTaskArn = replicationTaskArnDecoded
    }
}

extension StopReplicationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopReplicationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationTask = output.replicationTask
        } else {
            self.replicationTask = nil
        }
    }
}

///
public struct StopReplicationTaskOutput: Swift.Equatable {
    /// The replication task stopped.
    public var replicationTask: DatabaseMigrationClientTypes.ReplicationTask?

    public init(
        replicationTask: DatabaseMigrationClientTypes.ReplicationTask? = nil
    )
    {
        self.replicationTask = replicationTask
    }
}

struct StopReplicationTaskOutputBody: Swift.Equatable {
    let replicationTask: DatabaseMigrationClientTypes.ReplicationTask?
}

extension StopReplicationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationTask = "ReplicationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationTaskDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationTask.self, forKey: .replicationTask)
        replicationTask = replicationTaskDecoded
    }
}

enum StopReplicationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StorageQuotaExceededFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StorageQuotaExceededFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The storage quota has been exceeded.
public struct StorageQuotaExceededFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageQuotaExceededFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = self.subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = self.subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// In response to a request by the DescribeReplicationSubnetGroups operation, this object identifies a subnet by its given Availability Zone, subnet identifier, and status.
    public struct Subnet: Swift.Equatable {
        /// The Availability Zone of the subnet.
        public var subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone?
        /// The subnet identifier.
        public var subnetIdentifier: Swift.String?
        /// The status of the subnet.
        public var subnetStatus: Swift.String?

        public init(
            subnetAvailabilityZone: DatabaseMigrationClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetAlreadyInUseBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified subnet is already in use.
public struct SubnetAlreadyInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetAlreadyInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes.SupportedEndpointType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case engineDisplayName = "EngineDisplayName"
        case engineName = "EngineName"
        case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
        case supportsCDC = "SupportsCDC"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = self.endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let engineDisplayName = self.engineDisplayName {
            try encodeContainer.encode(engineDisplayName, forKey: .engineDisplayName)
        }
        if let engineName = self.engineName {
            try encodeContainer.encode(engineName, forKey: .engineName)
        }
        if let replicationInstanceEngineMinimumVersion = self.replicationInstanceEngineMinimumVersion {
            try encodeContainer.encode(replicationInstanceEngineMinimumVersion, forKey: .replicationInstanceEngineMinimumVersion)
        }
        if supportsCDC != false {
            try encodeContainer.encode(supportsCDC, forKey: .supportsCDC)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let supportsCDCDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsCDC) ?? false
        supportsCDC = supportsCDCDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ReplicationEndpointTypeValue.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let replicationInstanceEngineMinimumVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceEngineMinimumVersion)
        replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersionDecoded
        let engineDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineDisplayName)
        engineDisplayName = engineDisplayNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information about types of supported endpoints in response to a request by the DescribeEndpointTypes operation. This information includes the type of endpoint, the database engine name, and whether change data capture (CDC) is supported.
    public struct SupportedEndpointType: Swift.Equatable {
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public var engineDisplayName: Swift.String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public var engineName: Swift.String?
        /// The earliest DMS engine version that supports this endpoint engine. Note that endpoint engines released with DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public var replicationInstanceEngineMinimumVersion: Swift.String?
        /// Indicates if change data capture (CDC) is supported.
        public var supportsCDC: Swift.Bool

        public init(
            endpointType: DatabaseMigrationClientTypes.ReplicationEndpointTypeValue? = nil,
            engineDisplayName: Swift.String? = nil,
            engineName: Swift.String? = nil,
            replicationInstanceEngineMinimumVersion: Swift.String? = nil,
            supportsCDC: Swift.Bool = false
        )
        {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }
    }

}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case password = "Password"
        case port = "Port"
        case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
        case secretsManagerSecretId = "SecretsManagerSecretId"
        case serverName = "ServerName"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let secretsManagerAccessRoleArn = self.secretsManagerAccessRoleArn {
            try encodeContainer.encode(secretsManagerAccessRoleArn, forKey: .secretsManagerAccessRoleArn)
        }
        if let secretsManagerSecretId = self.secretsManagerSecretId {
            try encodeContainer.encode(secretsManagerSecretId, forKey: .secretsManagerSecretId)
        }
        if let serverName = self.serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let secretsManagerAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerAccessRoleArn)
        secretsManagerAccessRoleArn = secretsManagerAccessRoleArnDecoded
        let secretsManagerSecretIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerSecretId)
        secretsManagerSecretId = secretsManagerSecretIdDecoded
    }
}

extension DatabaseMigrationClientTypes.SybaseSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SybaseSettings(databaseName: \(Swift.String(describing: databaseName)), port: \(Swift.String(describing: port)), secretsManagerAccessRoleArn: \(Swift.String(describing: secretsManagerAccessRoleArn)), secretsManagerSecretId: \(Swift.String(describing: secretsManagerSecretId)), serverName: \(Swift.String(describing: serverName)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines a SAP ASE endpoint.
    public struct SybaseSettings: Swift.Equatable {
        /// Database name for the endpoint.
        public var databaseName: Swift.String?
        /// Endpoint connection password.
        public var password: Swift.String?
        /// Endpoint TCP port. The default is 5000.
        public var port: Swift.Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SAP ASE endpoint. You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see [Using secrets to access Database Migration Service resources](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Security.html#security-iam-secretsmanager) in the Database Migration Service User Guide.
        public var secretsManagerAccessRoleArn: Swift.String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SAP SAE endpoint connection details.
        public var secretsManagerSecretId: Swift.String?
        /// Fully qualified domain name of the endpoint.
        public var serverName: Swift.String?
        /// Endpoint connection user name.
        public var username: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            password: Swift.String? = nil,
            port: Swift.Int? = nil,
            secretsManagerAccessRoleArn: Swift.String? = nil,
            secretsManagerSecretId: Swift.String? = nil,
            serverName: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }
    }

}

extension DatabaseMigrationClientTypes.TableStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedDdls = "AppliedDdls"
        case appliedDeletes = "AppliedDeletes"
        case appliedInserts = "AppliedInserts"
        case appliedUpdates = "AppliedUpdates"
        case ddls = "Ddls"
        case deletes = "Deletes"
        case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
        case fullLoadEndTime = "FullLoadEndTime"
        case fullLoadErrorRows = "FullLoadErrorRows"
        case fullLoadReloaded = "FullLoadReloaded"
        case fullLoadRows = "FullLoadRows"
        case fullLoadStartTime = "FullLoadStartTime"
        case inserts = "Inserts"
        case lastUpdateTime = "LastUpdateTime"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case tableState = "TableState"
        case updates = "Updates"
        case validationFailedRecords = "ValidationFailedRecords"
        case validationPendingRecords = "ValidationPendingRecords"
        case validationState = "ValidationState"
        case validationStateDetails = "ValidationStateDetails"
        case validationSuspendedRecords = "ValidationSuspendedRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedDdls = self.appliedDdls {
            try encodeContainer.encode(appliedDdls, forKey: .appliedDdls)
        }
        if let appliedDeletes = self.appliedDeletes {
            try encodeContainer.encode(appliedDeletes, forKey: .appliedDeletes)
        }
        if let appliedInserts = self.appliedInserts {
            try encodeContainer.encode(appliedInserts, forKey: .appliedInserts)
        }
        if let appliedUpdates = self.appliedUpdates {
            try encodeContainer.encode(appliedUpdates, forKey: .appliedUpdates)
        }
        if ddls != 0 {
            try encodeContainer.encode(ddls, forKey: .ddls)
        }
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if fullLoadCondtnlChkFailedRows != 0 {
            try encodeContainer.encode(fullLoadCondtnlChkFailedRows, forKey: .fullLoadCondtnlChkFailedRows)
        }
        if let fullLoadEndTime = self.fullLoadEndTime {
            try encodeContainer.encodeTimestamp(fullLoadEndTime, format: .epochSeconds, forKey: .fullLoadEndTime)
        }
        if fullLoadErrorRows != 0 {
            try encodeContainer.encode(fullLoadErrorRows, forKey: .fullLoadErrorRows)
        }
        if let fullLoadReloaded = self.fullLoadReloaded {
            try encodeContainer.encode(fullLoadReloaded, forKey: .fullLoadReloaded)
        }
        if fullLoadRows != 0 {
            try encodeContainer.encode(fullLoadRows, forKey: .fullLoadRows)
        }
        if let fullLoadStartTime = self.fullLoadStartTime {
            try encodeContainer.encodeTimestamp(fullLoadStartTime, format: .epochSeconds, forKey: .fullLoadStartTime)
        }
        if inserts != 0 {
            try encodeContainer.encode(inserts, forKey: .inserts)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableState = self.tableState {
            try encodeContainer.encode(tableState, forKey: .tableState)
        }
        if updates != 0 {
            try encodeContainer.encode(updates, forKey: .updates)
        }
        if validationFailedRecords != 0 {
            try encodeContainer.encode(validationFailedRecords, forKey: .validationFailedRecords)
        }
        if validationPendingRecords != 0 {
            try encodeContainer.encode(validationPendingRecords, forKey: .validationPendingRecords)
        }
        if let validationState = self.validationState {
            try encodeContainer.encode(validationState, forKey: .validationState)
        }
        if let validationStateDetails = self.validationStateDetails {
            try encodeContainer.encode(validationStateDetails, forKey: .validationStateDetails)
        }
        if validationSuspendedRecords != 0 {
            try encodeContainer.encode(validationSuspendedRecords, forKey: .validationSuspendedRecords)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let insertsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inserts) ?? 0
        inserts = insertsDecoded
        let deletesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deletes) ?? 0
        deletes = deletesDecoded
        let updatesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updates) ?? 0
        updates = updatesDecoded
        let ddlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ddls) ?? 0
        ddls = ddlsDecoded
        let appliedInsertsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedInserts)
        appliedInserts = appliedInsertsDecoded
        let appliedDeletesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedDeletes)
        appliedDeletes = appliedDeletesDecoded
        let appliedUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedUpdates)
        appliedUpdates = appliedUpdatesDecoded
        let appliedDdlsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedDdls)
        appliedDdls = appliedDdlsDecoded
        let fullLoadRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadRows) ?? 0
        fullLoadRows = fullLoadRowsDecoded
        let fullLoadCondtnlChkFailedRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadCondtnlChkFailedRows) ?? 0
        fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRowsDecoded
        let fullLoadErrorRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fullLoadErrorRows) ?? 0
        fullLoadErrorRows = fullLoadErrorRowsDecoded
        let fullLoadStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadStartTime)
        fullLoadStartTime = fullLoadStartTimeDecoded
        let fullLoadEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fullLoadEndTime)
        fullLoadEndTime = fullLoadEndTimeDecoded
        let fullLoadReloadedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .fullLoadReloaded)
        fullLoadReloaded = fullLoadReloadedDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tableStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableState)
        tableState = tableStateDecoded
        let validationPendingRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationPendingRecords) ?? 0
        validationPendingRecords = validationPendingRecordsDecoded
        let validationFailedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationFailedRecords) ?? 0
        validationFailedRecords = validationFailedRecordsDecoded
        let validationSuspendedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationSuspendedRecords) ?? 0
        validationSuspendedRecords = validationSuspendedRecordsDecoded
        let validationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationState)
        validationState = validationStateDecoded
        let validationStateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationStateDetails)
        validationStateDetails = validationStateDetailsDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides a collection of table statistics in response to a request by the DescribeTableStatistics operation.
    public struct TableStatistics: Swift.Equatable {
        /// The number of data definition language (DDL) statements used to build and modify the structure of your tables applied on the target.
        public var appliedDdls: Swift.Int?
        /// The number of delete actions applied on a target table.
        public var appliedDeletes: Swift.Int?
        /// The number of insert actions applied on a target table.
        public var appliedInserts: Swift.Int?
        /// The number of update actions applied on a target table.
        public var appliedUpdates: Swift.Int?
        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public var ddls: Swift.Int
        /// The number of delete actions performed on a table.
        public var deletes: Swift.Int
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadCondtnlChkFailedRows: Swift.Int
        /// The time when the full load operation completed.
        public var fullLoadEndTime: ClientRuntime.Date?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public var fullLoadErrorRows: Swift.Int
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public var fullLoadReloaded: Swift.Bool?
        /// The number of rows added during the full load operation.
        public var fullLoadRows: Swift.Int
        /// The time when the full load operation started.
        public var fullLoadStartTime: ClientRuntime.Date?
        /// The number of insert actions performed on a table.
        public var inserts: Swift.Int
        /// The last time a table was updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The schema name.
        public var schemaName: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table is being reloaded
        public var tableState: Swift.String?
        /// The number of update actions performed on a table.
        public var updates: Swift.Int
        /// The number of records that failed validation.
        public var validationFailedRecords: Swift.Int
        /// The number of records that have yet to be validated.
        public var validationPendingRecords: Swift.Int
        /// The validation state of the table. This parameter can have the following values:
        ///
        /// * Not enabled â€“ Validation isn't enabled for the table in the migration task.
        ///
        /// * Pending records â€“ Some records in the table are waiting for validation.
        ///
        /// * Mismatched records â€“ Some records in the table don't match between the source and target.
        ///
        /// * Suspended records â€“ Some records in the table couldn't be validated.
        ///
        /// * No primary key â€“The table couldn't be validated because it has no primary key.
        ///
        /// * Table error â€“ The table wasn't validated because it's in an error state and some data wasn't migrated.
        ///
        /// * Validated â€“ All rows in the table are validated. If the table is updated, the status can change from Validated.
        ///
        /// * Error â€“ The table couldn't be validated because of an unexpected error.
        ///
        /// * Pending validation â€“ The table is waiting validation.
        ///
        /// * Preparing table â€“ Preparing the table enabled in the migration task for validation.
        ///
        /// * Pending revalidation â€“ All rows in the table are pending validation after the table was updated.
        public var validationState: Swift.String?
        /// Additional details about the state of validation.
        public var validationStateDetails: Swift.String?
        /// The number of records that couldn't be validated.
        public var validationSuspendedRecords: Swift.Int

        public init(
            appliedDdls: Swift.Int? = nil,
            appliedDeletes: Swift.Int? = nil,
            appliedInserts: Swift.Int? = nil,
            appliedUpdates: Swift.Int? = nil,
            ddls: Swift.Int = 0,
            deletes: Swift.Int = 0,
            fullLoadCondtnlChkFailedRows: Swift.Int = 0,
            fullLoadEndTime: ClientRuntime.Date? = nil,
            fullLoadErrorRows: Swift.Int = 0,
            fullLoadReloaded: Swift.Bool? = nil,
            fullLoadRows: Swift.Int = 0,
            fullLoadStartTime: ClientRuntime.Date? = nil,
            inserts: Swift.Int = 0,
            lastUpdateTime: ClientRuntime.Date? = nil,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableState: Swift.String? = nil,
            updates: Swift.Int = 0,
            validationFailedRecords: Swift.Int = 0,
            validationPendingRecords: Swift.Int = 0,
            validationState: Swift.String? = nil,
            validationStateDetails: Swift.String? = nil,
            validationSuspendedRecords: Swift.Int = 0
        )
        {
            self.appliedDdls = appliedDdls
            self.appliedDeletes = appliedDeletes
            self.appliedInserts = appliedInserts
            self.appliedUpdates = appliedUpdates
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }
    }

}

extension DatabaseMigrationClientTypes.TableToReload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaName = "SchemaName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides the name of the schema and table to be reloaded.
    public struct TableToReload: Swift.Equatable {
        /// The schema name of the table to be reloaded.
        /// This member is required.
        public var schemaName: Swift.String?
        /// The table name of the table to be reloaded.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.schemaName = schemaName
            self.tableName = tableName
        }
    }

}

extension DatabaseMigrationClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case resourceArn = "ResourceArn"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// A user-defined key-value pair that describes metadata added to an DMS resource and that is used by operations such as the following:
    ///
    /// * AddTagsToResource
    ///
    /// * ListTagsForResource
    ///
    /// * RemoveTagsFromResource
    public struct Tag: Swift.Equatable {
        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var key: Swift.String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the resource for which the tag is created.
        public var resourceArn: Swift.String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.resourceArn = resourceArn
            self.value = value
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum TargetDbType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multipleDatabases
        case specificDatabase
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDbType] {
            return [
                .multipleDatabases,
                .specificDatabase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multipleDatabases: return "multiple-databases"
            case .specificDatabase: return "specific-database"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDbType(rawValue: rawValue) ?? TargetDbType.sdkUnknown(rawValue)
        }
    }
}

extension TestConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointArn = self.endpointArn {
            try encodeContainer.encode(endpointArn, forKey: .endpointArn)
        }
        if let replicationInstanceArn = self.replicationInstanceArn {
            try encodeContainer.encode(replicationInstanceArn, forKey: .replicationInstanceArn)
        }
    }
}

extension TestConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct TestConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the replication instance.
    /// This member is required.
    public var replicationInstanceArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil,
        replicationInstanceArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
        self.replicationInstanceArn = replicationInstanceArn
    }
}

struct TestConnectionInputBody: Swift.Equatable {
    let replicationInstanceArn: Swift.String?
    let endpointArn: Swift.String?
}

extension TestConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
        case replicationInstanceArn = "ReplicationInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationInstanceArn)
        replicationInstanceArn = replicationInstanceArnDecoded
        let endpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointArn)
        endpointArn = endpointArnDecoded
    }
}

extension TestConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

///
public struct TestConnectionOutput: Swift.Equatable {
    /// The connection tested.
    public var connection: DatabaseMigrationClientTypes.Connection?

    public init(
        connection: DatabaseMigrationClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct TestConnectionOutputBody: Swift.Equatable {
    let connection: DatabaseMigrationClientTypes.Connection?
}

extension TestConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

enum TestConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSKeyNotAccessibleFault": return try await KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundFault": return try await ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceQuotaExceededFault": return try await ResourceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DatabaseMigrationClientTypes.TimestreamSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case databaseName = "DatabaseName"
        case enableMagneticStoreWrites = "EnableMagneticStoreWrites"
        case magneticDuration = "MagneticDuration"
        case memoryDuration = "MemoryDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdcInsertsAndUpdates = self.cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let enableMagneticStoreWrites = self.enableMagneticStoreWrites {
            try encodeContainer.encode(enableMagneticStoreWrites, forKey: .enableMagneticStoreWrites)
        }
        if let magneticDuration = self.magneticDuration {
            try encodeContainer.encode(magneticDuration, forKey: .magneticDuration)
        }
        if let memoryDuration = self.memoryDuration {
            try encodeContainer.encode(memoryDuration, forKey: .memoryDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let memoryDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryDuration)
        memoryDuration = memoryDurationDecoded
        let magneticDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .magneticDuration)
        magneticDuration = magneticDurationDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let enableMagneticStoreWritesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMagneticStoreWrites)
        enableMagneticStoreWrites = enableMagneticStoreWritesDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Provides information that defines an Amazon Timestream endpoint.
    public struct TimestreamSettings: Swift.Equatable {
        /// Set this attribute to true to specify that DMS only applies inserts and updates, and not deletes. Amazon Timestream does not allow deleting records, so if this value is false, DMS nulls out the corresponding record in the Timestream database rather than deleting it.
        public var cdcInsertsAndUpdates: Swift.Bool?
        /// Database name for the endpoint.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Set this attribute to true to enable memory store writes. When this value is false, DMS does not write records that are older in days than the value specified in MagneticDuration, because Amazon Timestream does not allow memory writes by default. For more information, see [Storage](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html) in the [Amazon Timestream Developer Guide](https://docs.aws.amazon.com/timestream/latest/developerguide/).
        public var enableMagneticStoreWrites: Swift.Bool?
        /// Set this attribute to specify the default magnetic duration applied to the Amazon Timestream tables in days. This is the number of days that records remain in magnetic store before being discarded. For more information, see [Storage](https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html) in the [Amazon Timestream Developer Guide](https://docs.aws.amazon.com/timestream/latest/developerguide/).
        /// This member is required.
        public var magneticDuration: Swift.Int?
        /// Set this attribute to specify the length of time to store all of the tables in memory that are migrated into Amazon Timestream from the source database. Time is measured in units of hours. When Timestream data comes in, it first resides in memory for the specified duration, which allows quick access to it.
        /// This member is required.
        public var memoryDuration: Swift.Int?

        public init(
            cdcInsertsAndUpdates: Swift.Bool? = nil,
            databaseName: Swift.String? = nil,
            enableMagneticStoreWrites: Swift.Bool? = nil,
            magneticDuration: Swift.Int? = nil,
            memoryDuration: Swift.Int? = nil
        )
        {
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.databaseName = databaseName
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticDuration = magneticDuration
            self.memoryDuration = memoryDuration
        }
    }

}

extension DatabaseMigrationClientTypes {
    public enum TlogAccessMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backuponly
        case preferbackup
        case prefertlog
        case tlogonly
        case sdkUnknown(Swift.String)

        public static var allCases: [TlogAccessMode] {
            return [
                .backuponly,
                .preferbackup,
                .prefertlog,
                .tlogonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backuponly: return "BackupOnly"
            case .preferbackup: return "PreferBackup"
            case .prefertlog: return "PreferTlog"
            case .tlogonly: return "TlogOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TlogAccessMode(rawValue: rawValue) ?? TlogAccessMode.sdkUnknown(rawValue)
        }
    }
}

extension UpdateSubscriptionsToEventBridgeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceMove = "ForceMove"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forceMove = self.forceMove {
            try encodeContainer.encode(forceMove, forKey: .forceMove)
        }
    }
}

extension UpdateSubscriptionsToEventBridgeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct UpdateSubscriptionsToEventBridgeInput: Swift.Equatable {
    /// When set to true, this operation migrates DMS subscriptions for Amazon SNS notifications no matter what your replication instance version is. If not set or set to false, this operation runs only when all your replication instances are from DMS version 3.4.5 or higher.
    public var forceMove: Swift.Bool?

    public init(
        forceMove: Swift.Bool? = nil
    )
    {
        self.forceMove = forceMove
    }
}

struct UpdateSubscriptionsToEventBridgeInputBody: Swift.Equatable {
    let forceMove: Swift.Bool?
}

extension UpdateSubscriptionsToEventBridgeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forceMove = "ForceMove"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceMoveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceMove)
        forceMove = forceMoveDecoded
    }
}

extension UpdateSubscriptionsToEventBridgeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriptionsToEventBridgeOutputBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

///
public struct UpdateSubscriptionsToEventBridgeOutput: Swift.Equatable {
    /// A string that indicates how many event subscriptions were migrated and how many remain to be migrated.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

struct UpdateSubscriptionsToEventBridgeOutputBody: Swift.Equatable {
    let result: Swift.String?
}

extension UpdateSubscriptionsToEventBridgeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result = "Result"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

enum UpdateSubscriptionsToEventBridgeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedFault": return try await AccessDeniedFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceStateFault": return try await InvalidResourceStateFault(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradeDependencyFailureFault {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpgradeDependencyFailureFaultBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An upgrade dependency is preventing the database migration.
public struct UpgradeDependencyFailureFault: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UpgradeDependencyFailureFault" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UpgradeDependencyFailureFaultBody: Swift.Equatable {
    let message: Swift.String?
}

extension UpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DatabaseMigrationClientTypes {
    public enum VersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case outdated
        case unsupported
        case upToDate
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionStatus] {
            return [
                .outdated,
                .unsupported,
                .upToDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .outdated: return "OUTDATED"
            case .unsupported: return "UNSUPPORTED"
            case .upToDate: return "UP_TO_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionStatus(rawValue: rawValue) ?? VersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DatabaseMigrationClientTypes.VpcSecurityGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DatabaseMigrationClientTypes {
    /// Describes the status of a security group associated with the virtual private cloud (VPC) hosting your replication and DB instances.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The VPC security group ID.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}
