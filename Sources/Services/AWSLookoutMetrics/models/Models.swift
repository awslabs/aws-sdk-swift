// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaConfiguration = "LambdaConfiguration"
        case snsConfiguration = "SNSConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConfiguration = self.lambdaConfiguration {
            try encodeContainer.encode(lambdaConfiguration, forKey: .lambdaConfiguration)
        }
        if let snsConfiguration = self.snsConfiguration {
            try encodeContainer.encode(snsConfiguration, forKey: .snsConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.SNSConfiguration.self, forKey: .snsConfiguration)
        snsConfiguration = snsConfigurationDecoded
        let lambdaConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.LambdaConfiguration.self, forKey: .lambdaConfiguration)
        lambdaConfiguration = lambdaConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A configuration that specifies the action to perform when anomalies are detected.
    public struct Action: Swift.Equatable {
        /// A configuration for an AWS Lambda channel.
        public var lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration?
        /// A configuration for an Amazon SNS channel.
        public var snsConfiguration: LookoutMetricsClientTypes.SNSConfiguration?

        public init (
            lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration? = nil,
            snsConfiguration: LookoutMetricsClientTypes.SNSConfiguration? = nil
        )
        {
            self.lambdaConfiguration = lambdaConfiguration
            self.snsConfiguration = snsConfiguration
        }
    }

}

extension ActivateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension ActivateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ActivateAnomalyDetector"
    }
}

public struct ActivateAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct ActivateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension ActivateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension ActivateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ActivateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ActivateAnomalyDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension LookoutMetricsClientTypes {
    public enum AggregationFunction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFunction] {
            return [
                .avg,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationFunction(rawValue: rawValue) ?? AggregationFunction.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.Alert: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertArn = "AlertArn"
        case alertDescription = "AlertDescription"
        case alertFilters = "AlertFilters"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertArn = self.alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertDescription = self.alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertFilters = self.alertFilters {
            try encodeContainer.encode(alertFilters, forKey: .alertFilters)
        }
        if let alertName = self.alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = self.alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = self.alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .alertSensitivityThreshold) ?? 0
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let alertFiltersDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertFilters.self, forKey: .alertFilters)
        alertFilters = alertFiltersDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A configuration for Amazon SNS-integrated notifications.
    public struct Alert: Swift.Equatable {
        /// Action that will be triggered when there is an alert.
        public var action: LookoutMetricsClientTypes.Action?
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// A description of the alert.
        public var alertDescription: Swift.String?
        /// The configuration of the alert filters, containing MetricList and DimensionFilter.
        public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: ClientRuntime.Date?

        public init (
            action: LookoutMetricsClientTypes.Action? = nil,
            alertArn: Swift.String? = nil,
            alertDescription: Swift.String? = nil,
            alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertFilters = alertFilters
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
        }
    }

}

extension LookoutMetricsClientTypes.AlertFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionFilterList = "DimensionFilterList"
        case metricList = "MetricList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionFilterList = dimensionFilterList {
            var dimensionFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionFilterList)
            for dimensionfilter0 in dimensionFilterList {
                try dimensionFilterListContainer.encode(dimensionfilter0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metricname0 in metricList {
                try metricListContainer.encode(metricname0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metricList)
        var metricListDecoded0:[Swift.String]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [Swift.String]()
            for string0 in metricListContainer {
                if let string0 = string0 {
                    metricListDecoded0?.append(string0)
                }
            }
        }
        metricList = metricListDecoded0
        let dimensionFilterListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionFilter?].self, forKey: .dimensionFilterList)
        var dimensionFilterListDecoded0:[LookoutMetricsClientTypes.DimensionFilter]? = nil
        if let dimensionFilterListContainer = dimensionFilterListContainer {
            dimensionFilterListDecoded0 = [LookoutMetricsClientTypes.DimensionFilter]()
            for structure0 in dimensionFilterListContainer {
                if let structure0 = structure0 {
                    dimensionFilterListDecoded0?.append(structure0)
                }
            }
        }
        dimensionFilterList = dimensionFilterListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// The configuration of the alert filters.
    public struct AlertFilters: Swift.Equatable {
        /// The list of DimensionFilter objects that are used for dimension-based filtering.
        public var dimensionFilterList: [LookoutMetricsClientTypes.DimensionFilter]?
        /// The list of measures that you want to get alerts for.
        public var metricList: [Swift.String]?

        public init (
            dimensionFilterList: [LookoutMetricsClientTypes.DimensionFilter]? = nil,
            metricList: [Swift.String]? = nil
        )
        {
            self.dimensionFilterList = dimensionFilterList
            self.metricList = metricList
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AlertStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertStatus(rawValue: rawValue) ?? AlertStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AlertSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case alertStatus = "AlertStatus"
        case alertType = "AlertType"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = self.alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertName = self.alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let alertStatus = self.alertStatus {
            try encodeContainer.encode(alertStatus.rawValue, forKey: .alertStatus)
        }
        if let alertType = self.alertType {
            try encodeContainer.encode(alertType.rawValue, forKey: .alertType)
        }
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .alertSensitivityThreshold) ?? 0
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertType.self, forKey: .alertType)
        alertType = alertTypeDecoded
        let alertStatusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertStatus.self, forKey: .alertStatus)
        alertStatus = alertStatusDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Provides a summary of an alert's configuration.
    public struct AlertSummary: Swift.Equatable {
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The alert's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            alertArn: Swift.String? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.alertArn = alertArn
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AlertType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambda
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertType] {
            return [
                .lambda,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertType(rawValue: rawValue) ?? AlertType.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes {
    public enum AnomalyDetectionTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case failedToSchedule
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectionTaskStatus] {
            return [
                .completed,
                .failed,
                .failedToSchedule,
                .inProgress,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyDetectionTaskStatus(rawValue: rawValue) ?? AnomalyDetectionTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = self.anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfig: Swift.Equatable {
        /// The frequency at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init (
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyDetectorConfigSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorFrequency = "AnomalyDetectorFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorFrequency = self.anomalyDetectorFrequency {
            try encodeContainer.encode(anomalyDetectorFrequency.rawValue, forKey: .anomalyDetectorFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .anomalyDetectorFrequency)
        anomalyDetectorFrequency = anomalyDetectorFrequencyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfigSummary: Swift.Equatable {
        /// The interval at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init (
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetDataQualityMetricList = "MetricSetDataQualityMetricList"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricSetDataQualityMetricList = metricSetDataQualityMetricList {
            var metricSetDataQualityMetricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricSetDataQualityMetricList)
            for metricsetdataqualitymetric0 in metricSetDataQualityMetricList {
                try metricSetDataQualityMetricListContainer.encode(metricsetdataqualitymetric0)
            }
        }
        if let startTimestamp = self.startTimestamp {
            try encodeContainer.encodeTimestamp(startTimestamp, format: .epochSeconds, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let metricSetDataQualityMetricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetDataQualityMetric?].self, forKey: .metricSetDataQualityMetricList)
        var metricSetDataQualityMetricListDecoded0:[LookoutMetricsClientTypes.MetricSetDataQualityMetric]? = nil
        if let metricSetDataQualityMetricListContainer = metricSetDataQualityMetricListContainer {
            metricSetDataQualityMetricListDecoded0 = [LookoutMetricsClientTypes.MetricSetDataQualityMetric]()
            for structure0 in metricSetDataQualityMetricListContainer {
                if let structure0 = structure0 {
                    metricSetDataQualityMetricListDecoded0?.append(structure0)
                }
            }
        }
        metricSetDataQualityMetricList = metricSetDataQualityMetricListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated details about the data quality metrics collected for the AnomalyDetectorArn provided in the [GetDataQualityMetrics] object.
    public struct AnomalyDetectorDataQualityMetric: Swift.Equatable {
        /// An array of DataQualityMetricList objects. Each object in the array contains information about a data quality metric.
        public var metricSetDataQualityMetricList: [LookoutMetricsClientTypes.MetricSetDataQualityMetric]?
        /// The start time for the data quality metrics collection.
        public var startTimestamp: ClientRuntime.Date?

        public init (
            metricSetDataQualityMetricList: [LookoutMetricsClientTypes.MetricSetDataQualityMetric]? = nil,
            startTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.metricSetDataQualityMetricList = metricSetDataQualityMetricList
            self.startTimestamp = startTimestamp
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum AnomalyDetectorFailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activationFailure
        case backTestActivationFailure
        case deactivationFailure
        case deletionFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectorFailureType] {
            return [
                .activationFailure,
                .backTestActivationFailure,
                .deactivationFailure,
                .deletionFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activationFailure: return "ACTIVATION_FAILURE"
            case .backTestActivationFailure: return "BACK_TEST_ACTIVATION_FAILURE"
            case .deactivationFailure: return "DEACTIVATION_FAILURE"
            case .deletionFailure: return "DELETION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyDetectorFailureType(rawValue: rawValue) ?? AnomalyDetectorFailureType.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes {
    public enum AnomalyDetectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case backTestActivating
        case backTestActive
        case backTestComplete
        case deactivated
        case deactivating
        case deleting
        case failed
        case inactive
        case learning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectorStatus] {
            return [
                .activating,
                .active,
                .backTestActivating,
                .backTestActive,
                .backTestComplete,
                .deactivated,
                .deactivating,
                .deleting,
                .failed,
                .inactive,
                .learning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .backTestActivating: return "BACK_TEST_ACTIVATING"
            case .backTestActive: return "BACK_TEST_ACTIVE"
            case .backTestComplete: return "BACK_TEST_COMPLETE"
            case .deactivated: return "DEACTIVATED"
            case .deactivating: return "DEACTIVATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .learning: return "LEARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyDetectorStatus(rawValue: rawValue) ?? AnomalyDetectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorDescription = self.anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = self.anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about an an anomaly detector.
    public struct AnomalyDetectorSummary: Swift.Equatable {
        /// The ARN of the detector.
        public var anomalyDetectorArn: Swift.String?
        /// A description of the detector.
        public var anomalyDetectorDescription: Swift.String?
        /// The name of the detector.
        public var anomalyDetectorName: Swift.String?
        /// The time at which the detector was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the detector was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The status of detector.
        public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?
        /// The detector's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            anomalyDetectorArn: Swift.String? = nil,
            anomalyDetectorDescription: Swift.String? = nil,
            anomalyDetectorName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.status = status
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case metricLevelImpactList = "MetricLevelImpactList"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = self.anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let metricLevelImpactList = metricLevelImpactList {
            var metricLevelImpactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricLevelImpactList)
            for metriclevelimpact0 in metricLevelImpactList {
                try metricLevelImpactListContainer.encode(metriclevelimpact0)
            }
        }
        if let primaryMetricName = self.primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
        let metricLevelImpactListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricLevelImpact?].self, forKey: .metricLevelImpactList)
        var metricLevelImpactListDecoded0:[LookoutMetricsClientTypes.MetricLevelImpact]? = nil
        if let metricLevelImpactListContainer = metricLevelImpactListContainer {
            metricLevelImpactListDecoded0 = [LookoutMetricsClientTypes.MetricLevelImpact]()
            for structure0 in metricLevelImpactListContainer {
                if let structure0 = structure0 {
                    metricLevelImpactListDecoded0?.append(structure0)
                }
            }
        }
        metricLevelImpactList = metricLevelImpactListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// A group of anomalous metrics
    public struct AnomalyGroup: Swift.Equatable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// A list of measures affected by the anomaly.
        public var metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.metricLevelImpactList = metricLevelImpactList
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationStartDate = "EvaluationStartDate"
        case itemizedMetricStatsList = "ItemizedMetricStatsList"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationStartDate = self.evaluationStartDate {
            try encodeContainer.encode(evaluationStartDate, forKey: .evaluationStartDate)
        }
        if let itemizedMetricStatsList = itemizedMetricStatsList {
            var itemizedMetricStatsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .itemizedMetricStatsList)
            for itemizedmetricstats0 in itemizedMetricStatsList {
                try itemizedMetricStatsListContainer.encode(itemizedmetricstats0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationStartDate)
        evaluationStartDate = evaluationStartDateDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
        let itemizedMetricStatsListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ItemizedMetricStats?].self, forKey: .itemizedMetricStatsList)
        var itemizedMetricStatsListDecoded0:[LookoutMetricsClientTypes.ItemizedMetricStats]? = nil
        if let itemizedMetricStatsListContainer = itemizedMetricStatsListContainer {
            itemizedMetricStatsListDecoded0 = [LookoutMetricsClientTypes.ItemizedMetricStats]()
            for structure0 in itemizedMetricStatsListContainer {
                if let structure0 = structure0 {
                    itemizedMetricStatsListDecoded0?.append(structure0)
                }
            }
        }
        itemizedMetricStatsList = itemizedMetricStatsListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated statistics for a group of anomalous metrics.
    public struct AnomalyGroupStatistics: Swift.Equatable {
        /// The start of the time range that was searched.
        public var evaluationStartDate: Swift.String?
        /// Statistics for individual metrics within the group.
        public var itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]?
        /// The number of groups found.
        public var totalCount: Swift.Int

        public init (
            evaluationStartDate: Swift.String? = nil,
            itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.evaluationStartDate = evaluationStartDate
            self.itemizedMetricStatsList = itemizedMetricStatsList
            self.totalCount = totalCount
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case anomalyGroupScore = "AnomalyGroupScore"
        case endTime = "EndTime"
        case primaryMetricName = "PrimaryMetricName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let anomalyGroupScore = self.anomalyGroupScore {
            try encodeContainer.encode(anomalyGroupScore, forKey: .anomalyGroupScore)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let primaryMetricName = self.primaryMetricName {
            try encodeContainer.encode(primaryMetricName, forKey: .primaryMetricName)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyGroupScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .anomalyGroupScore)
        anomalyGroupScore = anomalyGroupScoreDecoded
        let primaryMetricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMetricName)
        primaryMetricName = primaryMetricNameDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a group of anomalous metrics.
    public struct AnomalyGroupSummary: Swift.Equatable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeries: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An anomalous metric in an anomaly group.
    public struct AnomalyGroupTimeSeries: Swift.Equatable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let isAnomaly = self.isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Feedback for an anomalous metric.
    public struct AnomalyGroupTimeSeriesFeedback: Swift.Equatable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// Feedback on whether the metric is a legitimate anomaly.
        /// This member is required.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init (
            anomalyGroupId: Swift.String? = nil,
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.AppFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName = "FlowName"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about an Amazon AppFlow flow datasource.
    public struct AppFlowConfig: Swift.Equatable {
        /// name of the flow.
        public var flowName: Swift.String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the flow.
        public var roleArn: Swift.String?

        public init (
            flowName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.flowName = flowName
            self.roleArn = roleArn
        }
    }

}

extension LookoutMetricsClientTypes.AthenaSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestConfiguration = "BackTestConfiguration"
        case dataCatalog = "DataCatalog"
        case databaseName = "DatabaseName"
        case roleArn = "RoleArn"
        case s3ResultsPath = "S3ResultsPath"
        case tableName = "TableName"
        case workGroupName = "WorkGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestConfiguration = self.backTestConfiguration {
            try encodeContainer.encode(backTestConfiguration, forKey: .backTestConfiguration)
        }
        if let dataCatalog = self.dataCatalog {
            try encodeContainer.encode(dataCatalog, forKey: .dataCatalog)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ResultsPath = self.s3ResultsPath {
            try encodeContainer.encode(s3ResultsPath, forKey: .s3ResultsPath)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let workGroupName = self.workGroupName {
            try encodeContainer.encode(workGroupName, forKey: .workGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dataCatalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataCatalog)
        dataCatalog = dataCatalogDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let workGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroupName)
        workGroupName = workGroupNameDecoded
        let s3ResultsPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResultsPath)
        s3ResultsPath = s3ResultsPathDecoded
        let backTestConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.BackTestConfiguration.self, forKey: .backTestConfiguration)
        backTestConfiguration = backTestConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about an Amazon Athena datasource.
    public struct AthenaSourceConfig: Swift.Equatable {
        /// Settings for backtest mode.
        public var backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration?
        /// The database's data catalog.
        public var dataCatalog: Swift.String?
        /// The database's name.
        public var databaseName: Swift.String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the data.
        public var roleArn: Swift.String?
        /// The database's results path.
        public var s3ResultsPath: Swift.String?
        /// The database's table name.
        public var tableName: Swift.String?
        /// The database's work group name.
        public var workGroupName: Swift.String?

        public init (
            backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration? = nil,
            dataCatalog: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3ResultsPath: Swift.String? = nil,
            tableName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.backTestConfiguration = backTestConfiguration
            self.dataCatalog = dataCatalog
            self.databaseName = databaseName
            self.roleArn = roleArn
            self.s3ResultsPath = s3ResultsPath
            self.tableName = tableName
            self.workGroupName = workGroupName
        }
    }

}

extension LookoutMetricsClientTypes.AttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case b = "B"
        case bs = "BS"
        case n = "N"
        case ns = "NS"
        case s = "S"
        case ss = "SS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let b = self.b {
            try encodeContainer.encode(b, forKey: .b)
        }
        if let bs = bs {
            var bsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bs)
            for binaryattributevalue0 in bs {
                try bsContainer.encode(binaryattributevalue0)
            }
        }
        if let n = self.n {
            try encodeContainer.encode(n, forKey: .n)
        }
        if let ns = ns {
            var nsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ns)
            for numberattributevalue0 in ns {
                try nsContainer.encode(numberattributevalue0)
            }
        }
        if let s = self.s {
            try encodeContainer.encode(s, forKey: .s)
        }
        if let ss = ss {
            var ssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ss)
            for stringattributevalue0 in ss {
                try ssContainer.encode(stringattributevalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s)
        s = sDecoded
        let nDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .n)
        n = nDecoded
        let bDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .b)
        b = bDecoded
        let ssContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ss)
        var ssDecoded0:[Swift.String]? = nil
        if let ssContainer = ssContainer {
            ssDecoded0 = [Swift.String]()
            for string0 in ssContainer {
                if let string0 = string0 {
                    ssDecoded0?.append(string0)
                }
            }
        }
        ss = ssDecoded0
        let nsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ns)
        var nsDecoded0:[Swift.String]? = nil
        if let nsContainer = nsContainer {
            nsDecoded0 = [Swift.String]()
            for string0 in nsContainer {
                if let string0 = string0 {
                    nsDecoded0?.append(string0)
                }
            }
        }
        ns = nsDecoded0
        let bsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bs)
        var bsDecoded0:[Swift.String]? = nil
        if let bsContainer = bsContainer {
            bsDecoded0 = [Swift.String]()
            for string0 in bsContainer {
                if let string0 = string0 {
                    bsDecoded0?.append(string0)
                }
            }
        }
        bs = bsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// An attribute value.
    public struct AttributeValue: Swift.Equatable {
        /// A binary value.
        public var b: Swift.String?
        /// A list of binary values.
        public var bs: [Swift.String]?
        /// A number.
        public var n: Swift.String?
        /// A list of numbers.
        public var ns: [Swift.String]?
        /// A string.
        public var s: Swift.String?
        /// A list of strings.
        public var ss: [Swift.String]?

        public init (
            b: Swift.String? = nil,
            bs: [Swift.String]? = nil,
            n: Swift.String? = nil,
            ns: [Swift.String]? = nil,
            s: Swift.String? = nil,
            ss: [Swift.String]? = nil
        )
        {
            self.b = b
            self.bs = bs
            self.n = n
            self.ns = ns
            self.s = s
            self.ss = ss
        }
    }

}

extension LookoutMetricsClientTypes.AutoDetectionMetricSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SourceConfig = self.s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AutoDetectionS3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An auto detection metric source.
    public struct AutoDetectionMetricSource: Swift.Equatable {
        /// The source's source config.
        public var s3SourceConfig: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig?

        public init (
            s3SourceConfig: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig? = nil
        )
        {
            self.s3SourceConfig = s3SourceConfig
        }
    }

}

extension LookoutMetricsClientTypes.AutoDetectionS3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case historicalDataPathList = "HistoricalDataPathList"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapath0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapath0)
            }
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpath0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpath0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatedPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[Swift.String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [Swift.String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[Swift.String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [Swift.String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// An auto detection source config.
    public struct AutoDetectionS3SourceConfig: Swift.Equatable {
        /// The config's historical data path list.
        public var historicalDataPathList: [Swift.String]?
        /// The config's templated path list.
        public var templatedPathList: [Swift.String]?

        public init (
            historicalDataPathList: [Swift.String]? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.historicalDataPathList = historicalDataPathList
            self.templatedPathList = templatedPathList
        }
    }

}

extension BackTestAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension BackTestAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BackTestAnomalyDetector"
    }
}

public struct BackTestAnomalyDetectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct BackTestAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension BackTestAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension BackTestAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BackTestAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BackTestAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BackTestAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct BackTestAnomalyDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension LookoutMetricsClientTypes.BackTestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runBackTestMode = "RunBackTestMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runBackTestMode = self.runBackTestMode {
            try encodeContainer.encode(runBackTestMode, forKey: .runBackTestMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runBackTestModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runBackTestMode)
        runBackTestMode = runBackTestModeDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Settings for backtest mode.
    public struct BackTestConfiguration: Swift.Equatable {
        /// Run a backtest instead of monitoring new data.
        /// This member is required.
        public var runBackTestMode: Swift.Bool?

        public init (
            runBackTestMode: Swift.Bool? = nil
        )
        {
            self.runBackTestMode = runBackTestMode
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum CSVFileCompression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CSVFileCompression] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CSVFileCompression(rawValue: rawValue) ?? CSVFileCompression.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.CloudWatchConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backTestConfiguration = "BackTestConfiguration"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestConfiguration = self.backTestConfiguration {
            try encodeContainer.encode(backTestConfiguration, forKey: .backTestConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let backTestConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.BackTestConfiguration.self, forKey: .backTestConfiguration)
        backTestConfiguration = backTestConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about an Amazon CloudWatch datasource.
    public struct CloudWatchConfig: Swift.Equatable {
        /// Settings for backtest mode.
        public var backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.
        public var roleArn: Swift.String?

        public init (
            backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.backTestConfiguration = backTestConfiguration
            self.roleArn = roleArn
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum Confidence: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Confidence] {
            return [
                .high,
                .low,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Confidence(rawValue: rawValue) ?? Confidence.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutMetricsClientTypes.ContributionMatrix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionContributionList = "DimensionContributionList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionContributionList = dimensionContributionList {
            var dimensionContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionContributionList)
            for dimensioncontribution0 in dimensionContributionList {
                try dimensionContributionListContainer.encode(dimensioncontribution0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionContributionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionContribution?].self, forKey: .dimensionContributionList)
        var dimensionContributionListDecoded0:[LookoutMetricsClientTypes.DimensionContribution]? = nil
        if let dimensionContributionListContainer = dimensionContributionListContainer {
            dimensionContributionListDecoded0 = [LookoutMetricsClientTypes.DimensionContribution]()
            for structure0 in dimensionContributionListContainer {
                if let structure0 = structure0 {
                    dimensionContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionContributionList = dimensionContributionListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about dimensions that contributed to an anomaly.
    public struct ContributionMatrix: Swift.Equatable {
        /// A list of contributing dimensions.
        public var dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]?

        public init (
            dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]? = nil
        )
        {
            self.dimensionContributionList = dimensionContributionList
        }
    }

}

extension CreateAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertFilters = "AlertFilters"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertDescription = self.alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertFilters = self.alertFilters {
            try encodeContainer.encode(alertFilters, forKey: .alertFilters)
        }
        if let alertName = self.alertName {
            try encodeContainer.encode(alertName, forKey: .alertName)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateAlert"
    }
}

public struct CreateAlertInput: Swift.Equatable {
    /// Action that will be triggered when there is an alert.
    /// This member is required.
    public var action: LookoutMetricsClientTypes.Action?
    /// A description of the alert.
    public var alertDescription: Swift.String?
    /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
    public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
    /// The name of the alert.
    /// This member is required.
    public var alertName: Swift.String?
    /// An integer from 0 to 100 specifying the alert sensitivity threshold.
    public var alertSensitivityThreshold: Swift.Int
    /// The ARN of the detector to which the alert is attached.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the alert.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: LookoutMetricsClientTypes.Action? = nil,
        alertDescription: Swift.String? = nil,
        alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
        alertName: Swift.String? = nil,
        alertSensitivityThreshold: Swift.Int = 0,
        anomalyDetectorArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.alertDescription = alertDescription
        self.alertFilters = alertFilters
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.anomalyDetectorArn = anomalyDetectorArn
        self.tags = tags
    }
}

struct CreateAlertInputBody: Swift.Equatable {
    let alertName: Swift.String?
    let alertSensitivityThreshold: Swift.Int
    let alertDescription: Swift.String?
    let anomalyDetectorArn: Swift.String?
    let action: LookoutMetricsClientTypes.Action?
    let tags: [Swift.String:Swift.String]?
    let alertFilters: LookoutMetricsClientTypes.AlertFilters?
}

extension CreateAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertDescription = "AlertDescription"
        case alertFilters = "AlertFilters"
        case alertName = "AlertName"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertName)
        alertName = alertNameDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .alertSensitivityThreshold) ?? 0
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let alertFiltersDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertFilters.self, forKey: .alertFilters)
        alertFilters = alertFiltersDecoded
    }
}

extension CreateAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAlertOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertArn = output.alertArn
        } else {
            self.alertArn = nil
        }
    }
}

public struct CreateAlertOutputResponse: Swift.Equatable {
    /// The ARN of the alert.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct CreateAlertOutputResponseBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension CreateAlertOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension CreateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorConfig = self.anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = self.anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let anomalyDetectorName = self.anomalyDetectorName {
            try encodeContainer.encode(anomalyDetectorName, forKey: .anomalyDetectorName)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateAnomalyDetector"
    }
}

public struct CreateAnomalyDetectorInput: Swift.Equatable {
    /// Contains information about the configuration of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    /// This member is required.
    public var anomalyDetectorName: Swift.String?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the anomaly detector.
    public var tags: [Swift.String:Swift.String]?

    public init (
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

struct CreateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorName: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    let kmsKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case kmsKeyArn = "KmsKeyArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct CreateAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct CreateAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension CreateAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension CreateMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionFilterList = "DimensionFilterList"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let dimensionFilterList = dimensionFilterList {
            var dimensionFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionFilterList)
            for metricsetdimensionfilter0 in dimensionFilterList {
                try dimensionFilterListContainer.encode(metricsetdimensionfilter0)
            }
        }
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for columnname0 in dimensionList {
                try dimensionListContainer.encode(columnname0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metric0 in metricList {
                try metricListContainer.encode(metric0)
            }
        }
        if let metricSetDescription = self.metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = self.metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSetName = self.metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let metricSource = self.metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timestampColumn = self.timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }
}

extension CreateMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateMetricSet"
    }
}

public struct CreateMetricSetInput: Swift.Equatable {
    /// The ARN of the anomaly detector that will use the dataset.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of filters that specify which data is kept for anomaly detection.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// A list of the fields you want to treat as dimensions.
    public var dimensionList: [Swift.String]?
    /// A list of metrics that the dataset will contain.
    /// This member is required.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// A description of the dataset you are creating.
    public var metricSetDescription: Swift.String?
    /// The frequency with which the source data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    /// This member is required.
    public var metricSetName: Swift.String?
    /// Contains information about how the source data should be interpreted.
    /// This member is required.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the dataset.
    public var tags: [Swift.String:Swift.String]?
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which your source data was recorded.
    public var timezone: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.tags = tags
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct CreateMetricSetInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let metricSetName: Swift.String?
    let metricSetDescription: Swift.String?
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let offset: Swift.Int?
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
    let timezone: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
}

extension CreateMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case dimensionFilterList = "DimensionFilterList"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case tags = "Tags"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let dimensionFilterListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetDimensionFilter?].self, forKey: .dimensionFilterList)
        var dimensionFilterListDecoded0:[LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil
        if let dimensionFilterListContainer = dimensionFilterListContainer {
            dimensionFilterListDecoded0 = [LookoutMetricsClientTypes.MetricSetDimensionFilter]()
            for structure0 in dimensionFilterListContainer {
                if let structure0 = structure0 {
                    dimensionFilterListDecoded0?.append(structure0)
                }
            }
        }
        dimensionFilterList = dimensionFilterListDecoded0
    }
}

extension CreateMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct CreateMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct CreateMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension CreateMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension LookoutMetricsClientTypes.CsvFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case fileCompression = "FileCompression"
        case headerList = "HeaderList"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = self.charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let containsHeader = self.containsHeader {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let fileCompression = self.fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
        if let headerList = headerList {
            var headerListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerList)
            for columnname0 in headerList {
                try headerListContainer.encode(columnname0)
            }
        }
        if let quoteSymbol = self.quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CSVFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .charset)
        charset = charsetDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .headerList)
        var headerListDecoded0:[Swift.String]? = nil
        if let headerListContainer = headerListContainer {
            headerListDecoded0 = [Swift.String]()
            for string0 in headerListContainer {
                if let string0 = string0 {
                    headerListDecoded0?.append(string0)
                }
            }
        }
        headerList = headerListDecoded0
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about how a source CSV data file should be analyzed.
    public struct CsvFormatDescriptor: Swift.Equatable {
        /// The character set in which the source CSV file is written.
        public var charset: Swift.String?
        /// Whether or not the source CSV file contains a header.
        public var containsHeader: Swift.Bool?
        /// The character used to delimit the source CSV file.
        public var delimiter: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.CSVFileCompression?
        /// A list of the source CSV file's headers, if any.
        public var headerList: [Swift.String]?
        /// The character used as a quote character.
        public var quoteSymbol: Swift.String?

        public init (
            charset: Swift.String? = nil,
            containsHeader: Swift.Bool? = nil,
            delimiter: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.CSVFileCompression? = nil,
            headerList: [Swift.String]? = nil,
            quoteSymbol: Swift.String? = nil
        )
        {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }
    }

}

extension LookoutMetricsClientTypes.DataQualityMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDescription = "MetricDescription"
        case metricType = "MetricType"
        case metricValue = "MetricValue"
        case relatedColumnName = "RelatedColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDescription = self.metricDescription {
            try encodeContainer.encode(metricDescription, forKey: .metricDescription)
        }
        if let metricType = self.metricType {
            try encodeContainer.encode(metricType.rawValue, forKey: .metricType)
        }
        if let metricValue = self.metricValue {
            try encodeContainer.encode(metricValue, forKey: .metricValue)
        }
        if let relatedColumnName = self.relatedColumnName {
            try encodeContainer.encode(relatedColumnName, forKey: .relatedColumnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DataQualityMetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let metricDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricDescription)
        metricDescription = metricDescriptionDecoded
        let relatedColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedColumnName)
        relatedColumnName = relatedColumnNameDecoded
        let metricValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .metricValue)
        metricValue = metricValueDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An array that describes a data quality metric. Each DataQualityMetric object contains the data quality metric name, its value, a description of the metric, and the affected column.
    public struct DataQualityMetric: Swift.Equatable {
        /// A description of the data quality metric.
        public var metricDescription: Swift.String?
        /// The name of the data quality metric.
        public var metricType: LookoutMetricsClientTypes.DataQualityMetricType?
        /// The value of the data quality metric.
        public var metricValue: Swift.Double?
        /// The column that is being monitored.
        public var relatedColumnName: Swift.String?

        public init (
            metricDescription: Swift.String? = nil,
            metricType: LookoutMetricsClientTypes.DataQualityMetricType? = nil,
            metricValue: Swift.Double? = nil,
            relatedColumnName: Swift.String? = nil
        )
        {
            self.metricDescription = metricDescription
            self.metricType = metricType
            self.metricValue = metricValue
            self.relatedColumnName = relatedColumnName
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum DataQualityMetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backtestInferenceDataEndTimeStamp
        case backtestInferenceDataStartTimeStamp
        case backtestTrainingDataEndTimeStamp
        case backtestTrainingDataStartTimeStamp
        case columnCompleteness
        case dimensionUniqueness
        case invalidRowsCompliance
        case rowsPartialCompliance
        case rowsProcessed
        case timeSeriesCount
        case sdkUnknown(Swift.String)

        public static var allCases: [DataQualityMetricType] {
            return [
                .backtestInferenceDataEndTimeStamp,
                .backtestInferenceDataStartTimeStamp,
                .backtestTrainingDataEndTimeStamp,
                .backtestTrainingDataStartTimeStamp,
                .columnCompleteness,
                .dimensionUniqueness,
                .invalidRowsCompliance,
                .rowsPartialCompliance,
                .rowsProcessed,
                .timeSeriesCount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backtestInferenceDataEndTimeStamp: return "BACKTEST_INFERENCE_DATA_END_TIME_STAMP"
            case .backtestInferenceDataStartTimeStamp: return "BACKTEST_INFERENCE_DATA_START_TIME_STAMP"
            case .backtestTrainingDataEndTimeStamp: return "BACKTEST_TRAINING_DATA_END_TIME_STAMP"
            case .backtestTrainingDataStartTimeStamp: return "BACKTEST_TRAINING_DATA_START_TIME_STAMP"
            case .columnCompleteness: return "COLUMN_COMPLETENESS"
            case .dimensionUniqueness: return "DIMENSION_UNIQUENESS"
            case .invalidRowsCompliance: return "INVALID_ROWS_COMPLIANCE"
            case .rowsPartialCompliance: return "ROWS_PARTIAL_COMPLIANCE"
            case .rowsProcessed: return "ROWS_PROCESSED"
            case .timeSeriesCount: return "TIME_SERIES_COUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataQualityMetricType(rawValue: rawValue) ?? DataQualityMetricType.sdkUnknown(rawValue)
        }
    }
}

extension DeactivateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension DeactivateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeactivateAnomalyDetector"
    }
}

public struct DeactivateAnomalyDetectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DeactivateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension DeactivateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DeactivateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeactivateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateAnomalyDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = self.alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

extension DeleteAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteAlert"
    }
}

public struct DeleteAlertInput: Swift.Equatable {
    /// The ARN of the alert to delete.
    /// This member is required.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DeleteAlertInputBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension DeleteAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DeleteAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlertOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension DeleteAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteAnomalyDetector"
    }
}

public struct DeleteAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to delete.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DeleteAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension DeleteAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DeleteAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalyDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertArn = self.alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
    }
}

extension DescribeAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAlert"
    }
}

public struct DescribeAlertInput: Swift.Equatable {
    /// The ARN of the alert to describe.
    /// This member is required.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct DescribeAlertInputBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension DescribeAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension DescribeAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAlertOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alert = output.alert
        } else {
            self.alert = nil
        }
    }
}

public struct DescribeAlertOutputResponse: Swift.Equatable {
    /// Contains information about an alert.
    public var alert: LookoutMetricsClientTypes.Alert?

    public init (
        alert: LookoutMetricsClientTypes.Alert? = nil
    )
    {
        self.alert = alert
    }
}

struct DescribeAlertOutputResponseBody: Swift.Equatable {
    let alert: LookoutMetricsClientTypes.Alert?
}

extension DescribeAlertOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alert = "Alert"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Alert.self, forKey: .alert)
        alert = alertDecoded
    }
}

extension DescribeAnomalyDetectionExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }
}

extension DescribeAnomalyDetectionExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAnomalyDetectionExecutions"
    }
}

public struct DescribeAnomalyDetectionExecutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The timestamp of the anomaly detection job.
    public var timestamp: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timestamp = timestamp
    }
}

struct DescribeAnomalyDetectionExecutionsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let timestamp: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAnomalyDetectionExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timestamp = "Timestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectionExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnomalyDetectionExecutionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectionExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnomalyDetectionExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionList = output.executionList
            self.nextToken = output.nextToken
        } else {
            self.executionList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAnomalyDetectionExecutionsOutputResponse: Swift.Equatable {
    /// A list of detection jobs.
    public var executionList: [LookoutMetricsClientTypes.ExecutionStatus]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        executionList: [LookoutMetricsClientTypes.ExecutionStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionList = executionList
        self.nextToken = nextToken
    }
}

struct DescribeAnomalyDetectionExecutionsOutputResponseBody: Swift.Equatable {
    let executionList: [LookoutMetricsClientTypes.ExecutionStatus]?
    let nextToken: Swift.String?
}

extension DescribeAnomalyDetectionExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionList = "ExecutionList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ExecutionStatus?].self, forKey: .executionList)
        var executionListDecoded0:[LookoutMetricsClientTypes.ExecutionStatus]? = nil
        if let executionListContainer = executionListContainer {
            executionListDecoded0 = [LookoutMetricsClientTypes.ExecutionStatus]()
            for structure0 in executionListContainer {
                if let structure0 = structure0 {
                    executionListDecoded0?.append(structure0)
                }
            }
        }
        executionList = executionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
    }
}

extension DescribeAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeAnomalyDetector"
    }
}

public struct DescribeAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to describe.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct DescribeAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension DescribeAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension DescribeAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.anomalyDetectorConfig = output.anomalyDetectorConfig
            self.anomalyDetectorDescription = output.anomalyDetectorDescription
            self.anomalyDetectorName = output.anomalyDetectorName
            self.creationTime = output.creationTime
            self.failureReason = output.failureReason
            self.failureType = output.failureType
            self.kmsKeyArn = output.kmsKeyArn
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.anomalyDetectorArn = nil
            self.anomalyDetectorConfig = nil
            self.anomalyDetectorDescription = nil
            self.anomalyDetectorName = nil
            self.creationTime = nil
            self.failureReason = nil
            self.failureType = nil
            self.kmsKeyArn = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the detector's configuration.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    public var anomalyDetectorName: Swift.String?
    /// The time at which the detector was created.
    public var creationTime: ClientRuntime.Date?
    /// The reason that the detector failed.
    public var failureReason: Swift.String?
    /// The process that caused the detector to fail.
    public var failureType: LookoutMetricsClientTypes.AnomalyDetectorFailureType?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The time at which the detector was last modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of the detector.
    public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        failureReason: Swift.String? = nil,
        failureType: LookoutMetricsClientTypes.AnomalyDetectorFailureType? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.failureType = failureType
        self.kmsKeyArn = kmsKeyArn
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyDetectorName: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let status: LookoutMetricsClientTypes.AnomalyDetectorStatus?
    let failureReason: Swift.String?
    let kmsKeyArn: Swift.String?
    let failureType: LookoutMetricsClientTypes.AnomalyDetectorFailureType?
}

extension DescribeAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case anomalyDetectorName = "AnomalyDetectorName"
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case failureType = "FailureType"
        case kmsKeyArn = "KmsKeyArn"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyDetectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorName)
        anomalyDetectorName = anomalyDetectorNameDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfigSummary.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let failureTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorFailureType.self, forKey: .failureType)
        failureType = failureTypeDecoded
    }
}

extension DescribeMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricSetArn = self.metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
    }
}

extension DescribeMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeMetricSet"
    }
}

public struct DescribeMetricSetInput: Swift.Equatable {
    /// The ARN of the dataset.
    /// This member is required.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct DescribeMetricSetInputBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension DescribeMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension DescribeMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
            self.creationTime = output.creationTime
            self.dimensionFilterList = output.dimensionFilterList
            self.dimensionList = output.dimensionList
            self.lastModificationTime = output.lastModificationTime
            self.metricList = output.metricList
            self.metricSetArn = output.metricSetArn
            self.metricSetDescription = output.metricSetDescription
            self.metricSetFrequency = output.metricSetFrequency
            self.metricSetName = output.metricSetName
            self.metricSource = output.metricSource
            self.offset = output.offset
            self.timestampColumn = output.timestampColumn
            self.timezone = output.timezone
        } else {
            self.anomalyDetectorArn = nil
            self.creationTime = nil
            self.dimensionFilterList = nil
            self.dimensionList = nil
            self.lastModificationTime = nil
            self.metricList = nil
            self.metricSetArn = nil
            self.metricSetDescription = nil
            self.metricSetFrequency = nil
            self.metricSetName = nil
            self.metricSource = nil
            self.offset = nil
            self.timestampColumn = nil
            self.timezone = nil
        }
    }
}

public struct DescribeMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the detector that contains the dataset.
    public var anomalyDetectorArn: Swift.String?
    /// The time at which the dataset was created.
    public var creationTime: ClientRuntime.Date?
    /// The dimensions and their values that were used to filter the dataset.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// A list of the dimensions chosen for analysis.
    public var dimensionList: [Swift.String]?
    /// The time at which the dataset was last modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// A list of the metrics defined by the dataset.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The interval at which the data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    public var metricSetName: Swift.String?
    /// Contains information about the dataset's source data.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which the dataset's data was recorded.
    public var timezone: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = nil,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.lastModificationTime = lastModificationTime
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

struct DescribeMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
    let anomalyDetectorArn: Swift.String?
    let metricSetName: Swift.String?
    let metricSetDescription: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let offset: Swift.Int?
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let timezone: Swift.String?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
    let dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
}

extension DescribeMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case dimensionFilterList = "DimensionFilterList"
        case dimensionList = "DimensionList"
        case lastModificationTime = "LastModificationTime"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSetName = "MetricSetName"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
        case timezone = "Timezone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
        let dimensionFilterListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetDimensionFilter?].self, forKey: .dimensionFilterList)
        var dimensionFilterListDecoded0:[LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil
        if let dimensionFilterListContainer = dimensionFilterListContainer {
            dimensionFilterListDecoded0 = [LookoutMetricsClientTypes.MetricSetDimensionFilter]()
            for structure0 in dimensionFilterListContainer {
                if let structure0 = structure0 {
                    dimensionFilterListDecoded0?.append(structure0)
                }
            }
        }
        dimensionFilterList = dimensionFilterListDecoded0
    }
}

extension DetectMetricSetConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case autoDetectionMetricSource = "AutoDetectionMetricSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let autoDetectionMetricSource = self.autoDetectionMetricSource {
            try encodeContainer.encode(autoDetectionMetricSource, forKey: .autoDetectionMetricSource)
        }
    }
}

extension DetectMetricSetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DetectMetricSetConfig"
    }
}

public struct DetectMetricSetConfigInput: Swift.Equatable {
    /// An anomaly detector ARN.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A data source.
    /// This member is required.
    public var autoDetectionMetricSource: LookoutMetricsClientTypes.AutoDetectionMetricSource?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        autoDetectionMetricSource: LookoutMetricsClientTypes.AutoDetectionMetricSource? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.autoDetectionMetricSource = autoDetectionMetricSource
    }
}

struct DetectMetricSetConfigInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let autoDetectionMetricSource: LookoutMetricsClientTypes.AutoDetectionMetricSource?
}

extension DetectMetricSetConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case autoDetectionMetricSource = "AutoDetectionMetricSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let autoDetectionMetricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AutoDetectionMetricSource.self, forKey: .autoDetectionMetricSource)
        autoDetectionMetricSource = autoDetectionMetricSourceDecoded
    }
}

extension DetectMetricSetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectMetricSetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetectMetricSetConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectMetricSetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DetectMetricSetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectedMetricSetConfig = output.detectedMetricSetConfig
        } else {
            self.detectedMetricSetConfig = nil
        }
    }
}

public struct DetectMetricSetConfigOutputResponse: Swift.Equatable {
    /// The inferred dataset configuration for the datasource.
    public var detectedMetricSetConfig: LookoutMetricsClientTypes.DetectedMetricSetConfig?

    public init (
        detectedMetricSetConfig: LookoutMetricsClientTypes.DetectedMetricSetConfig? = nil
    )
    {
        self.detectedMetricSetConfig = detectedMetricSetConfig
    }
}

struct DetectMetricSetConfigOutputResponseBody: Swift.Equatable {
    let detectedMetricSetConfig: LookoutMetricsClientTypes.DetectedMetricSetConfig?
}

extension DetectMetricSetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectedMetricSetConfig = "DetectedMetricSetConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectedMetricSetConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedMetricSetConfig.self, forKey: .detectedMetricSetConfig)
        detectedMetricSetConfig = detectedMetricSetConfigDecoded
    }
}

extension LookoutMetricsClientTypes.DetectedCsvFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case containsHeader = "ContainsHeader"
        case delimiter = "Delimiter"
        case fileCompression = "FileCompression"
        case headerList = "HeaderList"
        case quoteSymbol = "QuoteSymbol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = self.charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let containsHeader = self.containsHeader {
            try encodeContainer.encode(containsHeader, forKey: .containsHeader)
        }
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let fileCompression = self.fileCompression {
            try encodeContainer.encode(fileCompression, forKey: .fileCompression)
        }
        if let headerList = self.headerList {
            try encodeContainer.encode(headerList, forKey: .headerList)
        }
        if let quoteSymbol = self.quoteSymbol {
            try encodeContainer.encode(quoteSymbol, forKey: .quoteSymbol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .charset)
        charset = charsetDecoded
        let containsHeaderDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .containsHeader)
        containsHeader = containsHeaderDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let headerListDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .headerList)
        headerList = headerListDecoded
        let quoteSymbolDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .quoteSymbol)
        quoteSymbol = quoteSymbolDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Properties of an inferred CSV format.
    public struct DetectedCsvFormatDescriptor: Swift.Equatable {
        /// The format's charset.
        public var charset: LookoutMetricsClientTypes.DetectedField?
        /// Whether the format includes a header.
        public var containsHeader: LookoutMetricsClientTypes.DetectedField?
        /// The format's delimiter.
        public var delimiter: LookoutMetricsClientTypes.DetectedField?
        /// The format's file compression.
        public var fileCompression: LookoutMetricsClientTypes.DetectedField?
        /// The format's header list.
        public var headerList: LookoutMetricsClientTypes.DetectedField?
        /// The format's quote symbol.
        public var quoteSymbol: LookoutMetricsClientTypes.DetectedField?

        public init (
            charset: LookoutMetricsClientTypes.DetectedField? = nil,
            containsHeader: LookoutMetricsClientTypes.DetectedField? = nil,
            delimiter: LookoutMetricsClientTypes.DetectedField? = nil,
            fileCompression: LookoutMetricsClientTypes.DetectedField? = nil,
            headerList: LookoutMetricsClientTypes.DetectedField? = nil,
            quoteSymbol: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }
    }

}

extension LookoutMetricsClientTypes.DetectedField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case message = "Message"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = self.confidence {
            try encodeContainer.encode(confidence.rawValue, forKey: .confidence)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AttributeValue.self, forKey: .value)
        value = valueDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Confidence.self, forKey: .confidence)
        confidence = confidenceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An inferred field.
    public struct DetectedField: Swift.Equatable {
        /// The field's confidence.
        public var confidence: LookoutMetricsClientTypes.Confidence?
        /// The field's message.
        public var message: Swift.String?
        /// The field's value.
        public var value: LookoutMetricsClientTypes.AttributeValue?

        public init (
            confidence: LookoutMetricsClientTypes.Confidence? = nil,
            message: Swift.String? = nil,
            value: LookoutMetricsClientTypes.AttributeValue? = nil
        )
        {
            self.confidence = confidence
            self.message = message
            self.value = value
        }
    }

}

extension LookoutMetricsClientTypes.DetectedFileFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvFormatDescriptor = "CsvFormatDescriptor"
        case jsonFormatDescriptor = "JsonFormatDescriptor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvFormatDescriptor = self.csvFormatDescriptor {
            try encodeContainer.encode(csvFormatDescriptor, forKey: .csvFormatDescriptor)
        }
        if let jsonFormatDescriptor = self.jsonFormatDescriptor {
            try encodeContainer.encode(jsonFormatDescriptor, forKey: .jsonFormatDescriptor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedCsvFormatDescriptor.self, forKey: .csvFormatDescriptor)
        csvFormatDescriptor = csvFormatDescriptorDecoded
        let jsonFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedJsonFormatDescriptor.self, forKey: .jsonFormatDescriptor)
        jsonFormatDescriptor = jsonFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Properties of an inferred data format.
    public struct DetectedFileFormatDescriptor: Swift.Equatable {
        /// Details about a CSV format.
        public var csvFormatDescriptor: LookoutMetricsClientTypes.DetectedCsvFormatDescriptor?
        /// Details about a JSON format.
        public var jsonFormatDescriptor: LookoutMetricsClientTypes.DetectedJsonFormatDescriptor?

        public init (
            csvFormatDescriptor: LookoutMetricsClientTypes.DetectedCsvFormatDescriptor? = nil,
            jsonFormatDescriptor: LookoutMetricsClientTypes.DetectedJsonFormatDescriptor? = nil
        )
        {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }
    }

}

extension LookoutMetricsClientTypes.DetectedJsonFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case fileCompression = "FileCompression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = self.charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let fileCompression = self.fileCompression {
            try encodeContainer.encode(fileCompression, forKey: .fileCompression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A detected JSON format descriptor.
    public struct DetectedJsonFormatDescriptor: Swift.Equatable {
        /// The format's character set.
        public var charset: LookoutMetricsClientTypes.DetectedField?
        /// The format's file compression.
        public var fileCompression: LookoutMetricsClientTypes.DetectedField?

        public init (
            charset: LookoutMetricsClientTypes.DetectedField? = nil,
            fileCompression: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.charset = charset
            self.fileCompression = fileCompression
        }
    }

}

extension LookoutMetricsClientTypes.DetectedMetricSetConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricSetFrequency = self.metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency, forKey: .metricSetFrequency)
        }
        if let metricSource = self.metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offsetDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .offset)
        offset = offsetDecoded
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedField.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedMetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An inferred dataset configuration.
    public struct DetectedMetricSetConfig: Swift.Equatable {
        /// The dataset's interval.
        public var metricSetFrequency: LookoutMetricsClientTypes.DetectedField?
        /// The dataset's data source.
        public var metricSource: LookoutMetricsClientTypes.DetectedMetricSource?
        /// The dataset's offset.
        public var offset: LookoutMetricsClientTypes.DetectedField?

        public init (
            metricSetFrequency: LookoutMetricsClientTypes.DetectedField? = nil,
            metricSource: LookoutMetricsClientTypes.DetectedMetricSource? = nil,
            offset: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.metricSetFrequency = metricSetFrequency
            self.metricSource = metricSource
            self.offset = offset
        }
    }

}

extension LookoutMetricsClientTypes.DetectedMetricSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SourceConfig = self.s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedS3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An inferred data source.
    public struct DetectedMetricSource: Swift.Equatable {
        /// The data source's source configuration.
        public var s3SourceConfig: LookoutMetricsClientTypes.DetectedS3SourceConfig?

        public init (
            s3SourceConfig: LookoutMetricsClientTypes.DetectedS3SourceConfig? = nil
        )
        {
            self.s3SourceConfig = s3SourceConfig
        }
    }

}

extension LookoutMetricsClientTypes.DetectedS3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = self.fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.DetectedFileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// An inferred source configuration.
    public struct DetectedS3SourceConfig: Swift.Equatable {
        /// The source's file format descriptor.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.DetectedFileFormatDescriptor?

        public init (
            fileFormatDescriptor: LookoutMetricsClientTypes.DetectedFileFormatDescriptor? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
        }
    }

}

extension LookoutMetricsClientTypes.DimensionContribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValueContributionList = "DimensionValueContributionList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = self.dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueContributionList = dimensionValueContributionList {
            var dimensionValueContributionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionValueContributionList)
            for dimensionvaluecontribution0 in dimensionValueContributionList {
                try dimensionValueContributionListContainer.encode(dimensionvaluecontribution0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueContributionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionValueContribution?].self, forKey: .dimensionValueContributionList)
        var dimensionValueContributionListDecoded0:[LookoutMetricsClientTypes.DimensionValueContribution]? = nil
        if let dimensionValueContributionListContainer = dimensionValueContributionListContainer {
            dimensionValueContributionListDecoded0 = [LookoutMetricsClientTypes.DimensionValueContribution]()
            for structure0 in dimensionValueContributionListContainer {
                if let structure0 = structure0 {
                    dimensionValueContributionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueContributionList = dimensionValueContributionListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a dimension that contributed to an anomaly.
    public struct DimensionContribution: Swift.Equatable {
        /// The name of the dimension.
        public var dimensionName: Swift.String?
        /// A list of dimension values that contributed to the anomaly.
        public var dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]?

        public init (
            dimensionName: Swift.String? = nil,
            dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValueContributionList = dimensionValueContributionList
        }
    }

}

extension LookoutMetricsClientTypes.DimensionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValueList = "DimensionValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = self.dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValueList = dimensionValueList {
            var dimensionValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionValueList)
            for dimensionvalue0 in dimensionValueList {
                try dimensionValueListContainer.encode(dimensionvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionValueList)
        var dimensionValueListDecoded0:[Swift.String]? = nil
        if let dimensionValueListContainer = dimensionValueListContainer {
            dimensionValueListDecoded0 = [Swift.String]()
            for string0 in dimensionValueListContainer {
                if let string0 = string0 {
                    dimensionValueListDecoded0?.append(string0)
                }
            }
        }
        dimensionValueList = dimensionValueListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// The dimension filter, containing DimensionName and DimensionValueList.
    public struct DimensionFilter: Swift.Equatable {
        /// The name of the dimension to filter on.
        public var dimensionName: Swift.String?
        /// The list of values for the dimension specified in DimensionName that you want to filter on.
        public var dimensionValueList: [Swift.String]?

        public init (
            dimensionName: Swift.String? = nil,
            dimensionValueList: [Swift.String]? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValueList = dimensionValueList
        }
    }

}

extension LookoutMetricsClientTypes.DimensionNameValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionName = "DimensionName"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionName = self.dimensionName {
            try encodeContainer.encode(dimensionName, forKey: .dimensionName)
        }
        if let dimensionValue = self.dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A dimension name and value.
    public struct DimensionNameValue: Swift.Equatable {
        /// The name of the dimension.
        /// This member is required.
        public var dimensionName: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var dimensionValue: Swift.String?

        public init (
            dimensionName: Swift.String? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValue = dimensionValue
        }
    }

}

extension LookoutMetricsClientTypes.DimensionValueContribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributionScore = "ContributionScore"
        case dimensionValue = "DimensionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionScore = self.contributionScore {
            try encodeContainer.encode(contributionScore, forKey: .contributionScore)
        }
        if let dimensionValue = self.dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let contributionScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .contributionScore)
        contributionScore = contributionScoreDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// The severity of a value of a dimension that contributed to an anomaly.
    public struct DimensionValueContribution: Swift.Equatable {
        /// The severity score of the value.
        public var contributionScore: Swift.Double?
        /// The value of the dimension.
        public var dimensionValue: Swift.String?

        public init (
            contributionScore: Swift.Double? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.contributionScore = contributionScore
            self.dimensionValue = dimensionValue
        }
    }

}

extension LookoutMetricsClientTypes.ExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureReason = "FailureReason"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectionTaskStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// The status of an anomaly detector run.
    public struct ExecutionStatus: Swift.Equatable {
        /// The reason that the run failed, if applicable.
        public var failureReason: Swift.String?
        /// The run's status.
        public var status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus?
        /// The run's timestamp.
        public var timestamp: Swift.String?

        public init (
            failureReason: Swift.String? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension LookoutMetricsClientTypes.FileFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvFormatDescriptor = "CsvFormatDescriptor"
        case jsonFormatDescriptor = "JsonFormatDescriptor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvFormatDescriptor = self.csvFormatDescriptor {
            try encodeContainer.encode(csvFormatDescriptor, forKey: .csvFormatDescriptor)
        }
        if let jsonFormatDescriptor = self.jsonFormatDescriptor {
            try encodeContainer.encode(jsonFormatDescriptor, forKey: .jsonFormatDescriptor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CsvFormatDescriptor.self, forKey: .csvFormatDescriptor)
        csvFormatDescriptor = csvFormatDescriptorDecoded
        let jsonFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.JsonFormatDescriptor.self, forKey: .jsonFormatDescriptor)
        jsonFormatDescriptor = jsonFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a source file's formatting.
    public struct FileFormatDescriptor: Swift.Equatable {
        /// Contains information about how a source CSV data file should be analyzed.
        public var csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor?
        /// Contains information about how a source JSON data file should be analyzed.
        public var jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor?

        public init (
            csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor? = nil,
            jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor? = nil
        )
        {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }
    }

}

extension LookoutMetricsClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValue = "DimensionValue"
        case filterOperation = "FilterOperation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionValue = self.dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
        if let filterOperation = self.filterOperation {
            try encodeContainer.encode(filterOperation.rawValue, forKey: .filterOperation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let filterOperationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.FilterOperation.self, forKey: .filterOperation)
        filterOperation = filterOperationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Describes a filter for choosing a subset of dimension values. Each filter consists of the dimension that you want to include and the condition statement. The condition statement is specified in the FilterOperation object.
    public struct Filter: Swift.Equatable {
        /// The value that you want to include in the filter.
        public var dimensionValue: Swift.String?
        /// The condition to apply.
        public var filterOperation: LookoutMetricsClientTypes.FilterOperation?

        public init (
            dimensionValue: Swift.String? = nil,
            filterOperation: LookoutMetricsClientTypes.FilterOperation? = nil
        )
        {
            self.dimensionValue = dimensionValue
            self.filterOperation = filterOperation
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum FilterOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperation] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperation(rawValue: rawValue) ?? FilterOperation.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes {
    public enum Frequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case p1d
        case pt10m
        case pt1h
        case pt5m
        case sdkUnknown(Swift.String)

        public static var allCases: [Frequency] {
            return [
                .p1d,
                .pt10m,
                .pt1h,
                .pt5m,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .p1d: return "P1D"
            case .pt10m: return "PT10M"
            case .pt1h: return "PT1H"
            case .pt5m: return "PT5M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Frequency(rawValue: rawValue) ?? Frequency.sdkUnknown(rawValue)
        }
    }
}

extension GetAnomalyGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
    }
}

extension GetAnomalyGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetAnomalyGroup"
    }
}

public struct GetAnomalyGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
    }
}

struct GetAnomalyGroupInputBody: Swift.Equatable {
    let anomalyGroupId: Swift.String?
    let anomalyDetectorArn: Swift.String?
}

extension GetAnomalyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension GetAnomalyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAnomalyGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAnomalyGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroup = output.anomalyGroup
        } else {
            self.anomalyGroup = nil
        }
    }
}

public struct GetAnomalyGroupOutputResponse: Swift.Equatable {
    /// Details about the anomaly group.
    public var anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup?

    public init (
        anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup? = nil
    )
    {
        self.anomalyGroup = anomalyGroup
    }
}

struct GetAnomalyGroupOutputResponseBody: Swift.Equatable {
    let anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup?
}

extension GetAnomalyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroup = "AnomalyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroup.self, forKey: .anomalyGroup)
        anomalyGroup = anomalyGroupDecoded
    }
}

extension GetDataQualityMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case metricSetArn = "MetricSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let metricSetArn = self.metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
    }
}

extension GetDataQualityMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDataQualityMetrics"
    }
}

public struct GetDataQualityMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector that you want to investigate.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of a specific data quality metric set.
    public var metricSetArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        metricSetArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.metricSetArn = metricSetArn
    }
}

struct GetDataQualityMetricsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let metricSetArn: Swift.String?
}

extension GetDataQualityMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension GetDataQualityMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataQualityMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataQualityMetricsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataQualityMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataQualityMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorDataQualityMetricList = output.anomalyDetectorDataQualityMetricList
        } else {
            self.anomalyDetectorDataQualityMetricList = nil
        }
    }
}

public struct GetDataQualityMetricsOutputResponse: Swift.Equatable {
    /// A list of the data quality metrics for the AnomalyDetectorArn that you requested.
    public var anomalyDetectorDataQualityMetricList: [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]?

    public init (
        anomalyDetectorDataQualityMetricList: [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]? = nil
    )
    {
        self.anomalyDetectorDataQualityMetricList = anomalyDetectorDataQualityMetricList
    }
}

struct GetDataQualityMetricsOutputResponseBody: Swift.Equatable {
    let anomalyDetectorDataQualityMetricList: [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]?
}

extension GetDataQualityMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorDataQualityMetricList = "AnomalyDetectorDataQualityMetricList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorDataQualityMetricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric?].self, forKey: .anomalyDetectorDataQualityMetricList)
        var anomalyDetectorDataQualityMetricListDecoded0:[LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]? = nil
        if let anomalyDetectorDataQualityMetricListContainer = anomalyDetectorDataQualityMetricListContainer {
            anomalyDetectorDataQualityMetricListDecoded0 = [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]()
            for structure0 in anomalyDetectorDataQualityMetricListContainer {
                if let structure0 = structure0 {
                    anomalyDetectorDataQualityMetricListDecoded0?.append(structure0)
                }
            }
        }
        anomalyDetectorDataQualityMetricList = anomalyDetectorDataQualityMetricListDecoded0
    }
}

extension GetFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = self.anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetFeedback"
    }
}

public struct GetFeedbackInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The anomalous metric and group ID.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFeedbackInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupTimeSeries.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupTimeSeriesFeedback = output.anomalyGroupTimeSeriesFeedback
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupTimeSeriesFeedback = nil
            self.nextToken = nil
        }
    }
}

public struct GetFeedbackOutputResponse: Swift.Equatable {
    /// Feedback for an anomalous metric.
    public var anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.nextToken = nextToken
    }
}

struct GetFeedbackOutputResponseBody: Swift.Equatable {
    let anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]?
    let nextToken: Swift.String?
}

extension GetFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupTimeSeriesFeedbackContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.TimeSeriesFeedback?].self, forKey: .anomalyGroupTimeSeriesFeedback)
        var anomalyGroupTimeSeriesFeedbackDecoded0:[LookoutMetricsClientTypes.TimeSeriesFeedback]? = nil
        if let anomalyGroupTimeSeriesFeedbackContainer = anomalyGroupTimeSeriesFeedbackContainer {
            anomalyGroupTimeSeriesFeedbackDecoded0 = [LookoutMetricsClientTypes.TimeSeriesFeedback]()
            for structure0 in anomalyGroupTimeSeriesFeedbackContainer {
                if let structure0 = structure0 {
                    anomalyGroupTimeSeriesFeedbackDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSampleDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3SourceConfig = self.s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }
}

extension GetSampleDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetSampleData"
    }
}

public struct GetSampleDataInput: Swift.Equatable {
    /// A datasource bucket in Amazon S3.
    public var s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig?

    public init (
        s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig? = nil
    )
    {
        self.s3SourceConfig = s3SourceConfig
    }
}

struct GetSampleDataInputBody: Swift.Equatable {
    let s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig?
}

extension GetSampleDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3SourceConfig = "S3SourceConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.SampleDataS3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
    }
}

extension GetSampleDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSampleDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSampleDataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSampleDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSampleDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.headerValues = output.headerValues
            self.sampleRows = output.sampleRows
        } else {
            self.headerValues = nil
            self.sampleRows = nil
        }
    }
}

public struct GetSampleDataOutputResponse: Swift.Equatable {
    /// A list of header labels for the records.
    public var headerValues: [Swift.String]?
    /// A list of records.
    public var sampleRows: [[Swift.String]]?

    public init (
        headerValues: [Swift.String]? = nil,
        sampleRows: [[Swift.String]]? = nil
    )
    {
        self.headerValues = headerValues
        self.sampleRows = sampleRows
    }
}

struct GetSampleDataOutputResponseBody: Swift.Equatable {
    let headerValues: [Swift.String]?
    let sampleRows: [[Swift.String]]?
}

extension GetSampleDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerValues = "HeaderValues"
        case sampleRows = "SampleRows"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .headerValues)
        var headerValuesDecoded0:[Swift.String]? = nil
        if let headerValuesContainer = headerValuesContainer {
            headerValuesDecoded0 = [Swift.String]()
            for string0 in headerValuesContainer {
                if let string0 = string0 {
                    headerValuesDecoded0?.append(string0)
                }
            }
        }
        headerValues = headerValuesDecoded0
        let sampleRowsContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .sampleRows)
        var sampleRowsDecoded0:[[Swift.String]]? = nil
        if let sampleRowsContainer = sampleRowsContainer {
            sampleRowsDecoded0 = [[Swift.String]]()
            for list0 in sampleRowsContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    sampleRowsDecoded0?.append(list0Decoded0)
                }
            }
        }
        sampleRows = sampleRowsDecoded0
    }
}

extension LookoutMetricsClientTypes.InterMetricImpactDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case contributionPercentage = "ContributionPercentage"
        case metricName = "MetricName"
        case relationshipType = "RelationshipType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let contributionPercentage = self.contributionPercentage {
            try encodeContainer.encode(contributionPercentage, forKey: .contributionPercentage)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let contributionPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .contributionPercentage)
        contributionPercentage = contributionPercentageDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated details about the measures contributing to the anomaly group, and the measures potentially impacted by the anomaly group.
    public struct InterMetricImpactDetails: Swift.Equatable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// For potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP), the percentage contribution the measure has in causing the anomalies.
        public var contributionPercentage: Swift.Double?
        /// The name of the measure.
        public var metricName: Swift.String?
        /// Whether a measure is a potential cause of the anomaly group (CAUSE_OF_INPUT_ANOMALY_GROUP), or whether the measure is impacted by the anomaly group (EFFECT_OF_INPUT_ANOMALY_GROUP).
        public var relationshipType: LookoutMetricsClientTypes.RelationshipType?

        public init (
            anomalyGroupId: Swift.String? = nil,
            contributionPercentage: Swift.Double? = nil,
            metricName: Swift.String? = nil,
            relationshipType: LookoutMetricsClientTypes.RelationshipType? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.contributionPercentage = contributionPercentage
            self.metricName = metricName
            self.relationshipType = relationshipType
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes.ItemizedMetricStats: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case occurrenceCount = "OccurrenceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if occurrenceCount != 0 {
            try encodeContainer.encode(occurrenceCount, forKey: .occurrenceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let occurrenceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .occurrenceCount) ?? 0
        occurrenceCount = occurrenceCountDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Aggregated statistics about a measure affected by an anomaly.
    public struct ItemizedMetricStats: Swift.Equatable {
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of times that the measure appears.
        public var occurrenceCount: Swift.Int

        public init (
            metricName: Swift.String? = nil,
            occurrenceCount: Swift.Int = 0
        )
        {
            self.metricName = metricName
            self.occurrenceCount = occurrenceCount
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum JsonFileCompression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [JsonFileCompression] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JsonFileCompression(rawValue: rawValue) ?? JsonFileCompression.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.JsonFormatDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case charset = "Charset"
        case fileCompression = "FileCompression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = self.charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let fileCompression = self.fileCompression {
            try encodeContainer.encode(fileCompression.rawValue, forKey: .fileCompression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileCompressionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.JsonFileCompression.self, forKey: .fileCompression)
        fileCompression = fileCompressionDecoded
        let charsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .charset)
        charset = charsetDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about how a source JSON data file should be analyzed.
    public struct JsonFormatDescriptor: Swift.Equatable {
        /// The character set in which the source JSON file is written.
        public var charset: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.JsonFileCompression?

        public init (
            charset: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.JsonFileCompression? = nil
        )
        {
            self.charset = charset
            self.fileCompression = fileCompression
        }
    }

}

extension LookoutMetricsClientTypes.LambdaConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a Lambda configuration.
    public struct LambdaConfiguration: Swift.Equatable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var lambdaArn: Swift.String?
        /// The ARN of an IAM role that has permission to invoke the Lambda function.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            lambdaArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
        }
    }

}

extension ListAlertsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAlertsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAlerts"
    }
}

public struct ListAlertsInput: Swift.Equatable {
    /// The ARN of the alert's detector.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results that will be displayed by the request.
    public var maxResults: Swift.Int?
    /// If the result of the previous request is truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlertsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAlertsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlertsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlertsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAlertsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlertsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAlertsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertSummaryList = output.alertSummaryList
            self.nextToken = output.nextToken
        } else {
            self.alertSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlertsOutputResponse: Swift.Equatable {
    /// Contains information about an alert.
    public var alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use this token in the next request.
    public var nextToken: Swift.String?

    public init (
        alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alertSummaryList = alertSummaryList
        self.nextToken = nextToken
    }
}

struct ListAlertsOutputResponseBody: Swift.Equatable {
    let alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]?
    let nextToken: Swift.String?
}

extension ListAlertsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertSummaryList = "AlertSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AlertSummary?].self, forKey: .alertSummaryList)
        var alertSummaryListDecoded0:[LookoutMetricsClientTypes.AlertSummary]? = nil
        if let alertSummaryListContainer = alertSummaryListContainer {
            alertSummaryListDecoded0 = [LookoutMetricsClientTypes.AlertSummary]()
            for structure0 in alertSummaryListContainer {
                if let structure0 = structure0 {
                    alertSummaryListDecoded0?.append(structure0)
                }
            }
        }
        alertSummaryList = alertSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAnomalyDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyDetectors"
    }
}

public struct ListAnomalyDetectorsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAnomalyDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnomalyDetectorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnomalyDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorSummaryList = output.anomalyDetectorSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyDetectorSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyDetectorsOutputResponse: Swift.Equatable {
    /// A list of anomaly detectors in the account in the current region.
    public var anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyDetectorsOutputResponseBody: Swift.Equatable {
    let anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]?
    let nextToken: Swift.String?
}

extension ListAnomalyDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorSummaryList = "AnomalyDetectorSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AnomalyDetectorSummary?].self, forKey: .anomalyDetectorSummaryList)
        var anomalyDetectorSummaryListDecoded0:[LookoutMetricsClientTypes.AnomalyDetectorSummary]? = nil
        if let anomalyDetectorSummaryListContainer = anomalyDetectorSummaryListContainer {
            anomalyDetectorSummaryListDecoded0 = [LookoutMetricsClientTypes.AnomalyDetectorSummary]()
            for structure0 in anomalyDetectorSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyDetectorSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyDetectorSummaryList = anomalyDetectorSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupRelatedMetricsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case relationshipTypeFilter = "RelationshipTypeFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let relationshipTypeFilter = self.relationshipTypeFilter {
            try encodeContainer.encode(relationshipTypeFilter.rawValue, forKey: .relationshipTypeFilter)
        }
    }
}

extension ListAnomalyGroupRelatedMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyGroupRelatedMetrics"
    }
}

public struct ListAnomalyGroupRelatedMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Filter for potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP) or downstream effects (EFFECT_OF_INPUT_ANOMALY_GROUP) of the anomaly group.
    public var relationshipTypeFilter: LookoutMetricsClientTypes.RelationshipType?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        relationshipTypeFilter: LookoutMetricsClientTypes.RelationshipType? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.relationshipTypeFilter = relationshipTypeFilter
    }
}

struct ListAnomalyGroupRelatedMetricsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupId: Swift.String?
    let relationshipTypeFilter: LookoutMetricsClientTypes.RelationshipType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupRelatedMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case relationshipTypeFilter = "RelationshipTypeFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let relationshipTypeFilterDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RelationshipType.self, forKey: .relationshipTypeFilter)
        relationshipTypeFilter = relationshipTypeFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupRelatedMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupRelatedMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnomalyGroupRelatedMetricsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupRelatedMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnomalyGroupRelatedMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interMetricImpactList = output.interMetricImpactList
            self.nextToken = output.nextToken
        } else {
            self.interMetricImpactList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyGroupRelatedMetricsOutputResponse: Swift.Equatable {
    /// Aggregated details about the measures contributing to the anomaly group, and the measures potentially impacted by the anomaly group.
    public var interMetricImpactList: [LookoutMetricsClientTypes.InterMetricImpactDetails]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        interMetricImpactList: [LookoutMetricsClientTypes.InterMetricImpactDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interMetricImpactList = interMetricImpactList
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupRelatedMetricsOutputResponseBody: Swift.Equatable {
    let interMetricImpactList: [LookoutMetricsClientTypes.InterMetricImpactDetails]?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupRelatedMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interMetricImpactList = "InterMetricImpactList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interMetricImpactListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.InterMetricImpactDetails?].self, forKey: .interMetricImpactList)
        var interMetricImpactListDecoded0:[LookoutMetricsClientTypes.InterMetricImpactDetails]? = nil
        if let interMetricImpactListContainer = interMetricImpactListContainer {
            interMetricImpactListDecoded0 = [LookoutMetricsClientTypes.InterMetricImpactDetails]()
            for structure0 in interMetricImpactListContainer {
                if let structure0 = structure0 {
                    interMetricImpactListDecoded0?.append(structure0)
                }
            }
        }
        interMetricImpactList = interMetricImpactListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if sensitivityThreshold != 0 {
            try encodeContainer.encode(sensitivityThreshold, forKey: .sensitivityThreshold)
        }
    }
}

extension ListAnomalyGroupSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyGroupSummaries"
    }
}

public struct ListAnomalyGroupSummariesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The minimum severity score for inclusion in the output.
    /// This member is required.
    public var sensitivityThreshold: Swift.Int

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sensitivityThreshold: Swift.Int = 0
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sensitivityThreshold = sensitivityThreshold
    }
}

struct ListAnomalyGroupSummariesInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let sensitivityThreshold: Swift.Int
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sensitivityThreshold = "SensitivityThreshold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let sensitivityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sensitivityThreshold) ?? 0
        sensitivityThreshold = sensitivityThresholdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnomalyGroupSummariesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnomalyGroupSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupStatistics = output.anomalyGroupStatistics
            self.anomalyGroupSummaryList = output.anomalyGroupSummaryList
            self.nextToken = output.nextToken
        } else {
            self.anomalyGroupStatistics = nil
            self.anomalyGroupSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnomalyGroupSummariesOutputResponse: Swift.Equatable {
    /// Aggregated details about the anomaly groups.
    public var anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics?
    /// A list of anomaly group summaries.
    public var anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics? = nil,
        anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupStatistics = anomalyGroupStatistics
        self.anomalyGroupSummaryList = anomalyGroupSummaryList
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupSummariesOutputResponseBody: Swift.Equatable {
    let anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]?
    let anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupStatistics = "AnomalyGroupStatistics"
        case anomalyGroupSummaryList = "AnomalyGroupSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.AnomalyGroupSummary?].self, forKey: .anomalyGroupSummaryList)
        var anomalyGroupSummaryListDecoded0:[LookoutMetricsClientTypes.AnomalyGroupSummary]? = nil
        if let anomalyGroupSummaryListContainer = anomalyGroupSummaryListContainer {
            anomalyGroupSummaryListDecoded0 = [LookoutMetricsClientTypes.AnomalyGroupSummary]()
            for structure0 in anomalyGroupSummaryListContainer {
                if let structure0 = structure0 {
                    anomalyGroupSummaryListDecoded0?.append(structure0)
                }
            }
        }
        anomalyGroupSummaryList = anomalyGroupSummaryListDecoded0
        let anomalyGroupStatisticsDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupStatistics.self, forKey: .anomalyGroupStatistics)
        anomalyGroupStatistics = anomalyGroupStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupTimeSeriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupId = self.anomalyGroupId {
            try encodeContainer.encode(anomalyGroupId, forKey: .anomalyGroupId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAnomalyGroupTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListAnomalyGroupTimeSeries"
    }
}

public struct ListAnomalyGroupTimeSeriesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The name of the measure field.
    /// This member is required.
    public var metricName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

struct ListAnomalyGroupTimeSeriesInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupId: Swift.String?
    let metricName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAnomalyGroupTimeSeriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupId = "AnomalyGroupId"
        case maxResults = "MaxResults"
        case metricName = "MetricName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnomalyGroupTimeSeriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnomalyGroupTimeSeriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnomalyGroupTimeSeriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnomalyGroupTimeSeriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnomalyGroupTimeSeriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyGroupId = output.anomalyGroupId
            self.metricName = output.metricName
            self.nextToken = output.nextToken
            self.timeSeriesList = output.timeSeriesList
            self.timestampList = output.timestampList
        } else {
            self.anomalyGroupId = nil
            self.metricName = nil
            self.nextToken = nil
            self.timeSeriesList = nil
            self.timestampList = nil
        }
    }
}

public struct ListAnomalyGroupTimeSeriesOutputResponse: Swift.Equatable {
    /// The ID of the anomaly group.
    public var anomalyGroupId: Swift.String?
    /// The name of the measure field.
    public var metricName: Swift.String?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of anomalous metrics.
    public var timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]?
    /// Timestamps for the anomalous metrics.
    public var timestampList: [Swift.String]?

    public init (
        anomalyGroupId: Swift.String? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]? = nil,
        timestampList: [Swift.String]? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.metricName = metricName
        self.nextToken = nextToken
        self.timeSeriesList = timeSeriesList
        self.timestampList = timestampList
    }
}

struct ListAnomalyGroupTimeSeriesOutputResponseBody: Swift.Equatable {
    let anomalyGroupId: Swift.String?
    let metricName: Swift.String?
    let timestampList: [Swift.String]?
    let nextToken: Swift.String?
    let timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]?
}

extension ListAnomalyGroupTimeSeriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyGroupId = "AnomalyGroupId"
        case metricName = "MetricName"
        case nextToken = "NextToken"
        case timeSeriesList = "TimeSeriesList"
        case timestampList = "TimestampList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyGroupId)
        anomalyGroupId = anomalyGroupIdDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let timestampListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .timestampList)
        var timestampListDecoded0:[Swift.String]? = nil
        if let timestampListContainer = timestampListContainer {
            timestampListDecoded0 = [Swift.String]()
            for string0 in timestampListContainer {
                if let string0 = string0 {
                    timestampListDecoded0?.append(string0)
                }
            }
        }
        timestampList = timestampListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let timeSeriesListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.TimeSeries?].self, forKey: .timeSeriesList)
        var timeSeriesListDecoded0:[LookoutMetricsClientTypes.TimeSeries]? = nil
        if let timeSeriesListContainer = timeSeriesListContainer {
            timeSeriesListDecoded0 = [LookoutMetricsClientTypes.TimeSeries]()
            for structure0 in timeSeriesListContainer {
                if let structure0 = structure0 {
                    timeSeriesListDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesList = timeSeriesListDecoded0
    }
}

extension ListMetricSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMetricSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListMetricSets"
    }
}

public struct ListMetricSetsInput: Swift.Equatable {
    /// The ARN of the anomaly detector containing the metrics sets to list.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMetricSetsInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMetricSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMetricSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMetricSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMetricSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMetricSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMetricSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetSummaryList = output.metricSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.metricSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMetricSetsOutputResponse: Swift.Equatable {
    /// A list of the datasets in the AWS Region, with configuration details for each.
    public var metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]?
    /// If the response is truncated, the list call returns this token. To retrieve the next set of results, use the token in the next list request.
    public var nextToken: Swift.String?

    public init (
        metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricSetSummaryList = metricSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListMetricSetsOutputResponseBody: Swift.Equatable {
    let metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]?
    let nextToken: Swift.String?
}

extension ListMetricSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetSummaryList = "MetricSetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetSummaryListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetSummary?].self, forKey: .metricSetSummaryList)
        var metricSetSummaryListDecoded0:[LookoutMetricsClientTypes.MetricSetSummary]? = nil
        if let metricSetSummaryListContainer = metricSetSummaryListContainer {
            metricSetSummaryListDecoded0 = [LookoutMetricsClientTypes.MetricSetSummary]()
            for structure0 in metricSetSummaryListContainer {
                if let structure0 = structure0 {
                    metricSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        metricSetSummaryList = metricSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes.Metric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationFunction = "AggregationFunction"
        case metricName = "MetricName"
        case namespace = "Namespace"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationFunction = self.aggregationFunction {
            try encodeContainer.encode(aggregationFunction.rawValue, forKey: .aggregationFunction)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let aggregationFunctionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AggregationFunction.self, forKey: .aggregationFunction)
        aggregationFunction = aggregationFunctionDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// A calculation made by contrasting a measure and a dimension from your source data.
    public struct Metric: Swift.Equatable {
        /// The function with which the metric is calculated.
        /// This member is required.
        public var aggregationFunction: LookoutMetricsClientTypes.AggregationFunction?
        /// The name of the metric.
        /// This member is required.
        public var metricName: Swift.String?
        /// The namespace for the metric.
        public var namespace: Swift.String?

        public init (
            aggregationFunction: LookoutMetricsClientTypes.AggregationFunction? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension LookoutMetricsClientTypes.MetricLevelImpact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contributionMatrix = "ContributionMatrix"
        case metricName = "MetricName"
        case numTimeSeries = "NumTimeSeries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contributionMatrix = self.contributionMatrix {
            try encodeContainer.encode(contributionMatrix, forKey: .contributionMatrix)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if numTimeSeries != 0 {
            try encodeContainer.encode(numTimeSeries, forKey: .numTimeSeries)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let numTimeSeriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numTimeSeries) ?? 0
        numTimeSeries = numTimeSeriesDecoded
        let contributionMatrixDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.ContributionMatrix.self, forKey: .contributionMatrix)
        contributionMatrix = contributionMatrixDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a measure affected by an anomaly.
    public struct MetricLevelImpact: Swift.Equatable {
        /// Details about the dimensions that contributed to the anomaly.
        public var contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix?
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of anomalous metrics for the measure.
        public var numTimeSeries: Swift.Int

        public init (
            contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix? = nil,
            metricName: Swift.String? = nil,
            numTimeSeries: Swift.Int = 0
        )
        {
            self.contributionMatrix = contributionMatrix
            self.metricName = metricName
            self.numTimeSeries = numTimeSeries
        }
    }

}

extension LookoutMetricsClientTypes.MetricSetDataQualityMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataQualityMetricList = "DataQualityMetricList"
        case metricSetArn = "MetricSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataQualityMetricList = dataQualityMetricList {
            var dataQualityMetricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataQualityMetricList)
            for dataqualitymetric0 in dataQualityMetricList {
                try dataQualityMetricListContainer.encode(dataqualitymetric0)
            }
        }
        if let metricSetArn = self.metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let dataQualityMetricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DataQualityMetric?].self, forKey: .dataQualityMetricList)
        var dataQualityMetricListDecoded0:[LookoutMetricsClientTypes.DataQualityMetric]? = nil
        if let dataQualityMetricListContainer = dataQualityMetricListContainer {
            dataQualityMetricListDecoded0 = [LookoutMetricsClientTypes.DataQualityMetric]()
            for structure0 in dataQualityMetricListContainer {
                if let structure0 = structure0 {
                    dataQualityMetricListDecoded0?.append(structure0)
                }
            }
        }
        dataQualityMetricList = dataQualityMetricListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// An array of DataQualityMetric objects that describes one or more data quality metrics.
    public struct MetricSetDataQualityMetric: Swift.Equatable {
        /// The array of data quality metrics contained in the data quality metric set.
        public var dataQualityMetricList: [LookoutMetricsClientTypes.DataQualityMetric]?
        /// The Amazon Resource Name (ARN) of the data quality metric array.
        public var metricSetArn: Swift.String?

        public init (
            dataQualityMetricList: [LookoutMetricsClientTypes.DataQualityMetric]? = nil,
            metricSetArn: Swift.String? = nil
        )
        {
            self.dataQualityMetricList = dataQualityMetricList
            self.metricSetArn = metricSetArn
        }
    }

}

extension LookoutMetricsClientTypes.MetricSetDimensionFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterList = "FilterList"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filter0 in filterList {
                try filterListContainer.encode(filter0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Filter?].self, forKey: .filterList)
        var filterListDecoded0:[LookoutMetricsClientTypes.Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [LookoutMetricsClientTypes.Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Describes a list of filters for choosing a subset of dimension values. Each filter consists of the dimension and one of its values that you want to include. When multiple dimensions or values are specified, the dimensions are joined with an AND operation and the values are joined with an OR operation.
    public struct MetricSetDimensionFilter: Swift.Equatable {
        /// The list of filters that you are applying.
        public var filterList: [LookoutMetricsClientTypes.Filter]?
        /// The dimension that you want to filter on.
        public var name: Swift.String?

        public init (
            filterList: [LookoutMetricsClientTypes.Filter]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filterList = filterList
            self.name = name
        }
    }

}

extension LookoutMetricsClientTypes.MetricSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case creationTime = "CreationTime"
        case lastModificationTime = "LastModificationTime"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetName = "MetricSetName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let metricSetArn = self.metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = self.metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetName = self.metricSetName {
            try encodeContainer.encode(metricSetName, forKey: .metricSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetName)
        metricSetName = metricSetNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a dataset.
    public struct MetricSetSummary: Swift.Equatable {
        /// The ARN of the detector to which the dataset belongs.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the dataset was created.
        public var creationTime: ClientRuntime.Date?
        /// The time at which the dataset was last modified.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of the dataset.
        public var metricSetArn: Swift.String?
        /// The description of the dataset.
        public var metricSetDescription: Swift.String?
        /// The name of the dataset.
        public var metricSetName: Swift.String?
        /// The dataset's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            metricSetArn: Swift.String? = nil,
            metricSetDescription: Swift.String? = nil,
            metricSetName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetName = metricSetName
            self.tags = tags
        }
    }

}

extension LookoutMetricsClientTypes.MetricSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appFlowConfig = "AppFlowConfig"
        case athenaSourceConfig = "AthenaSourceConfig"
        case cloudWatchConfig = "CloudWatchConfig"
        case rdsSourceConfig = "RDSSourceConfig"
        case redshiftSourceConfig = "RedshiftSourceConfig"
        case s3SourceConfig = "S3SourceConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appFlowConfig = self.appFlowConfig {
            try encodeContainer.encode(appFlowConfig, forKey: .appFlowConfig)
        }
        if let athenaSourceConfig = self.athenaSourceConfig {
            try encodeContainer.encode(athenaSourceConfig, forKey: .athenaSourceConfig)
        }
        if let cloudWatchConfig = self.cloudWatchConfig {
            try encodeContainer.encode(cloudWatchConfig, forKey: .cloudWatchConfig)
        }
        if let rdsSourceConfig = self.rdsSourceConfig {
            try encodeContainer.encode(rdsSourceConfig, forKey: .rdsSourceConfig)
        }
        if let redshiftSourceConfig = self.redshiftSourceConfig {
            try encodeContainer.encode(redshiftSourceConfig, forKey: .redshiftSourceConfig)
        }
        if let s3SourceConfig = self.s3SourceConfig {
            try encodeContainer.encode(s3SourceConfig, forKey: .s3SourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3SourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.S3SourceConfig.self, forKey: .s3SourceConfig)
        s3SourceConfig = s3SourceConfigDecoded
        let appFlowConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AppFlowConfig.self, forKey: .appFlowConfig)
        appFlowConfig = appFlowConfigDecoded
        let cloudWatchConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.CloudWatchConfig.self, forKey: .cloudWatchConfig)
        cloudWatchConfig = cloudWatchConfigDecoded
        let rdsSourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RDSSourceConfig.self, forKey: .rdsSourceConfig)
        rdsSourceConfig = rdsSourceConfigDecoded
        let redshiftSourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.RedshiftSourceConfig.self, forKey: .redshiftSourceConfig)
        redshiftSourceConfig = redshiftSourceConfigDecoded
        let athenaSourceConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AthenaSourceConfig.self, forKey: .athenaSourceConfig)
        athenaSourceConfig = athenaSourceConfigDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about source data used to generate metrics.
    public struct MetricSource: Swift.Equatable {
        /// Details about an AppFlow datasource.
        public var appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig?
        /// Details about an Amazon Athena datasource.
        public var athenaSourceConfig: LookoutMetricsClientTypes.AthenaSourceConfig?
        /// Details about an Amazon CloudWatch monitoring datasource.
        public var cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig?
        /// Details about an Amazon Relational Database Service (RDS) datasource.
        public var rdsSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig?
        /// Details about an Amazon Redshift database datasource.
        public var redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig?
        /// Contains information about the configuration of the S3 bucket that contains source files.
        public var s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig?

        public init (
            appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig? = nil,
            athenaSourceConfig: LookoutMetricsClientTypes.AthenaSourceConfig? = nil,
            cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig? = nil,
            rdsSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig? = nil,
            redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig? = nil,
            s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig? = nil
        )
        {
            self.appFlowConfig = appFlowConfig
            self.athenaSourceConfig = athenaSourceConfig
            self.cloudWatchConfig = cloudWatchConfig
            self.rdsSourceConfig = rdsSourceConfig
            self.redshiftSourceConfig = redshiftSourceConfig
            self.s3SourceConfig = s3SourceConfig
        }
    }

}

extension PutFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyGroupTimeSeriesFeedback = self.anomalyGroupTimeSeriesFeedback {
            try encodeContainer.encode(anomalyGroupTimeSeriesFeedback, forKey: .anomalyGroupTimeSeriesFeedback)
        }
    }
}

extension PutFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutFeedback"
    }
}

public struct PutFeedbackInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Feedback for an anomalous metric.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
    }
}

struct PutFeedbackInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?
}

extension PutFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyGroupTimeSeriesFeedback = "AnomalyGroupTimeSeriesFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let anomalyGroupTimeSeriesFeedbackDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback.self, forKey: .anomalyGroupTimeSeriesFeedback)
        anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedbackDecoded
    }
}

extension PutFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutFeedbackOutputResponse: Swift.Equatable {

    public init () { }
}

extension LookoutMetricsClientTypes.RDSSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbInstanceIdentifier = "DBInstanceIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let databaseHost = self.databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databasePort = self.databasePort {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = self.secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the Amazon Relational Database Service (RDS) configuration.
    public struct RDSSourceConfig: Swift.Equatable {
        /// The host name of the database.
        public var databaseHost: Swift.String?
        /// The name of the RDS database.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        public var databasePort: Swift.Int?
        /// A string identifying the database instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public var secretManagerArn: Swift.String?
        /// The name of the table in the database.
        public var tableName: Swift.String?
        /// An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init (
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension LookoutMetricsClientTypes.RedshiftSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterIdentifier = "ClusterIdentifier"
        case databaseHost = "DatabaseHost"
        case databaseName = "DatabaseName"
        case databasePort = "DatabasePort"
        case roleArn = "RoleArn"
        case secretManagerArn = "SecretManagerArn"
        case tableName = "TableName"
        case vpcConfiguration = "VpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let databaseHost = self.databaseHost {
            try encodeContainer.encode(databaseHost, forKey: .databaseHost)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databasePort = self.databasePort {
            try encodeContainer.encode(databasePort, forKey: .databasePort)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretManagerArn = self.secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let vpcConfiguration = self.vpcConfiguration {
            try encodeContainer.encode(vpcConfiguration, forKey: .vpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let databaseHostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseHost)
        databaseHost = databaseHostDecoded
        let databasePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .databasePort)
        databasePort = databasePortDecoded
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Provides information about the Amazon Redshift database configuration.
    public struct RedshiftSourceConfig: Swift.Equatable {
        /// A string identifying the Redshift cluster.
        public var clusterIdentifier: Swift.String?
        /// The name of the database host.
        public var databaseHost: Swift.String?
        /// The Redshift database name.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        public var databasePort: Swift.Int?
        /// The Amazon Resource Name (ARN) of the role providing access to the database.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public var secretManagerArn: Swift.String?
        /// The table name of the Redshift database.
        public var tableName: Swift.String?
        /// Contains information about the Amazon Virtual Private Cloud (VPC) configuration.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init (
            clusterIdentifier: Swift.String? = nil,
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum RelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case causeOfInputAnomalyGroup
        case effectOfInputAnomalyGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .causeOfInputAnomalyGroup,
                .effectOfInputAnomalyGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .causeOfInputAnomalyGroup: return "CAUSE_OF_INPUT_ANOMALY_GROUP"
            case .effectOfInputAnomalyGroup: return "EFFECT_OF_INPUT_ANOMALY_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found. Check the ARN of the resource and try again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension LookoutMetricsClientTypes.S3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = self.fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapath0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapath0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpath0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpath0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[Swift.String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [Swift.String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[Swift.String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [Swift.String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the configuration of the S3 bucket that contains source files.
    public struct S3SourceConfig: Swift.Equatable {
        /// Contains information about a source file's formatting.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// A list of paths to the historical data files.
        public var historicalDataPathList: [Swift.String]?
        /// The ARN of an IAM role that has read and write access permissions to the source S3 bucket.
        public var roleArn: Swift.String?
        /// A list of templated paths to the source files.
        public var templatedPathList: [Swift.String]?

        public init (
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }

}

extension LookoutMetricsClientTypes.SNSConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case snsFormat = "SnsFormat"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let snsFormat = self.snsFormat {
            try encodeContainer.encode(snsFormat.rawValue, forKey: .snsFormat)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsFormatDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.SnsFormat.self, forKey: .snsFormat)
        snsFormat = snsFormatDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the SNS topic to which you want to send your alerts and the IAM role that has access to that topic.
    public struct SNSConfiguration: Swift.Equatable {
        /// The ARN of the IAM role that has access to the target SNS topic.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The format of the SNS topic.
        ///
        /// * JSON – Send JSON alerts with an anomaly ID and a link to the anomaly detail page. This is the default.
        ///
        /// * LONG_TEXT – Send human-readable alerts with information about the impacted timeseries and a link to the anomaly detail page. We recommend this for email.
        ///
        /// * SHORT_TEXT – Send human-readable alerts with a link to the anomaly detail page. We recommend this for SMS.
        public var snsFormat: LookoutMetricsClientTypes.SnsFormat?
        /// The ARN of the target SNS topic.
        /// This member is required.
        public var snsTopicArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            snsFormat: LookoutMetricsClientTypes.SnsFormat? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.snsFormat = snsFormat
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension LookoutMetricsClientTypes.SampleDataS3SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormatDescriptor = "FileFormatDescriptor"
        case historicalDataPathList = "HistoricalDataPathList"
        case roleArn = "RoleArn"
        case templatedPathList = "TemplatedPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormatDescriptor = self.fileFormatDescriptor {
            try encodeContainer.encode(fileFormatDescriptor, forKey: .fileFormatDescriptor)
        }
        if let historicalDataPathList = historicalDataPathList {
            var historicalDataPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .historicalDataPathList)
            for historicaldatapath0 in historicalDataPathList {
                try historicalDataPathListContainer.encode(historicaldatapath0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let templatedPathList = templatedPathList {
            var templatedPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templatedPathList)
            for templatedpath0 in templatedPathList {
                try templatedPathListContainer.encode(templatedpath0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let templatedPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .templatedPathList)
        var templatedPathListDecoded0:[Swift.String]? = nil
        if let templatedPathListContainer = templatedPathListContainer {
            templatedPathListDecoded0 = [Swift.String]()
            for string0 in templatedPathListContainer {
                if let string0 = string0 {
                    templatedPathListDecoded0?.append(string0)
                }
            }
        }
        templatedPathList = templatedPathListDecoded0
        let historicalDataPathListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .historicalDataPathList)
        var historicalDataPathListDecoded0:[Swift.String]? = nil
        if let historicalDataPathListContainer = historicalDataPathListContainer {
            historicalDataPathListDecoded0 = [Swift.String]()
            for string0 in historicalDataPathListContainer {
                if let string0 = string0 {
                    historicalDataPathListDecoded0?.append(string0)
                }
            }
        }
        historicalDataPathList = historicalDataPathListDecoded0
        let fileFormatDescriptorDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.FileFormatDescriptor.self, forKey: .fileFormatDescriptor)
        fileFormatDescriptor = fileFormatDescriptorDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the source configuration in Amazon S3.
    public struct SampleDataS3SourceConfig: Swift.Equatable {
        /// Contains information about a source file's formatting.
        /// This member is required.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// An array of strings containing the historical set of data paths.
        public var historicalDataPathList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// An array of strings containing the list of templated paths.
        public var templatedPathList: [Swift.String]?

        public init (
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the service's quotas. Check the service quotas and try again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota code.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?
    /// The service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension LookoutMetricsClientTypes {
    public enum SnsFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case longText
        case shortText
        case sdkUnknown(Swift.String)

        public static var allCases: [SnsFormat] {
            return [
                .json,
                .longText,
                .shortText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .longText: return "LONG_TEXT"
            case .shortText: return "SHORT_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnsFormat(rawValue: rawValue) ?? SnsFormat.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following symbols: _.:/=+@-
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension LookoutMetricsClientTypes.TimeSeries: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionList = "DimensionList"
        case metricValueList = "MetricValueList"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for dimensionnamevalue0 in dimensionList {
                try dimensionListContainer.encode(dimensionnamevalue0)
            }
        }
        if let metricValueList = metricValueList {
            var metricValueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricValueList)
            for metricvalue0 in metricValueList {
                try metricValueListContainer.encode(metricvalue0)
            }
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.DimensionNameValue?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[LookoutMetricsClientTypes.DimensionNameValue]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [LookoutMetricsClientTypes.DimensionNameValue]()
            for structure0 in dimensionListContainer {
                if let structure0 = structure0 {
                    dimensionListDecoded0?.append(structure0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricValueListContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .metricValueList)
        var metricValueListDecoded0:[Swift.Double]? = nil
        if let metricValueListContainer = metricValueListContainer {
            metricValueListDecoded0 = [Swift.Double]()
            for double0 in metricValueListContainer {
                if let double0 = double0 {
                    metricValueListDecoded0?.append(double0)
                }
            }
        }
        metricValueList = metricValueListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Details about a metric. A metric is an aggregation of the values of a measure for a dimension value, such as availability in the us-east-1 Region.
    public struct TimeSeries: Swift.Equatable {
        /// The dimensions of the metric.
        /// This member is required.
        public var dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]?
        /// The values for the metric.
        /// This member is required.
        public var metricValueList: [Swift.Double]?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init (
            dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]? = nil,
            metricValueList: [Swift.Double]? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.dimensionList = dimensionList
            self.metricValueList = metricValueList
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.TimeSeriesFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isAnomaly = "IsAnomaly"
        case timeSeriesId = "TimeSeriesId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isAnomaly = self.isAnomaly {
            try encodeContainer.encode(isAnomaly, forKey: .isAnomaly)
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let isAnomalyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAnomaly)
        isAnomaly = isAnomalyDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Details about feedback submitted for an anomalous metric.
    public struct TimeSeriesFeedback: Swift.Equatable {
        /// Feedback on whether the metric is a legitimate anomaly.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init (
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }

}

extension LookoutMetricsClientTypes.TimestampColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnFormat = "ColumnFormat"
        case columnName = "ColumnName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnFormat = self.columnFormat {
            try encodeContainer.encode(columnFormat, forKey: .columnFormat)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnFormat)
        columnFormat = columnFormatDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about the column used to track time in a source data file.
    public struct TimestampColumn: Swift.Equatable {
        /// The format of the timestamp column.
        public var columnFormat: Swift.String?
        /// The name of the timestamp column.
        public var columnName: Swift.String?

        public init (
            columnFormat: Swift.String? = nil,
            columnName: Swift.String? = nil
        )
        {
            self.columnFormat = columnFormat
            self.columnName = columnName
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to too many requests being submitted at the same time.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys to remove from the resource's tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAlertInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertArn = "AlertArn"
        case alertDescription = "AlertDescription"
        case alertFilters = "AlertFilters"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let alertArn = self.alertArn {
            try encodeContainer.encode(alertArn, forKey: .alertArn)
        }
        if let alertDescription = self.alertDescription {
            try encodeContainer.encode(alertDescription, forKey: .alertDescription)
        }
        if let alertFilters = self.alertFilters {
            try encodeContainer.encode(alertFilters, forKey: .alertFilters)
        }
        if alertSensitivityThreshold != 0 {
            try encodeContainer.encode(alertSensitivityThreshold, forKey: .alertSensitivityThreshold)
        }
    }
}

extension UpdateAlertInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateAlert"
    }
}

public struct UpdateAlertInput: Swift.Equatable {
    /// Action that will be triggered when there is an alert.
    public var action: LookoutMetricsClientTypes.Action?
    /// The ARN of the alert to update.
    /// This member is required.
    public var alertArn: Swift.String?
    /// A description of the alert.
    public var alertDescription: Swift.String?
    /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
    public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
    /// An integer from 0 to 100 specifying the alert sensitivity threshold.
    public var alertSensitivityThreshold: Swift.Int

    public init (
        action: LookoutMetricsClientTypes.Action? = nil,
        alertArn: Swift.String? = nil,
        alertDescription: Swift.String? = nil,
        alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
        alertSensitivityThreshold: Swift.Int = 0
    )
    {
        self.action = action
        self.alertArn = alertArn
        self.alertDescription = alertDescription
        self.alertFilters = alertFilters
        self.alertSensitivityThreshold = alertSensitivityThreshold
    }
}

struct UpdateAlertInputBody: Swift.Equatable {
    let alertArn: Swift.String?
    let alertDescription: Swift.String?
    let alertSensitivityThreshold: Swift.Int
    let action: LookoutMetricsClientTypes.Action?
    let alertFilters: LookoutMetricsClientTypes.AlertFilters?
}

extension UpdateAlertInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case alertArn = "AlertArn"
        case alertDescription = "AlertDescription"
        case alertFilters = "AlertFilters"
        case alertSensitivityThreshold = "AlertSensitivityThreshold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
        let alertDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertDescription)
        alertDescription = alertDescriptionDecoded
        let alertSensitivityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .alertSensitivityThreshold) ?? 0
        alertSensitivityThreshold = alertSensitivityThresholdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let alertFiltersDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AlertFilters.self, forKey: .alertFilters)
        alertFilters = alertFiltersDecoded
    }
}

extension UpdateAlertOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAlertOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAlertOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAlertOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAlertOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertArn = output.alertArn
        } else {
            self.alertArn = nil
        }
    }
}

public struct UpdateAlertOutputResponse: Swift.Equatable {
    /// The ARN of the updated alert.
    public var alertArn: Swift.String?

    public init (
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

struct UpdateAlertOutputResponseBody: Swift.Equatable {
    let alertArn: Swift.String?
}

extension UpdateAlertOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertArn = "AlertArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertArn)
        alertArn = alertArnDecoded
    }
}

extension UpdateAnomalyDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyDetectorArn = self.anomalyDetectorArn {
            try encodeContainer.encode(anomalyDetectorArn, forKey: .anomalyDetectorArn)
        }
        if let anomalyDetectorConfig = self.anomalyDetectorConfig {
            try encodeContainer.encode(anomalyDetectorConfig, forKey: .anomalyDetectorConfig)
        }
        if let anomalyDetectorDescription = self.anomalyDetectorDescription {
            try encodeContainer.encode(anomalyDetectorDescription, forKey: .anomalyDetectorDescription)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

extension UpdateAnomalyDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateAnomalyDetector"
    }
}

public struct UpdateAnomalyDetectorInput: Swift.Equatable {
    /// The ARN of the detector to update.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the configuration to which the detector will be updated.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// The updated detector description.
    public var anomalyDetectorDescription: Swift.String?
    /// The Amazon Resource Name (ARN) of an AWS KMS encryption key.
    public var kmsKeyArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.kmsKeyArn = kmsKeyArn
    }
}

struct UpdateAnomalyDetectorInputBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
    let kmsKeyArn: Swift.String?
    let anomalyDetectorDescription: Swift.String?
    let anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
}

extension UpdateAnomalyDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
        case anomalyDetectorConfig = "AnomalyDetectorConfig"
        case anomalyDetectorDescription = "AnomalyDetectorDescription"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let anomalyDetectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorDescription)
        anomalyDetectorDescription = anomalyDetectorDescriptionDecoded
        let anomalyDetectorConfigDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.AnomalyDetectorConfig.self, forKey: .anomalyDetectorConfig)
        anomalyDetectorConfig = anomalyDetectorConfigDecoded
    }
}

extension UpdateAnomalyDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalyDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAnomalyDetectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalyDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAnomalyDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyDetectorArn = output.anomalyDetectorArn
        } else {
            self.anomalyDetectorArn = nil
        }
    }
}

public struct UpdateAnomalyDetectorOutputResponse: Swift.Equatable {
    /// The ARN of the updated detector.
    public var anomalyDetectorArn: Swift.String?

    public init (
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

struct UpdateAnomalyDetectorOutputResponseBody: Swift.Equatable {
    let anomalyDetectorArn: Swift.String?
}

extension UpdateAnomalyDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyDetectorArn = "AnomalyDetectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyDetectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyDetectorArn)
        anomalyDetectorArn = anomalyDetectorArnDecoded
    }
}

extension UpdateMetricSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionFilterList = "DimensionFilterList"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionFilterList = dimensionFilterList {
            var dimensionFilterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionFilterList)
            for metricsetdimensionfilter0 in dimensionFilterList {
                try dimensionFilterListContainer.encode(metricsetdimensionfilter0)
            }
        }
        if let dimensionList = dimensionList {
            var dimensionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionList)
            for columnname0 in dimensionList {
                try dimensionListContainer.encode(columnname0)
            }
        }
        if let metricList = metricList {
            var metricListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricList)
            for metric0 in metricList {
                try metricListContainer.encode(metric0)
            }
        }
        if let metricSetArn = self.metricSetArn {
            try encodeContainer.encode(metricSetArn, forKey: .metricSetArn)
        }
        if let metricSetDescription = self.metricSetDescription {
            try encodeContainer.encode(metricSetDescription, forKey: .metricSetDescription)
        }
        if let metricSetFrequency = self.metricSetFrequency {
            try encodeContainer.encode(metricSetFrequency.rawValue, forKey: .metricSetFrequency)
        }
        if let metricSource = self.metricSource {
            try encodeContainer.encode(metricSource, forKey: .metricSource)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let timestampColumn = self.timestampColumn {
            try encodeContainer.encode(timestampColumn, forKey: .timestampColumn)
        }
    }
}

extension UpdateMetricSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateMetricSet"
    }
}

public struct UpdateMetricSetInput: Swift.Equatable {
    /// Describes a list of filters for choosing specific dimensions and specific values. Each filter consists of the dimension and one of its values that you want to include. When multiple dimensions or values are specified, the dimensions are joined with an AND operation and the values are joined with an OR operation.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// The dimension list.
    public var dimensionList: [Swift.String]?
    /// The metric list.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset to update.
    /// This member is required.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The dataset's interval.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// Contains information about source data used to generate metrics.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// The timestamp column.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?

    public init (
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = nil,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil
    )
    {
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
    }
}

struct UpdateMetricSetInputBody: Swift.Equatable {
    let metricSetArn: Swift.String?
    let metricSetDescription: Swift.String?
    let metricList: [LookoutMetricsClientTypes.Metric]?
    let offset: Swift.Int?
    let timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    let dimensionList: [Swift.String]?
    let metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    let metricSource: LookoutMetricsClientTypes.MetricSource?
    let dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
}

extension UpdateMetricSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionFilterList = "DimensionFilterList"
        case dimensionList = "DimensionList"
        case metricList = "MetricList"
        case metricSetArn = "MetricSetArn"
        case metricSetDescription = "MetricSetDescription"
        case metricSetFrequency = "MetricSetFrequency"
        case metricSource = "MetricSource"
        case offset = "Offset"
        case timestampColumn = "TimestampColumn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
        let metricSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetDescription)
        metricSetDescription = metricSetDescriptionDecoded
        let metricListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.Metric?].self, forKey: .metricList)
        var metricListDecoded0:[LookoutMetricsClientTypes.Metric]? = nil
        if let metricListContainer = metricListContainer {
            metricListDecoded0 = [LookoutMetricsClientTypes.Metric]()
            for structure0 in metricListContainer {
                if let structure0 = structure0 {
                    metricListDecoded0?.append(structure0)
                }
            }
        }
        metricList = metricListDecoded0
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let timestampColumnDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.TimestampColumn.self, forKey: .timestampColumn)
        timestampColumn = timestampColumnDecoded
        let dimensionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionList)
        var dimensionListDecoded0:[Swift.String]? = nil
        if let dimensionListContainer = dimensionListContainer {
            dimensionListDecoded0 = [Swift.String]()
            for string0 in dimensionListContainer {
                if let string0 = string0 {
                    dimensionListDecoded0?.append(string0)
                }
            }
        }
        dimensionList = dimensionListDecoded0
        let metricSetFrequencyDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.Frequency.self, forKey: .metricSetFrequency)
        metricSetFrequency = metricSetFrequencyDecoded
        let metricSourceDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.MetricSource.self, forKey: .metricSource)
        metricSource = metricSourceDecoded
        let dimensionFilterListContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.MetricSetDimensionFilter?].self, forKey: .dimensionFilterList)
        var dimensionFilterListDecoded0:[LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil
        if let dimensionFilterListContainer = dimensionFilterListContainer {
            dimensionFilterListDecoded0 = [LookoutMetricsClientTypes.MetricSetDimensionFilter]()
            for structure0 in dimensionFilterListContainer {
                if let structure0 = structure0 {
                    dimensionFilterListDecoded0?.append(structure0)
                }
            }
        }
        dimensionFilterList = dimensionFilterListDecoded0
    }
}

extension UpdateMetricSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMetricSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMetricSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMetricSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMetricSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metricSetArn = output.metricSetArn
        } else {
            self.metricSetArn = nil
        }
    }
}

public struct UpdateMetricSetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init (
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

struct UpdateMetricSetOutputResponseBody: Swift.Equatable {
    let metricSetArn: Swift.String?
}

extension UpdateMetricSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricSetArn = "MetricSetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricSetArn)
        metricSetArn = metricSetArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by the AWS service. Check your input values and try again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Fields that failed validation.
    public var fields: [LookoutMetricsClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason that validation failed.
    public var reason: LookoutMetricsClientTypes.ValidationExceptionReason?

    public init (
        fields: [LookoutMetricsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LookoutMetricsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: LookoutMetricsClientTypes.ValidationExceptionReason?
    let fields: [LookoutMetricsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(LookoutMetricsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([LookoutMetricsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[LookoutMetricsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [LookoutMetricsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension LookoutMetricsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LookoutMetricsClientTypes {
    /// Contains information about a a field in a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message with more information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension LookoutMetricsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension LookoutMetricsClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIdList = "SecurityGroupIdList"
        case subnetIdList = "SubnetIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdList = securityGroupIdList {
            var securityGroupIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdList)
            for securitygroupid0 in securityGroupIdList {
                try securityGroupIdListContainer.encode(securitygroupid0)
            }
        }
        if let subnetIdList = subnetIdList {
            var subnetIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIdList)
            for subnetid0 in subnetIdList {
                try subnetIdListContainer.encode(subnetid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIdList)
        var subnetIdListDecoded0:[Swift.String]? = nil
        if let subnetIdListContainer = subnetIdListContainer {
            subnetIdListDecoded0 = [Swift.String]()
            for string0 in subnetIdListContainer {
                if let string0 = string0 {
                    subnetIdListDecoded0?.append(string0)
                }
            }
        }
        subnetIdList = subnetIdListDecoded0
        let securityGroupIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIdList)
        var securityGroupIdListDecoded0:[Swift.String]? = nil
        if let securityGroupIdListContainer = securityGroupIdListContainer {
            securityGroupIdListDecoded0 = [Swift.String]()
            for string0 in securityGroupIdListContainer {
                if let string0 = string0 {
                    securityGroupIdListDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdList = securityGroupIdListDecoded0
    }
}

extension LookoutMetricsClientTypes {
    /// Contains configuration information about the Amazon Virtual Private Cloud (VPC).
    public struct VpcConfiguration: Swift.Equatable {
        /// An array of strings containing the list of security groups.
        /// This member is required.
        public var securityGroupIdList: [Swift.String]?
        /// An array of strings containing the Amazon VPC subnet IDs (e.g., subnet-0bb1c79de3EXAMPLE.
        /// This member is required.
        public var subnetIdList: [Swift.String]?

        public init (
            securityGroupIdList: [Swift.String]? = nil,
            subnetIdList: [Swift.String]? = nil
        )
        {
            self.securityGroupIdList = securityGroupIdList
            self.subnetIdList = subnetIdList
        }
    }

}
