//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// You do not have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a Lambda configuration.
    public struct LambdaConfiguration: Swift.Sendable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var lambdaArn: Swift.String?
        /// The ARN of an IAM role that has permission to invoke the Lambda function.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum SnsFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case longText
        case shortText
        case sdkUnknown(Swift.String)

        public static var allCases: [SnsFormat] {
            return [
                .json,
                .longText,
                .shortText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .longText: return "LONG_TEXT"
            case .shortText: return "SHORT_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about the SNS topic to which you want to send your alerts and the IAM role that has access to that topic.
    public struct SNSConfiguration: Swift.Sendable {
        /// The ARN of the IAM role that has access to the target SNS topic.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The format of the SNS topic.
        ///
        /// * JSON – Send JSON alerts with an anomaly ID and a link to the anomaly detail page. This is the default.
        ///
        /// * LONG_TEXT – Send human-readable alerts with information about the impacted timeseries and a link to the anomaly detail page. We recommend this for email.
        ///
        /// * SHORT_TEXT – Send human-readable alerts with a link to the anomaly detail page. We recommend this for SMS.
        public var snsFormat: LookoutMetricsClientTypes.SnsFormat?
        /// The ARN of the target SNS topic.
        /// This member is required.
        public var snsTopicArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            snsFormat: LookoutMetricsClientTypes.SnsFormat? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.snsFormat = snsFormat
            self.snsTopicArn = snsTopicArn
        }
    }
}

extension LookoutMetricsClientTypes {

    /// A configuration that specifies the action to perform when anomalies are detected.
    public struct Action: Swift.Sendable {
        /// A configuration for an AWS Lambda channel.
        public var lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration?
        /// A configuration for an Amazon SNS channel.
        public var snsConfiguration: LookoutMetricsClientTypes.SNSConfiguration?

        public init(
            lambdaConfiguration: LookoutMetricsClientTypes.LambdaConfiguration? = nil,
            snsConfiguration: LookoutMetricsClientTypes.SNSConfiguration? = nil
        )
        {
            self.lambdaConfiguration = lambdaConfiguration
            self.snsConfiguration = snsConfiguration
        }
    }
}

/// There was a conflict processing the request. Try your request again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request processing has failed because of an unknown error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource cannot be found. Check the ARN of the resource and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied due to too many requests being submitted at the same time.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a a field in a validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message with more information about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by the AWS service. Check your input values and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Fields that failed validation.
        public internal(set) var fields: [LookoutMetricsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that validation failed.
        public internal(set) var reason: LookoutMetricsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [LookoutMetricsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: LookoutMetricsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct ActivateAnomalyDetectorInput: Swift.Sendable {
    /// The ARN of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct ActivateAnomalyDetectorOutput: Swift.Sendable {

    public init() { }
}

extension LookoutMetricsClientTypes {

    public enum AggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFunction] {
            return [
                .avg,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// The dimension filter, containing DimensionName and DimensionValueList.
    public struct DimensionFilter: Swift.Sendable {
        /// The name of the dimension to filter on.
        public var dimensionName: Swift.String?
        /// The list of values for the dimension specified in DimensionName that you want to filter on.
        public var dimensionValueList: [Swift.String]?

        public init(
            dimensionName: Swift.String? = nil,
            dimensionValueList: [Swift.String]? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValueList = dimensionValueList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// The configuration of the alert filters.
    public struct AlertFilters: Swift.Sendable {
        /// The list of DimensionFilter objects that are used for dimension-based filtering.
        public var dimensionFilterList: [LookoutMetricsClientTypes.DimensionFilter]?
        /// The list of measures that you want to get alerts for.
        public var metricList: [Swift.String]?

        public init(
            dimensionFilterList: [LookoutMetricsClientTypes.DimensionFilter]? = nil,
            metricList: [Swift.String]? = nil
        )
        {
            self.dimensionFilterList = dimensionFilterList
            self.metricList = metricList
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum AlertStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum AlertType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambda
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertType] {
            return [
                .lambda,
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// A configuration for Amazon SNS-integrated notifications.
    public struct Alert: Swift.Sendable {
        /// Action that will be triggered when there is an alert.
        public var action: LookoutMetricsClientTypes.Action?
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// A description of the alert.
        public var alertDescription: Swift.String?
        /// The configuration of the alert filters, containing MetricList and DimensionFilter.
        public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: Foundation.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: Foundation.Date?

        public init(
            action: LookoutMetricsClientTypes.Action? = nil,
            alertArn: Swift.String? = nil,
            alertDescription: Swift.String? = nil,
            alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil
        )
        {
            self.action = action
            self.alertArn = alertArn
            self.alertDescription = alertDescription
            self.alertFilters = alertFilters
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Provides a summary of an alert's configuration.
    public struct AlertSummary: Swift.Sendable {
        /// The ARN of the alert.
        public var alertArn: Swift.String?
        /// The name of the alert.
        public var alertName: Swift.String?
        /// The minimum severity for an anomaly to trigger the alert.
        public var alertSensitivityThreshold: Swift.Int
        /// The status of the alert.
        public var alertStatus: LookoutMetricsClientTypes.AlertStatus?
        /// The type of the alert.
        public var alertType: LookoutMetricsClientTypes.AlertType?
        /// The ARN of the detector to which the alert is attached.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the alert was created.
        public var creationTime: Foundation.Date?
        /// The time at which the alert was last modified.
        public var lastModificationTime: Foundation.Date?
        /// The alert's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String: Swift.String]?

        public init(
            alertArn: Swift.String? = nil,
            alertName: Swift.String? = nil,
            alertSensitivityThreshold: Swift.Int = 0,
            alertStatus: LookoutMetricsClientTypes.AlertStatus? = nil,
            alertType: LookoutMetricsClientTypes.AlertType? = nil,
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.alertArn = alertArn
            self.alertName = alertName
            self.alertSensitivityThreshold = alertSensitivityThreshold
            self.alertStatus = alertStatus
            self.alertType = alertType
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.tags = tags
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum AnomalyDetectionTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case failedToSchedule
        case inProgress
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectionTaskStatus] {
            return [
                .completed,
                .failed,
                .failedToSchedule,
                .inProgress,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum Frequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case p1d
        case pt10m
        case pt1h
        case pt5m
        case sdkUnknown(Swift.String)

        public static var allCases: [Frequency] {
            return [
                .p1d,
                .pt10m,
                .pt1h,
                .pt5m
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .p1d: return "P1D"
            case .pt10m: return "PT10M"
            case .pt1h: return "PT1H"
            case .pt5m: return "PT5M"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfig: Swift.Sendable {
        /// The frequency at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init(
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a detector's configuration.
    public struct AnomalyDetectorConfigSummary: Swift.Sendable {
        /// The interval at which the detector analyzes its source data.
        public var anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency?

        public init(
            anomalyDetectorFrequency: LookoutMetricsClientTypes.Frequency? = nil
        )
        {
            self.anomalyDetectorFrequency = anomalyDetectorFrequency
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum DataQualityMetricType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backtestInferenceDataEndTimeStamp
        case backtestInferenceDataStartTimeStamp
        case backtestTrainingDataEndTimeStamp
        case backtestTrainingDataStartTimeStamp
        case columnCompleteness
        case dimensionUniqueness
        case invalidRowsCompliance
        case rowsPartialCompliance
        case rowsProcessed
        case timeSeriesCount
        case sdkUnknown(Swift.String)

        public static var allCases: [DataQualityMetricType] {
            return [
                .backtestInferenceDataEndTimeStamp,
                .backtestInferenceDataStartTimeStamp,
                .backtestTrainingDataEndTimeStamp,
                .backtestTrainingDataStartTimeStamp,
                .columnCompleteness,
                .dimensionUniqueness,
                .invalidRowsCompliance,
                .rowsPartialCompliance,
                .rowsProcessed,
                .timeSeriesCount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backtestInferenceDataEndTimeStamp: return "BACKTEST_INFERENCE_DATA_END_TIME_STAMP"
            case .backtestInferenceDataStartTimeStamp: return "BACKTEST_INFERENCE_DATA_START_TIME_STAMP"
            case .backtestTrainingDataEndTimeStamp: return "BACKTEST_TRAINING_DATA_END_TIME_STAMP"
            case .backtestTrainingDataStartTimeStamp: return "BACKTEST_TRAINING_DATA_START_TIME_STAMP"
            case .columnCompleteness: return "COLUMN_COMPLETENESS"
            case .dimensionUniqueness: return "DIMENSION_UNIQUENESS"
            case .invalidRowsCompliance: return "INVALID_ROWS_COMPLIANCE"
            case .rowsPartialCompliance: return "ROWS_PARTIAL_COMPLIANCE"
            case .rowsProcessed: return "ROWS_PROCESSED"
            case .timeSeriesCount: return "TIME_SERIES_COUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An array that describes a data quality metric. Each DataQualityMetric object contains the data quality metric name, its value, a description of the metric, and the affected column.
    public struct DataQualityMetric: Swift.Sendable {
        /// A description of the data quality metric.
        public var metricDescription: Swift.String?
        /// The name of the data quality metric.
        public var metricType: LookoutMetricsClientTypes.DataQualityMetricType?
        /// The value of the data quality metric.
        public var metricValue: Swift.Double?
        /// The column that is being monitored.
        public var relatedColumnName: Swift.String?

        public init(
            metricDescription: Swift.String? = nil,
            metricType: LookoutMetricsClientTypes.DataQualityMetricType? = nil,
            metricValue: Swift.Double? = nil,
            relatedColumnName: Swift.String? = nil
        )
        {
            self.metricDescription = metricDescription
            self.metricType = metricType
            self.metricValue = metricValue
            self.relatedColumnName = relatedColumnName
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An array of DataQualityMetric objects that describes one or more data quality metrics.
    public struct MetricSetDataQualityMetric: Swift.Sendable {
        /// The array of data quality metrics contained in the data quality metric set.
        public var dataQualityMetricList: [LookoutMetricsClientTypes.DataQualityMetric]?
        /// The Amazon Resource Name (ARN) of the data quality metric array.
        public var metricSetArn: Swift.String?

        public init(
            dataQualityMetricList: [LookoutMetricsClientTypes.DataQualityMetric]? = nil,
            metricSetArn: Swift.String? = nil
        )
        {
            self.dataQualityMetricList = dataQualityMetricList
            self.metricSetArn = metricSetArn
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Aggregated details about the data quality metrics collected for the AnomalyDetectorArn provided in the [GetDataQualityMetrics] object.
    public struct AnomalyDetectorDataQualityMetric: Swift.Sendable {
        /// An array of DataQualityMetricList objects. Each object in the array contains information about a data quality metric.
        public var metricSetDataQualityMetricList: [LookoutMetricsClientTypes.MetricSetDataQualityMetric]?
        /// The start time for the data quality metrics collection.
        public var startTimestamp: Foundation.Date?

        public init(
            metricSetDataQualityMetricList: [LookoutMetricsClientTypes.MetricSetDataQualityMetric]? = nil,
            startTimestamp: Foundation.Date? = nil
        )
        {
            self.metricSetDataQualityMetricList = metricSetDataQualityMetricList
            self.startTimestamp = startTimestamp
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum AnomalyDetectorFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activationFailure
        case backTestActivationFailure
        case deactivationFailure
        case deletionFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectorFailureType] {
            return [
                .activationFailure,
                .backTestActivationFailure,
                .deactivationFailure,
                .deletionFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activationFailure: return "ACTIVATION_FAILURE"
            case .backTestActivationFailure: return "BACK_TEST_ACTIVATION_FAILURE"
            case .deactivationFailure: return "DEACTIVATION_FAILURE"
            case .deletionFailure: return "DELETION_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum AnomalyDetectorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case backTestActivating
        case backTestActive
        case backTestComplete
        case deactivated
        case deactivating
        case deleting
        case failed
        case inactive
        case learning
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyDetectorStatus] {
            return [
                .activating,
                .active,
                .backTestActivating,
                .backTestActive,
                .backTestComplete,
                .deactivated,
                .deactivating,
                .deleting,
                .failed,
                .inactive,
                .learning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .backTestActivating: return "BACK_TEST_ACTIVATING"
            case .backTestActive: return "BACK_TEST_ACTIVE"
            case .backTestComplete: return "BACK_TEST_COMPLETE"
            case .deactivated: return "DEACTIVATED"
            case .deactivating: return "DEACTIVATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .learning: return "LEARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about an an anomaly detector.
    public struct AnomalyDetectorSummary: Swift.Sendable {
        /// The ARN of the detector.
        public var anomalyDetectorArn: Swift.String?
        /// A description of the detector.
        public var anomalyDetectorDescription: Swift.String?
        /// The name of the detector.
        public var anomalyDetectorName: Swift.String?
        /// The time at which the detector was created.
        public var creationTime: Foundation.Date?
        /// The time at which the detector was last modified.
        public var lastModificationTime: Foundation.Date?
        /// The status of detector.
        public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?
        /// The detector's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String: Swift.String]?

        public init(
            anomalyDetectorArn: Swift.String? = nil,
            anomalyDetectorDescription: Swift.String? = nil,
            anomalyDetectorName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.anomalyDetectorDescription = anomalyDetectorDescription
            self.anomalyDetectorName = anomalyDetectorName
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.status = status
            self.tags = tags
        }
    }
}

extension LookoutMetricsClientTypes {

    /// The severity of a value of a dimension that contributed to an anomaly.
    public struct DimensionValueContribution: Swift.Sendable {
        /// The severity score of the value.
        public var contributionScore: Swift.Double?
        /// The value of the dimension.
        public var dimensionValue: Swift.String?

        public init(
            contributionScore: Swift.Double? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.contributionScore = contributionScore
            self.dimensionValue = dimensionValue
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about a dimension that contributed to an anomaly.
    public struct DimensionContribution: Swift.Sendable {
        /// The name of the dimension.
        public var dimensionName: Swift.String?
        /// A list of dimension values that contributed to the anomaly.
        public var dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]?

        public init(
            dimensionName: Swift.String? = nil,
            dimensionValueContributionList: [LookoutMetricsClientTypes.DimensionValueContribution]? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValueContributionList = dimensionValueContributionList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about dimensions that contributed to an anomaly.
    public struct ContributionMatrix: Swift.Sendable {
        /// A list of contributing dimensions.
        public var dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]?

        public init(
            dimensionContributionList: [LookoutMetricsClientTypes.DimensionContribution]? = nil
        )
        {
            self.dimensionContributionList = dimensionContributionList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about a measure affected by an anomaly.
    public struct MetricLevelImpact: Swift.Sendable {
        /// Details about the dimensions that contributed to the anomaly.
        public var contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix?
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of anomalous metrics for the measure.
        public var numTimeSeries: Swift.Int

        public init(
            contributionMatrix: LookoutMetricsClientTypes.ContributionMatrix? = nil,
            metricName: Swift.String? = nil,
            numTimeSeries: Swift.Int = 0
        )
        {
            self.contributionMatrix = contributionMatrix
            self.metricName = metricName
            self.numTimeSeries = numTimeSeries
        }
    }
}

extension LookoutMetricsClientTypes {

    /// A group of anomalous metrics
    public struct AnomalyGroup: Swift.Sendable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// A list of measures affected by the anomaly.
        public var metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init(
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            metricLevelImpactList: [LookoutMetricsClientTypes.MetricLevelImpact]? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.metricLevelImpactList = metricLevelImpactList
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Aggregated statistics about a measure affected by an anomaly.
    public struct ItemizedMetricStats: Swift.Sendable {
        /// The name of the measure.
        public var metricName: Swift.String?
        /// The number of times that the measure appears.
        public var occurrenceCount: Swift.Int

        public init(
            metricName: Swift.String? = nil,
            occurrenceCount: Swift.Int = 0
        )
        {
            self.metricName = metricName
            self.occurrenceCount = occurrenceCount
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Aggregated statistics for a group of anomalous metrics.
    public struct AnomalyGroupStatistics: Swift.Sendable {
        /// The start of the time range that was searched.
        public var evaluationStartDate: Swift.String?
        /// Statistics for individual metrics within the group.
        public var itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]?
        /// The number of groups found.
        public var totalCount: Swift.Int

        public init(
            evaluationStartDate: Swift.String? = nil,
            itemizedMetricStatsList: [LookoutMetricsClientTypes.ItemizedMetricStats]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.evaluationStartDate = evaluationStartDate
            self.itemizedMetricStatsList = itemizedMetricStatsList
            self.totalCount = totalCount
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about a group of anomalous metrics.
    public struct AnomalyGroupSummary: Swift.Sendable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// The severity score of the group.
        public var anomalyGroupScore: Swift.Double?
        /// The end time for the group.
        public var endTime: Swift.String?
        /// The name of the primary affected measure for the group.
        public var primaryMetricName: Swift.String?
        /// The start time for the group.
        public var startTime: Swift.String?

        public init(
            anomalyGroupId: Swift.String? = nil,
            anomalyGroupScore: Swift.Double? = nil,
            endTime: Swift.String? = nil,
            primaryMetricName: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.anomalyGroupScore = anomalyGroupScore
            self.endTime = endTime
            self.primaryMetricName = primaryMetricName
            self.startTime = startTime
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An anomalous metric in an anomaly group.
    public struct AnomalyGroupTimeSeries: Swift.Sendable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init(
            anomalyGroupId: Swift.String? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.timeSeriesId = timeSeriesId
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Feedback for an anomalous metric.
    public struct AnomalyGroupTimeSeriesFeedback: Swift.Sendable {
        /// The ID of the anomaly group.
        /// This member is required.
        public var anomalyGroupId: Swift.String?
        /// Feedback on whether the metric is a legitimate anomaly.
        /// This member is required.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init(
            anomalyGroupId: Swift.String? = nil,
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about an Amazon AppFlow flow datasource.
    public struct AppFlowConfig: Swift.Sendable {
        /// name of the flow.
        public var flowName: Swift.String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the flow.
        public var roleArn: Swift.String?

        public init(
            flowName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.flowName = flowName
            self.roleArn = roleArn
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Settings for backtest mode.
    public struct BackTestConfiguration: Swift.Sendable {
        /// Run a backtest instead of monitoring new data.
        /// This member is required.
        public var runBackTestMode: Swift.Bool?

        public init(
            runBackTestMode: Swift.Bool? = nil
        )
        {
            self.runBackTestMode = runBackTestMode
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Details about an Amazon Athena datasource.
    public struct AthenaSourceConfig: Swift.Sendable {
        /// Settings for backtest mode.
        public var backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration?
        /// The database's data catalog.
        public var dataCatalog: Swift.String?
        /// The database's name.
        public var databaseName: Swift.String?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access the data.
        public var roleArn: Swift.String?
        /// The database's results path.
        public var s3ResultsPath: Swift.String?
        /// The database's table name.
        public var tableName: Swift.String?
        /// The database's work group name.
        public var workGroupName: Swift.String?

        public init(
            backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration? = nil,
            dataCatalog: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3ResultsPath: Swift.String? = nil,
            tableName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.backTestConfiguration = backTestConfiguration
            self.dataCatalog = dataCatalog
            self.databaseName = databaseName
            self.roleArn = roleArn
            self.s3ResultsPath = s3ResultsPath
            self.tableName = tableName
            self.workGroupName = workGroupName
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An attribute value.
    public struct AttributeValue: Swift.Sendable {
        /// A binary value.
        public var b: Swift.String?
        /// A list of binary values.
        public var bs: [Swift.String]?
        /// A number.
        public var n: Swift.String?
        /// A list of numbers.
        public var ns: [Swift.String]?
        /// A string.
        public var s: Swift.String?
        /// A list of strings.
        public var ss: [Swift.String]?

        public init(
            b: Swift.String? = nil,
            bs: [Swift.String]? = nil,
            n: Swift.String? = nil,
            ns: [Swift.String]? = nil,
            s: Swift.String? = nil,
            ss: [Swift.String]? = nil
        )
        {
            self.b = b
            self.bs = bs
            self.n = n
            self.ns = ns
            self.s = s
            self.ss = ss
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An auto detection source config.
    public struct AutoDetectionS3SourceConfig: Swift.Sendable {
        /// The config's historical data path list.
        public var historicalDataPathList: [Swift.String]?
        /// The config's templated path list.
        public var templatedPathList: [Swift.String]?

        public init(
            historicalDataPathList: [Swift.String]? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.historicalDataPathList = historicalDataPathList
            self.templatedPathList = templatedPathList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An auto detection metric source.
    public struct AutoDetectionMetricSource: Swift.Sendable {
        /// The source's source config.
        public var s3SourceConfig: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig?

        public init(
            s3SourceConfig: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig? = nil
        )
        {
            self.s3SourceConfig = s3SourceConfig
        }
    }
}

public struct BackTestAnomalyDetectorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct BackTestAnomalyDetectorOutput: Swift.Sendable {

    public init() { }
}

extension LookoutMetricsClientTypes {

    /// Details about an Amazon CloudWatch datasource.
    public struct CloudWatchConfig: Swift.Sendable {
        /// Settings for backtest mode.
        public var backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration?
        /// An IAM role that gives Amazon Lookout for Metrics permission to access data in Amazon CloudWatch.
        public var roleArn: Swift.String?

        public init(
            backTestConfiguration: LookoutMetricsClientTypes.BackTestConfiguration? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.backTestConfiguration = backTestConfiguration
            self.roleArn = roleArn
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum Confidence: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [Confidence] {
            return [
                .high,
                .low,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request exceeded the service's quotas. Check the service quotas and try again.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct CreateAlertInput: Swift.Sendable {
    /// Action that will be triggered when there is an alert.
    /// This member is required.
    public var action: LookoutMetricsClientTypes.Action?
    /// A description of the alert.
    public var alertDescription: Swift.String?
    /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
    public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
    /// The name of the alert.
    /// This member is required.
    public var alertName: Swift.String?
    /// An integer from 0 to 100 specifying the alert sensitivity threshold.
    public var alertSensitivityThreshold: Swift.Int?
    /// The ARN of the detector to which the alert is attached.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the alert.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: LookoutMetricsClientTypes.Action? = nil,
        alertDescription: Swift.String? = nil,
        alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
        alertName: Swift.String? = nil,
        alertSensitivityThreshold: Swift.Int? = 0,
        anomalyDetectorArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.action = action
        self.alertDescription = alertDescription
        self.alertFilters = alertFilters
        self.alertName = alertName
        self.alertSensitivityThreshold = alertSensitivityThreshold
        self.anomalyDetectorArn = anomalyDetectorArn
        self.tags = tags
    }
}

public struct CreateAlertOutput: Swift.Sendable {
    /// The ARN of the alert.
    public var alertArn: Swift.String?

    public init(
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

public struct CreateAnomalyDetectorInput: Swift.Sendable {
    /// Contains information about the configuration of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    /// This member is required.
    public var anomalyDetectorName: Swift.String?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the anomaly detector.
    public var tags: [Swift.String: Swift.String]?

    public init(
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

public struct CreateAnomalyDetectorOutput: Swift.Sendable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

extension LookoutMetricsClientTypes {

    public enum FilterOperation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperation] {
            return [
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Describes a filter for choosing a subset of dimension values. Each filter consists of the dimension that you want to include and the condition statement. The condition statement is specified in the FilterOperation object.
    public struct Filter: Swift.Sendable {
        /// The value that you want to include in the filter.
        public var dimensionValue: Swift.String?
        /// The condition to apply.
        public var filterOperation: LookoutMetricsClientTypes.FilterOperation?

        public init(
            dimensionValue: Swift.String? = nil,
            filterOperation: LookoutMetricsClientTypes.FilterOperation? = nil
        )
        {
            self.dimensionValue = dimensionValue
            self.filterOperation = filterOperation
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Describes a list of filters for choosing a subset of dimension values. Each filter consists of the dimension and one of its values that you want to include. When multiple dimensions or values are specified, the dimensions are joined with an AND operation and the values are joined with an OR operation.
    public struct MetricSetDimensionFilter: Swift.Sendable {
        /// The list of filters that you are applying.
        public var filterList: [LookoutMetricsClientTypes.Filter]?
        /// The dimension that you want to filter on.
        public var name: Swift.String?

        public init(
            filterList: [LookoutMetricsClientTypes.Filter]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filterList = filterList
            self.name = name
        }
    }
}

extension LookoutMetricsClientTypes {

    /// A calculation made by contrasting a measure and a dimension from your source data.
    public struct Metric: Swift.Sendable {
        /// The function with which the metric is calculated.
        /// This member is required.
        public var aggregationFunction: LookoutMetricsClientTypes.AggregationFunction?
        /// The name of the metric.
        /// This member is required.
        public var metricName: Swift.String?
        /// The namespace for the metric.
        public var namespace: Swift.String?

        public init(
            aggregationFunction: LookoutMetricsClientTypes.AggregationFunction? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.metricName = metricName
            self.namespace = namespace
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains configuration information about the Amazon Virtual Private Cloud (VPC).
    public struct VpcConfiguration: Swift.Sendable {
        /// An array of strings containing the list of security groups.
        /// This member is required.
        public var securityGroupIdList: [Swift.String]?
        /// An array of strings containing the Amazon VPC subnet IDs (e.g., subnet-0bb1c79de3EXAMPLE.
        /// This member is required.
        public var subnetIdList: [Swift.String]?

        public init(
            securityGroupIdList: [Swift.String]? = nil,
            subnetIdList: [Swift.String]? = nil
        )
        {
            self.securityGroupIdList = securityGroupIdList
            self.subnetIdList = subnetIdList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about the Amazon Relational Database Service (RDS) configuration.
    public struct RDSSourceConfig: Swift.Sendable {
        /// The host name of the database.
        public var databaseHost: Swift.String?
        /// The name of the RDS database.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        public var databasePort: Swift.Int?
        /// A string identifying the database instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public var secretManagerArn: Swift.String?
        /// The name of the table in the database.
        public var tableName: Swift.String?
        /// An object containing information about the Amazon Virtual Private Cloud (VPC) configuration.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init(
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Provides information about the Amazon Redshift database configuration.
    public struct RedshiftSourceConfig: Swift.Sendable {
        /// A string identifying the Redshift cluster.
        public var clusterIdentifier: Swift.String?
        /// The name of the database host.
        public var databaseHost: Swift.String?
        /// The Redshift database name.
        public var databaseName: Swift.String?
        /// The port number where the database can be accessed.
        public var databasePort: Swift.Int?
        /// The Amazon Resource Name (ARN) of the role providing access to the database.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager role.
        public var secretManagerArn: Swift.String?
        /// The table name of the Redshift database.
        public var tableName: Swift.String?
        /// Contains information about the Amazon Virtual Private Cloud (VPC) configuration.
        public var vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration?

        public init(
            clusterIdentifier: Swift.String? = nil,
            databaseHost: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databasePort: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            secretManagerArn: Swift.String? = nil,
            tableName: Swift.String? = nil,
            vpcConfiguration: LookoutMetricsClientTypes.VpcConfiguration? = nil
        )
        {
            self.clusterIdentifier = clusterIdentifier
            self.databaseHost = databaseHost
            self.databaseName = databaseName
            self.databasePort = databasePort
            self.roleArn = roleArn
            self.secretManagerArn = secretManagerArn
            self.tableName = tableName
            self.vpcConfiguration = vpcConfiguration
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum CSVFileCompression: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [CSVFileCompression] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about how a source CSV data file should be analyzed.
    public struct CsvFormatDescriptor: Swift.Sendable {
        /// The character set in which the source CSV file is written.
        public var charset: Swift.String?
        /// Whether or not the source CSV file contains a header.
        public var containsHeader: Swift.Bool?
        /// The character used to delimit the source CSV file.
        public var delimiter: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.CSVFileCompression?
        /// A list of the source CSV file's headers, if any.
        public var headerList: [Swift.String]?
        /// The character used as a quote character.
        public var quoteSymbol: Swift.String?

        public init(
            charset: Swift.String? = nil,
            containsHeader: Swift.Bool? = nil,
            delimiter: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.CSVFileCompression? = nil,
            headerList: [Swift.String]? = nil,
            quoteSymbol: Swift.String? = nil
        )
        {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }
    }
}

extension LookoutMetricsClientTypes {

    public enum JsonFileCompression: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [JsonFileCompression] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about how a source JSON data file should be analyzed.
    public struct JsonFormatDescriptor: Swift.Sendable {
        /// The character set in which the source JSON file is written.
        public var charset: Swift.String?
        /// The level of compression of the source CSV file.
        public var fileCompression: LookoutMetricsClientTypes.JsonFileCompression?

        public init(
            charset: Swift.String? = nil,
            fileCompression: LookoutMetricsClientTypes.JsonFileCompression? = nil
        )
        {
            self.charset = charset
            self.fileCompression = fileCompression
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a source file's formatting.
    public struct FileFormatDescriptor: Swift.Sendable {
        /// Contains information about how a source CSV data file should be analyzed.
        public var csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor?
        /// Contains information about how a source JSON data file should be analyzed.
        public var jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor?

        public init(
            csvFormatDescriptor: LookoutMetricsClientTypes.CsvFormatDescriptor? = nil,
            jsonFormatDescriptor: LookoutMetricsClientTypes.JsonFormatDescriptor? = nil
        )
        {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about the configuration of the S3 bucket that contains source files.
    public struct S3SourceConfig: Swift.Sendable {
        /// Contains information about a source file's formatting.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// A list of paths to the historical data files.
        public var historicalDataPathList: [Swift.String]?
        /// The ARN of an IAM role that has read and write access permissions to the source S3 bucket.
        public var roleArn: Swift.String?
        /// A list of templated paths to the source files.
        public var templatedPathList: [Swift.String]?

        public init(
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about source data used to generate metrics.
    public struct MetricSource: Swift.Sendable {
        /// Details about an AppFlow datasource.
        public var appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig?
        /// Details about an Amazon Athena datasource.
        public var athenaSourceConfig: LookoutMetricsClientTypes.AthenaSourceConfig?
        /// Details about an Amazon CloudWatch monitoring datasource.
        public var cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig?
        /// Details about an Amazon Relational Database Service (RDS) datasource.
        public var rdsSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig?
        /// Details about an Amazon Redshift database datasource.
        public var redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig?
        /// Contains information about the configuration of the S3 bucket that contains source files.
        public var s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig?

        public init(
            appFlowConfig: LookoutMetricsClientTypes.AppFlowConfig? = nil,
            athenaSourceConfig: LookoutMetricsClientTypes.AthenaSourceConfig? = nil,
            cloudWatchConfig: LookoutMetricsClientTypes.CloudWatchConfig? = nil,
            rdsSourceConfig: LookoutMetricsClientTypes.RDSSourceConfig? = nil,
            redshiftSourceConfig: LookoutMetricsClientTypes.RedshiftSourceConfig? = nil,
            s3SourceConfig: LookoutMetricsClientTypes.S3SourceConfig? = nil
        )
        {
            self.appFlowConfig = appFlowConfig
            self.athenaSourceConfig = athenaSourceConfig
            self.cloudWatchConfig = cloudWatchConfig
            self.rdsSourceConfig = rdsSourceConfig
            self.redshiftSourceConfig = redshiftSourceConfig
            self.s3SourceConfig = s3SourceConfig
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about the column used to track time in a source data file.
    public struct TimestampColumn: Swift.Sendable {
        /// The format of the timestamp column.
        public var columnFormat: Swift.String?
        /// The name of the timestamp column.
        public var columnName: Swift.String?

        public init(
            columnFormat: Swift.String? = nil,
            columnName: Swift.String? = nil
        )
        {
            self.columnFormat = columnFormat
            self.columnName = columnName
        }
    }
}

public struct CreateMetricSetInput: Swift.Sendable {
    /// The ARN of the anomaly detector that will use the dataset.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A list of filters that specify which data is kept for anomaly detection.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// A list of the fields you want to treat as dimensions.
    public var dimensionList: [Swift.String]?
    /// A list of metrics that the dataset will contain.
    /// This member is required.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// A description of the dataset you are creating.
    public var metricSetDescription: Swift.String?
    /// The frequency with which the source data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    /// This member is required.
    public var metricSetName: Swift.String?
    /// Contains information about how the source data should be interpreted.
    /// This member is required.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// A list of [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html) to apply to the dataset.
    public var tags: [Swift.String: Swift.String]?
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which your source data was recorded.
    public var timezone: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = 0,
        tags: [Swift.String: Swift.String]? = nil,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.tags = tags
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

public struct CreateMetricSetOutput: Swift.Sendable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init(
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

public struct DeactivateAnomalyDetectorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct DeactivateAnomalyDetectorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAlertInput: Swift.Sendable {
    /// The ARN of the alert to delete.
    /// This member is required.
    public var alertArn: Swift.String?

    public init(
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

public struct DeleteAlertOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAnomalyDetectorInput: Swift.Sendable {
    /// The ARN of the detector to delete.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct DeleteAnomalyDetectorOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeAlertInput: Swift.Sendable {
    /// The ARN of the alert to describe.
    /// This member is required.
    public var alertArn: Swift.String?

    public init(
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

public struct DescribeAlertOutput: Swift.Sendable {
    /// Contains information about an alert.
    public var alert: LookoutMetricsClientTypes.Alert?

    public init(
        alert: LookoutMetricsClientTypes.Alert? = nil
    )
    {
        self.alert = alert
    }
}

public struct DescribeAnomalyDetectionExecutionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The number of items to return in the response.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The timestamp of the anomaly detection job.
    public var timestamp: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timestamp: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timestamp = timestamp
    }
}

extension LookoutMetricsClientTypes {

    /// The status of an anomaly detector run.
    public struct ExecutionStatus: Swift.Sendable {
        /// The reason that the run failed, if applicable.
        public var failureReason: Swift.String?
        /// The run's status.
        public var status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus?
        /// The run's timestamp.
        public var timestamp: Swift.String?

        public init(
            failureReason: Swift.String? = nil,
            status: LookoutMetricsClientTypes.AnomalyDetectionTaskStatus? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.failureReason = failureReason
            self.status = status
            self.timestamp = timestamp
        }
    }
}

public struct DescribeAnomalyDetectionExecutionsOutput: Swift.Sendable {
    /// A list of detection jobs.
    public var executionList: [LookoutMetricsClientTypes.ExecutionStatus]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        executionList: [LookoutMetricsClientTypes.ExecutionStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executionList = executionList
        self.nextToken = nextToken
    }
}

public struct DescribeAnomalyDetectorInput: Swift.Sendable {
    /// The ARN of the detector to describe.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct DescribeAnomalyDetectorOutput: Swift.Sendable {
    /// The ARN of the detector.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the detector's configuration.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary?
    /// A description of the detector.
    public var anomalyDetectorDescription: Swift.String?
    /// The name of the detector.
    public var anomalyDetectorName: Swift.String?
    /// The time at which the detector was created.
    public var creationTime: Foundation.Date?
    /// The reason that the detector failed.
    public var failureReason: Swift.String?
    /// The process that caused the detector to fail.
    public var failureType: LookoutMetricsClientTypes.AnomalyDetectorFailureType?
    /// The ARN of the KMS key to use to encrypt your data.
    public var kmsKeyArn: Swift.String?
    /// The time at which the detector was last modified.
    public var lastModificationTime: Foundation.Date?
    /// The status of the detector.
    public var status: LookoutMetricsClientTypes.AnomalyDetectorStatus?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        anomalyDetectorName: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        failureReason: Swift.String? = nil,
        failureType: LookoutMetricsClientTypes.AnomalyDetectorFailureType? = nil,
        kmsKeyArn: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        status: LookoutMetricsClientTypes.AnomalyDetectorStatus? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.anomalyDetectorName = anomalyDetectorName
        self.creationTime = creationTime
        self.failureReason = failureReason
        self.failureType = failureType
        self.kmsKeyArn = kmsKeyArn
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

public struct DescribeMetricSetInput: Swift.Sendable {
    /// The ARN of the dataset.
    /// This member is required.
    public var metricSetArn: Swift.String?

    public init(
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

public struct DescribeMetricSetOutput: Swift.Sendable {
    /// The ARN of the detector that contains the dataset.
    public var anomalyDetectorArn: Swift.String?
    /// The time at which the dataset was created.
    public var creationTime: Foundation.Date?
    /// The dimensions and their values that were used to filter the dataset.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// A list of the dimensions chosen for analysis.
    public var dimensionList: [Swift.String]?
    /// The time at which the dataset was last modified.
    public var lastModificationTime: Foundation.Date?
    /// A list of the metrics defined by the dataset.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The interval at which the data will be analyzed for anomalies.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// The name of the dataset.
    public var metricSetName: Swift.String?
    /// Contains information about the dataset's source data.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// Contains information about the column used for tracking time in your source data.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?
    /// The time zone in which the dataset's data was recorded.
    public var timezone: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        lastModificationTime: Foundation.Date? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSetName: Swift.String? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = 0,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.creationTime = creationTime
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.lastModificationTime = lastModificationTime
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSetName = metricSetName
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
        self.timezone = timezone
    }
}

extension LookoutMetricsClientTypes {

    /// An inferred field.
    public struct DetectedField: Swift.Sendable {
        /// The field's confidence.
        public var confidence: LookoutMetricsClientTypes.Confidence?
        /// The field's message.
        public var message: Swift.String?
        /// The field's value.
        public var value: LookoutMetricsClientTypes.AttributeValue?

        public init(
            confidence: LookoutMetricsClientTypes.Confidence? = nil,
            message: Swift.String? = nil,
            value: LookoutMetricsClientTypes.AttributeValue? = nil
        )
        {
            self.confidence = confidence
            self.message = message
            self.value = value
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Properties of an inferred CSV format.
    public struct DetectedCsvFormatDescriptor: Swift.Sendable {
        /// The format's charset.
        public var charset: LookoutMetricsClientTypes.DetectedField?
        /// Whether the format includes a header.
        public var containsHeader: LookoutMetricsClientTypes.DetectedField?
        /// The format's delimiter.
        public var delimiter: LookoutMetricsClientTypes.DetectedField?
        /// The format's file compression.
        public var fileCompression: LookoutMetricsClientTypes.DetectedField?
        /// The format's header list.
        public var headerList: LookoutMetricsClientTypes.DetectedField?
        /// The format's quote symbol.
        public var quoteSymbol: LookoutMetricsClientTypes.DetectedField?

        public init(
            charset: LookoutMetricsClientTypes.DetectedField? = nil,
            containsHeader: LookoutMetricsClientTypes.DetectedField? = nil,
            delimiter: LookoutMetricsClientTypes.DetectedField? = nil,
            fileCompression: LookoutMetricsClientTypes.DetectedField? = nil,
            headerList: LookoutMetricsClientTypes.DetectedField? = nil,
            quoteSymbol: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.charset = charset
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.fileCompression = fileCompression
            self.headerList = headerList
            self.quoteSymbol = quoteSymbol
        }
    }
}

extension LookoutMetricsClientTypes {

    /// A detected JSON format descriptor.
    public struct DetectedJsonFormatDescriptor: Swift.Sendable {
        /// The format's character set.
        public var charset: LookoutMetricsClientTypes.DetectedField?
        /// The format's file compression.
        public var fileCompression: LookoutMetricsClientTypes.DetectedField?

        public init(
            charset: LookoutMetricsClientTypes.DetectedField? = nil,
            fileCompression: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.charset = charset
            self.fileCompression = fileCompression
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Properties of an inferred data format.
    public struct DetectedFileFormatDescriptor: Swift.Sendable {
        /// Details about a CSV format.
        public var csvFormatDescriptor: LookoutMetricsClientTypes.DetectedCsvFormatDescriptor?
        /// Details about a JSON format.
        public var jsonFormatDescriptor: LookoutMetricsClientTypes.DetectedJsonFormatDescriptor?

        public init(
            csvFormatDescriptor: LookoutMetricsClientTypes.DetectedCsvFormatDescriptor? = nil,
            jsonFormatDescriptor: LookoutMetricsClientTypes.DetectedJsonFormatDescriptor? = nil
        )
        {
            self.csvFormatDescriptor = csvFormatDescriptor
            self.jsonFormatDescriptor = jsonFormatDescriptor
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An inferred source configuration.
    public struct DetectedS3SourceConfig: Swift.Sendable {
        /// The source's file format descriptor.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.DetectedFileFormatDescriptor?

        public init(
            fileFormatDescriptor: LookoutMetricsClientTypes.DetectedFileFormatDescriptor? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An inferred data source.
    public struct DetectedMetricSource: Swift.Sendable {
        /// The data source's source configuration.
        public var s3SourceConfig: LookoutMetricsClientTypes.DetectedS3SourceConfig?

        public init(
            s3SourceConfig: LookoutMetricsClientTypes.DetectedS3SourceConfig? = nil
        )
        {
            self.s3SourceConfig = s3SourceConfig
        }
    }
}

extension LookoutMetricsClientTypes {

    /// An inferred dataset configuration.
    public struct DetectedMetricSetConfig: Swift.Sendable {
        /// The dataset's interval.
        public var metricSetFrequency: LookoutMetricsClientTypes.DetectedField?
        /// The dataset's data source.
        public var metricSource: LookoutMetricsClientTypes.DetectedMetricSource?
        /// The dataset's offset.
        public var offset: LookoutMetricsClientTypes.DetectedField?

        public init(
            metricSetFrequency: LookoutMetricsClientTypes.DetectedField? = nil,
            metricSource: LookoutMetricsClientTypes.DetectedMetricSource? = nil,
            offset: LookoutMetricsClientTypes.DetectedField? = nil
        )
        {
            self.metricSetFrequency = metricSetFrequency
            self.metricSource = metricSource
            self.offset = offset
        }
    }
}

public struct DetectMetricSetConfigInput: Swift.Sendable {
    /// An anomaly detector ARN.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// A data source.
    /// This member is required.
    public var autoDetectionMetricSource: LookoutMetricsClientTypes.AutoDetectionMetricSource?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        autoDetectionMetricSource: LookoutMetricsClientTypes.AutoDetectionMetricSource? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.autoDetectionMetricSource = autoDetectionMetricSource
    }
}

public struct DetectMetricSetConfigOutput: Swift.Sendable {
    /// The inferred dataset configuration for the datasource.
    public var detectedMetricSetConfig: LookoutMetricsClientTypes.DetectedMetricSetConfig?

    public init(
        detectedMetricSetConfig: LookoutMetricsClientTypes.DetectedMetricSetConfig? = nil
    )
    {
        self.detectedMetricSetConfig = detectedMetricSetConfig
    }
}

extension LookoutMetricsClientTypes {

    /// A dimension name and value.
    public struct DimensionNameValue: Swift.Sendable {
        /// The name of the dimension.
        /// This member is required.
        public var dimensionName: Swift.String?
        /// The value of the dimension.
        /// This member is required.
        public var dimensionValue: Swift.String?

        public init(
            dimensionName: Swift.String? = nil,
            dimensionValue: Swift.String? = nil
        )
        {
            self.dimensionName = dimensionName
            self.dimensionValue = dimensionValue
        }
    }
}

public struct GetAnomalyGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
    }
}

public struct GetAnomalyGroupOutput: Swift.Sendable {
    /// Details about the anomaly group.
    public var anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup?

    public init(
        anomalyGroup: LookoutMetricsClientTypes.AnomalyGroup? = nil
    )
    {
        self.anomalyGroup = anomalyGroup
    }
}

public struct GetDataQualityMetricsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector that you want to investigate.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The Amazon Resource Name (ARN) of a specific data quality metric set.
    public var metricSetArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        metricSetArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.metricSetArn = metricSetArn
    }
}

public struct GetDataQualityMetricsOutput: Swift.Sendable {
    /// A list of the data quality metrics for the AnomalyDetectorArn that you requested.
    public var anomalyDetectorDataQualityMetricList: [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]?

    public init(
        anomalyDetectorDataQualityMetricList: [LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric]? = nil
    )
    {
        self.anomalyDetectorDataQualityMetricList = anomalyDetectorDataQualityMetricList
    }
}

public struct GetFeedbackInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The anomalous metric and group ID.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeries? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LookoutMetricsClientTypes {

    /// Details about feedback submitted for an anomalous metric.
    public struct TimeSeriesFeedback: Swift.Sendable {
        /// Feedback on whether the metric is a legitimate anomaly.
        public var isAnomaly: Swift.Bool?
        /// The ID of the metric.
        public var timeSeriesId: Swift.String?

        public init(
            isAnomaly: Swift.Bool? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.isAnomaly = isAnomaly
            self.timeSeriesId = timeSeriesId
        }
    }
}

public struct GetFeedbackOutput: Swift.Sendable {
    /// Feedback for an anomalous metric.
    public var anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        anomalyGroupTimeSeriesFeedback: [LookoutMetricsClientTypes.TimeSeriesFeedback]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
        self.nextToken = nextToken
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about the source configuration in Amazon S3.
    public struct SampleDataS3SourceConfig: Swift.Sendable {
        /// Contains information about a source file's formatting.
        /// This member is required.
        public var fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor?
        /// An array of strings containing the historical set of data paths.
        public var historicalDataPathList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// An array of strings containing the list of templated paths.
        public var templatedPathList: [Swift.String]?

        public init(
            fileFormatDescriptor: LookoutMetricsClientTypes.FileFormatDescriptor? = nil,
            historicalDataPathList: [Swift.String]? = nil,
            roleArn: Swift.String? = nil,
            templatedPathList: [Swift.String]? = nil
        )
        {
            self.fileFormatDescriptor = fileFormatDescriptor
            self.historicalDataPathList = historicalDataPathList
            self.roleArn = roleArn
            self.templatedPathList = templatedPathList
        }
    }
}

public struct GetSampleDataInput: Swift.Sendable {
    /// A datasource bucket in Amazon S3.
    public var s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig?

    public init(
        s3SourceConfig: LookoutMetricsClientTypes.SampleDataS3SourceConfig? = nil
    )
    {
        self.s3SourceConfig = s3SourceConfig
    }
}

public struct GetSampleDataOutput: Swift.Sendable {
    /// A list of header labels for the records.
    public var headerValues: [Swift.String]?
    /// A list of records.
    public var sampleRows: [[Swift.String]]?

    public init(
        headerValues: [Swift.String]? = nil,
        sampleRows: [[Swift.String]]? = nil
    )
    {
        self.headerValues = headerValues
        self.sampleRows = sampleRows
    }
}

extension LookoutMetricsClientTypes {

    public enum RelationshipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case causeOfInputAnomalyGroup
        case effectOfInputAnomalyGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .causeOfInputAnomalyGroup,
                .effectOfInputAnomalyGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .causeOfInputAnomalyGroup: return "CAUSE_OF_INPUT_ANOMALY_GROUP"
            case .effectOfInputAnomalyGroup: return "EFFECT_OF_INPUT_ANOMALY_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LookoutMetricsClientTypes {

    /// Aggregated details about the measures contributing to the anomaly group, and the measures potentially impacted by the anomaly group.
    public struct InterMetricImpactDetails: Swift.Sendable {
        /// The ID of the anomaly group.
        public var anomalyGroupId: Swift.String?
        /// For potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP), the percentage contribution the measure has in causing the anomalies.
        public var contributionPercentage: Swift.Double?
        /// The name of the measure.
        public var metricName: Swift.String?
        /// Whether a measure is a potential cause of the anomaly group (CAUSE_OF_INPUT_ANOMALY_GROUP), or whether the measure is impacted by the anomaly group (EFFECT_OF_INPUT_ANOMALY_GROUP).
        public var relationshipType: LookoutMetricsClientTypes.RelationshipType?

        public init(
            anomalyGroupId: Swift.String? = nil,
            contributionPercentage: Swift.Double? = nil,
            metricName: Swift.String? = nil,
            relationshipType: LookoutMetricsClientTypes.RelationshipType? = nil
        )
        {
            self.anomalyGroupId = anomalyGroupId
            self.contributionPercentage = contributionPercentage
            self.metricName = metricName
            self.relationshipType = relationshipType
        }
    }
}

public struct ListAlertsInput: Swift.Sendable {
    /// The ARN of the alert's detector.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results that will be displayed by the request.
    public var maxResults: Swift.Int?
    /// If the result of the previous request is truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAlertsOutput: Swift.Sendable {
    /// Contains information about an alert.
    public var alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use this token in the next request.
    public var nextToken: Swift.String?

    public init(
        alertSummaryList: [LookoutMetricsClientTypes.AlertSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alertSummaryList = alertSummaryList
        self.nextToken = nextToken
    }
}

public struct ListAnomalyDetectorsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAnomalyDetectorsOutput: Swift.Sendable {
    /// A list of anomaly detectors in the account in the current region.
    public var anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]?
    /// If the response is truncated, the service returns this token. To retrieve the next set of results, use the token in the next request.
    public var nextToken: Swift.String?

    public init(
        anomalyDetectorSummaryList: [LookoutMetricsClientTypes.AnomalyDetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorSummaryList = anomalyDetectorSummaryList
        self.nextToken = nextToken
    }
}

public struct ListAnomalyGroupRelatedMetricsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Filter for potential causes (CAUSE_OF_INPUT_ANOMALY_GROUP) or downstream effects (EFFECT_OF_INPUT_ANOMALY_GROUP) of the anomaly group.
    public var relationshipTypeFilter: LookoutMetricsClientTypes.RelationshipType?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        relationshipTypeFilter: LookoutMetricsClientTypes.RelationshipType? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.relationshipTypeFilter = relationshipTypeFilter
    }
}

public struct ListAnomalyGroupRelatedMetricsOutput: Swift.Sendable {
    /// Aggregated details about the measures contributing to the anomaly group, and the measures potentially impacted by the anomaly group.
    public var interMetricImpactList: [LookoutMetricsClientTypes.InterMetricImpactDetails]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        interMetricImpactList: [LookoutMetricsClientTypes.InterMetricImpactDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interMetricImpactList = interMetricImpactList
        self.nextToken = nextToken
    }
}

public struct ListAnomalyGroupSummariesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The minimum severity score for inclusion in the output.
    /// This member is required.
    public var sensitivityThreshold: Swift.Int?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sensitivityThreshold: Swift.Int? = 0
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sensitivityThreshold = sensitivityThreshold
    }
}

public struct ListAnomalyGroupSummariesOutput: Swift.Sendable {
    /// Aggregated details about the anomaly groups.
    public var anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics?
    /// A list of anomaly group summaries.
    public var anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        anomalyGroupStatistics: LookoutMetricsClientTypes.AnomalyGroupStatistics? = nil,
        anomalyGroupSummaryList: [LookoutMetricsClientTypes.AnomalyGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyGroupStatistics = anomalyGroupStatistics
        self.anomalyGroupSummaryList = anomalyGroupSummaryList
        self.nextToken = nextToken
    }
}

public struct ListAnomalyGroupTimeSeriesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// The ID of the anomaly group.
    /// This member is required.
    public var anomalyGroupId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The name of the measure field.
    /// This member is required.
    public var metricName: Swift.String?
    /// Specify the pagination token that's returned by a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupId = anomalyGroupId
        self.maxResults = maxResults
        self.metricName = metricName
        self.nextToken = nextToken
    }
}

extension LookoutMetricsClientTypes {

    /// Details about a metric. A metric is an aggregation of the values of a measure for a dimension value, such as availability in the us-east-1 Region.
    public struct TimeSeries: Swift.Sendable {
        /// The dimensions of the metric.
        /// This member is required.
        public var dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]?
        /// The values for the metric.
        /// This member is required.
        public var metricValueList: [Swift.Double]?
        /// The ID of the metric.
        /// This member is required.
        public var timeSeriesId: Swift.String?

        public init(
            dimensionList: [LookoutMetricsClientTypes.DimensionNameValue]? = nil,
            metricValueList: [Swift.Double]? = nil,
            timeSeriesId: Swift.String? = nil
        )
        {
            self.dimensionList = dimensionList
            self.metricValueList = metricValueList
            self.timeSeriesId = timeSeriesId
        }
    }
}

public struct ListAnomalyGroupTimeSeriesOutput: Swift.Sendable {
    /// The ID of the anomaly group.
    public var anomalyGroupId: Swift.String?
    /// The name of the measure field.
    public var metricName: Swift.String?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of anomalous metrics.
    public var timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]?
    /// Timestamps for the anomalous metrics.
    public var timestampList: [Swift.String]?

    public init(
        anomalyGroupId: Swift.String? = nil,
        metricName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesList: [LookoutMetricsClientTypes.TimeSeries]? = nil,
        timestampList: [Swift.String]? = nil
    )
    {
        self.anomalyGroupId = anomalyGroupId
        self.metricName = metricName
        self.nextToken = nextToken
        self.timeSeriesList = timeSeriesList
        self.timestampList = timestampList
    }
}

public struct ListMetricSetsInput: Swift.Sendable {
    /// The ARN of the anomaly detector containing the metrics sets to list.
    public var anomalyDetectorArn: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LookoutMetricsClientTypes {

    /// Contains information about a dataset.
    public struct MetricSetSummary: Swift.Sendable {
        /// The ARN of the detector to which the dataset belongs.
        public var anomalyDetectorArn: Swift.String?
        /// The time at which the dataset was created.
        public var creationTime: Foundation.Date?
        /// The time at which the dataset was last modified.
        public var lastModificationTime: Foundation.Date?
        /// The ARN of the dataset.
        public var metricSetArn: Swift.String?
        /// The description of the dataset.
        public var metricSetDescription: Swift.String?
        /// The name of the dataset.
        public var metricSetName: Swift.String?
        /// The dataset's [tags](https://docs.aws.amazon.com/lookoutmetrics/latest/dev/detectors-tags.html).
        public var tags: [Swift.String: Swift.String]?

        public init(
            anomalyDetectorArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            metricSetArn: Swift.String? = nil,
            metricSetDescription: Swift.String? = nil,
            metricSetName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.anomalyDetectorArn = anomalyDetectorArn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.metricSetArn = metricSetArn
            self.metricSetDescription = metricSetDescription
            self.metricSetName = metricSetName
            self.tags = tags
        }
    }
}

public struct ListMetricSetsOutput: Swift.Sendable {
    /// A list of the datasets in the AWS Region, with configuration details for each.
    public var metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]?
    /// If the response is truncated, the list call returns this token. To retrieve the next set of results, use the token in the next list request.
    public var nextToken: Swift.String?

    public init(
        metricSetSummaryList: [LookoutMetricsClientTypes.MetricSetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metricSetSummaryList = metricSetSummaryList
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The resource's tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutFeedbackInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the anomaly detector.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Feedback for an anomalous metric.
    /// This member is required.
    public var anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyGroupTimeSeriesFeedback: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyGroupTimeSeriesFeedback = anomalyGroupTimeSeriesFeedback
    }
}

public struct PutFeedbackOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags to apply to the resource. Tag keys and values can contain letters, numbers, spaces, and the following symbols: _.:/=+@-
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys to remove from the resource's tags.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAlertInput: Swift.Sendable {
    /// Action that will be triggered when there is an alert.
    public var action: LookoutMetricsClientTypes.Action?
    /// The ARN of the alert to update.
    /// This member is required.
    public var alertArn: Swift.String?
    /// A description of the alert.
    public var alertDescription: Swift.String?
    /// The configuration of the alert filters, containing MetricList and DimensionFilterList.
    public var alertFilters: LookoutMetricsClientTypes.AlertFilters?
    /// An integer from 0 to 100 specifying the alert sensitivity threshold.
    public var alertSensitivityThreshold: Swift.Int?

    public init(
        action: LookoutMetricsClientTypes.Action? = nil,
        alertArn: Swift.String? = nil,
        alertDescription: Swift.String? = nil,
        alertFilters: LookoutMetricsClientTypes.AlertFilters? = nil,
        alertSensitivityThreshold: Swift.Int? = 0
    )
    {
        self.action = action
        self.alertArn = alertArn
        self.alertDescription = alertDescription
        self.alertFilters = alertFilters
        self.alertSensitivityThreshold = alertSensitivityThreshold
    }
}

public struct UpdateAlertOutput: Swift.Sendable {
    /// The ARN of the updated alert.
    public var alertArn: Swift.String?

    public init(
        alertArn: Swift.String? = nil
    )
    {
        self.alertArn = alertArn
    }
}

public struct UpdateAnomalyDetectorInput: Swift.Sendable {
    /// The ARN of the detector to update.
    /// This member is required.
    public var anomalyDetectorArn: Swift.String?
    /// Contains information about the configuration to which the detector will be updated.
    public var anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig?
    /// The updated detector description.
    public var anomalyDetectorDescription: Swift.String?
    /// The Amazon Resource Name (ARN) of an AWS KMS encryption key.
    public var kmsKeyArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil,
        anomalyDetectorConfig: LookoutMetricsClientTypes.AnomalyDetectorConfig? = nil,
        anomalyDetectorDescription: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
        self.anomalyDetectorConfig = anomalyDetectorConfig
        self.anomalyDetectorDescription = anomalyDetectorDescription
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct UpdateAnomalyDetectorOutput: Swift.Sendable {
    /// The ARN of the updated detector.
    public var anomalyDetectorArn: Swift.String?

    public init(
        anomalyDetectorArn: Swift.String? = nil
    )
    {
        self.anomalyDetectorArn = anomalyDetectorArn
    }
}

public struct UpdateMetricSetInput: Swift.Sendable {
    /// Describes a list of filters for choosing specific dimensions and specific values. Each filter consists of the dimension and one of its values that you want to include. When multiple dimensions or values are specified, the dimensions are joined with an AND operation and the values are joined with an OR operation.
    public var dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]?
    /// The dimension list.
    public var dimensionList: [Swift.String]?
    /// The metric list.
    public var metricList: [LookoutMetricsClientTypes.Metric]?
    /// The ARN of the dataset to update.
    /// This member is required.
    public var metricSetArn: Swift.String?
    /// The dataset's description.
    public var metricSetDescription: Swift.String?
    /// The dataset's interval.
    public var metricSetFrequency: LookoutMetricsClientTypes.Frequency?
    /// Contains information about source data used to generate metrics.
    public var metricSource: LookoutMetricsClientTypes.MetricSource?
    /// After an interval ends, the amount of seconds that the detector waits before importing data. Offset is only supported for S3, Redshift, Athena and datasources.
    public var offset: Swift.Int?
    /// The timestamp column.
    public var timestampColumn: LookoutMetricsClientTypes.TimestampColumn?

    public init(
        dimensionFilterList: [LookoutMetricsClientTypes.MetricSetDimensionFilter]? = nil,
        dimensionList: [Swift.String]? = nil,
        metricList: [LookoutMetricsClientTypes.Metric]? = nil,
        metricSetArn: Swift.String? = nil,
        metricSetDescription: Swift.String? = nil,
        metricSetFrequency: LookoutMetricsClientTypes.Frequency? = nil,
        metricSource: LookoutMetricsClientTypes.MetricSource? = nil,
        offset: Swift.Int? = 0,
        timestampColumn: LookoutMetricsClientTypes.TimestampColumn? = nil
    )
    {
        self.dimensionFilterList = dimensionFilterList
        self.dimensionList = dimensionList
        self.metricList = metricList
        self.metricSetArn = metricSetArn
        self.metricSetDescription = metricSetDescription
        self.metricSetFrequency = metricSetFrequency
        self.metricSource = metricSource
        self.offset = offset
        self.timestampColumn = timestampColumn
    }
}

public struct UpdateMetricSetOutput: Swift.Sendable {
    /// The ARN of the dataset.
    public var metricSetArn: Swift.String?

    public init(
        metricSetArn: Swift.String? = nil
    )
    {
        self.metricSetArn = metricSetArn
    }
}

extension ActivateAnomalyDetectorInput {

    static func urlPathProvider(_ value: ActivateAnomalyDetectorInput) -> Swift.String? {
        return "/ActivateAnomalyDetector"
    }
}

extension BackTestAnomalyDetectorInput {

    static func urlPathProvider(_ value: BackTestAnomalyDetectorInput) -> Swift.String? {
        return "/BackTestAnomalyDetector"
    }
}

extension CreateAlertInput {

    static func urlPathProvider(_ value: CreateAlertInput) -> Swift.String? {
        return "/CreateAlert"
    }
}

extension CreateAnomalyDetectorInput {

    static func urlPathProvider(_ value: CreateAnomalyDetectorInput) -> Swift.String? {
        return "/CreateAnomalyDetector"
    }
}

extension CreateMetricSetInput {

    static func urlPathProvider(_ value: CreateMetricSetInput) -> Swift.String? {
        return "/CreateMetricSet"
    }
}

extension DeactivateAnomalyDetectorInput {

    static func urlPathProvider(_ value: DeactivateAnomalyDetectorInput) -> Swift.String? {
        return "/DeactivateAnomalyDetector"
    }
}

extension DeleteAlertInput {

    static func urlPathProvider(_ value: DeleteAlertInput) -> Swift.String? {
        return "/DeleteAlert"
    }
}

extension DeleteAnomalyDetectorInput {

    static func urlPathProvider(_ value: DeleteAnomalyDetectorInput) -> Swift.String? {
        return "/DeleteAnomalyDetector"
    }
}

extension DescribeAlertInput {

    static func urlPathProvider(_ value: DescribeAlertInput) -> Swift.String? {
        return "/DescribeAlert"
    }
}

extension DescribeAnomalyDetectionExecutionsInput {

    static func urlPathProvider(_ value: DescribeAnomalyDetectionExecutionsInput) -> Swift.String? {
        return "/DescribeAnomalyDetectionExecutions"
    }
}

extension DescribeAnomalyDetectorInput {

    static func urlPathProvider(_ value: DescribeAnomalyDetectorInput) -> Swift.String? {
        return "/DescribeAnomalyDetector"
    }
}

extension DescribeMetricSetInput {

    static func urlPathProvider(_ value: DescribeMetricSetInput) -> Swift.String? {
        return "/DescribeMetricSet"
    }
}

extension DetectMetricSetConfigInput {

    static func urlPathProvider(_ value: DetectMetricSetConfigInput) -> Swift.String? {
        return "/DetectMetricSetConfig"
    }
}

extension GetAnomalyGroupInput {

    static func urlPathProvider(_ value: GetAnomalyGroupInput) -> Swift.String? {
        return "/GetAnomalyGroup"
    }
}

extension GetDataQualityMetricsInput {

    static func urlPathProvider(_ value: GetDataQualityMetricsInput) -> Swift.String? {
        return "/GetDataQualityMetrics"
    }
}

extension GetFeedbackInput {

    static func urlPathProvider(_ value: GetFeedbackInput) -> Swift.String? {
        return "/GetFeedback"
    }
}

extension GetSampleDataInput {

    static func urlPathProvider(_ value: GetSampleDataInput) -> Swift.String? {
        return "/GetSampleData"
    }
}

extension ListAlertsInput {

    static func urlPathProvider(_ value: ListAlertsInput) -> Swift.String? {
        return "/ListAlerts"
    }
}

extension ListAnomalyDetectorsInput {

    static func urlPathProvider(_ value: ListAnomalyDetectorsInput) -> Swift.String? {
        return "/ListAnomalyDetectors"
    }
}

extension ListAnomalyGroupRelatedMetricsInput {

    static func urlPathProvider(_ value: ListAnomalyGroupRelatedMetricsInput) -> Swift.String? {
        return "/ListAnomalyGroupRelatedMetrics"
    }
}

extension ListAnomalyGroupSummariesInput {

    static func urlPathProvider(_ value: ListAnomalyGroupSummariesInput) -> Swift.String? {
        return "/ListAnomalyGroupSummaries"
    }
}

extension ListAnomalyGroupTimeSeriesInput {

    static func urlPathProvider(_ value: ListAnomalyGroupTimeSeriesInput) -> Swift.String? {
        return "/ListAnomalyGroupTimeSeries"
    }
}

extension ListMetricSetsInput {

    static func urlPathProvider(_ value: ListMetricSetsInput) -> Swift.String? {
        return "/ListMetricSets"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutFeedbackInput {

    static func urlPathProvider(_ value: PutFeedbackInput) -> Swift.String? {
        return "/PutFeedback"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAlertInput {

    static func urlPathProvider(_ value: UpdateAlertInput) -> Swift.String? {
        return "/UpdateAlert"
    }
}

extension UpdateAnomalyDetectorInput {

    static func urlPathProvider(_ value: UpdateAnomalyDetectorInput) -> Swift.String? {
        return "/UpdateAnomalyDetector"
    }
}

extension UpdateMetricSetInput {

    static func urlPathProvider(_ value: UpdateMetricSetInput) -> Swift.String? {
        return "/UpdateMetricSet"
    }
}

extension ActivateAnomalyDetectorInput {

    static func write(value: ActivateAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
    }
}

extension BackTestAnomalyDetectorInput {

    static func write(value: BackTestAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
    }
}

extension CreateAlertInput {

    static func write(value: CreateAlertInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: LookoutMetricsClientTypes.Action.write(value:to:))
        try writer["AlertDescription"].write(value.alertDescription)
        try writer["AlertFilters"].write(value.alertFilters, with: LookoutMetricsClientTypes.AlertFilters.write(value:to:))
        try writer["AlertName"].write(value.alertName)
        try writer["AlertSensitivityThreshold"].write(value.alertSensitivityThreshold)
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAnomalyDetectorInput {

    static func write(value: CreateAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorConfig"].write(value.anomalyDetectorConfig, with: LookoutMetricsClientTypes.AnomalyDetectorConfig.write(value:to:))
        try writer["AnomalyDetectorDescription"].write(value.anomalyDetectorDescription)
        try writer["AnomalyDetectorName"].write(value.anomalyDetectorName)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateMetricSetInput {

    static func write(value: CreateMetricSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["DimensionFilterList"].writeList(value.dimensionFilterList, memberWritingClosure: LookoutMetricsClientTypes.MetricSetDimensionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DimensionList"].writeList(value.dimensionList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricList"].writeList(value.metricList, memberWritingClosure: LookoutMetricsClientTypes.Metric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricSetDescription"].write(value.metricSetDescription)
        try writer["MetricSetFrequency"].write(value.metricSetFrequency)
        try writer["MetricSetName"].write(value.metricSetName)
        try writer["MetricSource"].write(value.metricSource, with: LookoutMetricsClientTypes.MetricSource.write(value:to:))
        try writer["Offset"].write(value.offset)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TimestampColumn"].write(value.timestampColumn, with: LookoutMetricsClientTypes.TimestampColumn.write(value:to:))
        try writer["Timezone"].write(value.timezone)
    }
}

extension DeactivateAnomalyDetectorInput {

    static func write(value: DeactivateAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
    }
}

extension DeleteAlertInput {

    static func write(value: DeleteAlertInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlertArn"].write(value.alertArn)
    }
}

extension DeleteAnomalyDetectorInput {

    static func write(value: DeleteAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
    }
}

extension DescribeAlertInput {

    static func write(value: DescribeAlertInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlertArn"].write(value.alertArn)
    }
}

extension DescribeAnomalyDetectionExecutionsInput {

    static func write(value: DescribeAnomalyDetectionExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Timestamp"].write(value.timestamp)
    }
}

extension DescribeAnomalyDetectorInput {

    static func write(value: DescribeAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
    }
}

extension DescribeMetricSetInput {

    static func write(value: DescribeMetricSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricSetArn"].write(value.metricSetArn)
    }
}

extension DetectMetricSetConfigInput {

    static func write(value: DetectMetricSetConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AutoDetectionMetricSource"].write(value.autoDetectionMetricSource, with: LookoutMetricsClientTypes.AutoDetectionMetricSource.write(value:to:))
    }
}

extension GetAnomalyGroupInput {

    static func write(value: GetAnomalyGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyGroupId"].write(value.anomalyGroupId)
    }
}

extension GetDataQualityMetricsInput {

    static func write(value: GetDataQualityMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["MetricSetArn"].write(value.metricSetArn)
    }
}

extension GetFeedbackInput {

    static func write(value: GetFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyGroupTimeSeriesFeedback"].write(value.anomalyGroupTimeSeriesFeedback, with: LookoutMetricsClientTypes.AnomalyGroupTimeSeries.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetSampleDataInput {

    static func write(value: GetSampleDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3SourceConfig"].write(value.s3SourceConfig, with: LookoutMetricsClientTypes.SampleDataS3SourceConfig.write(value:to:))
    }
}

extension ListAlertsInput {

    static func write(value: ListAlertsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAnomalyDetectorsInput {

    static func write(value: ListAnomalyDetectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAnomalyGroupRelatedMetricsInput {

    static func write(value: ListAnomalyGroupRelatedMetricsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyGroupId"].write(value.anomalyGroupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RelationshipTypeFilter"].write(value.relationshipTypeFilter)
    }
}

extension ListAnomalyGroupSummariesInput {

    static func write(value: ListAnomalyGroupSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SensitivityThreshold"].write(value.sensitivityThreshold)
    }
}

extension ListAnomalyGroupTimeSeriesInput {

    static func write(value: ListAnomalyGroupTimeSeriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyGroupId"].write(value.anomalyGroupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MetricName"].write(value.metricName)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListMetricSetsInput {

    static func write(value: ListMetricSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PutFeedbackInput {

    static func write(value: PutFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyGroupTimeSeriesFeedback"].write(value.anomalyGroupTimeSeriesFeedback, with: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAlertInput {

    static func write(value: UpdateAlertInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: LookoutMetricsClientTypes.Action.write(value:to:))
        try writer["AlertArn"].write(value.alertArn)
        try writer["AlertDescription"].write(value.alertDescription)
        try writer["AlertFilters"].write(value.alertFilters, with: LookoutMetricsClientTypes.AlertFilters.write(value:to:))
        try writer["AlertSensitivityThreshold"].write(value.alertSensitivityThreshold)
    }
}

extension UpdateAnomalyDetectorInput {

    static func write(value: UpdateAnomalyDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorArn"].write(value.anomalyDetectorArn)
        try writer["AnomalyDetectorConfig"].write(value.anomalyDetectorConfig, with: LookoutMetricsClientTypes.AnomalyDetectorConfig.write(value:to:))
        try writer["AnomalyDetectorDescription"].write(value.anomalyDetectorDescription)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension UpdateMetricSetInput {

    static func write(value: UpdateMetricSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionFilterList"].writeList(value.dimensionFilterList, memberWritingClosure: LookoutMetricsClientTypes.MetricSetDimensionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DimensionList"].writeList(value.dimensionList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricList"].writeList(value.metricList, memberWritingClosure: LookoutMetricsClientTypes.Metric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricSetArn"].write(value.metricSetArn)
        try writer["MetricSetDescription"].write(value.metricSetDescription)
        try writer["MetricSetFrequency"].write(value.metricSetFrequency)
        try writer["MetricSource"].write(value.metricSource, with: LookoutMetricsClientTypes.MetricSource.write(value:to:))
        try writer["Offset"].write(value.offset)
        try writer["TimestampColumn"].write(value.timestampColumn, with: LookoutMetricsClientTypes.TimestampColumn.write(value:to:))
    }
}

extension ActivateAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateAnomalyDetectorOutput {
        return ActivateAnomalyDetectorOutput()
    }
}

extension BackTestAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BackTestAnomalyDetectorOutput {
        return BackTestAnomalyDetectorOutput()
    }
}

extension CreateAlertOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAlertOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAlertOutput()
        value.alertArn = try reader["AlertArn"].readIfPresent()
        return value
    }
}

extension CreateAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnomalyDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnomalyDetectorOutput()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        return value
    }
}

extension CreateMetricSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMetricSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMetricSetOutput()
        value.metricSetArn = try reader["MetricSetArn"].readIfPresent()
        return value
    }
}

extension DeactivateAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateAnomalyDetectorOutput {
        return DeactivateAnomalyDetectorOutput()
    }
}

extension DeleteAlertOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAlertOutput {
        return DeleteAlertOutput()
    }
}

extension DeleteAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnomalyDetectorOutput {
        return DeleteAnomalyDetectorOutput()
    }
}

extension DescribeAlertOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAlertOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAlertOutput()
        value.alert = try reader["Alert"].readIfPresent(with: LookoutMetricsClientTypes.Alert.read(from:))
        return value
    }
}

extension DescribeAnomalyDetectionExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnomalyDetectionExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnomalyDetectionExecutionsOutput()
        value.executionList = try reader["ExecutionList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.ExecutionStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnomalyDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnomalyDetectorOutput()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.anomalyDetectorConfig = try reader["AnomalyDetectorConfig"].readIfPresent(with: LookoutMetricsClientTypes.AnomalyDetectorConfigSummary.read(from:))
        value.anomalyDetectorDescription = try reader["AnomalyDetectorDescription"].readIfPresent()
        value.anomalyDetectorName = try reader["AnomalyDetectorName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeMetricSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMetricSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMetricSetOutput()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dimensionFilterList = try reader["DimensionFilterList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.MetricSetDimensionFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dimensionList = try reader["DimensionList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricList = try reader["MetricList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.Metric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricSetArn = try reader["MetricSetArn"].readIfPresent()
        value.metricSetDescription = try reader["MetricSetDescription"].readIfPresent()
        value.metricSetFrequency = try reader["MetricSetFrequency"].readIfPresent()
        value.metricSetName = try reader["MetricSetName"].readIfPresent()
        value.metricSource = try reader["MetricSource"].readIfPresent(with: LookoutMetricsClientTypes.MetricSource.read(from:))
        value.offset = try reader["Offset"].readIfPresent()
        value.timestampColumn = try reader["TimestampColumn"].readIfPresent(with: LookoutMetricsClientTypes.TimestampColumn.read(from:))
        value.timezone = try reader["Timezone"].readIfPresent()
        return value
    }
}

extension DetectMetricSetConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetectMetricSetConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetectMetricSetConfigOutput()
        value.detectedMetricSetConfig = try reader["DetectedMetricSetConfig"].readIfPresent(with: LookoutMetricsClientTypes.DetectedMetricSetConfig.read(from:))
        return value
    }
}

extension GetAnomalyGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnomalyGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnomalyGroupOutput()
        value.anomalyGroup = try reader["AnomalyGroup"].readIfPresent(with: LookoutMetricsClientTypes.AnomalyGroup.read(from:))
        return value
    }
}

extension GetDataQualityMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataQualityMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataQualityMetricsOutput()
        value.anomalyDetectorDataQualityMetricList = try reader["AnomalyDetectorDataQualityMetricList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFeedbackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFeedbackOutput()
        value.anomalyGroupTimeSeriesFeedback = try reader["AnomalyGroupTimeSeriesFeedback"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.TimeSeriesFeedback.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetSampleDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSampleDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSampleDataOutput()
        value.headerValues = try reader["HeaderValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sampleRows = try reader["SampleRows"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAlertsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAlertsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAlertsOutput()
        value.alertSummaryList = try reader["AlertSummaryList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.AlertSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAnomalyDetectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomalyDetectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomalyDetectorsOutput()
        value.anomalyDetectorSummaryList = try reader["AnomalyDetectorSummaryList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.AnomalyDetectorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAnomalyGroupRelatedMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomalyGroupRelatedMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomalyGroupRelatedMetricsOutput()
        value.interMetricImpactList = try reader["InterMetricImpactList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.InterMetricImpactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAnomalyGroupSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomalyGroupSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomalyGroupSummariesOutput()
        value.anomalyGroupStatistics = try reader["AnomalyGroupStatistics"].readIfPresent(with: LookoutMetricsClientTypes.AnomalyGroupStatistics.read(from:))
        value.anomalyGroupSummaryList = try reader["AnomalyGroupSummaryList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.AnomalyGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAnomalyGroupTimeSeriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnomalyGroupTimeSeriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnomalyGroupTimeSeriesOutput()
        value.anomalyGroupId = try reader["AnomalyGroupId"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.timeSeriesList = try reader["TimeSeriesList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.TimeSeries.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timestampList = try reader["TimestampList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMetricSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetricSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetricSetsOutput()
        value.metricSetSummaryList = try reader["MetricSetSummaryList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.MetricSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutFeedbackOutput {
        return PutFeedbackOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAlertOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAlertOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAlertOutput()
        value.alertArn = try reader["AlertArn"].readIfPresent()
        return value
    }
}

extension UpdateAnomalyDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnomalyDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnomalyDetectorOutput()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        return value
    }
}

extension UpdateMetricSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMetricSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMetricSetOutput()
        value.metricSetArn = try reader["MetricSetArn"].readIfPresent()
        return value
    }
}

enum ActivateAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BackTestAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAlertOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMetricSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAlertOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAlertOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnomalyDetectionExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMetricSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetectMetricSetConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnomalyGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataQualityMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSampleDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAlertsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomalyDetectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomalyGroupRelatedMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomalyGroupSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnomalyGroupTimeSeriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetricSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAlertOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnomalyDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMetricSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LookoutMetricsClientTypes.Alert {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.Alert {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.Alert()
        value.action = try reader["Action"].readIfPresent(with: LookoutMetricsClientTypes.Action.read(from:))
        value.alertDescription = try reader["AlertDescription"].readIfPresent()
        value.alertArn = try reader["AlertArn"].readIfPresent()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.alertName = try reader["AlertName"].readIfPresent()
        value.alertSensitivityThreshold = try reader["AlertSensitivityThreshold"].readIfPresent() ?? 0
        value.alertType = try reader["AlertType"].readIfPresent()
        value.alertStatus = try reader["AlertStatus"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.alertFilters = try reader["AlertFilters"].readIfPresent(with: LookoutMetricsClientTypes.AlertFilters.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.AlertFilters {

    static func write(value: LookoutMetricsClientTypes.AlertFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionFilterList"].writeList(value.dimensionFilterList, memberWritingClosure: LookoutMetricsClientTypes.DimensionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricList"].writeList(value.metricList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AlertFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AlertFilters()
        value.metricList = try reader["MetricList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dimensionFilterList = try reader["DimensionFilterList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.DimensionFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.DimensionFilter {

    static func write(value: LookoutMetricsClientTypes.DimensionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionName"].write(value.dimensionName)
        try writer["DimensionValueList"].writeList(value.dimensionValueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DimensionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DimensionFilter()
        value.dimensionName = try reader["DimensionName"].readIfPresent()
        value.dimensionValueList = try reader["DimensionValueList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.Action {

    static func write(value: LookoutMetricsClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaConfiguration"].write(value.lambdaConfiguration, with: LookoutMetricsClientTypes.LambdaConfiguration.write(value:to:))
        try writer["SNSConfiguration"].write(value.snsConfiguration, with: LookoutMetricsClientTypes.SNSConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.Action()
        value.snsConfiguration = try reader["SNSConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.SNSConfiguration.read(from:))
        value.lambdaConfiguration = try reader["LambdaConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.LambdaConfiguration.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.LambdaConfiguration {

    static func write(value: LookoutMetricsClientTypes.LambdaConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaArn"].write(value.lambdaArn)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.LambdaConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.LambdaConfiguration()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.lambdaArn = try reader["LambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension LookoutMetricsClientTypes.SNSConfiguration {

    static func write(value: LookoutMetricsClientTypes.SNSConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
        try writer["SnsFormat"].write(value.snsFormat)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.SNSConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.SNSConfiguration()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent() ?? ""
        value.snsFormat = try reader["SnsFormat"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.ExecutionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.ExecutionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.ExecutionStatus()
        value.timestamp = try reader["Timestamp"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyDetectorConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyDetectorConfigSummary()
        value.anomalyDetectorFrequency = try reader["AnomalyDetectorFrequency"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.Metric {

    static func write(value: LookoutMetricsClientTypes.Metric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction)
        try writer["MetricName"].write(value.metricName)
        try writer["Namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.Metric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.Metric()
        value.metricName = try reader["MetricName"].readIfPresent() ?? ""
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent() ?? .sdkUnknown("")
        value.namespace = try reader["Namespace"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.TimestampColumn {

    static func write(value: LookoutMetricsClientTypes.TimestampColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnFormat"].write(value.columnFormat)
        try writer["ColumnName"].write(value.columnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.TimestampColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.TimestampColumn()
        value.columnName = try reader["ColumnName"].readIfPresent()
        value.columnFormat = try reader["ColumnFormat"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.MetricSource {

    static func write(value: LookoutMetricsClientTypes.MetricSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppFlowConfig"].write(value.appFlowConfig, with: LookoutMetricsClientTypes.AppFlowConfig.write(value:to:))
        try writer["AthenaSourceConfig"].write(value.athenaSourceConfig, with: LookoutMetricsClientTypes.AthenaSourceConfig.write(value:to:))
        try writer["CloudWatchConfig"].write(value.cloudWatchConfig, with: LookoutMetricsClientTypes.CloudWatchConfig.write(value:to:))
        try writer["RDSSourceConfig"].write(value.rdsSourceConfig, with: LookoutMetricsClientTypes.RDSSourceConfig.write(value:to:))
        try writer["RedshiftSourceConfig"].write(value.redshiftSourceConfig, with: LookoutMetricsClientTypes.RedshiftSourceConfig.write(value:to:))
        try writer["S3SourceConfig"].write(value.s3SourceConfig, with: LookoutMetricsClientTypes.S3SourceConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.MetricSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.MetricSource()
        value.s3SourceConfig = try reader["S3SourceConfig"].readIfPresent(with: LookoutMetricsClientTypes.S3SourceConfig.read(from:))
        value.appFlowConfig = try reader["AppFlowConfig"].readIfPresent(with: LookoutMetricsClientTypes.AppFlowConfig.read(from:))
        value.cloudWatchConfig = try reader["CloudWatchConfig"].readIfPresent(with: LookoutMetricsClientTypes.CloudWatchConfig.read(from:))
        value.rdsSourceConfig = try reader["RDSSourceConfig"].readIfPresent(with: LookoutMetricsClientTypes.RDSSourceConfig.read(from:))
        value.redshiftSourceConfig = try reader["RedshiftSourceConfig"].readIfPresent(with: LookoutMetricsClientTypes.RedshiftSourceConfig.read(from:))
        value.athenaSourceConfig = try reader["AthenaSourceConfig"].readIfPresent(with: LookoutMetricsClientTypes.AthenaSourceConfig.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.AthenaSourceConfig {

    static func write(value: LookoutMetricsClientTypes.AthenaSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackTestConfiguration"].write(value.backTestConfiguration, with: LookoutMetricsClientTypes.BackTestConfiguration.write(value:to:))
        try writer["DataCatalog"].write(value.dataCatalog)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3ResultsPath"].write(value.s3ResultsPath)
        try writer["TableName"].write(value.tableName)
        try writer["WorkGroupName"].write(value.workGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AthenaSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AthenaSourceConfig()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.dataCatalog = try reader["DataCatalog"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.workGroupName = try reader["WorkGroupName"].readIfPresent()
        value.s3ResultsPath = try reader["S3ResultsPath"].readIfPresent()
        value.backTestConfiguration = try reader["BackTestConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.BackTestConfiguration.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.BackTestConfiguration {

    static func write(value: LookoutMetricsClientTypes.BackTestConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RunBackTestMode"].write(value.runBackTestMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.BackTestConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.BackTestConfiguration()
        value.runBackTestMode = try reader["RunBackTestMode"].readIfPresent() ?? false
        return value
    }
}

extension LookoutMetricsClientTypes.RedshiftSourceConfig {

    static func write(value: LookoutMetricsClientTypes.RedshiftSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["DatabaseHost"].write(value.databaseHost)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DatabasePort"].write(value.databasePort)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecretManagerArn"].write(value.secretManagerArn)
        try writer["TableName"].write(value.tableName)
        try writer["VpcConfiguration"].write(value.vpcConfiguration, with: LookoutMetricsClientTypes.VpcConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.RedshiftSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.RedshiftSourceConfig()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.databaseHost = try reader["DatabaseHost"].readIfPresent()
        value.databasePort = try reader["DatabasePort"].readIfPresent()
        value.secretManagerArn = try reader["SecretManagerArn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.vpcConfiguration = try reader["VpcConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.VpcConfiguration.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.VpcConfiguration {

    static func write(value: LookoutMetricsClientTypes.VpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIdList"].writeList(value.securityGroupIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIdList"].writeList(value.subnetIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.VpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.VpcConfiguration()
        value.subnetIdList = try reader["SubnetIdList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIdList = try reader["SecurityGroupIdList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LookoutMetricsClientTypes.RDSSourceConfig {

    static func write(value: LookoutMetricsClientTypes.RDSSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DBInstanceIdentifier"].write(value.dbInstanceIdentifier)
        try writer["DatabaseHost"].write(value.databaseHost)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DatabasePort"].write(value.databasePort)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecretManagerArn"].write(value.secretManagerArn)
        try writer["TableName"].write(value.tableName)
        try writer["VpcConfiguration"].write(value.vpcConfiguration, with: LookoutMetricsClientTypes.VpcConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.RDSSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.RDSSourceConfig()
        value.dbInstanceIdentifier = try reader["DBInstanceIdentifier"].readIfPresent()
        value.databaseHost = try reader["DatabaseHost"].readIfPresent()
        value.databasePort = try reader["DatabasePort"].readIfPresent()
        value.secretManagerArn = try reader["SecretManagerArn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.vpcConfiguration = try reader["VpcConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.VpcConfiguration.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.CloudWatchConfig {

    static func write(value: LookoutMetricsClientTypes.CloudWatchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackTestConfiguration"].write(value.backTestConfiguration, with: LookoutMetricsClientTypes.BackTestConfiguration.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.CloudWatchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.CloudWatchConfig()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.backTestConfiguration = try reader["BackTestConfiguration"].readIfPresent(with: LookoutMetricsClientTypes.BackTestConfiguration.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.AppFlowConfig {

    static func write(value: LookoutMetricsClientTypes.AppFlowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowName"].write(value.flowName)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AppFlowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AppFlowConfig()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.flowName = try reader["FlowName"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.S3SourceConfig {

    static func write(value: LookoutMetricsClientTypes.S3SourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileFormatDescriptor"].write(value.fileFormatDescriptor, with: LookoutMetricsClientTypes.FileFormatDescriptor.write(value:to:))
        try writer["HistoricalDataPathList"].writeList(value.historicalDataPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["TemplatedPathList"].writeList(value.templatedPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.S3SourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.S3SourceConfig()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.templatedPathList = try reader["TemplatedPathList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.historicalDataPathList = try reader["HistoricalDataPathList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.fileFormatDescriptor = try reader["FileFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.FileFormatDescriptor.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.FileFormatDescriptor {

    static func write(value: LookoutMetricsClientTypes.FileFormatDescriptor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CsvFormatDescriptor"].write(value.csvFormatDescriptor, with: LookoutMetricsClientTypes.CsvFormatDescriptor.write(value:to:))
        try writer["JsonFormatDescriptor"].write(value.jsonFormatDescriptor, with: LookoutMetricsClientTypes.JsonFormatDescriptor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.FileFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.FileFormatDescriptor()
        value.csvFormatDescriptor = try reader["CsvFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.CsvFormatDescriptor.read(from:))
        value.jsonFormatDescriptor = try reader["JsonFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.JsonFormatDescriptor.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.JsonFormatDescriptor {

    static func write(value: LookoutMetricsClientTypes.JsonFormatDescriptor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Charset"].write(value.charset)
        try writer["FileCompression"].write(value.fileCompression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.JsonFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.JsonFormatDescriptor()
        value.fileCompression = try reader["FileCompression"].readIfPresent()
        value.charset = try reader["Charset"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.CsvFormatDescriptor {

    static func write(value: LookoutMetricsClientTypes.CsvFormatDescriptor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Charset"].write(value.charset)
        try writer["ContainsHeader"].write(value.containsHeader)
        try writer["Delimiter"].write(value.delimiter)
        try writer["FileCompression"].write(value.fileCompression)
        try writer["HeaderList"].writeList(value.headerList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QuoteSymbol"].write(value.quoteSymbol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.CsvFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.CsvFormatDescriptor()
        value.fileCompression = try reader["FileCompression"].readIfPresent()
        value.charset = try reader["Charset"].readIfPresent()
        value.containsHeader = try reader["ContainsHeader"].readIfPresent()
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.headerList = try reader["HeaderList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.quoteSymbol = try reader["QuoteSymbol"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.MetricSetDimensionFilter {

    static func write(value: LookoutMetricsClientTypes.MetricSetDimensionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterList"].writeList(value.filterList, memberWritingClosure: LookoutMetricsClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.MetricSetDimensionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.MetricSetDimensionFilter()
        value.name = try reader["Name"].readIfPresent()
        value.filterList = try reader["FilterList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.Filter {

    static func write(value: LookoutMetricsClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionValue"].write(value.dimensionValue)
        try writer["FilterOperation"].write(value.filterOperation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.Filter()
        value.dimensionValue = try reader["DimensionValue"].readIfPresent()
        value.filterOperation = try reader["FilterOperation"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedMetricSetConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedMetricSetConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedMetricSetConfig()
        value.offset = try reader["Offset"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.metricSetFrequency = try reader["MetricSetFrequency"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.metricSource = try reader["MetricSource"].readIfPresent(with: LookoutMetricsClientTypes.DetectedMetricSource.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedMetricSource {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedMetricSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedMetricSource()
        value.s3SourceConfig = try reader["S3SourceConfig"].readIfPresent(with: LookoutMetricsClientTypes.DetectedS3SourceConfig.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedS3SourceConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedS3SourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedS3SourceConfig()
        value.fileFormatDescriptor = try reader["FileFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.DetectedFileFormatDescriptor.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedFileFormatDescriptor {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedFileFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedFileFormatDescriptor()
        value.csvFormatDescriptor = try reader["CsvFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.DetectedCsvFormatDescriptor.read(from:))
        value.jsonFormatDescriptor = try reader["JsonFormatDescriptor"].readIfPresent(with: LookoutMetricsClientTypes.DetectedJsonFormatDescriptor.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedJsonFormatDescriptor {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedJsonFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedJsonFormatDescriptor()
        value.fileCompression = try reader["FileCompression"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.charset = try reader["Charset"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedField {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedField()
        value.value = try reader["Value"].readIfPresent(with: LookoutMetricsClientTypes.AttributeValue.read(from:))
        value.confidence = try reader["Confidence"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AttributeValue {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AttributeValue()
        value.s = try reader["S"].readIfPresent()
        value.n = try reader["N"].readIfPresent()
        value.b = try reader["B"].readIfPresent()
        value.ss = try reader["SS"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ns = try reader["NS"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.bs = try reader["BS"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.DetectedCsvFormatDescriptor {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DetectedCsvFormatDescriptor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DetectedCsvFormatDescriptor()
        value.fileCompression = try reader["FileCompression"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.charset = try reader["Charset"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.containsHeader = try reader["ContainsHeader"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.delimiter = try reader["Delimiter"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.headerList = try reader["HeaderList"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        value.quoteSymbol = try reader["QuoteSymbol"].readIfPresent(with: LookoutMetricsClientTypes.DetectedField.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyGroup()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.anomalyGroupId = try reader["AnomalyGroupId"].readIfPresent()
        value.anomalyGroupScore = try reader["AnomalyGroupScore"].readIfPresent()
        value.primaryMetricName = try reader["PrimaryMetricName"].readIfPresent()
        value.metricLevelImpactList = try reader["MetricLevelImpactList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.MetricLevelImpact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.MetricLevelImpact {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.MetricLevelImpact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.MetricLevelImpact()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.numTimeSeries = try reader["NumTimeSeries"].readIfPresent() ?? 0
        value.contributionMatrix = try reader["ContributionMatrix"].readIfPresent(with: LookoutMetricsClientTypes.ContributionMatrix.read(from:))
        return value
    }
}

extension LookoutMetricsClientTypes.ContributionMatrix {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.ContributionMatrix {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.ContributionMatrix()
        value.dimensionContributionList = try reader["DimensionContributionList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.DimensionContribution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.DimensionContribution {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DimensionContribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DimensionContribution()
        value.dimensionName = try reader["DimensionName"].readIfPresent()
        value.dimensionValueContributionList = try reader["DimensionValueContributionList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.DimensionValueContribution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.DimensionValueContribution {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DimensionValueContribution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DimensionValueContribution()
        value.dimensionValue = try reader["DimensionValue"].readIfPresent()
        value.contributionScore = try reader["ContributionScore"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyDetectorDataQualityMetric()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metricSetDataQualityMetricList = try reader["MetricSetDataQualityMetricList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.MetricSetDataQualityMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.MetricSetDataQualityMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.MetricSetDataQualityMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.MetricSetDataQualityMetric()
        value.metricSetArn = try reader["MetricSetArn"].readIfPresent()
        value.dataQualityMetricList = try reader["DataQualityMetricList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.DataQualityMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.DataQualityMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DataQualityMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DataQualityMetric()
        value.metricType = try reader["MetricType"].readIfPresent()
        value.metricDescription = try reader["MetricDescription"].readIfPresent()
        value.relatedColumnName = try reader["RelatedColumnName"].readIfPresent()
        value.metricValue = try reader["MetricValue"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.TimeSeriesFeedback {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.TimeSeriesFeedback {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.TimeSeriesFeedback()
        value.timeSeriesId = try reader["TimeSeriesId"].readIfPresent()
        value.isAnomaly = try reader["IsAnomaly"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AlertSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AlertSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AlertSummary()
        value.alertArn = try reader["AlertArn"].readIfPresent()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.alertName = try reader["AlertName"].readIfPresent()
        value.alertSensitivityThreshold = try reader["AlertSensitivityThreshold"].readIfPresent() ?? 0
        value.alertType = try reader["AlertType"].readIfPresent()
        value.alertStatus = try reader["AlertStatus"].readIfPresent()
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyDetectorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyDetectorSummary()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.anomalyDetectorName = try reader["AnomalyDetectorName"].readIfPresent()
        value.anomalyDetectorDescription = try reader["AnomalyDetectorDescription"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.InterMetricImpactDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.InterMetricImpactDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.InterMetricImpactDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.anomalyGroupId = try reader["AnomalyGroupId"].readIfPresent()
        value.relationshipType = try reader["RelationshipType"].readIfPresent()
        value.contributionPercentage = try reader["ContributionPercentage"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyGroupSummary()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.anomalyGroupId = try reader["AnomalyGroupId"].readIfPresent()
        value.anomalyGroupScore = try reader["AnomalyGroupScore"].readIfPresent()
        value.primaryMetricName = try reader["PrimaryMetricName"].readIfPresent()
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyGroupStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.AnomalyGroupStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.AnomalyGroupStatistics()
        value.evaluationStartDate = try reader["EvaluationStartDate"].readIfPresent()
        value.totalCount = try reader["TotalCount"].readIfPresent() ?? 0
        value.itemizedMetricStatsList = try reader["ItemizedMetricStatsList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.ItemizedMetricStats.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.ItemizedMetricStats {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.ItemizedMetricStats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.ItemizedMetricStats()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.occurrenceCount = try reader["OccurrenceCount"].readIfPresent() ?? 0
        return value
    }
}

extension LookoutMetricsClientTypes.TimeSeries {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.TimeSeries {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.TimeSeries()
        value.timeSeriesId = try reader["TimeSeriesId"].readIfPresent() ?? ""
        value.dimensionList = try reader["DimensionList"].readListIfPresent(memberReadingClosure: LookoutMetricsClientTypes.DimensionNameValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.metricValueList = try reader["MetricValueList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LookoutMetricsClientTypes.DimensionNameValue {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.DimensionNameValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.DimensionNameValue()
        value.dimensionName = try reader["DimensionName"].readIfPresent() ?? ""
        value.dimensionValue = try reader["DimensionValue"].readIfPresent() ?? ""
        return value
    }
}

extension LookoutMetricsClientTypes.MetricSetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.MetricSetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.MetricSetSummary()
        value.metricSetArn = try reader["MetricSetArn"].readIfPresent()
        value.anomalyDetectorArn = try reader["AnomalyDetectorArn"].readIfPresent()
        value.metricSetDescription = try reader["MetricSetDescription"].readIfPresent()
        value.metricSetName = try reader["MetricSetName"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["LastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LookoutMetricsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> LookoutMetricsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LookoutMetricsClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension LookoutMetricsClientTypes.AnomalyDetectorConfig {

    static func write(value: LookoutMetricsClientTypes.AnomalyDetectorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyDetectorFrequency"].write(value.anomalyDetectorFrequency)
    }
}

extension LookoutMetricsClientTypes.AutoDetectionMetricSource {

    static func write(value: LookoutMetricsClientTypes.AutoDetectionMetricSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3SourceConfig"].write(value.s3SourceConfig, with: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig.write(value:to:))
    }
}

extension LookoutMetricsClientTypes.AutoDetectionS3SourceConfig {

    static func write(value: LookoutMetricsClientTypes.AutoDetectionS3SourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HistoricalDataPathList"].writeList(value.historicalDataPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TemplatedPathList"].writeList(value.templatedPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeries {

    static func write(value: LookoutMetricsClientTypes.AnomalyGroupTimeSeries?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyGroupId"].write(value.anomalyGroupId)
        try writer["TimeSeriesId"].write(value.timeSeriesId)
    }
}

extension LookoutMetricsClientTypes.SampleDataS3SourceConfig {

    static func write(value: LookoutMetricsClientTypes.SampleDataS3SourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileFormatDescriptor"].write(value.fileFormatDescriptor, with: LookoutMetricsClientTypes.FileFormatDescriptor.write(value:to:))
        try writer["HistoricalDataPathList"].writeList(value.historicalDataPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["TemplatedPathList"].writeList(value.templatedPathList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback {

    static func write(value: LookoutMetricsClientTypes.AnomalyGroupTimeSeriesFeedback?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyGroupId"].write(value.anomalyGroupId)
        try writer["IsAnomaly"].write(value.isAnomaly)
        try writer["TimeSeriesId"].write(value.timeSeriesId)
    }
}

public enum LookoutMetricsClientTypes {}
