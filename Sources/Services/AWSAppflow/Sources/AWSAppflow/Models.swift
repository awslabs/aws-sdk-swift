//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// AppFlow/Requester has invalid or missing permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppflowClientTypes {

    public enum AggregationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case singleFile
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .none,
                .singleFile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .singleFile: return "SingleFile"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The aggregation settings that you can use to customize the output format of your flow data.
    public struct AggregationConfig: Swift.Sendable {
        /// Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        public var aggregationType: AppflowClientTypes.AggregationType?
        /// The desired file size, in MB, for each output file that Amazon AppFlow writes to the flow destination. For each file, Amazon AppFlow attempts to achieve the size that you specify. The actual file sizes might differ from this target based on the number and size of the records that each file contains.
        public var targetFileSize: Swift.Int?

        public init(
            aggregationType: AppflowClientTypes.AggregationType? = nil,
            targetFileSize: Swift.Int? = nil
        )
        {
            self.aggregationType = aggregationType
            self.targetFileSize = targetFileSize
        }
    }
}

extension AppflowClientTypes {

    public enum AmplitudeConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case sdkUnknown(Swift.String)

        public static var allCases: [AmplitudeConnectorOperator] {
            return [
                .between
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific credentials required when using Amplitude.
    public struct AmplitudeConnectorProfileCredentials: Swift.Sendable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var secretKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            secretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeConnectorProfileCredentials(apiKey: \"CONTENT_REDACTED\", secretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Amplitude.
    public struct AmplitudeConnectorProfileProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amplitude.
    public struct AmplitudeMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amplitude is being used as a source.
    public struct AmplitudeSourceProperties: Swift.Sendable {
        /// The object specified in the Amplitude flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The API key credentials required for API key authentication.
    public struct ApiKeyCredentials: Swift.Sendable {
        /// The API key required for API key authentication.
        /// This member is required.
        public var apiKey: Swift.String?
        /// The API secret key required for API key authentication.
        public var apiSecretKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.apiSecretKey = apiSecretKey
        }
    }
}

extension AppflowClientTypes.ApiKeyCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyCredentials(apiKey: \"CONTENT_REDACTED\", apiSecretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// Information about required authentication parameters.
    public struct AuthParameter: Swift.Sendable {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public var connectorSuppliedValues: [Swift.String]?
        /// A description about the authentication parameter.
        public var description: Swift.String?
        /// Indicates whether this authentication parameter is required.
        public var isRequired: Swift.Bool
        /// Indicates whether this authentication parameter is a sensitive field.
        public var isSensitiveField: Swift.Bool
        /// The authentication key required to authenticate with the connector.
        public var key: Swift.String?
        /// Label used for authentication parameter.
        public var label: Swift.String?

        public init(
            connectorSuppliedValues: [Swift.String]? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            isSensitiveField: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil
        )
        {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
        }
    }
}

extension AppflowClientTypes {

    /// Configuration information required for custom authentication.
    public struct CustomAuthConfig: Swift.Sendable {
        /// Information about authentication parameters required for authentication.
        public var authParameters: [AppflowClientTypes.AuthParameter]?
        /// The authentication type that the custom connector uses.
        public var customAuthenticationType: Swift.String?

        public init(
            authParameters: [AppflowClientTypes.AuthParameter]? = nil,
            customAuthenticationType: Swift.String? = nil
        )
        {
            self.authParameters = authParameters
            self.customAuthenticationType = customAuthenticationType
        }
    }
}

extension AppflowClientTypes {

    public enum OAuth2CustomPropType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authUrl
        case tokenUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2CustomPropType] {
            return [
                .authUrl,
                .tokenUrl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authUrl: return "AUTH_URL"
            case .tokenUrl: return "TOKEN_URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Custom parameter required for OAuth 2.0 authentication.
    public struct OAuth2CustomParameter: Swift.Sendable {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public var connectorSuppliedValues: [Swift.String]?
        /// A description about the custom parameter used for OAuth 2.0 authentication.
        public var description: Swift.String?
        /// Indicates whether the custom parameter for OAuth 2.0 authentication is required.
        public var isRequired: Swift.Bool
        /// Indicates whether this authentication custom parameter is a sensitive field.
        public var isSensitiveField: Swift.Bool
        /// The key of the custom parameter required for OAuth 2.0 authentication.
        public var key: Swift.String?
        /// The label of the custom parameter used for OAuth 2.0 authentication.
        public var label: Swift.String?
        /// Indicates whether custom parameter is used with TokenUrl or AuthUrl.
        public var type: AppflowClientTypes.OAuth2CustomPropType?

        public init(
            connectorSuppliedValues: [Swift.String]? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            isSensitiveField: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil,
            type: AppflowClientTypes.OAuth2CustomPropType? = nil
        )
        {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
            self.type = type
        }
    }
}

extension AppflowClientTypes {

    public enum OAuth2GrantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorizationCode
        case clientCredentials
        case jwtBearer
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2GrantType] {
            return [
                .authorizationCode,
                .clientCredentials,
                .jwtBearer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorizationCode: return "AUTHORIZATION_CODE"
            case .clientCredentials: return "CLIENT_CREDENTIALS"
            case .jwtBearer: return "JWT_BEARER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Contains the default values required for OAuth 2.0 authentication.
    public struct OAuth2Defaults: Swift.Sendable {
        /// Auth code URLs that can be used for OAuth 2.0 authentication.
        public var authCodeUrls: [Swift.String]?
        /// List of custom parameters required for OAuth 2.0 authentication.
        public var oauth2CustomProperties: [AppflowClientTypes.OAuth2CustomParameter]?
        /// OAuth 2.0 grant types supported by the connector.
        public var oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]?
        /// OAuth 2.0 scopes that the connector supports.
        public var oauthScopes: [Swift.String]?
        /// Token URLs that can be used for OAuth 2.0 authentication.
        public var tokenUrls: [Swift.String]?

        public init(
            authCodeUrls: [Swift.String]? = nil,
            oauth2CustomProperties: [AppflowClientTypes.OAuth2CustomParameter]? = nil,
            oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]? = nil,
            oauthScopes: [Swift.String]? = nil,
            tokenUrls: [Swift.String]? = nil
        )
        {
            self.authCodeUrls = authCodeUrls
            self.oauth2CustomProperties = oauth2CustomProperties
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
            self.oauthScopes = oauthScopes
            self.tokenUrls = tokenUrls
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the authentication config that the connector supports.
    public struct AuthenticationConfig: Swift.Sendable {
        /// Contains information required for custom authentication.
        public var customAuthConfigs: [AppflowClientTypes.CustomAuthConfig]?
        /// Indicates whether API key authentication is supported by the connector
        public var isApiKeyAuthSupported: Swift.Bool
        /// Indicates whether basic authentication is supported by the connector.
        public var isBasicAuthSupported: Swift.Bool
        /// Indicates whether custom authentication is supported by the connector
        public var isCustomAuthSupported: Swift.Bool
        /// Indicates whether OAuth 2.0 authentication is supported by the connector.
        public var isOAuth2Supported: Swift.Bool
        /// Contains the default values required for OAuth 2.0 authentication.
        public var oAuth2Defaults: AppflowClientTypes.OAuth2Defaults?

        public init(
            customAuthConfigs: [AppflowClientTypes.CustomAuthConfig]? = nil,
            isApiKeyAuthSupported: Swift.Bool = false,
            isBasicAuthSupported: Swift.Bool = false,
            isCustomAuthSupported: Swift.Bool = false,
            isOAuth2Supported: Swift.Bool = false,
            oAuth2Defaults: AppflowClientTypes.OAuth2Defaults? = nil
        )
        {
            self.customAuthConfigs = customAuthConfigs
            self.isApiKeyAuthSupported = isApiKeyAuthSupported
            self.isBasicAuthSupported = isBasicAuthSupported
            self.isCustomAuthSupported = isCustomAuthSupported
            self.isOAuth2Supported = isOAuth2Supported
            self.oAuth2Defaults = oAuth2Defaults
        }
    }
}

extension AppflowClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apikey
        case basic
        case custom
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .apikey,
                .basic,
                .custom,
                .oauth2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apikey: return "APIKEY"
            case .basic: return "BASIC"
            case .custom: return "CUSTOM"
            case .oauth2: return "OAUTH2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The basic auth credentials required for basic authentication.
    public struct BasicAuthCredentials: Swift.Sendable {
        /// The password to use to connect to a resource.
        /// This member is required.
        public var password: Swift.String?
        /// The username to use to connect to a resource.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }
}

extension AppflowClientTypes.BasicAuthCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BasicAuthCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource specified in the request (such as the source or destination connector profile) is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// API calls have exceeded the maximum allowed API request rate per account and per Region.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelFlowExecutionsInput: Swift.Sendable {
    /// The ID of each active run to cancel. These runs must belong to the flow you specify in your request. If you omit this parameter, your request ends all active runs that belong to the flow.
    public var executionIds: [Swift.String]?
    /// The name of a flow with active runs that you want to cancel.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        executionIds: [Swift.String]? = nil,
        flowName: Swift.String? = nil
    )
    {
        self.executionIds = executionIds
        self.flowName = flowName
    }
}

public struct CancelFlowExecutionsOutput: Swift.Sendable {
    /// The IDs of runs that Amazon AppFlow couldn't cancel. These runs might be ineligible for canceling because they haven't started yet or have already completed.
    public var invalidExecutions: [Swift.String]?

    public init(
        invalidExecutions: [Swift.String]? = nil
    )
    {
        self.invalidExecutions = invalidExecutions
    }
}

extension AppflowClientTypes {

    public enum CatalogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case glue
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogType] {
            return [
                .glue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppflowClientTypes {

    public enum ConnectionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionMode] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "Private"
            case .public: return "Public"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An error occurred when authenticating with the connector endpoint.
public struct ConnectorAuthenticationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorAuthenticationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amazon Connect Customer Profiles.
    public struct CustomerProfilesMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Datadog.
    public struct DatadogMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Dynatrace.
    public struct DynatraceMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amazon EventBridge.
    public struct EventBridgeMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Google Analytics.
    public struct GoogleAnalyticsMetadata: Swift.Sendable {
        /// The desired authorization scope for the Google Analytics account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amazon Honeycode.
    public struct HoneycodeMetadata: Swift.Sendable {
        /// The desired authorization scope for the Amazon Honeycode account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Infor Nexus.
    public struct InforNexusMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Marketo.
    public struct MarketoMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Salesforce Pardot.
    public struct PardotMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amazon Redshift.
    public struct RedshiftMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Amazon S3.
    public struct S3Metadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    public enum SalesforceDataTransferApi: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case bulkv2
        case restSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceDataTransferApi] {
            return [
                .automatic,
                .bulkv2,
                .restSync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .bulkv2: return "BULKV2"
            case .restSync: return "REST_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Salesforce.
    public struct SalesforceMetadata: Swift.Sendable {
        /// The Salesforce APIs that you can have Amazon AppFlow use when your flows transfers data to or from Salesforce.
        public var dataTransferApis: [AppflowClientTypes.SalesforceDataTransferApi]?
        /// The desired authorization scope for the Salesforce account.
        public var oAuthScopes: [Swift.String]?
        /// The OAuth 2.0 grant types that Amazon AppFlow can use when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records. AUTHORIZATION_CODE Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records. JWT_BEARER Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records. The CLIENT_CREDENTIALS value is not supported for Salesforce.
        public var oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]?

        public init(
            dataTransferApis: [AppflowClientTypes.SalesforceDataTransferApi]? = nil,
            oAuthScopes: [Swift.String]? = nil,
            oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]? = nil
        )
        {
            self.dataTransferApis = dataTransferApis
            self.oAuthScopes = oAuthScopes
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to SAPOData.
    public struct SAPODataMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to ServiceNow.
    public struct ServiceNowMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Singular.
    public struct SingularMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Slack.
    public struct SlackMetadata: Swift.Sendable {
        /// The desired authorization scope for the Slack account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Snowflake.
    public struct SnowflakeMetadata: Swift.Sendable {
        /// Specifies the supported Amazon Web Services Regions when using Snowflake.
        public var supportedRegions: [Swift.String]?

        public init(
            supportedRegions: [Swift.String]? = nil
        )
        {
            self.supportedRegions = supportedRegions
        }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Trend Micro.
    public struct TrendmicroMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Upsolver.
    public struct UpsolverMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Veeva.
    public struct VeevaMetadata: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector metadata specific to Zendesk.
    public struct ZendeskMetadata: Swift.Sendable {
        /// The desired authorization scope for the Zendesk account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }
}

extension AppflowClientTypes {

    /// A structure to specify connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
    public struct ConnectorMetadata: Swift.Sendable {
        /// The connector metadata specific to Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeMetadata?
        /// The connector metadata specific to Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesMetadata?
        /// The connector metadata specific to Datadog.
        public var datadog: AppflowClientTypes.DatadogMetadata?
        /// The connector metadata specific to Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceMetadata?
        /// The connector metadata specific to Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeMetadata?
        /// The connector metadata specific to Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata?
        /// The connector metadata specific to Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeMetadata?
        /// The connector metadata specific to Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusMetadata?
        /// The connector metadata specific to Marketo.
        public var marketo: AppflowClientTypes.MarketoMetadata?
        /// The connector metadata specific to Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotMetadata?
        /// The connector metadata specific to Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftMetadata?
        /// The connector metadata specific to Amazon S3.
        public var s3: AppflowClientTypes.S3Metadata?
        /// The connector metadata specific to Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceMetadata?
        /// The connector metadata specific to SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataMetadata?
        /// The connector metadata specific to ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowMetadata?
        /// The connector metadata specific to Singular.
        public var singular: AppflowClientTypes.SingularMetadata?
        /// The connector metadata specific to Slack.
        public var slack: AppflowClientTypes.SlackMetadata?
        /// The connector metadata specific to Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeMetadata?
        /// The connector metadata specific to Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroMetadata?
        /// The connector metadata specific to Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverMetadata?
        /// The connector metadata specific to Veeva.
        public var veeva: AppflowClientTypes.VeevaMetadata?
        /// The connector metadata specific to Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskMetadata?

        public init(
            amplitude: AppflowClientTypes.AmplitudeMetadata? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesMetadata? = nil,
            datadog: AppflowClientTypes.DatadogMetadata? = nil,
            dynatrace: AppflowClientTypes.DynatraceMetadata? = nil,
            eventBridge: AppflowClientTypes.EventBridgeMetadata? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata? = nil,
            honeycode: AppflowClientTypes.HoneycodeMetadata? = nil,
            inforNexus: AppflowClientTypes.InforNexusMetadata? = nil,
            marketo: AppflowClientTypes.MarketoMetadata? = nil,
            pardot: AppflowClientTypes.PardotMetadata? = nil,
            redshift: AppflowClientTypes.RedshiftMetadata? = nil,
            s3: AppflowClientTypes.S3Metadata? = nil,
            salesforce: AppflowClientTypes.SalesforceMetadata? = nil,
            sapoData: AppflowClientTypes.SAPODataMetadata? = nil,
            serviceNow: AppflowClientTypes.ServiceNowMetadata? = nil,
            singular: AppflowClientTypes.SingularMetadata? = nil,
            slack: AppflowClientTypes.SlackMetadata? = nil,
            snowflake: AppflowClientTypes.SnowflakeMetadata? = nil,
            trendmicro: AppflowClientTypes.TrendmicroMetadata? = nil,
            upsolver: AppflowClientTypes.UpsolverMetadata? = nil,
            veeva: AppflowClientTypes.VeevaMetadata? = nil,
            zendesk: AppflowClientTypes.ZendeskMetadata? = nil
        )
        {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the configuration of the lambda which is being registered as the connector.
    public struct LambdaConnectorProvisioningConfig: Swift.Sendable {
        /// Lambda ARN of the connector being registered.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the configuration of the connector being registered.
    public struct ConnectorProvisioningConfig: Swift.Sendable {
        /// Contains information about the configuration of the lambda which is being registered as the connector.
        public var lambda: AppflowClientTypes.LambdaConnectorProvisioningConfig?

        public init(
            lambda: AppflowClientTypes.LambdaConnectorProvisioningConfig? = nil
        )
        {
            self.lambda = lambda
        }
    }
}

extension AppflowClientTypes {

    /// The type of provisioning that the connector supports, such as Lambda.
    public enum ConnectorProvisioningType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorProvisioningType] {
            return [
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the connector runtime settings that are required for flow execution.
    public struct ConnectorRuntimeSetting: Swift.Sendable {
        /// Contains default values for the connector runtime setting that are supplied by the connector.
        public var connectorSuppliedValueOptions: [Swift.String]?
        /// Data type of the connector runtime setting.
        public var dataType: Swift.String?
        /// A description about the connector runtime setting.
        public var description: Swift.String?
        /// Indicates whether this connector runtime setting is required.
        public var isRequired: Swift.Bool
        /// Contains value information about the connector runtime setting.
        public var key: Swift.String?
        /// A label used for connector runtime setting.
        public var label: Swift.String?
        /// Indicates the scope of the connector runtime setting.
        public var scope: Swift.String?

        public init(
            connectorSuppliedValueOptions: [Swift.String]? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil,
            scope: Swift.String? = nil
        )
        {
            self.connectorSuppliedValueOptions = connectorSuppliedValueOptions
            self.dataType = dataType
            self.description = description
            self.isRequired = isRequired
            self.key = key
            self.label = label
            self.scope = scope
        }
    }
}

extension AppflowClientTypes {

    public enum ConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amplitude
        case customconnector
        case customerprofiles
        case datadog
        case dynatrace
        case eventbridge
        case googleanalytics
        case honeycode
        case infornexus
        case lookoutmetrics
        case marketo
        case pardot
        case redshift
        case s3
        case salesforce
        case sapodata
        case servicenow
        case singular
        case slack
        case snowflake
        case trendmicro
        case upsolver
        case veeva
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorType] {
            return [
                .amplitude,
                .customconnector,
                .customerprofiles,
                .datadog,
                .dynatrace,
                .eventbridge,
                .googleanalytics,
                .honeycode,
                .infornexus,
                .lookoutmetrics,
                .marketo,
                .pardot,
                .redshift,
                .s3,
                .salesforce,
                .sapodata,
                .servicenow,
                .singular,
                .slack,
                .snowflake,
                .trendmicro,
                .upsolver,
                .veeva,
                .zendesk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amplitude: return "Amplitude"
            case .customconnector: return "CustomConnector"
            case .customerprofiles: return "CustomerProfiles"
            case .datadog: return "Datadog"
            case .dynatrace: return "Dynatrace"
            case .eventbridge: return "EventBridge"
            case .googleanalytics: return "Googleanalytics"
            case .honeycode: return "Honeycode"
            case .infornexus: return "Infornexus"
            case .lookoutmetrics: return "LookoutMetrics"
            case .marketo: return "Marketo"
            case .pardot: return "Pardot"
            case .redshift: return "Redshift"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .sapodata: return "SAPOData"
            case .servicenow: return "Servicenow"
            case .singular: return "Singular"
            case .slack: return "Slack"
            case .snowflake: return "Snowflake"
            case .trendmicro: return "Trendmicro"
            case .upsolver: return "Upsolver"
            case .veeva: return "Veeva"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum DataTransferApiType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case async
        case automatic
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [DataTransferApiType] {
            return [
                .async,
                .automatic,
                .sync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case .automatic: return "AUTOMATIC"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The API of the connector application that Amazon AppFlow uses to transfer your data.
    public struct DataTransferApi: Swift.Sendable {
        /// The name of the connector application API.
        public var name: Swift.String?
        /// You can specify one of the following types: AUTOMATIC The default. Optimizes a flow for datasets that fluctuate in size from small to large. For each flow run, Amazon AppFlow chooses to use the SYNC or ASYNC API type based on the amount of data that the run transfers. SYNC A synchronous API. This type of API optimizes a flow for small to medium-sized datasets. ASYNC An asynchronous API. This type of API optimizes a flow for large datasets.
        public var type: AppflowClientTypes.DataTransferApiType?

        public init(
            name: Swift.String? = nil,
            type: AppflowClientTypes.DataTransferApiType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension AppflowClientTypes {

    public enum SupportedDataTransferType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case file
        case record
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedDataTransferType] {
            return [
                .file,
                .record
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .file: return "FILE"
            case .record: return "RECORD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum Operators: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operators] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum ScheduleFrequencyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byminute
        case daily
        case hourly
        case monthly
        case once
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleFrequencyType] {
            return [
                .byminute,
                .daily,
                .hourly,
                .monthly,
                .once,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byminute: return "BYMINUTE"
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .once: return "ONCE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum TriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
    public enum WriteOperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case insert
        case update
        case upsert
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteOperationType] {
            return [
                .delete,
                .insert,
                .update,
                .upsert
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .insert: return "INSERT"
            case .update: return "UPDATE"
            case .upsert: return "UPSERT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The configuration settings related to a given connector.
    public struct ConnectorConfiguration: Swift.Sendable {
        /// The authentication config required for the connector.
        public var authenticationConfig: AppflowClientTypes.AuthenticationConfig?
        /// Specifies whether the connector can be used as a destination.
        public var canUseAsDestination: Swift.Bool
        /// Specifies whether the connector can be used as a source.
        public var canUseAsSource: Swift.Bool
        /// The Amazon Resource Name (ARN) for the registered connector.
        public var connectorArn: Swift.String?
        /// A description about the connector.
        public var connectorDescription: Swift.String?
        /// The label used for registering the connector.
        public var connectorLabel: Swift.String?
        /// Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
        public var connectorMetadata: AppflowClientTypes.ConnectorMetadata?
        /// The connection modes that the connector supports.
        public var connectorModes: [Swift.String]?
        /// The connector name.
        public var connectorName: Swift.String?
        /// The owner who developed the connector.
        public var connectorOwner: Swift.String?
        /// The configuration required for registering the connector.
        public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
        /// The provisioning type used to register the connector.
        public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
        /// The required connector runtime settings.
        public var connectorRuntimeSettings: [AppflowClientTypes.ConnectorRuntimeSetting]?
        /// The connector type.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// The connector version.
        public var connectorVersion: Swift.String?
        /// Specifies if PrivateLink is enabled for that connector.
        public var isPrivateLinkEnabled: Swift.Bool
        /// Specifies if a PrivateLink endpoint URL is required.
        public var isPrivateLinkEndpointUrlRequired: Swift.Bool
        /// Logo URL of the connector.
        public var logoURL: Swift.String?
        /// The date on which the connector was registered.
        public var registeredAt: Foundation.Date?
        /// Information about who registered the connector.
        public var registeredBy: Swift.String?
        /// A list of API versions that are supported by the connector.
        public var supportedApiVersions: [Swift.String]?
        /// The APIs of the connector application that Amazon AppFlow can use to transfer your data.
        public var supportedDataTransferApis: [AppflowClientTypes.DataTransferApi]?
        /// The data transfer types that the connector supports. RECORD Structured records. FILE Files or binary data.
        public var supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]?
        /// Lists the connectors that are available for use as destinations.
        public var supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]?
        /// A list of operators supported by the connector.
        public var supportedOperators: [AppflowClientTypes.Operators]?
        /// Specifies the supported flow frequency for that connector.
        public var supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]?
        /// Specifies the supported trigger types for the flow.
        public var supportedTriggerTypes: [AppflowClientTypes.TriggerType]?
        /// A list of write operations supported by the connector.
        public var supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init(
            authenticationConfig: AppflowClientTypes.AuthenticationConfig? = nil,
            canUseAsDestination: Swift.Bool = false,
            canUseAsSource: Swift.Bool = false,
            connectorArn: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorLabel: Swift.String? = nil,
            connectorMetadata: AppflowClientTypes.ConnectorMetadata? = nil,
            connectorModes: [Swift.String]? = nil,
            connectorName: Swift.String? = nil,
            connectorOwner: Swift.String? = nil,
            connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
            connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
            connectorRuntimeSettings: [AppflowClientTypes.ConnectorRuntimeSetting]? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            connectorVersion: Swift.String? = nil,
            isPrivateLinkEnabled: Swift.Bool = false,
            isPrivateLinkEndpointUrlRequired: Swift.Bool = false,
            logoURL: Swift.String? = nil,
            registeredAt: Foundation.Date? = nil,
            registeredBy: Swift.String? = nil,
            supportedApiVersions: [Swift.String]? = nil,
            supportedDataTransferApis: [AppflowClientTypes.DataTransferApi]? = nil,
            supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]? = nil,
            supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]? = nil,
            supportedOperators: [AppflowClientTypes.Operators]? = nil,
            supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]? = nil,
            supportedTriggerTypes: [AppflowClientTypes.TriggerType]? = nil,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.authenticationConfig = authenticationConfig
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorMetadata = connectorMetadata
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningConfig = connectorProvisioningConfig
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorRuntimeSettings = connectorRuntimeSettings
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.logoURL = logoURL
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedApiVersions = supportedApiVersions
            self.supportedDataTransferApis = supportedDataTransferApis
            self.supportedDataTransferTypes = supportedDataTransferTypes
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedOperators = supportedOperators
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
            self.supportedWriteOperations = supportedWriteOperations
        }
    }
}

extension AppflowClientTypes {

    /// Information about the registered connector.
    public struct ConnectorDetail: Swift.Sendable {
        /// The application type of the connector.
        public var applicationType: Swift.String?
        /// A description about the registered connector.
        public var connectorDescription: Swift.String?
        /// A label used for the connector.
        public var connectorLabel: Swift.String?
        /// The connection mode that the connector supports.
        public var connectorModes: [Swift.String]?
        /// The name of the connector.
        public var connectorName: Swift.String?
        /// The owner of the connector.
        public var connectorOwner: Swift.String?
        /// The provisioning type that the connector uses.
        public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
        /// The connector type.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// The connector version.
        public var connectorVersion: Swift.String?
        /// The time at which the connector was registered.
        public var registeredAt: Foundation.Date?
        /// The user who registered the connector.
        public var registeredBy: Swift.String?
        /// The data transfer types that the connector supports. RECORD Structured records. FILE Files or binary data.
        public var supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]?

        public init(
            applicationType: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorLabel: Swift.String? = nil,
            connectorModes: [Swift.String]? = nil,
            connectorName: Swift.String? = nil,
            connectorOwner: Swift.String? = nil,
            connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            connectorVersion: Swift.String? = nil,
            registeredAt: Foundation.Date? = nil,
            registeredBy: Swift.String? = nil,
            supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]? = nil
        )
        {
            self.applicationType = applicationType
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedDataTransferTypes = supportedDataTransferTypes
        }
    }
}

extension AppflowClientTypes {

    /// The high-level entity that can be queried in Amazon AppFlow. For example, a Salesforce entity might be an Account or Opportunity, whereas a ServiceNow entity might be an Incident.
    public struct ConnectorEntity: Swift.Sendable {
        /// Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        public var hasNestedEntities: Swift.Bool
        /// The label applied to the connector entity.
        public var label: Swift.String?
        /// The name of the connector entity.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hasNestedEntities: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }
    }
}

extension AppflowClientTypes {

    /// The properties that can be applied to a field when connector is being used as a destination.
    public struct DestinationFieldProperties: Swift.Sendable {
        /// Specifies if the destination field can be created by the current user.
        public var isCreatable: Swift.Bool
        /// Specifies whether the field can use the default value during a Create operation.
        public var isDefaultedOnCreate: Swift.Bool
        /// Specifies if the destination field can have a null value.
        public var isNullable: Swift.Bool
        /// Specifies whether the field can be updated during an UPDATE or UPSERT write operation.
        public var isUpdatable: Swift.Bool
        /// Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        public var isUpsertable: Swift.Bool
        /// A list of supported write operations. For each write operation listed, this field can be used in idFieldNames when that write operation is present as a destination option.
        public var supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init(
            isCreatable: Swift.Bool = false,
            isDefaultedOnCreate: Swift.Bool = false,
            isNullable: Swift.Bool = false,
            isUpdatable: Swift.Bool = false,
            isUpsertable: Swift.Bool = false,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.isCreatable = isCreatable
            self.isDefaultedOnCreate = isDefaultedOnCreate
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }
    }
}

extension AppflowClientTypes {

    /// The properties that can be applied to a field when the connector is being used as a source.
    public struct SourceFieldProperties: Swift.Sendable {
        /// Indicates if the field can be queried.
        public var isQueryable: Swift.Bool
        /// Indicates whether the field can be returned in a search result.
        public var isRetrievable: Swift.Bool
        /// Indicates if this timestamp field can be used for incremental queries.
        public var isTimestampFieldForIncrementalQueries: Swift.Bool

        public init(
            isQueryable: Swift.Bool = false,
            isRetrievable: Swift.Bool = false,
            isTimestampFieldForIncrementalQueries: Swift.Bool = false
        )
        {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
            self.isTimestampFieldForIncrementalQueries = isTimestampFieldForIncrementalQueries
        }
    }
}

extension AppflowClientTypes {

    /// The range of values that the property supports.
    public struct Range: Swift.Sendable {
        /// Maximum value supported by the field.
        public var maximum: Swift.Double
        /// Minimum value supported by the field.
        public var minimum: Swift.Double

        public init(
            maximum: Swift.Double = 0.0,
            minimum: Swift.Double = 0.0
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }
}

extension AppflowClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Contains details regarding the supported field type and the operators that can be applied for filtering.
    public struct FieldTypeDetails: Swift.Sendable {
        /// This is the allowable length range for this field's value.
        public var fieldLengthRange: AppflowClientTypes.Range?
        /// The type of field, such as string, integer, date, and so on.
        /// This member is required.
        public var fieldType: Swift.String?
        /// The range of values this field can hold.
        public var fieldValueRange: AppflowClientTypes.Range?
        /// The list of operators supported by a field.
        /// This member is required.
        public var filterOperators: [AppflowClientTypes.Operator]?
        /// The date format that the field supports.
        public var supportedDateFormat: Swift.String?
        /// The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false".
        public var supportedValues: [Swift.String]?
        /// The regular expression pattern for the field name.
        public var valueRegexPattern: Swift.String?

        public init(
            fieldLengthRange: AppflowClientTypes.Range? = nil,
            fieldType: Swift.String? = nil,
            fieldValueRange: AppflowClientTypes.Range? = nil,
            filterOperators: [AppflowClientTypes.Operator]? = nil,
            supportedDateFormat: Swift.String? = nil,
            supportedValues: [Swift.String]? = nil,
            valueRegexPattern: Swift.String? = nil
        )
        {
            self.fieldLengthRange = fieldLengthRange
            self.fieldType = fieldType
            self.fieldValueRange = fieldValueRange
            self.filterOperators = filterOperators
            self.supportedDateFormat = supportedDateFormat
            self.supportedValues = supportedValues
            self.valueRegexPattern = valueRegexPattern
        }
    }
}

extension AppflowClientTypes {

    /// Contains details regarding all the supported FieldTypes and their corresponding filterOperators and supportedValues.
    public struct SupportedFieldTypeDetails: Swift.Sendable {
        /// The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced.
        /// This member is required.
        public var v1: AppflowClientTypes.FieldTypeDetails?

        public init(
            v1: AppflowClientTypes.FieldTypeDetails? = nil
        )
        {
            self.v1 = v1
        }
    }
}

extension AppflowClientTypes {

    /// Describes the data model of a connector field. For example, for an account entity, the fields would be account name, account ID, and so on.
    public struct ConnectorEntityField: Swift.Sendable {
        /// A map that has specific properties related to the ConnectorEntityField.
        public var customProperties: [Swift.String: Swift.String]?
        /// Default value that can be assigned to this field.
        public var defaultValue: Swift.String?
        /// A description of the connector entity field.
        public var description: Swift.String?
        /// The properties applied to a field when the connector is being used as a destination.
        public var destinationProperties: AppflowClientTypes.DestinationFieldProperties?
        /// The unique identifier of the connector field.
        /// This member is required.
        public var identifier: Swift.String?
        /// Booelan value that indicates whether this field is deprecated or not.
        public var isDeprecated: Swift.Bool
        /// Booelan value that indicates whether this field can be used as a primary key.
        public var isPrimaryKey: Swift.Bool
        /// The label applied to a connector entity field.
        public var label: Swift.String?
        /// The parent identifier of the connector field.
        public var parentIdentifier: Swift.String?
        /// The properties that can be applied to a field when the connector is being used as a source.
        public var sourceProperties: AppflowClientTypes.SourceFieldProperties?
        /// Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues.
        public var supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails?

        public init(
            customProperties: [Swift.String: Swift.String]? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationProperties: AppflowClientTypes.DestinationFieldProperties? = nil,
            identifier: Swift.String? = nil,
            isDeprecated: Swift.Bool = false,
            isPrimaryKey: Swift.Bool = false,
            label: Swift.String? = nil,
            parentIdentifier: Swift.String? = nil,
            sourceProperties: AppflowClientTypes.SourceFieldProperties? = nil,
            supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails? = nil
        )
        {
            self.customProperties = customProperties
            self.defaultValue = defaultValue
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.isDeprecated = isDeprecated
            self.isPrimaryKey = isPrimaryKey
            self.label = label
            self.parentIdentifier = parentIdentifier
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }
    }
}

extension AppflowClientTypes {

    /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
    public struct ConnectorOAuthRequest: Swift.Sendable {
        /// The code provided by the connector when it has been authenticated via the connected app.
        public var authCode: Swift.String?
        /// The URL to which the authentication server redirects the browser after authorization has been granted.
        public var redirectUri: Swift.String?

        public init(
            authCode: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }
    }
}

extension AppflowClientTypes {

    public enum DatadogConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DatadogConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum DynatraceConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DynatraceConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum GoogleAnalyticsConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case projection
        case sdkUnknown(Swift.String)

        public static var allCases: [GoogleAnalyticsConnectorOperator] {
            return [
                .between,
                .projection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .projection: return "PROJECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum InforNexusConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [InforNexusConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum MarketoConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum PardotConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [PardotConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum S3ConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum SalesforceConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum SAPODataConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SAPODataConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum ServiceNowConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum SingularConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SingularConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum SlackConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SlackConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum TrendmicroConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [TrendmicroConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum VeevaConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [VeevaConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum ZendeskConnectorOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Sendable {
        /// The operation to be performed on the provided Amplitude source fields.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorOperator?
        /// Operators supported by the custom connector.
        public var customConnector: AppflowClientTypes.Operator?
        /// The operation to be performed on the provided Datadog source fields.
        public var datadog: AppflowClientTypes.DatadogConnectorOperator?
        /// The operation to be performed on the provided Dynatrace source fields.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorOperator?
        /// The operation to be performed on the provided Google Analytics source fields.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator?
        /// The operation to be performed on the provided Infor Nexus source fields.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorOperator?
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: AppflowClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Salesforce Pardot source fields.
        public var pardot: AppflowClientTypes.PardotConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: AppflowClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: AppflowClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided SAPOData source fields.
        public var sapoData: AppflowClientTypes.SAPODataConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Singular source fields.
        public var singular: AppflowClientTypes.SingularConnectorOperator?
        /// The operation to be performed on the provided Slack source fields.
        public var slack: AppflowClientTypes.SlackConnectorOperator?
        /// The operation to be performed on the provided Trend Micro source fields.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorOperator?
        /// The operation to be performed on the provided Veeva source fields.
        public var veeva: AppflowClientTypes.VeevaConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: AppflowClientTypes.ZendeskConnectorOperator?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorOperator? = nil,
            customConnector: AppflowClientTypes.Operator? = nil,
            datadog: AppflowClientTypes.DatadogConnectorOperator? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorOperator? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorOperator? = nil,
            marketo: AppflowClientTypes.MarketoConnectorOperator? = nil,
            pardot: AppflowClientTypes.PardotConnectorOperator? = nil,
            s3: AppflowClientTypes.S3ConnectorOperator? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorOperator? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorOperator? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorOperator? = nil,
            singular: AppflowClientTypes.SingularConnectorOperator? = nil,
            slack: AppflowClientTypes.SlackConnectorOperator? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorOperator? = nil,
            veeva: AppflowClientTypes.VeevaConnectorOperator? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    /// The OAuth 2.0 properties required for OAuth 2.0 authentication.
    public struct OAuth2Properties: Swift.Sendable {
        /// The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication.
        /// This member is required.
        public var oAuth2GrantType: AppflowClientTypes.OAuth2GrantType?
        /// The token URL required for OAuth 2.0 authentication.
        /// This member is required.
        public var tokenUrl: Swift.String?
        /// Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        public var tokenUrlCustomProperties: [Swift.String: Swift.String]?

        public init(
            oAuth2GrantType: AppflowClientTypes.OAuth2GrantType? = nil,
            tokenUrl: Swift.String? = nil,
            tokenUrlCustomProperties: [Swift.String: Swift.String]? = nil
        )
        {
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlCustomProperties = tokenUrlCustomProperties
        }
    }
}

extension AppflowClientTypes {

    /// The profile properties required by the custom connector.
    public struct CustomConnectorProfileProperties: Swift.Sendable {
        /// The OAuth 2.0 properties required for OAuth 2.0 authentication.
        public var oAuth2Properties: AppflowClientTypes.OAuth2Properties?
        /// A map of properties that are required to create a profile for the custom connector.
        public var profileProperties: [Swift.String: Swift.String]?

        public init(
            oAuth2Properties: AppflowClientTypes.OAuth2Properties? = nil,
            profileProperties: [Swift.String: Swift.String]? = nil
        )
        {
            self.oAuth2Properties = oAuth2Properties
            self.profileProperties = profileProperties
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required by Datadog.
    public struct DatadogConnectorProfileProperties: Swift.Sendable {
        /// The location of the Datadog resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required by Dynatrace.
    public struct DynatraceConnectorProfileProperties: Swift.Sendable {
        /// The location of the Dynatrace resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector-specific properties required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required by Infor Nexus.
    public struct InforNexusConnectorProfileProperties: Swift.Sendable {
        /// The location of the Infor Nexus resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Marketo.
    public struct MarketoConnectorProfileProperties: Swift.Sendable {
        /// The location of the Marketo resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Salesforce Pardot.
    public struct PardotConnectorProfileProperties: Swift.Sendable {
        /// The business unit id of Salesforce Pardot instance.
        public var businessUnitId: Swift.String?
        /// The location of the Salesforce Pardot resource.
        public var instanceUrl: Swift.String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public var isSandboxEnvironment: Swift.Bool

        public init(
            businessUnitId: Swift.String? = nil,
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false
        )
        {
            self.businessUnitId = businessUnitId
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties when using Amazon Redshift.
    public struct RedshiftConnectorProfileProperties: Swift.Sendable {
        /// A name for the associated Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The unique ID that's assigned to an Amazon Redshift cluster.
        public var clusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that permits Amazon AppFlow to access your Amazon Redshift database through the Data API. For more information, and for the polices that you attach to this role, see [Allow Amazon AppFlow to access Amazon Redshift databases with the Data API](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_service-role-policies.html#access-redshift).
        public var dataApiRoleArn: Swift.String?
        /// The name of an Amazon Redshift database.
        public var databaseName: Swift.String?
        /// The JDBC URL of the Amazon Redshift cluster.
        public var databaseUrl: Swift.String?
        /// Indicates whether the connector profile defines a connection to an Amazon Redshift Serverless data warehouse.
        public var isRedshiftServerless: Swift.Bool
        /// The Amazon Resource Name (ARN) of IAM role that grants Amazon Redshift read-only access to Amazon S3. For more information, and for the polices that you attach to this role, see [Allow Amazon Redshift to access your Amazon AppFlow data in Amazon S3](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_service-role-policies.html#redshift-access-s3).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of an Amazon Redshift workgroup.
        public var workgroupName: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            clusterIdentifier: Swift.String? = nil,
            dataApiRoleArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseUrl: Swift.String? = nil,
            isRedshiftServerless: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.clusterIdentifier = clusterIdentifier
            self.dataApiRoleArn = dataApiRoleArn
            self.databaseName = databaseName
            self.databaseUrl = databaseUrl
            self.isRedshiftServerless = isRedshiftServerless
            self.roleArn = roleArn
            self.workgroupName = workgroupName
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Salesforce.
    public struct SalesforceConnectorProfileProperties: Swift.Sendable {
        /// The location of the Salesforce resource.
        public var instanceUrl: Swift.String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public var isSandboxEnvironment: Swift.Bool
        /// If the connection mode for the connector profile is private, this parameter sets whether Amazon AppFlow uses the private network to send metadata and authorization calls to Salesforce. Amazon AppFlow sends private calls through Amazon Web Services PrivateLink. These calls travel through Amazon Web Services infrastructure without being exposed to the public internet. Set either of the following values: true Amazon AppFlow sends all calls to Salesforce over the private network. These private calls are:
        ///
        /// * Calls to get metadata about your Salesforce records. This metadata describes your Salesforce objects and their fields.
        ///
        /// * Calls to get or refresh access tokens that allow Amazon AppFlow to access your Salesforce records.
        ///
        /// * Calls to transfer your Salesforce records as part of a flow run.
        ///
        ///
        /// false The default value. Amazon AppFlow sends some calls to Salesforce privately and other calls over the public internet. The public calls are:
        ///
        /// * Calls to get metadata about your Salesforce records.
        ///
        /// * Calls to get or refresh access tokens.
        ///
        ///
        /// The private calls are:
        ///
        /// * Calls to transfer your Salesforce records as part of a flow run.
        public var usePrivateLinkForMetadataAndAuthorization: Swift.Bool

        public init(
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false,
            usePrivateLinkForMetadataAndAuthorization: Swift.Bool = false
        )
        {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
            self.usePrivateLinkForMetadataAndAuthorization = usePrivateLinkForMetadataAndAuthorization
        }
    }
}

extension AppflowClientTypes {

    /// The OAuth properties required for OAuth type authentication.
    public struct OAuthProperties: Swift.Sendable {
        /// The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        /// This member is required.
        public var authCodeUrl: Swift.String?
        /// The OAuth scopes required for OAuth type authentication.
        /// This member is required.
        public var oAuthScopes: [Swift.String]?
        /// The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        /// This member is required.
        public var tokenUrl: Swift.String?

        public init(
            authCodeUrl: Swift.String? = nil,
            oAuthScopes: [Swift.String]? = nil,
            tokenUrl: Swift.String? = nil
        )
        {
            self.authCodeUrl = authCodeUrl
            self.oAuthScopes = oAuthScopes
            self.tokenUrl = tokenUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using SAPOData.
    public struct SAPODataConnectorProfileProperties: Swift.Sendable {
        /// The location of the SAPOData resource.
        /// This member is required.
        public var applicationHostUrl: Swift.String?
        /// The application path to catalog service.
        /// This member is required.
        public var applicationServicePath: Swift.String?
        /// The client number for the client creating the connection.
        /// This member is required.
        public var clientNumber: Swift.String?
        /// If you set this parameter to true, Amazon AppFlow bypasses the single sign-on (SSO) settings in your SAP account when it accesses your SAP OData instance. Whether you need this option depends on the types of credentials that you applied to your SAP OData connection profile. If your profile uses basic authentication credentials, SAP SSO can prevent Amazon AppFlow from connecting to your account with your username and password. In this case, bypassing SSO makes it possible for Amazon AppFlow to connect successfully. However, if your profile uses OAuth credentials, this parameter has no affect.
        public var disableSSO: Swift.Bool
        /// The logon language of SAPOData instance.
        public var logonLanguage: Swift.String?
        /// The SAPOData OAuth properties required for OAuth type authentication.
        public var oAuthProperties: AppflowClientTypes.OAuthProperties?
        /// The port number of the SAPOData instance.
        /// This member is required.
        public var portNumber: Swift.Int?
        /// The SAPOData Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?

        public init(
            applicationHostUrl: Swift.String? = nil,
            applicationServicePath: Swift.String? = nil,
            clientNumber: Swift.String? = nil,
            disableSSO: Swift.Bool = false,
            logonLanguage: Swift.String? = nil,
            oAuthProperties: AppflowClientTypes.OAuthProperties? = nil,
            portNumber: Swift.Int? = nil,
            privateLinkServiceName: Swift.String? = nil
        )
        {
            self.applicationHostUrl = applicationHostUrl
            self.applicationServicePath = applicationServicePath
            self.clientNumber = clientNumber
            self.disableSSO = disableSSO
            self.logonLanguage = logonLanguage
            self.oAuthProperties = oAuthProperties
            self.portNumber = portNumber
            self.privateLinkServiceName = privateLinkServiceName
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using ServiceNow.
    public struct ServiceNowConnectorProfileProperties: Swift.Sendable {
        /// The location of the ServiceNow resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Singular.
    public struct SingularConnectorProfileProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Slack.
    public struct SlackConnectorProfileProperties: Swift.Sendable {
        /// The location of the Slack resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Snowflake.
    public struct SnowflakeConnectorProfileProperties: Swift.Sendable {
        /// The name of the account.
        public var accountName: Swift.String?
        /// The name of the Amazon S3 bucket associated with Snowflake.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        public var bucketPrefix: Swift.String?
        /// The Snowflake Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?
        /// The Amazon Web Services Region of the Snowflake account.
        public var region: Swift.String?
        /// The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: < Database>< Schema>.
        /// This member is required.
        public var stage: Swift.String?
        /// The name of the Snowflake warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            privateLinkServiceName: Swift.String? = nil,
            region: Swift.String? = nil,
            stage: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Trend Micro.
    public struct TrendmicroConnectorProfileProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Veeva.
    public struct VeevaConnectorProfileProperties: Swift.Sendable {
        /// The location of the Veeva resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required when using Zendesk.
    public struct ZendeskConnectorProfileProperties: Swift.Sendable {
        /// The location of the Zendesk resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile properties required by each connector.
    public struct ConnectorProfileProperties: Swift.Sendable {
        /// The connector-specific properties required by Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties?
        /// The properties required by the custom connector.
        public var customConnector: AppflowClientTypes.CustomConnectorProfileProperties?
        /// The connector-specific properties required by Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileProperties?
        /// The connector-specific properties required by Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties?
        /// The connector-specific properties required Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties?
        /// The connector-specific properties required by Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties?
        /// The connector-specific properties required by Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties?
        /// The connector-specific profile properties required when using SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataConnectorProfileProperties?
        /// The connector-specific properties required by serviceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties?
        /// The connector-specific properties required by Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileProperties?
        /// The connector-specific properties required by Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileProperties?
        /// The connector-specific properties required by Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties?
        /// The connector-specific properties required by Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties?
        /// The connector-specific properties required by Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileProperties?
        /// The connector-specific properties required by Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties? = nil,
            customConnector: AppflowClientTypes.CustomConnectorProfileProperties? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileProperties? = nil,
            pardot: AppflowClientTypes.PardotConnectorProfileProperties? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorProfileProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileProperties? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    public enum PrivateConnectionProvisioningFailureCause: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case connectorAuthentication
        case connectorServer
        case internalServer
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningFailureCause] {
            return [
                .accessDenied,
                .connectorAuthentication,
                .connectorServer,
                .internalServer,
                .validation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .connectorAuthentication: return "CONNECTOR_AUTHENTICATION"
            case .connectorServer: return "CONNECTOR_SERVER"
            case .internalServer: return "INTERNAL_SERVER"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum PrivateConnectionProvisioningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningStatus] {
            return [
                .created,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the private connection provisioning state.
    public struct PrivateConnectionProvisioningState: Swift.Sendable {
        /// Specifies the private connection provisioning failure cause.
        public var failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause?
        /// Specifies the private connection provisioning failure reason.
        public var failureMessage: Swift.String?
        /// Specifies the private connection provisioning status.
        public var status: AppflowClientTypes.PrivateConnectionProvisioningStatus?

        public init(
            failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause? = nil,
            failureMessage: Swift.String? = nil,
            status: AppflowClientTypes.PrivateConnectionProvisioningStatus? = nil
        )
        {
            self.failureCause = failureCause
            self.failureMessage = failureMessage
            self.status = status
        }
    }
}

extension AppflowClientTypes {

    /// Describes an instance of a connector. This includes the provided name, credentials ARN, connection-mode, and so on. To keep the API intuitive and extensible, the fields that are common to all types of connector profiles are explicitly specified at the top level. The rest of the connector-specific properties are available via the connectorProfileProperties field.
    public struct ConnectorProfile: Swift.Sendable {
        /// Indicates the connection mode and if it is public or private.
        public var connectionMode: AppflowClientTypes.ConnectionMode?
        /// The label for the connector profile being created.
        public var connectorLabel: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector profile.
        public var connectorProfileArn: Swift.String?
        /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The connector-specific properties of the profile configuration.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Specifies when the connector profile was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the connector profile credentials.
        public var credentialsArn: Swift.String?
        /// Specifies when the connector profile was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// Specifies the private connection provisioning state.
        public var privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState?

        public init(
            connectionMode: AppflowClientTypes.ConnectionMode? = nil,
            connectorLabel: Swift.String? = nil,
            connectorProfileArn: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            createdAt: Foundation.Date? = nil,
            credentialsArn: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState? = nil
        )
        {
            self.connectionMode = connectionMode
            self.connectorLabel = connectorLabel
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
            self.privateConnectionProvisioningState = privateConnectionProvisioningState
        }
    }
}

extension AppflowClientTypes {

    /// The custom credentials required for custom authentication.
    public struct CustomAuthCredentials: Swift.Sendable {
        /// A map that holds custom authentication credentials.
        public var credentialsMap: [Swift.String: Swift.String]?
        /// The custom authentication type that the connector uses.
        /// This member is required.
        public var customAuthenticationType: Swift.String?

        public init(
            credentialsMap: [Swift.String: Swift.String]? = nil,
            customAuthenticationType: Swift.String? = nil
        )
        {
            self.credentialsMap = credentialsMap
            self.customAuthenticationType = customAuthenticationType
        }
    }
}

extension AppflowClientTypes.CustomAuthCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomAuthCredentials(customAuthenticationType: \(Swift.String(describing: customAuthenticationType)), credentialsMap: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The OAuth 2.0 credentials required for OAuth 2.0 authentication.
    public struct OAuth2Credentials: Swift.Sendable {
        /// The access token used to access the connector on your behalf.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        public var clientSecret: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The refresh token used to refresh an expired access token.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.OAuth2Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OAuth2Credentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials that are required when using the custom connector.
    public struct CustomConnectorProfileCredentials: Swift.Sendable {
        /// The API keys required for the authentication of the user.
        public var apiKey: AppflowClientTypes.ApiKeyCredentials?
        /// The authentication type that the custom connector uses for authenticating while creating a connector profile.
        /// This member is required.
        public var authenticationType: AppflowClientTypes.AuthenticationType?
        /// The basic credentials that are required for the authentication of the user.
        public var basic: AppflowClientTypes.BasicAuthCredentials?
        /// If the connector uses the custom authentication mechanism, this holds the required credentials.
        public var custom: AppflowClientTypes.CustomAuthCredentials?
        /// The OAuth 2.0 credentials required for the authentication of the user.
        public var oauth2: AppflowClientTypes.OAuth2Credentials?

        public init(
            apiKey: AppflowClientTypes.ApiKeyCredentials? = nil,
            authenticationType: AppflowClientTypes.AuthenticationType? = nil,
            basic: AppflowClientTypes.BasicAuthCredentials? = nil,
            custom: AppflowClientTypes.CustomAuthCredentials? = nil,
            oauth2: AppflowClientTypes.OAuth2Credentials? = nil
        )
        {
            self.apiKey = apiKey
            self.authenticationType = authenticationType
            self.basic = basic
            self.custom = custom
            self.oauth2 = oauth2
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific credentials required by Datadog.
    public struct DatadogConnectorProfileCredentials: Swift.Sendable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        /// This member is required.
        public var applicationKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            applicationKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogConnectorProfileCredentials(applicationKey: \(Swift.String(describing: applicationKey)), apiKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required by Dynatrace.
    public struct DynatraceConnectorProfileCredentials: Swift.Sendable {
        /// The API tokens used by Dynatrace API to authenticate various API calls.
        /// This member is required.
        public var apiToken: Swift.String?

        public init(
            apiToken: Swift.String? = nil
        )
        {
            self.apiToken = apiToken
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Google Analytics resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific credentials required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Amazon Honeycode resources.
        public var accessToken: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeConnectorProfileCredentials(oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required by Infor Nexus.
    public struct InforNexusConnectorProfileCredentials: Swift.Sendable {
        /// The Access Key portion of the credentials.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The encryption keys used to encrypt data.
        /// This member is required.
        public var datakey: Swift.String?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The identifier for the user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            datakey: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusConnectorProfileCredentials(datakey: \(Swift.String(describing: datakey)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), userId: \(Swift.String(describing: userId)), accessKeyId: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required by Marketo.
    public struct MarketoConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Marketo resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Salesforce Pardot.
    public struct PardotConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Salesforce Pardot resources.
        public var accessToken: Swift.String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public var clientCredentialsArn: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.PardotConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PardotConnectorProfileCredentials(oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientCredentialsArn: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Amazon Redshift.
    public struct RedshiftConnectorProfileCredentials: Swift.Sendable {
        /// The password that corresponds to the user name.
        public var password: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Salesforce.
    public struct SalesforceConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Salesforce resources.
        public var accessToken: Swift.String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public var clientCredentialsArn: Swift.String?
        /// A JSON web token (JWT) that authorizes Amazon AppFlow to access your Salesforce records.
        public var jwtToken: Swift.String?
        /// Specifies the OAuth 2.0 grant type that Amazon AppFlow uses when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records. You can specify one of the following values: AUTHORIZATION_CODE Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records. JWT_BEARER Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records. The CLIENT_CREDENTIALS value is not supported for Salesforce.
        public var oAuth2GrantType: AppflowClientTypes.OAuth2GrantType?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            jwtToken: Swift.String? = nil,
            oAuth2GrantType: AppflowClientTypes.OAuth2GrantType? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.jwtToken = jwtToken
            self.oAuth2GrantType = oAuth2GrantType
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceConnectorProfileCredentials(oAuth2GrantType: \(Swift.String(describing: oAuth2GrantType)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientCredentialsArn: \"CONTENT_REDACTED\", jwtToken: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The OAuth credentials required for OAuth type authentication.
    public struct OAuthCredentials: Swift.Sendable {
        /// The access token used to access protected SAPOData resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The refresh token used to refresh expired access token.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }
}

extension AppflowClientTypes.OAuthCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OAuthCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using SAPOData.
    public struct SAPODataConnectorProfileCredentials: Swift.Sendable {
        /// The SAPOData basic authentication credentials.
        public var basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials?
        /// The SAPOData OAuth type authentication credentials.
        public var oAuthCredentials: AppflowClientTypes.OAuthCredentials?

        public init(
            basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials? = nil,
            oAuthCredentials: AppflowClientTypes.OAuthCredentials? = nil
        )
        {
            self.basicAuthCredentials = basicAuthCredentials
            self.oAuthCredentials = oAuthCredentials
        }
    }
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using ServiceNow.
    public struct ServiceNowConnectorProfileCredentials: Swift.Sendable {
        /// The OAuth 2.0 credentials required to authenticate the user.
        public var oAuth2Credentials: AppflowClientTypes.OAuth2Credentials?
        /// The password that corresponds to the user name.
        public var password: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            oAuth2Credentials: AppflowClientTypes.OAuth2Credentials? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.oAuth2Credentials = oAuth2Credentials
            self.password = password
            self.username = username
        }
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowConnectorProfileCredentials(oAuth2Credentials: \(Swift.String(describing: oAuth2Credentials)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Singular.
    public struct SingularConnectorProfileCredentials: Swift.Sendable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularConnectorProfileCredentials(apiKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Slack.
    public struct SlackConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Slack resources.
        public var accessToken: Swift.String?
        /// The identifier for the client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Snowflake.
    public struct SnowflakeConnectorProfileCredentials: Swift.Sendable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Trend Micro.
    public struct TrendmicroConnectorProfileCredentials: Swift.Sendable {
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var apiSecretKey: Swift.String?

        public init(
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiSecretKey = apiSecretKey
        }
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroConnectorProfileCredentials(apiSecretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Veeva.
    public struct VeevaConnectorProfileCredentials: Swift.Sendable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific profile credentials required when using Zendesk.
    public struct ZendeskConnectorProfileCredentials: Swift.Sendable {
        /// The credentials used to access protected Zendesk resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {

    /// The connector-specific credentials required by a connector.
    public struct ConnectorProfileCredentials: Swift.Sendable {
        /// The connector-specific credentials required when using Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials?
        /// The connector-specific profile credentials that are required when using the custom connector.
        public var customConnector: AppflowClientTypes.CustomConnectorProfileCredentials?
        /// The connector-specific credentials required when using Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileCredentials?
        /// The connector-specific credentials required when using Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials?
        /// The connector-specific credentials required when using Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials?
        /// The connector-specific credentials required when using Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials?
        /// The connector-specific profile credentials required when using SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataConnectorProfileCredentials?
        /// The connector-specific credentials required when using ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials?
        /// The connector-specific credentials required when using Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileCredentials?
        /// The connector-specific credentials required when using Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileCredentials?
        /// The connector-specific credentials required when using Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials?
        /// The connector-specific credentials required when using Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileCredentials?
        /// The connector-specific credentials required when using Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials? = nil,
            customConnector: AppflowClientTypes.CustomConnectorProfileCredentials? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileCredentials? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileCredentials? = nil,
            pardot: AppflowClientTypes.PardotConnectorProfileCredentials? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorProfileCredentials? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileCredentials? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileCredentials? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileCredentials? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    /// Defines the connector-specific configuration and credentials for the connector profile.
    public struct ConnectorProfileConfig: Swift.Sendable {
        /// The connector-specific credentials required by each connector.
        public var connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials?
        /// The connector-specific properties of the profile configuration.
        /// This member is required.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?

        public init(
            connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil
        )
        {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }
    }
}

/// An error occurred when retrieving data from the connector endpoint.
public struct ConnectorServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorServerException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request would cause a service quota (such as the number of flows) to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateConnectorProfileInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your CreateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateConnectorProfile. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// Indicates the connection mode and specifies whether it is public or private. Private flows use Amazon Web Services PrivateLink to route data over Amazon Web Services infrastructure without exposing it to the public internet.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// Defines the connector-specific configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    /// This member is required.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        kmsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionMode = connectionMode
        self.connectorLabel = connectorLabel
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.kmsArn = kmsArn
    }
}

public struct CreateConnectorProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init(
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

extension AppflowClientTypes {

    /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
    public struct ErrorHandlingConfig: Swift.Sendable {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?
        /// Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        public var failOnFirstDestinationError: Swift.Bool

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            failOnFirstDestinationError: Swift.Bool = false
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when the custom connector is being used as a destination.
    public struct CustomConnectorDestinationProperties: Swift.Sendable {
        /// The custom properties that are specific to the connector when it's used as a destination in the flow.
        public var customProperties: [Swift.String: Swift.String]?
        /// The entity specified in the custom connector as a destination in the flow.
        /// This member is required.
        public var entityName: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        public var idFieldNames: [Swift.String]?
        /// Specifies the type of write operation to be performed in the custom connector when it's used as destination.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            customProperties: [Swift.String: Swift.String]? = nil,
            entityName: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.customProperties = customProperties
            self.entityName = entityName
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.writeOperationType = writeOperationType
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon Connect Customer Profiles is used as a destination.
    public struct CustomerProfilesDestinationProperties: Swift.Sendable {
        /// The unique name of the Amazon Connect Customer Profiles domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The object specified in the Amazon Connect Customer Profiles flow destination.
        public var objectTypeName: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            objectTypeName: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon EventBridge is being used as a destination.
    public struct EventBridgeDestinationProperties: Swift.Sendable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon EventBridge flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon Honeycode is used as a destination.
    public struct HoneycodeDestinationProperties: Swift.Sendable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon Honeycode flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon Lookout for Metrics is used as a destination.
    public struct LookoutMetricsDestinationProperties: Swift.Sendable {

        public init() { }
    }
}

extension AppflowClientTypes {

    /// The properties that Amazon AppFlow applies when you use Marketo as a flow destination.
    public struct MarketoDestinationProperties: Swift.Sendable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Marketo flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon Redshift is being used as a destination.
    public struct RedshiftDestinationProperties: Swift.Sendable {
        /// The object key for the bucket in which Amazon AppFlow places the destination files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Amazon Redshift flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    public enum FileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .csv,
                .json,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum PathPrefix: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executionId
        case schemaVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [PathPrefix] {
            return [
                .executionId,
                .schemaVersion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executionId: return "EXECUTION_ID"
            case .schemaVersion: return "SCHEMA_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum PrefixFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixFormat] {
            return [
                .day,
                .hour,
                .minute,
                .month,
                .year
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum PrefixType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case filename
        case path
        case pathAndFilename
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixType] {
            return [
                .filename,
                .path,
                .pathAndFilename
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .filename: return "FILENAME"
            case .path: return "PATH"
            case .pathAndFilename: return "PATH_AND_FILENAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Specifies elements that Amazon AppFlow includes in the file and folder names in the flow destination.
    public struct PrefixConfig: Swift.Sendable {
        /// Specifies whether the destination file path includes either or both of the following elements: EXECUTION_ID The ID that Amazon AppFlow assigns to the flow run. SCHEMA_VERSION The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:
        ///
        /// * Source-to-destination field mappings
        ///
        /// * Field data types
        ///
        /// * Partition keys
        public var pathPrefixHierarchy: [AppflowClientTypes.PathPrefix]?
        /// Determines the level of granularity for the date and time that's included in the prefix.
        public var prefixFormat: AppflowClientTypes.PrefixFormat?
        /// Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        public var prefixType: AppflowClientTypes.PrefixType?

        public init(
            pathPrefixHierarchy: [AppflowClientTypes.PathPrefix]? = nil,
            prefixFormat: AppflowClientTypes.PrefixFormat? = nil,
            prefixType: AppflowClientTypes.PrefixType? = nil
        )
        {
            self.pathPrefixHierarchy = pathPrefixHierarchy
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }
    }
}

extension AppflowClientTypes {

    /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
    public struct S3OutputFormatConfig: Swift.Sendable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?
        /// If your file output format is Parquet, use this parameter to set whether Amazon AppFlow preserves the data types in your source data when it writes the output to Amazon S3.
        ///
        /// * true: Amazon AppFlow preserves the data types when it writes to Amazon S3. For example, an integer or 1 in your source data is still an integer in your output.
        ///
        /// * false: Amazon AppFlow converts all of the source data into strings when it writes to Amazon S3. For example, an integer of 1 in your source data becomes the string "1" in the output.
        public var preserveSourceDataTyping: Swift.Bool?

        public init(
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil,
            preserveSourceDataTyping: Swift.Bool? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
            self.preserveSourceDataTyping = preserveSourceDataTyping
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon S3 is used as a destination.
    public struct S3DestinationProperties: Swift.Sendable {
        /// The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
        public var s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Salesforce is being used as a destination.
    public struct SalesforceDestinationProperties: Swift.Sendable {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data to Salesforce. AUTOMATIC The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers to Salesforce. If your flow transfers fewer than 1,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900 records, and it might use Bulk API 2.0 on the next day to transfer 1,100 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output. BULKV2 Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields. REST_SYNC Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail with a timed out error.
        public var dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Salesforce flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// This specifies the type of write operation to be performed in Salesforce. When the value is UPSERT, then idFieldNames is required.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.dataTransferApi = dataTransferApi
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }
}

extension AppflowClientTypes {

    /// Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. For example, this setting would determine where to write the response from the destination connector upon a successful insert operation.
    public struct SuccessResponseHandlingConfig: Swift.Sendable {
        /// The name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// The Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when using SAPOData as a flow destination
    public struct SAPODataDestinationProperties: Swift.Sendable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// A list of field names that can be used as an ID field when performing a write operation.
        public var idFieldNames: [Swift.String]?
        /// The object path specified in the SAPOData flow destination.
        /// This member is required.
        public var objectPath: Swift.String?
        /// Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. For example, this setting would determine where to write the response from a destination connector upon a successful insert operation.
        public var successResponseHandlingConfig: AppflowClientTypes.SuccessResponseHandlingConfig?
        /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            objectPath: Swift.String? = nil,
            successResponseHandlingConfig: AppflowClientTypes.SuccessResponseHandlingConfig? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.objectPath = objectPath
            self.successResponseHandlingConfig = successResponseHandlingConfig
            self.writeOperationType = writeOperationType
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Snowflake is being used as a destination.
    public struct SnowflakeDestinationProperties: Swift.Sendable {
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Snowflake flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The configuration that determines how Amazon AppFlow formats the flow output data when Upsolver is used as the destination.
    public struct UpsolverS3OutputFormatConfig: Swift.Sendable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Specifies elements that Amazon AppFlow includes in the file and folder names in the flow destination.
        /// This member is required.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?

        public init(
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Upsolver is used as a destination.
    public struct UpsolverDestinationProperties: Swift.Sendable {
        /// The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        /// This member is required.
        public var s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Zendesk is used as a destination.
    public struct ZendeskDestinationProperties: Swift.Sendable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// A list of field names that can be used as an ID field when performing a write operation.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Zendesk flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }
}

extension AppflowClientTypes {

    /// This stores the information that is required to query a particular connector.
    public struct DestinationConnectorProperties: Swift.Sendable {
        /// The properties that are required to query the custom Connector.
        public var customConnector: AppflowClientTypes.CustomConnectorDestinationProperties?
        /// The properties required to query Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties?
        /// The properties required to query Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeDestinationProperties?
        /// The properties required to query Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeDestinationProperties?
        /// The properties required to query Amazon Lookout for Metrics.
        public var lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties?
        /// The properties required to query Marketo.
        public var marketo: AppflowClientTypes.MarketoDestinationProperties?
        /// The properties required to query Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftDestinationProperties?
        /// The properties required to query Amazon S3.
        public var s3: AppflowClientTypes.S3DestinationProperties?
        /// The properties required to query Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceDestinationProperties?
        /// The properties required to query SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataDestinationProperties?
        /// The properties required to query Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeDestinationProperties?
        /// The properties required to query Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverDestinationProperties?
        /// The properties required to query Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskDestinationProperties?

        public init(
            customConnector: AppflowClientTypes.CustomConnectorDestinationProperties? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties? = nil,
            eventBridge: AppflowClientTypes.EventBridgeDestinationProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeDestinationProperties? = nil,
            lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties? = nil,
            marketo: AppflowClientTypes.MarketoDestinationProperties? = nil,
            redshift: AppflowClientTypes.RedshiftDestinationProperties? = nil,
            s3: AppflowClientTypes.S3DestinationProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceDestinationProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataDestinationProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeDestinationProperties? = nil,
            upsolver: AppflowClientTypes.UpsolverDestinationProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskDestinationProperties? = nil
        )
        {
            self.customConnector = customConnector
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the configuration of destination connectors present in the flow.
    public struct DestinationFlowConfig: Swift.Sendable {
        /// The API version that the destination connector uses.
        public var apiVersion: Swift.String?
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// This stores the information that is required to query a particular connector.
        /// This member is required.
        public var destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties?

        public init(
            apiVersion: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties? = nil
        )
        {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data with the Glue Data Catalog. When Amazon AppFlow catalogs your data, it stores metadata in Data Catalog tables. This metadata represents the data that's transferred by the flow that you configure with these settings. You can configure a flow with these settings only when the flow destination is Amazon S3.
    public struct GlueDataCatalogConfig: Swift.Sendable {
        /// The name of the Data Catalog database that stores the metadata tables that Amazon AppFlow creates in your Amazon Web Services account. These tables contain metadata for the data that's transferred by the flow that you configure with this parameter. When you configure a new flow with this parameter, you must specify an existing database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon AppFlow the permissions it needs to create Data Catalog tables, databases, and partitions. For an example IAM policy that has the required permissions, see [Identity-based policy examples for Amazon AppFlow](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_id-based-policy-examples.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// A naming prefix for each Data Catalog table that Amazon AppFlow creates for the flow that you configure with this setting. Amazon AppFlow adds the prefix to the beginning of the each table name.
        /// This member is required.
        public var tablePrefix: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            tablePrefix: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.roleArn = roleArn
            self.tablePrefix = tablePrefix
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data. When Amazon AppFlow catalogs your data, it stores metadata in a data catalog.
    public struct MetadataCatalogConfig: Swift.Sendable {
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data with the Glue Data Catalog.
        public var glueDataCatalog: AppflowClientTypes.GlueDataCatalogConfig?

        public init(
            glueDataCatalog: AppflowClientTypes.GlueDataCatalogConfig? = nil
        )
        {
            self.glueDataCatalog = glueDataCatalog
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Sendable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init(
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when the custom connector is being used as a source.
    public struct CustomConnectorSourceProperties: Swift.Sendable {
        /// Custom properties that are required to use the custom connector as a source.
        public var customProperties: [Swift.String: Swift.String]?
        /// The API of the connector application that Amazon AppFlow uses to transfer your data.
        public var dataTransferApi: AppflowClientTypes.DataTransferApi?
        /// The entity specified in the custom connector as a source in the flow.
        /// This member is required.
        public var entityName: Swift.String?

        public init(
            customProperties: [Swift.String: Swift.String]? = nil,
            dataTransferApi: AppflowClientTypes.DataTransferApi? = nil,
            entityName: Swift.String? = nil
        )
        {
            self.customProperties = customProperties
            self.dataTransferApi = dataTransferApi
            self.entityName = entityName
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Datadog is being used as a source.
    public struct DatadogSourceProperties: Swift.Sendable {
        /// The object specified in the Datadog flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Dynatrace is being used as a source.
    public struct DynatraceSourceProperties: Swift.Sendable {
        /// The object specified in the Dynatrace flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Google Analytics is being used as a source.
    public struct GoogleAnalyticsSourceProperties: Swift.Sendable {
        /// The object specified in the Google Analytics flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Infor Nexus is being used as a source.
    public struct InforNexusSourceProperties: Swift.Sendable {
        /// The object specified in the Infor Nexus flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Sendable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Salesforce Pardot is being used as a source.
    public struct PardotSourceProperties: Swift.Sendable {
        /// The object specified in the Salesforce Pardot flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    public enum S3InputFileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFileType] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
    public struct S3InputFormatConfig: Swift.Sendable {
        /// The file type that Amazon AppFlow gets from your Amazon S3 bucket.
        public var s3InputFileType: AppflowClientTypes.S3InputFileType?

        public init(
            s3InputFileType: AppflowClientTypes.S3InputFileType? = nil
        )
        {
            self.s3InputFileType = s3InputFileType
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Sendable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?
        /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
        public var s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3InputFormatConfig = s3InputFormatConfig
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Sendable {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data from Salesforce. AUTOMATIC The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers from Salesforce. If your flow transfers fewer than 1,000,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900,000 records, and it might use Bulk API 2.0 on the next day to transfer 1,100,000 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output. BULKV2 Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields. REST_SYNC Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail wituh a timed out error.
        public var dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi?
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi? = nil,
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.dataTransferApi = dataTransferApi
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// Sets the page size for each concurrent process that transfers OData records from your SAP instance. A concurrent process is query that retrieves a batch of records as part of a flow run. Amazon AppFlow can run multiple concurrent processes in parallel to transfer data faster.
    public struct SAPODataPaginationConfig: Swift.Sendable {
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application. For transfers of OData records, the maximum page size is 3,000. For transfers of data that comes from an ODP provider, the maximum page size is 10,000.
        /// This member is required.
        public var maxPageSize: Swift.Int?

        public init(
            maxPageSize: Swift.Int? = nil
        )
        {
            self.maxPageSize = maxPageSize
        }
    }
}

extension AppflowClientTypes {

    /// Sets the number of concurrent processes that transfer OData records from your SAP instance. A concurrent process is query that retrieves a batch of records as part of a flow run. Amazon AppFlow can run multiple concurrent processes in parallel to transfer data faster.
    public struct SAPODataParallelismConfig: Swift.Sendable {
        /// The maximum number of processes that Amazon AppFlow runs at the same time when it retrieves your data from your SAP application.
        /// This member is required.
        public var maxParallelism: Swift.Int?

        public init(
            maxParallelism: Swift.Int? = nil
        )
        {
            self.maxParallelism = maxParallelism
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when using SAPOData as a flow source.
    public struct SAPODataSourceProperties: Swift.Sendable {
        /// The object path specified in the SAPOData flow source.
        public var objectPath: Swift.String?
        /// Sets the page size for each concurrent process that transfers OData records from your SAP instance.
        public var paginationConfig: AppflowClientTypes.SAPODataPaginationConfig?
        /// Sets the number of concurrent processes that transfers OData records from your SAP instance.
        public var parallelismConfig: AppflowClientTypes.SAPODataParallelismConfig?

        public init(
            objectPath: Swift.String? = nil,
            paginationConfig: AppflowClientTypes.SAPODataPaginationConfig? = nil,
            parallelismConfig: AppflowClientTypes.SAPODataParallelismConfig? = nil
        )
        {
            self.objectPath = objectPath
            self.paginationConfig = paginationConfig
            self.parallelismConfig = parallelismConfig
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Sendable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Singular is being used as a source.
    public struct SingularSourceProperties: Swift.Sendable {
        /// The object specified in the Singular flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when Slack is being used as a source.
    public struct SlackSourceProperties: Swift.Sendable {
        /// The object specified in the Slack flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when using Trend Micro as a flow source.
    public struct TrendmicroSourceProperties: Swift.Sendable {
        /// The object specified in the Trend Micro flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when using Veeva as a flow source.
    public struct VeevaSourceProperties: Swift.Sendable {
        /// The document type specified in the Veeva document extract flow.
        public var documentType: Swift.String?
        /// Boolean value to include All Versions of files in Veeva document extract flow.
        public var includeAllVersions: Swift.Bool
        /// Boolean value to include file renditions in Veeva document extract flow.
        public var includeRenditions: Swift.Bool
        /// Boolean value to include source files in Veeva document extract flow.
        public var includeSourceFiles: Swift.Bool
        /// The object specified in the Veeva flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            documentType: Swift.String? = nil,
            includeAllVersions: Swift.Bool = false,
            includeRenditions: Swift.Bool = false,
            includeSourceFiles: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.documentType = documentType
            self.includeAllVersions = includeAllVersions
            self.includeRenditions = includeRenditions
            self.includeSourceFiles = includeSourceFiles
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Sendable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the information that is required to query a particular connector.
    public struct SourceConnectorProperties: Swift.Sendable {
        /// Specifies the information that is required for querying Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeSourceProperties?
        /// The properties that are applied when the custom connector is being used as a source.
        public var customConnector: AppflowClientTypes.CustomConnectorSourceProperties?
        /// Specifies the information that is required for querying Datadog.
        public var datadog: AppflowClientTypes.DatadogSourceProperties?
        /// Specifies the information that is required for querying Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceSourceProperties?
        /// Specifies the information that is required for querying Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties?
        /// Specifies the information that is required for querying Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusSourceProperties?
        /// Specifies the information that is required for querying Marketo.
        public var marketo: AppflowClientTypes.MarketoSourceProperties?
        /// Specifies the information that is required for querying Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotSourceProperties?
        /// Specifies the information that is required for querying Amazon S3.
        public var s3: AppflowClientTypes.S3SourceProperties?
        /// Specifies the information that is required for querying Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceSourceProperties?
        /// The properties that are applied when using SAPOData as a flow source.
        public var sapoData: AppflowClientTypes.SAPODataSourceProperties?
        /// Specifies the information that is required for querying ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowSourceProperties?
        /// Specifies the information that is required for querying Singular.
        public var singular: AppflowClientTypes.SingularSourceProperties?
        /// Specifies the information that is required for querying Slack.
        public var slack: AppflowClientTypes.SlackSourceProperties?
        /// Specifies the information that is required for querying Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroSourceProperties?
        /// Specifies the information that is required for querying Veeva.
        public var veeva: AppflowClientTypes.VeevaSourceProperties?
        /// Specifies the information that is required for querying Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskSourceProperties?

        public init(
            amplitude: AppflowClientTypes.AmplitudeSourceProperties? = nil,
            customConnector: AppflowClientTypes.CustomConnectorSourceProperties? = nil,
            datadog: AppflowClientTypes.DatadogSourceProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceSourceProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusSourceProperties? = nil,
            marketo: AppflowClientTypes.MarketoSourceProperties? = nil,
            pardot: AppflowClientTypes.PardotSourceProperties? = nil,
            s3: AppflowClientTypes.S3SourceProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceSourceProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataSourceProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowSourceProperties? = nil,
            singular: AppflowClientTypes.SingularSourceProperties? = nil,
            slack: AppflowClientTypes.SlackSourceProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroSourceProperties? = nil,
            veeva: AppflowClientTypes.VeevaSourceProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }
}

extension AppflowClientTypes {

    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Sendable {
        /// The API version of the connector when it's used as a source in the flow.
        public var apiVersion: Swift.String?
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties?

        public init(
            apiVersion: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }
}

extension AppflowClientTypes {

    public enum OperatorPropertiesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case excludeSourceFieldsList
        case includeNewFields
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case orderedPartitionKeysList
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .excludeSourceFieldsList,
                .includeNewFields,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .orderedPartitionKeysList,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .excludeSourceFieldsList: return "EXCLUDE_SOURCE_FIELDS_LIST"
            case .includeNewFields: return "INCLUDE_NEW_FIELDS"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .orderedPartitionKeysList: return "ORDERED_PARTITION_KEYS_LIST"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    public enum TaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mapAll
        case mask
        case merge
        case partition
        case passthrough
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mapAll,
                .mask,
                .merge,
                .partition,
                .passthrough,
                .truncate,
                .validate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mapAll: return "Map_all"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .partition: return "Partition"
            case .passthrough: return "Passthrough"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Sendable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: AppflowClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The execution service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String: Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: AppflowClientTypes.TaskType?

        public init(
            connectorOperator: AppflowClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String: Swift.String]? = nil,
            taskType: AppflowClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }
}

extension AppflowClientTypes {

    public enum DataPullMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
    public struct ScheduledTriggerProperties: Swift.Sendable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: AppflowClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: Foundation.Date?
        /// Defines how many times a scheduled flow fails consecutively before Amazon AppFlow deactivates it.
        public var flowErrorDeactivationThreshold: Swift.Int?
        /// The time at which the scheduled flow ends. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-27T13:00:00-07:00.
        public var scheduleEndTime: Foundation.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int?
        /// The time at which the scheduled flow starts. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-26T13:00:00-07:00.
        public var scheduleStartTime: Foundation.Date?
        /// Specifies the time zone used when referring to the dates and times of a scheduled flow, such as America/New_York. This time zone is only a descriptive label. It doesn't affect how Amazon AppFlow interprets the timestamps that you specify to schedule the flow. If you want to schedule a flow by using times in a particular time zone, indicate the time zone as a UTC offset in your timestamps. For example, the UTC offsets for the America/New_York timezone are -04:00 EDT and -05:00 EST.
        public var timezone: Swift.String?

        public init(
            dataPullMode: AppflowClientTypes.DataPullMode? = nil,
            firstExecutionFrom: Foundation.Date? = nil,
            flowErrorDeactivationThreshold: Swift.Int? = nil,
            scheduleEndTime: Foundation.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = 0,
            scheduleStartTime: Foundation.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.flowErrorDeactivationThreshold = flowErrorDeactivationThreshold
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user.
        public var scheduled: AppflowClientTypes.ScheduledTriggerProperties?

        public init(
            scheduled: AppflowClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }
}

extension AppflowClientTypes {

    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Sendable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: AppflowClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init(
            triggerProperties: AppflowClientTypes.TriggerProperties? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }
}

public struct CreateFlowInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your CreateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description of the flow you want to create.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow places data in the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String: Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.metadataCatalogConfig = metadataCatalogConfig
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

extension AppflowClientTypes {

    public enum FlowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case deprecated
        case draft
        case errored
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowStatus] {
            return [
                .active,
                .deleted,
                .deprecated,
                .draft,
                .errored,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case .deprecated: return "Deprecated"
            case .draft: return "Draft"
            case .errored: return "Errored"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFlowOutput: Swift.Sendable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

public struct DeleteConnectorProfileInput: Swift.Sendable {
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    public var forceDelete: Swift.Bool?

    public init(
        connectorProfileName: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.connectorProfileName = connectorProfileName
        self.forceDelete = forceDelete
    }
}

public struct DeleteConnectorProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFlowInput: Swift.Sendable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    public var forceDelete: Swift.Bool?

    public init(
        flowName: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.flowName = flowName
        self.forceDelete = forceDelete
    }
}

public struct DeleteFlowOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeConnectorInput: Swift.Sendable {
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// The connector type, such as CUSTOMCONNECTOR, Saleforce, Marketo. Please choose CUSTOMCONNECTOR for Lambda based custom connectors.
    /// This member is required.
    public var connectorType: AppflowClientTypes.ConnectorType?

    public init(
        connectorLabel: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.connectorLabel = connectorLabel
        self.connectorType = connectorType
    }
}

public struct DescribeConnectorOutput: Swift.Sendable {
    /// Configuration info of all the connectors that the user requested.
    public var connectorConfiguration: AppflowClientTypes.ConnectorConfiguration?

    public init(
        connectorConfiguration: AppflowClientTypes.ConnectorConfiguration? = nil
    )
    {
        self.connectorConfiguration = connectorConfiguration
    }
}

public struct DescribeConnectorEntityInput: Swift.Sendable {
    /// The version of the API that's used by the connector.
    public var apiVersion: Swift.String?
    /// The entity name for that connector.
    /// This member is required.
    public var connectorEntityName: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileName: Swift.String?
    /// The type of connector application, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?

    public init(
        apiVersion: Swift.String? = nil,
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
    }
}

public struct DescribeConnectorEntityOutput: Swift.Sendable {
    /// Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on.
    /// This member is required.
    public var connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?

    public init(
        connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]? = nil
    )
    {
        self.connectorEntityFields = connectorEntityFields
    }
}

public struct DescribeConnectorProfilesInput: Swift.Sendable {
    /// The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileNames: [Swift.String]?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorLabel: Swift.String? = nil,
        connectorProfileNames: [Swift.String]? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorLabel = connectorLabel
        self.connectorProfileNames = connectorProfileNames
        self.connectorType = connectorType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeConnectorProfilesOutput: Swift.Sendable {
    /// Returns information about the connector profiles associated with the flow.
    public var connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
    public var nextToken: Swift.String?

    public init(
        connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileDetails = connectorProfileDetails
        self.nextToken = nextToken
    }
}

public struct DescribeConnectorsInput: Swift.Sendable {
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorTypes: [AppflowClientTypes.ConnectorType]?
    /// The maximum number of items that should be returned in the result set. The default is 20.
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorTypes: [AppflowClientTypes.ConnectorType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorTypes = connectorTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeConnectorsOutput: Swift.Sendable {
    /// The configuration that is applied to the connectors used in the flow.
    public var connectorConfigurations: [Swift.String: AppflowClientTypes.ConnectorConfiguration]?
    /// Information about the connectors supported in Amazon AppFlow.
    public var connectors: [AppflowClientTypes.ConnectorDetail]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorConfigurations: [Swift.String: AppflowClientTypes.ConnectorConfiguration]? = nil,
        connectors: [AppflowClientTypes.ConnectorDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorConfigurations = connectorConfigurations
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

public struct DescribeFlowInput: Swift.Sendable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

extension AppflowClientTypes {

    public enum ExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case cancelstarted
        case error
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .canceled,
                .cancelstarted,
                .error,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .cancelstarted: return "CancelStarted"
            case .error: return "Error"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppflowClientTypes {

    /// Describes the details of the flow run, including the timestamp, status, and message.
    public struct ExecutionDetails: Swift.Sendable {
        /// Describes the details of the most recent flow run.
        public var mostRecentExecutionMessage: Swift.String?
        /// Specifies the status of the most recent flow run.
        public var mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent flow run.
        public var mostRecentExecutionTime: Foundation.Date?

        public init(
            mostRecentExecutionMessage: Swift.String? = nil,
            mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            mostRecentExecutionTime: Foundation.Date? = nil
        )
        {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }
    }
}

extension AppflowClientTypes {

    /// Describes the status of an attempt from Amazon AppFlow to register a resource. When you run a flow that you've configured to use a metadata catalog, Amazon AppFlow registers a metadata table and data partitions with that catalog. This operation provides the status of that registration attempt. The operation also indicates how many related resources Amazon AppFlow created or updated.
    public struct RegistrationOutput: Swift.Sendable {
        /// Explains the status of the registration attempt from Amazon AppFlow. If the attempt fails, the message explains why.
        public var message: Swift.String?
        /// Indicates the number of resources that Amazon AppFlow created or updated. Possible resources include metadata tables and data partitions.
        public var result: Swift.String?
        /// Indicates the status of the registration attempt from Amazon AppFlow.
        public var status: AppflowClientTypes.ExecutionStatus?

        public init(
            message: Swift.String? = nil,
            result: Swift.String? = nil,
            status: AppflowClientTypes.ExecutionStatus? = nil
        )
        {
            self.message = message
            self.result = result
            self.status = status
        }
    }
}

extension AppflowClientTypes {

    /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
    public struct MetadataCatalogDetail: Swift.Sendable {
        /// The type of metadata catalog that Amazon AppFlow used for the associated flow run. This parameter returns the following value: GLUE The metadata catalog is provided by the Glue Data Catalog. Glue includes the Glue Data Catalog as a component.
        public var catalogType: AppflowClientTypes.CatalogType?
        /// Describes the status of the attempt from Amazon AppFlow to register the data partitions with the metadata catalog. The data partitions organize the flow output into a hierarchical path, such as a folder path in an S3 bucket. Amazon AppFlow creates the partitions (if they don't already exist) based on your flow configuration.
        public var partitionRegistrationOutput: AppflowClientTypes.RegistrationOutput?
        /// The name of the table that stores the metadata for the associated flow run. The table stores metadata that represents the data that the flow transferred. Amazon AppFlow stores the table in the metadata catalog.
        public var tableName: Swift.String?
        /// Describes the status of the attempt from Amazon AppFlow to register the metadata table with the metadata catalog. Amazon AppFlow creates or updates this table for the associated flow run.
        public var tableRegistrationOutput: AppflowClientTypes.RegistrationOutput?

        public init(
            catalogType: AppflowClientTypes.CatalogType? = nil,
            partitionRegistrationOutput: AppflowClientTypes.RegistrationOutput? = nil,
            tableName: Swift.String? = nil,
            tableRegistrationOutput: AppflowClientTypes.RegistrationOutput? = nil
        )
        {
            self.catalogType = catalogType
            self.partitionRegistrationOutput = partitionRegistrationOutput
            self.tableName = tableName
            self.tableRegistrationOutput = tableRegistrationOutput
        }
    }
}

public struct DescribeFlowOutput: Swift.Sendable {
    /// Specifies when the flow was created.
    public var createdAt: Foundation.Date?
    /// The ARN of the user who created the flow.
    public var createdBy: Swift.String?
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    public var flowName: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?
    /// Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
    public var flowStatusMessage: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// Describes the details of the most recent flow run.
    public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
    public var lastRunMetadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]?
    /// Specifies when the flow was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// Specifies the user name of the account that performed the most recent update.
    public var lastUpdatedBy: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:
    ///
    /// * Source-to-destination field mappings
    ///
    /// * Field data types
    ///
    /// * Partition keys
    public var schemaVersion: Swift.Int?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String: Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowArn: Swift.String? = nil,
        flowName: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil,
        flowStatusMessage: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
        lastRunMetadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        schemaVersion: Swift.Int? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.flowStatusMessage = flowStatusMessage
        self.kmsArn = kmsArn
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastRunMetadataCatalogDetails = lastRunMetadataCatalogDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.metadataCatalogConfig = metadataCatalogConfig
        self.schemaVersion = schemaVersion
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

public struct DescribeFlowExecutionRecordsInput: Swift.Sendable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        flowName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowName = flowName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppflowClientTypes {

    /// Provides details in the event of a failed flow, including the failure count and the related error messages.
    public struct ErrorInfo: Swift.Sendable {
        /// Specifies the error message that appears if a flow fails.
        public var executionMessage: Swift.String?
        /// Specifies the failure count for the attempted flow.
        public var putFailuresCount: Swift.Int?

        public init(
            executionMessage: Swift.String? = nil,
            putFailuresCount: Swift.Int? = nil
        )
        {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }
    }
}

extension AppflowClientTypes {

    /// Specifies the end result of the flow run.
    public struct ExecutionResult: Swift.Sendable {
        /// The total number of bytes processed by the flow run.
        public var bytesProcessed: Swift.Int?
        /// The total number of bytes written as a result of the flow run.
        public var bytesWritten: Swift.Int?
        /// Provides any error message information related to the flow run.
        public var errorInfo: AppflowClientTypes.ErrorInfo?
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application.
        public var maxPageSize: Swift.Int?
        /// The number of processes that Amazon AppFlow ran at the same time when it retrieved your data.
        public var numParallelProcesses: Swift.Int?
        /// The number of records processed in the flow run.
        public var recordsProcessed: Swift.Int?

        public init(
            bytesProcessed: Swift.Int? = nil,
            bytesWritten: Swift.Int? = nil,
            errorInfo: AppflowClientTypes.ErrorInfo? = nil,
            maxPageSize: Swift.Int? = nil,
            numParallelProcesses: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.maxPageSize = maxPageSize
            self.numParallelProcesses = numParallelProcesses
            self.recordsProcessed = recordsProcessed
        }
    }
}

extension AppflowClientTypes {

    /// Specifies information about the past flow run instances for a given flow.
    public struct ExecutionRecord: Swift.Sendable {
        /// The timestamp that indicates the last new or updated record to be transferred in the flow run.
        public var dataPullEndTime: Foundation.Date?
        /// The timestamp that determines the first new or updated record to be transferred in the flow run.
        public var dataPullStartTime: Foundation.Date?
        /// Specifies the identifier of the given flow run.
        public var executionId: Swift.String?
        /// Describes the result of the given flow run.
        public var executionResult: AppflowClientTypes.ExecutionResult?
        /// Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        public var executionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent update.
        public var lastUpdatedAt: Foundation.Date?
        /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
        public var metadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]?
        /// Specifies the start time of the flow run.
        public var startedAt: Foundation.Date?

        public init(
            dataPullEndTime: Foundation.Date? = nil,
            dataPullStartTime: Foundation.Date? = nil,
            executionId: Swift.String? = nil,
            executionResult: AppflowClientTypes.ExecutionResult? = nil,
            executionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            metadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]? = nil,
            startedAt: Foundation.Date? = nil
        )
        {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.metadataCatalogDetails = metadataCatalogDetails
            self.startedAt = startedAt
        }
    }
}

public struct DescribeFlowExecutionRecordsOutput: Swift.Sendable {
    /// Returns a list of all instances when this flow was run.
    public var flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        flowExecutions: [AppflowClientTypes.ExecutionRecord]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

extension AppflowClientTypes {

    /// The properties of the flow, such as its source, destination, trigger type, and so on.
    public struct FlowDefinition: Swift.Sendable {
        /// Specifies when the flow was created.
        public var createdAt: Foundation.Date?
        /// The ARN of the user who created the flow.
        public var createdBy: Swift.String?
        /// A user-entered description of the flow.
        public var description: Swift.String?
        /// The label of the destination connector in the flow.
        public var destinationConnectorLabel: Swift.String?
        /// Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var destinationConnectorType: AppflowClientTypes.ConnectorType?
        /// The flow's Amazon Resource Name (ARN).
        public var flowArn: Swift.String?
        /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public var flowName: Swift.String?
        /// Indicates the current status of the flow.
        public var flowStatus: AppflowClientTypes.FlowStatus?
        /// Describes the details of the most recent flow run.
        public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
        /// Specifies when the flow was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// Specifies the account user name that most recently updated the flow.
        public var lastUpdatedBy: Swift.String?
        /// The label of the source connector in the flow.
        public var sourceConnectorLabel: Swift.String?
        /// Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var sourceConnectorType: AppflowClientTypes.ConnectorType?
        /// The tags used to organize, track, or control access for your flow.
        public var tags: [Swift.String: Swift.String]?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationConnectorLabel: Swift.String? = nil,
            destinationConnectorType: AppflowClientTypes.ConnectorType? = nil,
            flowArn: Swift.String? = nil,
            flowName: Swift.String? = nil,
            flowStatus: AppflowClientTypes.FlowStatus? = nil,
            lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            sourceConnectorLabel: Swift.String? = nil,
            sourceConnectorType: AppflowClientTypes.ConnectorType? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorLabel = destinationConnectorLabel
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorLabel = sourceConnectorLabel
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }
    }
}

public struct ListConnectorEntitiesInput: Swift.Sendable {
    /// The version of the API that's used by the connector.
    public var apiVersion: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account, and is used to query the downstream connector.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    public var entitiesPath: Swift.String?
    /// The maximum number of items that the operation returns in the response.
    public var maxResults: Swift.Int?
    /// A token that was provided by your prior ListConnectorEntities operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.
    public var nextToken: Swift.String?

    public init(
        apiVersion: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorEntitiesOutput: Swift.Sendable {
    /// The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
    /// This member is required.
    public var connectorEntityMap: [Swift.String: [AppflowClientTypes.ConnectorEntity]]?
    /// A token that you specify in your next ListConnectorEntities operation to get the next page of results in paginated response. The ListConnectorEntities operation provides this token if the response is too big for the page size.
    public var nextToken: Swift.String?

    public init(
        connectorEntityMap: [Swift.String: [AppflowClientTypes.ConnectorEntity]]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorEntityMap = connectorEntityMap
        self.nextToken = nextToken
    }
}

public struct ListConnectorsInput: Swift.Sendable {
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorsOutput: Swift.Sendable {
    /// Contains information about the connectors supported by Amazon AppFlow.
    public var connectors: [AppflowClientTypes.ConnectorDetail]?
    /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
    public var nextToken: Swift.String?

    public init(
        connectors: [AppflowClientTypes.ConnectorDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

public struct ListFlowsInput: Swift.Sendable {
    /// Specifies the maximum number of items that should be returned in the result set.
    public var maxResults: Swift.Int?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFlowsOutput: Swift.Sendable {
    /// The list of flows associated with your account.
    public var flows: [AppflowClientTypes.FlowDefinition]?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init(
        flows: [AppflowClientTypes.FlowDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the specified flow.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct RegisterConnectorInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your RegisterConnector request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to RegisterConnector. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account.
    public var connectorLabel: Swift.String?
    /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
    public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
    public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
    /// A description about the connector that's being registered.
    public var description: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
        connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
        description: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectorLabel = connectorLabel
        self.connectorProvisioningConfig = connectorProvisioningConfig
        self.connectorProvisioningType = connectorProvisioningType
        self.description = description
    }
}

public struct RegisterConnectorOutput: Swift.Sendable {
    /// The ARN of the connector being registered.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

public struct ResetConnectorMetadataCacheInput: Swift.Sendable {
    /// The API version that you specified in the connector profile that you’re resetting cached metadata for. You must use this parameter only if the connector supports multiple API versions or if the connector type is CustomConnector. To look up how many versions a connector supports, use the DescribeConnectors action. In the response, find the value that Amazon AppFlow returns for the connectorVersion parameter. To look up the connector type, use the DescribeConnectorProfiles action. In the response, find the value that Amazon AppFlow returns for the connectorType parameter. To look up the API version that you specified in a connector profile, use the DescribeConnectorProfiles action.
    public var apiVersion: Swift.String?
    /// Use this parameter if you want to reset cached metadata about the details for an individual entity. If you don't include this parameter in your request, Amazon AppFlow only resets cached metadata about entity names, not entity details.
    public var connectorEntityName: Swift.String?
    /// The name of the connector profile that you want to reset cached metadata for. You can omit this parameter if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you must include this parameter in your request.
    public var connectorProfileName: Swift.String?
    /// The type of connector to reset cached metadata for. You must include this parameter in your request if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you can omit this parameter from your request.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// Use this parameter only if you’re resetting the cached metadata about a nested entity. Only some connectors support nested entities. A nested entity is one that has another entity as a parent. To use this parameter, specify the name of the parent entity. To look up the parent-child relationship of entities, you can send a ListConnectorEntities request that omits the entitiesPath parameter. Amazon AppFlow will return a list of top-level entities. For each one, it indicates whether the entity has nested entities. Then, in a subsequent ListConnectorEntities request, you can specify a parent entity name for the entitiesPath parameter. Amazon AppFlow will return a list of the child entities for that parent.
    public var entitiesPath: Swift.String?

    public init(
        apiVersion: Swift.String? = nil,
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
    }
}

public struct ResetConnectorMetadataCacheOutput: Swift.Sendable {

    public init() { }
}

public struct StartFlowInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your StartFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs for flows that run on a schedule or based on an event. However, the error doesn't occur for flows that run on demand. You set the conditions that initiate your flow for the triggerConfig parameter. If you use a different value for clientToken, Amazon AppFlow considers it a new call to StartFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        flowName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.flowName = flowName
    }
}

public struct StartFlowOutput: Swift.Sendable {
    /// Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
    public var executionId: Swift.String?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        executionId: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.executionId = executionId
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

/// The requested operation is not supported for the current flow.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StopFlowInput: Swift.Sendable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

public struct StopFlowOutput: Swift.Sendable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for your flow.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UnregisterConnectorInput: Swift.Sendable {
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account.
    /// This member is required.
    public var connectorLabel: Swift.String?
    /// Indicates whether Amazon AppFlow should unregister the connector, even if it is currently in use in one or more connector profiles. The default value is false.
    public var forceDelete: Swift.Bool?

    public init(
        connectorLabel: Swift.String? = nil,
        forceDelete: Swift.Bool? = false
    )
    {
        self.connectorLabel = connectorLabel
        self.forceDelete = forceDelete
    }
}

public struct UnregisterConnectorOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the tag that you want to remove from your flow.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectorProfileInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorProfile. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// Indicates the connection mode and if it is public or private.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// Defines the connector-specific profile configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile and is unique for each ConnectorProfile in the Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
    }
}

public struct UpdateConnectorProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init(
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

public struct UpdateConnectorRegistrationInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorRegistration request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorRegistration. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the connector. The name is unique for each connector registration in your AWS account.
    /// This member is required.
    public var connectorLabel: Swift.String?
    /// Contains information about the configuration of the connector being registered.
    public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    /// A description about the update that you're applying to the connector.
    public var description: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
        description: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectorLabel = connectorLabel
        self.connectorProvisioningConfig = connectorProvisioningConfig
        self.description = description
    }
}

public struct UpdateConnectorRegistrationOutput: Swift.Sendable {
    /// The ARN of the connector being updated.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

public struct UpdateFlowInput: Swift.Sendable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// Contains information about the configuration of the source connector used in the flow.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.metadataCatalogConfig = metadataCatalogConfig
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

public struct UpdateFlowOutput: Swift.Sendable {
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowStatus = flowStatus
    }
}

extension CancelFlowExecutionsInput {

    static func urlPathProvider(_ value: CancelFlowExecutionsInput) -> Swift.String? {
        return "/cancel-flow-executions"
    }
}

extension CreateConnectorProfileInput {

    static func urlPathProvider(_ value: CreateConnectorProfileInput) -> Swift.String? {
        return "/create-connector-profile"
    }
}

extension CreateFlowInput {

    static func urlPathProvider(_ value: CreateFlowInput) -> Swift.String? {
        return "/create-flow"
    }
}

extension DeleteConnectorProfileInput {

    static func urlPathProvider(_ value: DeleteConnectorProfileInput) -> Swift.String? {
        return "/delete-connector-profile"
    }
}

extension DeleteFlowInput {

    static func urlPathProvider(_ value: DeleteFlowInput) -> Swift.String? {
        return "/delete-flow"
    }
}

extension DescribeConnectorInput {

    static func urlPathProvider(_ value: DescribeConnectorInput) -> Swift.String? {
        return "/describe-connector"
    }
}

extension DescribeConnectorEntityInput {

    static func urlPathProvider(_ value: DescribeConnectorEntityInput) -> Swift.String? {
        return "/describe-connector-entity"
    }
}

extension DescribeConnectorProfilesInput {

    static func urlPathProvider(_ value: DescribeConnectorProfilesInput) -> Swift.String? {
        return "/describe-connector-profiles"
    }
}

extension DescribeConnectorsInput {

    static func urlPathProvider(_ value: DescribeConnectorsInput) -> Swift.String? {
        return "/describe-connectors"
    }
}

extension DescribeFlowInput {

    static func urlPathProvider(_ value: DescribeFlowInput) -> Swift.String? {
        return "/describe-flow"
    }
}

extension DescribeFlowExecutionRecordsInput {

    static func urlPathProvider(_ value: DescribeFlowExecutionRecordsInput) -> Swift.String? {
        return "/describe-flow-execution-records"
    }
}

extension ListConnectorEntitiesInput {

    static func urlPathProvider(_ value: ListConnectorEntitiesInput) -> Swift.String? {
        return "/list-connector-entities"
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/list-connectors"
    }
}

extension ListFlowsInput {

    static func urlPathProvider(_ value: ListFlowsInput) -> Swift.String? {
        return "/list-flows"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterConnectorInput {

    static func urlPathProvider(_ value: RegisterConnectorInput) -> Swift.String? {
        return "/register-connector"
    }
}

extension ResetConnectorMetadataCacheInput {

    static func urlPathProvider(_ value: ResetConnectorMetadataCacheInput) -> Swift.String? {
        return "/reset-connector-metadata-cache"
    }
}

extension StartFlowInput {

    static func urlPathProvider(_ value: StartFlowInput) -> Swift.String? {
        return "/start-flow"
    }
}

extension StopFlowInput {

    static func urlPathProvider(_ value: StopFlowInput) -> Swift.String? {
        return "/stop-flow"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UnregisterConnectorInput {

    static func urlPathProvider(_ value: UnregisterConnectorInput) -> Swift.String? {
        return "/unregister-connector"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateConnectorProfileInput {

    static func urlPathProvider(_ value: UpdateConnectorProfileInput) -> Swift.String? {
        return "/update-connector-profile"
    }
}

extension UpdateConnectorRegistrationInput {

    static func urlPathProvider(_ value: UpdateConnectorRegistrationInput) -> Swift.String? {
        return "/update-connector-registration"
    }
}

extension UpdateFlowInput {

    static func urlPathProvider(_ value: UpdateFlowInput) -> Swift.String? {
        return "/update-flow"
    }
}

extension CancelFlowExecutionsInput {

    static func write(value: CancelFlowExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionIds"].writeList(value.executionIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["flowName"].write(value.flowName)
    }
}

extension CreateConnectorProfileInput {

    static func write(value: CreateConnectorProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectionMode"].write(value.connectionMode)
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["connectorProfileConfig"].write(value.connectorProfileConfig, with: AppflowClientTypes.ConnectorProfileConfig.write(value:to:))
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
        try writer["kmsArn"].write(value.kmsArn)
    }
}

extension CreateFlowInput {

    static func write(value: CreateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["destinationFlowConfigList"].writeList(value.destinationFlowConfigList, memberWritingClosure: AppflowClientTypes.DestinationFlowConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["flowName"].write(value.flowName)
        try writer["kmsArn"].write(value.kmsArn)
        try writer["metadataCatalogConfig"].write(value.metadataCatalogConfig, with: AppflowClientTypes.MetadataCatalogConfig.write(value:to:))
        try writer["sourceFlowConfig"].write(value.sourceFlowConfig, with: AppflowClientTypes.SourceFlowConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tasks"].writeList(value.tasks, memberWritingClosure: AppflowClientTypes.Task.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["triggerConfig"].write(value.triggerConfig, with: AppflowClientTypes.TriggerConfig.write(value:to:))
    }
}

extension DeleteConnectorProfileInput {

    static func write(value: DeleteConnectorProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["forceDelete"].write(value.forceDelete)
    }
}

extension DeleteFlowInput {

    static func write(value: DeleteFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowName"].write(value.flowName)
        try writer["forceDelete"].write(value.forceDelete)
    }
}

extension DescribeConnectorInput {

    static func write(value: DescribeConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["connectorType"].write(value.connectorType)
    }
}

extension DescribeConnectorEntityInput {

    static func write(value: DescribeConnectorEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["connectorEntityName"].write(value.connectorEntityName)
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
    }
}

extension DescribeConnectorProfilesInput {

    static func write(value: DescribeConnectorProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["connectorProfileNames"].writeList(value.connectorProfileNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["connectorType"].write(value.connectorType)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeConnectorsInput {

    static func write(value: DescribeConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorTypes"].writeList(value.connectorTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppflowClientTypes.ConnectorType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeFlowInput {

    static func write(value: DescribeFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowName"].write(value.flowName)
    }
}

extension DescribeFlowExecutionRecordsInput {

    static func write(value: DescribeFlowExecutionRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowName"].write(value.flowName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListConnectorEntitiesInput {

    static func write(value: ListConnectorEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
        try writer["entitiesPath"].write(value.entitiesPath)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListConnectorsInput {

    static func write(value: ListConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFlowsInput {

    static func write(value: ListFlowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension RegisterConnectorInput {

    static func write(value: RegisterConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["connectorProvisioningConfig"].write(value.connectorProvisioningConfig, with: AppflowClientTypes.ConnectorProvisioningConfig.write(value:to:))
        try writer["connectorProvisioningType"].write(value.connectorProvisioningType)
        try writer["description"].write(value.description)
    }
}

extension ResetConnectorMetadataCacheInput {

    static func write(value: ResetConnectorMetadataCacheInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["connectorEntityName"].write(value.connectorEntityName)
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
        try writer["entitiesPath"].write(value.entitiesPath)
    }
}

extension StartFlowInput {

    static func write(value: StartFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["flowName"].write(value.flowName)
    }
}

extension StopFlowInput {

    static func write(value: StopFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowName"].write(value.flowName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UnregisterConnectorInput {

    static func write(value: UnregisterConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["forceDelete"].write(value.forceDelete)
    }
}

extension UpdateConnectorProfileInput {

    static func write(value: UpdateConnectorProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectionMode"].write(value.connectionMode)
        try writer["connectorProfileConfig"].write(value.connectorProfileConfig, with: AppflowClientTypes.ConnectorProfileConfig.write(value:to:))
        try writer["connectorProfileName"].write(value.connectorProfileName)
    }
}

extension UpdateConnectorRegistrationInput {

    static func write(value: UpdateConnectorRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectorLabel"].write(value.connectorLabel)
        try writer["connectorProvisioningConfig"].write(value.connectorProvisioningConfig, with: AppflowClientTypes.ConnectorProvisioningConfig.write(value:to:))
        try writer["description"].write(value.description)
    }
}

extension UpdateFlowInput {

    static func write(value: UpdateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["destinationFlowConfigList"].writeList(value.destinationFlowConfigList, memberWritingClosure: AppflowClientTypes.DestinationFlowConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["flowName"].write(value.flowName)
        try writer["metadataCatalogConfig"].write(value.metadataCatalogConfig, with: AppflowClientTypes.MetadataCatalogConfig.write(value:to:))
        try writer["sourceFlowConfig"].write(value.sourceFlowConfig, with: AppflowClientTypes.SourceFlowConfig.write(value:to:))
        try writer["tasks"].writeList(value.tasks, memberWritingClosure: AppflowClientTypes.Task.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["triggerConfig"].write(value.triggerConfig, with: AppflowClientTypes.TriggerConfig.write(value:to:))
    }
}

extension CancelFlowExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelFlowExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelFlowExecutionsOutput()
        value.invalidExecutions = try reader["invalidExecutions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateConnectorProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorProfileOutput()
        value.connectorProfileArn = try reader["connectorProfileArn"].readIfPresent()
        return value
    }
}

extension CreateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        return value
    }
}

extension DeleteConnectorProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorProfileOutput {
        return DeleteConnectorProfileOutput()
    }
}

extension DeleteFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowOutput {
        return DeleteFlowOutput()
    }
}

extension DescribeConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorOutput()
        value.connectorConfiguration = try reader["connectorConfiguration"].readIfPresent(with: AppflowClientTypes.ConnectorConfiguration.read(from:))
        return value
    }
}

extension DescribeConnectorEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorEntityOutput()
        value.connectorEntityFields = try reader["connectorEntityFields"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ConnectorEntityField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeConnectorProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorProfilesOutput()
        value.connectorProfileDetails = try reader["connectorProfileDetails"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ConnectorProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorsOutput()
        value.connectorConfigurations = try reader["connectorConfigurations"].readMapIfPresent(valueReadingClosure: AppflowClientTypes.ConnectorConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.connectors = try reader["connectors"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ConnectorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.destinationFlowConfigList = try reader["destinationFlowConfigList"].readListIfPresent(memberReadingClosure: AppflowClientTypes.DestinationFlowConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowName = try reader["flowName"].readIfPresent()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        value.flowStatusMessage = try reader["flowStatusMessage"].readIfPresent()
        value.kmsArn = try reader["kmsArn"].readIfPresent()
        value.lastRunExecutionDetails = try reader["lastRunExecutionDetails"].readIfPresent(with: AppflowClientTypes.ExecutionDetails.read(from:))
        value.lastRunMetadataCatalogDetails = try reader["lastRunMetadataCatalogDetails"].readListIfPresent(memberReadingClosure: AppflowClientTypes.MetadataCatalogDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.metadataCatalogConfig = try reader["metadataCatalogConfig"].readIfPresent(with: AppflowClientTypes.MetadataCatalogConfig.read(from:))
        value.schemaVersion = try reader["schemaVersion"].readIfPresent()
        value.sourceFlowConfig = try reader["sourceFlowConfig"].readIfPresent(with: AppflowClientTypes.SourceFlowConfig.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: AppflowClientTypes.Task.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.triggerConfig = try reader["triggerConfig"].readIfPresent(with: AppflowClientTypes.TriggerConfig.read(from:))
        return value
    }
}

extension DescribeFlowExecutionRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFlowExecutionRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFlowExecutionRecordsOutput()
        value.flowExecutions = try reader["flowExecutions"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ExecutionRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorEntitiesOutput()
        value.connectorEntityMap = try reader["connectorEntityMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: AppflowClientTypes.ConnectorEntity.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorsOutput()
        value.connectors = try reader["connectors"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ConnectorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowsOutput()
        value.flows = try reader["flows"].readListIfPresent(memberReadingClosure: AppflowClientTypes.FlowDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RegisterConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterConnectorOutput()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        return value
    }
}

extension ResetConnectorMetadataCacheOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetConnectorMetadataCacheOutput {
        return ResetConnectorMetadataCacheOutput()
    }
}

extension StartFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFlowOutput()
        value.executionId = try reader["executionId"].readIfPresent()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        return value
    }
}

extension StopFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopFlowOutput()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UnregisterConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnregisterConnectorOutput {
        return UnregisterConnectorOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectorProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectorProfileOutput()
        value.connectorProfileArn = try reader["connectorProfileArn"].readIfPresent()
        return value
    }
}

extension UpdateConnectorRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectorRegistrationOutput()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        return value
    }
}

extension UpdateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutput()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        return value
    }
}

enum CancelFlowExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFlowExecutionRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetConnectorMetadataCacheOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnregisterConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ConnectorAuthenticationException": return try ConnectorAuthenticationException.makeError(baseError: baseError)
            case "ConnectorServerException": return try ConnectorServerException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectorAuthenticationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConnectorAuthenticationException {
        let reader = baseError.errorBodyReader
        var value = ConnectorAuthenticationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectorServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConnectorServerException {
        let reader = baseError.errorBodyReader
        var value = ConnectorServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppflowClientTypes.ConnectorConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorConfiguration()
        value.canUseAsSource = try reader["canUseAsSource"].readIfPresent() ?? false
        value.canUseAsDestination = try reader["canUseAsDestination"].readIfPresent() ?? false
        value.supportedDestinationConnectors = try reader["supportedDestinationConnectors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.ConnectorType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedSchedulingFrequencies = try reader["supportedSchedulingFrequencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.ScheduleFrequencyType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isPrivateLinkEnabled = try reader["isPrivateLinkEnabled"].readIfPresent() ?? false
        value.isPrivateLinkEndpointUrlRequired = try reader["isPrivateLinkEndpointUrlRequired"].readIfPresent() ?? false
        value.supportedTriggerTypes = try reader["supportedTriggerTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.TriggerType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectorMetadata = try reader["connectorMetadata"].readIfPresent(with: AppflowClientTypes.ConnectorMetadata.read(from:))
        value.connectorType = try reader["connectorType"].readIfPresent()
        value.connectorLabel = try reader["connectorLabel"].readIfPresent()
        value.connectorDescription = try reader["connectorDescription"].readIfPresent()
        value.connectorOwner = try reader["connectorOwner"].readIfPresent()
        value.connectorName = try reader["connectorName"].readIfPresent()
        value.connectorVersion = try reader["connectorVersion"].readIfPresent()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorModes = try reader["connectorModes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authenticationConfig = try reader["authenticationConfig"].readIfPresent(with: AppflowClientTypes.AuthenticationConfig.read(from:))
        value.connectorRuntimeSettings = try reader["connectorRuntimeSettings"].readListIfPresent(memberReadingClosure: AppflowClientTypes.ConnectorRuntimeSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedApiVersions = try reader["supportedApiVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedOperators = try reader["supportedOperators"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.Operators>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedWriteOperations = try reader["supportedWriteOperations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.WriteOperationType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectorProvisioningType = try reader["connectorProvisioningType"].readIfPresent()
        value.connectorProvisioningConfig = try reader["connectorProvisioningConfig"].readIfPresent(with: AppflowClientTypes.ConnectorProvisioningConfig.read(from:))
        value.logoURL = try reader["logoURL"].readIfPresent()
        value.registeredAt = try reader["registeredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.registeredBy = try reader["registeredBy"].readIfPresent()
        value.supportedDataTransferTypes = try reader["supportedDataTransferTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.SupportedDataTransferType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedDataTransferApis = try reader["supportedDataTransferApis"].readListIfPresent(memberReadingClosure: AppflowClientTypes.DataTransferApi.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.DataTransferApi {

    static func write(value: AppflowClientTypes.DataTransferApi?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DataTransferApi {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DataTransferApi()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ConnectorProvisioningConfig {

    static func write(value: AppflowClientTypes.ConnectorProvisioningConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambda"].write(value.lambda, with: AppflowClientTypes.LambdaConnectorProvisioningConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorProvisioningConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorProvisioningConfig()
        value.lambda = try reader["lambda"].readIfPresent(with: AppflowClientTypes.LambdaConnectorProvisioningConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.LambdaConnectorProvisioningConfig {

    static func write(value: AppflowClientTypes.LambdaConnectorProvisioningConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.LambdaConnectorProvisioningConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.LambdaConnectorProvisioningConfig()
        value.lambdaArn = try reader["lambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.ConnectorRuntimeSetting {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorRuntimeSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorRuntimeSetting()
        value.key = try reader["key"].readIfPresent()
        value.dataType = try reader["dataType"].readIfPresent()
        value.isRequired = try reader["isRequired"].readIfPresent() ?? false
        value.label = try reader["label"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.scope = try reader["scope"].readIfPresent()
        value.connectorSuppliedValueOptions = try reader["connectorSuppliedValueOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.AuthenticationConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AuthenticationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.AuthenticationConfig()
        value.isBasicAuthSupported = try reader["isBasicAuthSupported"].readIfPresent() ?? false
        value.isApiKeyAuthSupported = try reader["isApiKeyAuthSupported"].readIfPresent() ?? false
        value.isOAuth2Supported = try reader["isOAuth2Supported"].readIfPresent() ?? false
        value.isCustomAuthSupported = try reader["isCustomAuthSupported"].readIfPresent() ?? false
        value.oAuth2Defaults = try reader["oAuth2Defaults"].readIfPresent(with: AppflowClientTypes.OAuth2Defaults.read(from:))
        value.customAuthConfigs = try reader["customAuthConfigs"].readListIfPresent(memberReadingClosure: AppflowClientTypes.CustomAuthConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.CustomAuthConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomAuthConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.CustomAuthConfig()
        value.customAuthenticationType = try reader["customAuthenticationType"].readIfPresent()
        value.authParameters = try reader["authParameters"].readListIfPresent(memberReadingClosure: AppflowClientTypes.AuthParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.AuthParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AuthParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.AuthParameter()
        value.key = try reader["key"].readIfPresent()
        value.isRequired = try reader["isRequired"].readIfPresent() ?? false
        value.label = try reader["label"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isSensitiveField = try reader["isSensitiveField"].readIfPresent() ?? false
        value.connectorSuppliedValues = try reader["connectorSuppliedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.OAuth2Defaults {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.OAuth2Defaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.OAuth2Defaults()
        value.oauthScopes = try reader["oauthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tokenUrls = try reader["tokenUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.authCodeUrls = try reader["authCodeUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.oauth2GrantTypesSupported = try reader["oauth2GrantTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.OAuth2GrantType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.oauth2CustomProperties = try reader["oauth2CustomProperties"].readListIfPresent(memberReadingClosure: AppflowClientTypes.OAuth2CustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.OAuth2CustomParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.OAuth2CustomParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.OAuth2CustomParameter()
        value.key = try reader["key"].readIfPresent()
        value.isRequired = try reader["isRequired"].readIfPresent() ?? false
        value.label = try reader["label"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.isSensitiveField = try reader["isSensitiveField"].readIfPresent() ?? false
        value.connectorSuppliedValues = try reader["connectorSuppliedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ConnectorMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorMetadata()
        value.amplitude = try reader["Amplitude"].readIfPresent(with: AppflowClientTypes.AmplitudeMetadata.read(from:))
        value.datadog = try reader["Datadog"].readIfPresent(with: AppflowClientTypes.DatadogMetadata.read(from:))
        value.dynatrace = try reader["Dynatrace"].readIfPresent(with: AppflowClientTypes.DynatraceMetadata.read(from:))
        value.googleAnalytics = try reader["GoogleAnalytics"].readIfPresent(with: AppflowClientTypes.GoogleAnalyticsMetadata.read(from:))
        value.inforNexus = try reader["InforNexus"].readIfPresent(with: AppflowClientTypes.InforNexusMetadata.read(from:))
        value.marketo = try reader["Marketo"].readIfPresent(with: AppflowClientTypes.MarketoMetadata.read(from:))
        value.redshift = try reader["Redshift"].readIfPresent(with: AppflowClientTypes.RedshiftMetadata.read(from:))
        value.s3 = try reader["S3"].readIfPresent(with: AppflowClientTypes.S3Metadata.read(from:))
        value.salesforce = try reader["Salesforce"].readIfPresent(with: AppflowClientTypes.SalesforceMetadata.read(from:))
        value.serviceNow = try reader["ServiceNow"].readIfPresent(with: AppflowClientTypes.ServiceNowMetadata.read(from:))
        value.singular = try reader["Singular"].readIfPresent(with: AppflowClientTypes.SingularMetadata.read(from:))
        value.slack = try reader["Slack"].readIfPresent(with: AppflowClientTypes.SlackMetadata.read(from:))
        value.snowflake = try reader["Snowflake"].readIfPresent(with: AppflowClientTypes.SnowflakeMetadata.read(from:))
        value.trendmicro = try reader["Trendmicro"].readIfPresent(with: AppflowClientTypes.TrendmicroMetadata.read(from:))
        value.veeva = try reader["Veeva"].readIfPresent(with: AppflowClientTypes.VeevaMetadata.read(from:))
        value.zendesk = try reader["Zendesk"].readIfPresent(with: AppflowClientTypes.ZendeskMetadata.read(from:))
        value.eventBridge = try reader["EventBridge"].readIfPresent(with: AppflowClientTypes.EventBridgeMetadata.read(from:))
        value.upsolver = try reader["Upsolver"].readIfPresent(with: AppflowClientTypes.UpsolverMetadata.read(from:))
        value.customerProfiles = try reader["CustomerProfiles"].readIfPresent(with: AppflowClientTypes.CustomerProfilesMetadata.read(from:))
        value.honeycode = try reader["Honeycode"].readIfPresent(with: AppflowClientTypes.HoneycodeMetadata.read(from:))
        value.sapoData = try reader["SAPOData"].readIfPresent(with: AppflowClientTypes.SAPODataMetadata.read(from:))
        value.pardot = try reader["Pardot"].readIfPresent(with: AppflowClientTypes.PardotMetadata.read(from:))
        return value
    }
}

extension AppflowClientTypes.PardotMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.PardotMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.PardotMetadata()
    }
}

extension AppflowClientTypes.SAPODataMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.SAPODataMetadata()
    }
}

extension AppflowClientTypes.HoneycodeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.HoneycodeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.HoneycodeMetadata()
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.CustomerProfilesMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomerProfilesMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.CustomerProfilesMetadata()
    }
}

extension AppflowClientTypes.UpsolverMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.UpsolverMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.UpsolverMetadata()
    }
}

extension AppflowClientTypes.EventBridgeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.EventBridgeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.EventBridgeMetadata()
    }
}

extension AppflowClientTypes.ZendeskMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ZendeskMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ZendeskMetadata()
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.VeevaMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.VeevaMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.VeevaMetadata()
    }
}

extension AppflowClientTypes.TrendmicroMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.TrendmicroMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.TrendmicroMetadata()
    }
}

extension AppflowClientTypes.SnowflakeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SnowflakeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SnowflakeMetadata()
        value.supportedRegions = try reader["supportedRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.SlackMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SlackMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SlackMetadata()
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.SingularMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SingularMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.SingularMetadata()
    }
}

extension AppflowClientTypes.ServiceNowMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ServiceNowMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.ServiceNowMetadata()
    }
}

extension AppflowClientTypes.SalesforceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SalesforceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SalesforceMetadata()
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataTransferApis = try reader["dataTransferApis"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.SalesforceDataTransferApi>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.oauth2GrantTypesSupported = try reader["oauth2GrantTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.OAuth2GrantType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.S3Metadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.S3Metadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.S3Metadata()
    }
}

extension AppflowClientTypes.RedshiftMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.RedshiftMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.RedshiftMetadata()
    }
}

extension AppflowClientTypes.MarketoMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MarketoMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.MarketoMetadata()
    }
}

extension AppflowClientTypes.InforNexusMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.InforNexusMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.InforNexusMetadata()
    }
}

extension AppflowClientTypes.GoogleAnalyticsMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.GoogleAnalyticsMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.GoogleAnalyticsMetadata()
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.DynatraceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DynatraceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.DynatraceMetadata()
    }
}

extension AppflowClientTypes.DatadogMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DatadogMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.DatadogMetadata()
    }
}

extension AppflowClientTypes.AmplitudeMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AmplitudeMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.AmplitudeMetadata()
    }
}

extension AppflowClientTypes.ConnectorEntityField {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorEntityField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorEntityField()
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.parentIdentifier = try reader["parentIdentifier"].readIfPresent()
        value.label = try reader["label"].readIfPresent()
        value.isPrimaryKey = try reader["isPrimaryKey"].readIfPresent() ?? false
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.isDeprecated = try reader["isDeprecated"].readIfPresent() ?? false
        value.supportedFieldTypeDetails = try reader["supportedFieldTypeDetails"].readIfPresent(with: AppflowClientTypes.SupportedFieldTypeDetails.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.sourceProperties = try reader["sourceProperties"].readIfPresent(with: AppflowClientTypes.SourceFieldProperties.read(from:))
        value.destinationProperties = try reader["destinationProperties"].readIfPresent(with: AppflowClientTypes.DestinationFieldProperties.read(from:))
        value.customProperties = try reader["customProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.DestinationFieldProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DestinationFieldProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DestinationFieldProperties()
        value.isCreatable = try reader["isCreatable"].readIfPresent() ?? false
        value.isNullable = try reader["isNullable"].readIfPresent() ?? false
        value.isUpsertable = try reader["isUpsertable"].readIfPresent() ?? false
        value.isUpdatable = try reader["isUpdatable"].readIfPresent() ?? false
        value.isDefaultedOnCreate = try reader["isDefaultedOnCreate"].readIfPresent() ?? false
        value.supportedWriteOperations = try reader["supportedWriteOperations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.WriteOperationType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.SourceFieldProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SourceFieldProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SourceFieldProperties()
        value.isRetrievable = try reader["isRetrievable"].readIfPresent() ?? false
        value.isQueryable = try reader["isQueryable"].readIfPresent() ?? false
        value.isTimestampFieldForIncrementalQueries = try reader["isTimestampFieldForIncrementalQueries"].readIfPresent() ?? false
        return value
    }
}

extension AppflowClientTypes.SupportedFieldTypeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SupportedFieldTypeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SupportedFieldTypeDetails()
        value.v1 = try reader["v1"].readIfPresent(with: AppflowClientTypes.FieldTypeDetails.read(from:))
        return value
    }
}

extension AppflowClientTypes.FieldTypeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.FieldTypeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.FieldTypeDetails()
        value.fieldType = try reader["fieldType"].readIfPresent() ?? ""
        value.filterOperators = try reader["filterOperators"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.Operator>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.supportedValues = try reader["supportedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.valueRegexPattern = try reader["valueRegexPattern"].readIfPresent()
        value.supportedDateFormat = try reader["supportedDateFormat"].readIfPresent()
        value.fieldValueRange = try reader["fieldValueRange"].readIfPresent(with: AppflowClientTypes.Range.read(from:))
        value.fieldLengthRange = try reader["fieldLengthRange"].readIfPresent(with: AppflowClientTypes.Range.read(from:))
        return value
    }
}

extension AppflowClientTypes.Range {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.Range {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.Range()
        value.maximum = try reader["maximum"].readIfPresent() ?? 0
        value.minimum = try reader["minimum"].readIfPresent() ?? 0
        return value
    }
}

extension AppflowClientTypes.ConnectorProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorProfile()
        value.connectorProfileArn = try reader["connectorProfileArn"].readIfPresent()
        value.connectorProfileName = try reader["connectorProfileName"].readIfPresent()
        value.connectorType = try reader["connectorType"].readIfPresent()
        value.connectorLabel = try reader["connectorLabel"].readIfPresent()
        value.connectionMode = try reader["connectionMode"].readIfPresent()
        value.credentialsArn = try reader["credentialsArn"].readIfPresent()
        value.connectorProfileProperties = try reader["connectorProfileProperties"].readIfPresent(with: AppflowClientTypes.ConnectorProfileProperties.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.privateConnectionProvisioningState = try reader["privateConnectionProvisioningState"].readIfPresent(with: AppflowClientTypes.PrivateConnectionProvisioningState.read(from:))
        return value
    }
}

extension AppflowClientTypes.PrivateConnectionProvisioningState {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.PrivateConnectionProvisioningState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.PrivateConnectionProvisioningState()
        value.status = try reader["status"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.failureCause = try reader["failureCause"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ConnectorProfileProperties {

    static func write(value: AppflowClientTypes.ConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amplitude"].write(value.amplitude, with: AppflowClientTypes.AmplitudeConnectorProfileProperties.write(value:to:))
        try writer["CustomConnector"].write(value.customConnector, with: AppflowClientTypes.CustomConnectorProfileProperties.write(value:to:))
        try writer["Datadog"].write(value.datadog, with: AppflowClientTypes.DatadogConnectorProfileProperties.write(value:to:))
        try writer["Dynatrace"].write(value.dynatrace, with: AppflowClientTypes.DynatraceConnectorProfileProperties.write(value:to:))
        try writer["GoogleAnalytics"].write(value.googleAnalytics, with: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties.write(value:to:))
        try writer["Honeycode"].write(value.honeycode, with: AppflowClientTypes.HoneycodeConnectorProfileProperties.write(value:to:))
        try writer["InforNexus"].write(value.inforNexus, with: AppflowClientTypes.InforNexusConnectorProfileProperties.write(value:to:))
        try writer["Marketo"].write(value.marketo, with: AppflowClientTypes.MarketoConnectorProfileProperties.write(value:to:))
        try writer["Pardot"].write(value.pardot, with: AppflowClientTypes.PardotConnectorProfileProperties.write(value:to:))
        try writer["Redshift"].write(value.redshift, with: AppflowClientTypes.RedshiftConnectorProfileProperties.write(value:to:))
        try writer["SAPOData"].write(value.sapoData, with: AppflowClientTypes.SAPODataConnectorProfileProperties.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: AppflowClientTypes.SalesforceConnectorProfileProperties.write(value:to:))
        try writer["ServiceNow"].write(value.serviceNow, with: AppflowClientTypes.ServiceNowConnectorProfileProperties.write(value:to:))
        try writer["Singular"].write(value.singular, with: AppflowClientTypes.SingularConnectorProfileProperties.write(value:to:))
        try writer["Slack"].write(value.slack, with: AppflowClientTypes.SlackConnectorProfileProperties.write(value:to:))
        try writer["Snowflake"].write(value.snowflake, with: AppflowClientTypes.SnowflakeConnectorProfileProperties.write(value:to:))
        try writer["Trendmicro"].write(value.trendmicro, with: AppflowClientTypes.TrendmicroConnectorProfileProperties.write(value:to:))
        try writer["Veeva"].write(value.veeva, with: AppflowClientTypes.VeevaConnectorProfileProperties.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: AppflowClientTypes.ZendeskConnectorProfileProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorProfileProperties()
        value.amplitude = try reader["Amplitude"].readIfPresent(with: AppflowClientTypes.AmplitudeConnectorProfileProperties.read(from:))
        value.datadog = try reader["Datadog"].readIfPresent(with: AppflowClientTypes.DatadogConnectorProfileProperties.read(from:))
        value.dynatrace = try reader["Dynatrace"].readIfPresent(with: AppflowClientTypes.DynatraceConnectorProfileProperties.read(from:))
        value.googleAnalytics = try reader["GoogleAnalytics"].readIfPresent(with: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties.read(from:))
        value.honeycode = try reader["Honeycode"].readIfPresent(with: AppflowClientTypes.HoneycodeConnectorProfileProperties.read(from:))
        value.inforNexus = try reader["InforNexus"].readIfPresent(with: AppflowClientTypes.InforNexusConnectorProfileProperties.read(from:))
        value.marketo = try reader["Marketo"].readIfPresent(with: AppflowClientTypes.MarketoConnectorProfileProperties.read(from:))
        value.redshift = try reader["Redshift"].readIfPresent(with: AppflowClientTypes.RedshiftConnectorProfileProperties.read(from:))
        value.salesforce = try reader["Salesforce"].readIfPresent(with: AppflowClientTypes.SalesforceConnectorProfileProperties.read(from:))
        value.serviceNow = try reader["ServiceNow"].readIfPresent(with: AppflowClientTypes.ServiceNowConnectorProfileProperties.read(from:))
        value.singular = try reader["Singular"].readIfPresent(with: AppflowClientTypes.SingularConnectorProfileProperties.read(from:))
        value.slack = try reader["Slack"].readIfPresent(with: AppflowClientTypes.SlackConnectorProfileProperties.read(from:))
        value.snowflake = try reader["Snowflake"].readIfPresent(with: AppflowClientTypes.SnowflakeConnectorProfileProperties.read(from:))
        value.trendmicro = try reader["Trendmicro"].readIfPresent(with: AppflowClientTypes.TrendmicroConnectorProfileProperties.read(from:))
        value.veeva = try reader["Veeva"].readIfPresent(with: AppflowClientTypes.VeevaConnectorProfileProperties.read(from:))
        value.zendesk = try reader["Zendesk"].readIfPresent(with: AppflowClientTypes.ZendeskConnectorProfileProperties.read(from:))
        value.sapoData = try reader["SAPOData"].readIfPresent(with: AppflowClientTypes.SAPODataConnectorProfileProperties.read(from:))
        value.customConnector = try reader["CustomConnector"].readIfPresent(with: AppflowClientTypes.CustomConnectorProfileProperties.read(from:))
        value.pardot = try reader["Pardot"].readIfPresent(with: AppflowClientTypes.PardotConnectorProfileProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.PardotConnectorProfileProperties {

    static func write(value: AppflowClientTypes.PardotConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessUnitId"].write(value.businessUnitId)
        try writer["instanceUrl"].write(value.instanceUrl)
        try writer["isSandboxEnvironment"].write(value.isSandboxEnvironment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.PardotConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.PardotConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent()
        value.isSandboxEnvironment = try reader["isSandboxEnvironment"].readIfPresent() ?? false
        value.businessUnitId = try reader["businessUnitId"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.CustomConnectorProfileProperties {

    static func write(value: AppflowClientTypes.CustomConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuth2Properties"].write(value.oAuth2Properties, with: AppflowClientTypes.OAuth2Properties.write(value:to:))
        try writer["profileProperties"].writeMap(value.profileProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.CustomConnectorProfileProperties()
        value.profileProperties = try reader["profileProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.oAuth2Properties = try reader["oAuth2Properties"].readIfPresent(with: AppflowClientTypes.OAuth2Properties.read(from:))
        return value
    }
}

extension AppflowClientTypes.OAuth2Properties {

    static func write(value: AppflowClientTypes.OAuth2Properties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuth2GrantType"].write(value.oAuth2GrantType)
        try writer["tokenUrl"].write(value.tokenUrl)
        try writer["tokenUrlCustomProperties"].writeMap(value.tokenUrlCustomProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.OAuth2Properties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.OAuth2Properties()
        value.tokenUrl = try reader["tokenUrl"].readIfPresent() ?? ""
        value.oAuth2GrantType = try reader["oAuth2GrantType"].readIfPresent() ?? .sdkUnknown("")
        value.tokenUrlCustomProperties = try reader["tokenUrlCustomProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.SAPODataConnectorProfileProperties {

    static func write(value: AppflowClientTypes.SAPODataConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationHostUrl"].write(value.applicationHostUrl)
        try writer["applicationServicePath"].write(value.applicationServicePath)
        try writer["clientNumber"].write(value.clientNumber)
        try writer["disableSSO"].write(value.disableSSO)
        try writer["logonLanguage"].write(value.logonLanguage)
        try writer["oAuthProperties"].write(value.oAuthProperties, with: AppflowClientTypes.OAuthProperties.write(value:to:))
        try writer["portNumber"].write(value.portNumber)
        try writer["privateLinkServiceName"].write(value.privateLinkServiceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SAPODataConnectorProfileProperties()
        value.applicationHostUrl = try reader["applicationHostUrl"].readIfPresent() ?? ""
        value.applicationServicePath = try reader["applicationServicePath"].readIfPresent() ?? ""
        value.portNumber = try reader["portNumber"].readIfPresent() ?? 0
        value.clientNumber = try reader["clientNumber"].readIfPresent() ?? ""
        value.logonLanguage = try reader["logonLanguage"].readIfPresent()
        value.privateLinkServiceName = try reader["privateLinkServiceName"].readIfPresent()
        value.oAuthProperties = try reader["oAuthProperties"].readIfPresent(with: AppflowClientTypes.OAuthProperties.read(from:))
        value.disableSSO = try reader["disableSSO"].readIfPresent() ?? false
        return value
    }
}

extension AppflowClientTypes.OAuthProperties {

    static func write(value: AppflowClientTypes.OAuthProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authCodeUrl"].write(value.authCodeUrl)
        try writer["oAuthScopes"].writeList(value.oAuthScopes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tokenUrl"].write(value.tokenUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.OAuthProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.OAuthProperties()
        value.tokenUrl = try reader["tokenUrl"].readIfPresent() ?? ""
        value.authCodeUrl = try reader["authCodeUrl"].readIfPresent() ?? ""
        value.oAuthScopes = try reader["oAuthScopes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileProperties {

    static func write(value: AppflowClientTypes.ZendeskConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ZendeskConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ZendeskConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.VeevaConnectorProfileProperties {

    static func write(value: AppflowClientTypes.VeevaConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.VeevaConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.VeevaConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileProperties {

    static func write(value: AppflowClientTypes.TrendmicroConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.TrendmicroConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.TrendmicroConnectorProfileProperties()
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileProperties {

    static func write(value: AppflowClientTypes.SnowflakeConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountName"].write(value.accountName)
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["privateLinkServiceName"].write(value.privateLinkServiceName)
        try writer["region"].write(value.region)
        try writer["stage"].write(value.stage)
        try writer["warehouse"].write(value.warehouse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SnowflakeConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SnowflakeConnectorProfileProperties()
        value.warehouse = try reader["warehouse"].readIfPresent() ?? ""
        value.stage = try reader["stage"].readIfPresent() ?? ""
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.privateLinkServiceName = try reader["privateLinkServiceName"].readIfPresent()
        value.accountName = try reader["accountName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.SlackConnectorProfileProperties {

    static func write(value: AppflowClientTypes.SlackConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SlackConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SlackConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.SingularConnectorProfileProperties {

    static func write(value: AppflowClientTypes.SingularConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SingularConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.SingularConnectorProfileProperties()
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileProperties {

    static func write(value: AppflowClientTypes.ServiceNowConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ServiceNowConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ServiceNowConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileProperties {

    static func write(value: AppflowClientTypes.SalesforceConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
        try writer["isSandboxEnvironment"].write(value.isSandboxEnvironment)
        try writer["usePrivateLinkForMetadataAndAuthorization"].write(value.usePrivateLinkForMetadataAndAuthorization)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SalesforceConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SalesforceConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent()
        value.isSandboxEnvironment = try reader["isSandboxEnvironment"].readIfPresent() ?? false
        value.usePrivateLinkForMetadataAndAuthorization = try reader["usePrivateLinkForMetadataAndAuthorization"].readIfPresent() ?? false
        return value
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileProperties {

    static func write(value: AppflowClientTypes.RedshiftConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["clusterIdentifier"].write(value.clusterIdentifier)
        try writer["dataApiRoleArn"].write(value.dataApiRoleArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["databaseUrl"].write(value.databaseUrl)
        try writer["isRedshiftServerless"].write(value.isRedshiftServerless)
        try writer["roleArn"].write(value.roleArn)
        try writer["workgroupName"].write(value.workgroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.RedshiftConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.RedshiftConnectorProfileProperties()
        value.databaseUrl = try reader["databaseUrl"].readIfPresent()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.dataApiRoleArn = try reader["dataApiRoleArn"].readIfPresent()
        value.isRedshiftServerless = try reader["isRedshiftServerless"].readIfPresent() ?? false
        value.clusterIdentifier = try reader["clusterIdentifier"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.MarketoConnectorProfileProperties {

    static func write(value: AppflowClientTypes.MarketoConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MarketoConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.MarketoConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileProperties {

    static func write(value: AppflowClientTypes.InforNexusConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.InforNexusConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.InforNexusConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileProperties {

    static func write(value: AppflowClientTypes.HoneycodeConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.HoneycodeConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.HoneycodeConnectorProfileProperties()
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties {

    static func write(value: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties()
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileProperties {

    static func write(value: AppflowClientTypes.DynatraceConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DynatraceConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DynatraceConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.DatadogConnectorProfileProperties {

    static func write(value: AppflowClientTypes.DatadogConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceUrl"].write(value.instanceUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DatadogConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DatadogConnectorProfileProperties()
        value.instanceUrl = try reader["instanceUrl"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileProperties {

    static func write(value: AppflowClientTypes.AmplitudeConnectorProfileProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AmplitudeConnectorProfileProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.AmplitudeConnectorProfileProperties()
    }
}

extension AppflowClientTypes.ConnectorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorDetail()
        value.connectorDescription = try reader["connectorDescription"].readIfPresent()
        value.connectorName = try reader["connectorName"].readIfPresent()
        value.connectorOwner = try reader["connectorOwner"].readIfPresent()
        value.connectorVersion = try reader["connectorVersion"].readIfPresent()
        value.applicationType = try reader["applicationType"].readIfPresent()
        value.connectorType = try reader["connectorType"].readIfPresent()
        value.connectorLabel = try reader["connectorLabel"].readIfPresent()
        value.registeredAt = try reader["registeredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.registeredBy = try reader["registeredBy"].readIfPresent()
        value.connectorProvisioningType = try reader["connectorProvisioningType"].readIfPresent()
        value.connectorModes = try reader["connectorModes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.supportedDataTransferTypes = try reader["supportedDataTransferTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.SupportedDataTransferType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.SourceFlowConfig {

    static func write(value: AppflowClientTypes.SourceFlowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
        try writer["incrementalPullConfig"].write(value.incrementalPullConfig, with: AppflowClientTypes.IncrementalPullConfig.write(value:to:))
        try writer["sourceConnectorProperties"].write(value.sourceConnectorProperties, with: AppflowClientTypes.SourceConnectorProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SourceFlowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SourceFlowConfig()
        value.connectorType = try reader["connectorType"].readIfPresent() ?? .sdkUnknown("")
        value.apiVersion = try reader["apiVersion"].readIfPresent()
        value.connectorProfileName = try reader["connectorProfileName"].readIfPresent()
        value.sourceConnectorProperties = try reader["sourceConnectorProperties"].readIfPresent(with: AppflowClientTypes.SourceConnectorProperties.read(from:))
        value.incrementalPullConfig = try reader["incrementalPullConfig"].readIfPresent(with: AppflowClientTypes.IncrementalPullConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.IncrementalPullConfig {

    static func write(value: AppflowClientTypes.IncrementalPullConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datetimeTypeFieldName"].write(value.datetimeTypeFieldName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.IncrementalPullConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.IncrementalPullConfig()
        value.datetimeTypeFieldName = try reader["datetimeTypeFieldName"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.SourceConnectorProperties {

    static func write(value: AppflowClientTypes.SourceConnectorProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amplitude"].write(value.amplitude, with: AppflowClientTypes.AmplitudeSourceProperties.write(value:to:))
        try writer["CustomConnector"].write(value.customConnector, with: AppflowClientTypes.CustomConnectorSourceProperties.write(value:to:))
        try writer["Datadog"].write(value.datadog, with: AppflowClientTypes.DatadogSourceProperties.write(value:to:))
        try writer["Dynatrace"].write(value.dynatrace, with: AppflowClientTypes.DynatraceSourceProperties.write(value:to:))
        try writer["GoogleAnalytics"].write(value.googleAnalytics, with: AppflowClientTypes.GoogleAnalyticsSourceProperties.write(value:to:))
        try writer["InforNexus"].write(value.inforNexus, with: AppflowClientTypes.InforNexusSourceProperties.write(value:to:))
        try writer["Marketo"].write(value.marketo, with: AppflowClientTypes.MarketoSourceProperties.write(value:to:))
        try writer["Pardot"].write(value.pardot, with: AppflowClientTypes.PardotSourceProperties.write(value:to:))
        try writer["S3"].write(value.s3, with: AppflowClientTypes.S3SourceProperties.write(value:to:))
        try writer["SAPOData"].write(value.sapoData, with: AppflowClientTypes.SAPODataSourceProperties.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: AppflowClientTypes.SalesforceSourceProperties.write(value:to:))
        try writer["ServiceNow"].write(value.serviceNow, with: AppflowClientTypes.ServiceNowSourceProperties.write(value:to:))
        try writer["Singular"].write(value.singular, with: AppflowClientTypes.SingularSourceProperties.write(value:to:))
        try writer["Slack"].write(value.slack, with: AppflowClientTypes.SlackSourceProperties.write(value:to:))
        try writer["Trendmicro"].write(value.trendmicro, with: AppflowClientTypes.TrendmicroSourceProperties.write(value:to:))
        try writer["Veeva"].write(value.veeva, with: AppflowClientTypes.VeevaSourceProperties.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: AppflowClientTypes.ZendeskSourceProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SourceConnectorProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SourceConnectorProperties()
        value.amplitude = try reader["Amplitude"].readIfPresent(with: AppflowClientTypes.AmplitudeSourceProperties.read(from:))
        value.datadog = try reader["Datadog"].readIfPresent(with: AppflowClientTypes.DatadogSourceProperties.read(from:))
        value.dynatrace = try reader["Dynatrace"].readIfPresent(with: AppflowClientTypes.DynatraceSourceProperties.read(from:))
        value.googleAnalytics = try reader["GoogleAnalytics"].readIfPresent(with: AppflowClientTypes.GoogleAnalyticsSourceProperties.read(from:))
        value.inforNexus = try reader["InforNexus"].readIfPresent(with: AppflowClientTypes.InforNexusSourceProperties.read(from:))
        value.marketo = try reader["Marketo"].readIfPresent(with: AppflowClientTypes.MarketoSourceProperties.read(from:))
        value.s3 = try reader["S3"].readIfPresent(with: AppflowClientTypes.S3SourceProperties.read(from:))
        value.salesforce = try reader["Salesforce"].readIfPresent(with: AppflowClientTypes.SalesforceSourceProperties.read(from:))
        value.serviceNow = try reader["ServiceNow"].readIfPresent(with: AppflowClientTypes.ServiceNowSourceProperties.read(from:))
        value.singular = try reader["Singular"].readIfPresent(with: AppflowClientTypes.SingularSourceProperties.read(from:))
        value.slack = try reader["Slack"].readIfPresent(with: AppflowClientTypes.SlackSourceProperties.read(from:))
        value.trendmicro = try reader["Trendmicro"].readIfPresent(with: AppflowClientTypes.TrendmicroSourceProperties.read(from:))
        value.veeva = try reader["Veeva"].readIfPresent(with: AppflowClientTypes.VeevaSourceProperties.read(from:))
        value.zendesk = try reader["Zendesk"].readIfPresent(with: AppflowClientTypes.ZendeskSourceProperties.read(from:))
        value.sapoData = try reader["SAPOData"].readIfPresent(with: AppflowClientTypes.SAPODataSourceProperties.read(from:))
        value.customConnector = try reader["CustomConnector"].readIfPresent(with: AppflowClientTypes.CustomConnectorSourceProperties.read(from:))
        value.pardot = try reader["Pardot"].readIfPresent(with: AppflowClientTypes.PardotSourceProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.PardotSourceProperties {

    static func write(value: AppflowClientTypes.PardotSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.PardotSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.PardotSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.CustomConnectorSourceProperties {

    static func write(value: AppflowClientTypes.CustomConnectorSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customProperties"].writeMap(value.customProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["dataTransferApi"].write(value.dataTransferApi, with: AppflowClientTypes.DataTransferApi.write(value:to:))
        try writer["entityName"].write(value.entityName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomConnectorSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.CustomConnectorSourceProperties()
        value.entityName = try reader["entityName"].readIfPresent() ?? ""
        value.customProperties = try reader["customProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dataTransferApi = try reader["dataTransferApi"].readIfPresent(with: AppflowClientTypes.DataTransferApi.read(from:))
        return value
    }
}

extension AppflowClientTypes.SAPODataSourceProperties {

    static func write(value: AppflowClientTypes.SAPODataSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["objectPath"].write(value.objectPath)
        try writer["paginationConfig"].write(value.paginationConfig, with: AppflowClientTypes.SAPODataPaginationConfig.write(value:to:))
        try writer["parallelismConfig"].write(value.parallelismConfig, with: AppflowClientTypes.SAPODataParallelismConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SAPODataSourceProperties()
        value.objectPath = try reader["objectPath"].readIfPresent()
        value.parallelismConfig = try reader["parallelismConfig"].readIfPresent(with: AppflowClientTypes.SAPODataParallelismConfig.read(from:))
        value.paginationConfig = try reader["paginationConfig"].readIfPresent(with: AppflowClientTypes.SAPODataPaginationConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.SAPODataPaginationConfig {

    static func write(value: AppflowClientTypes.SAPODataPaginationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxPageSize"].write(value.maxPageSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataPaginationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SAPODataPaginationConfig()
        value.maxPageSize = try reader["maxPageSize"].readIfPresent() ?? 0
        return value
    }
}

extension AppflowClientTypes.SAPODataParallelismConfig {

    static func write(value: AppflowClientTypes.SAPODataParallelismConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxParallelism"].write(value.maxParallelism)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataParallelismConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SAPODataParallelismConfig()
        value.maxParallelism = try reader["maxParallelism"].readIfPresent() ?? 0
        return value
    }
}

extension AppflowClientTypes.ZendeskSourceProperties {

    static func write(value: AppflowClientTypes.ZendeskSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ZendeskSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ZendeskSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.VeevaSourceProperties {

    static func write(value: AppflowClientTypes.VeevaSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["documentType"].write(value.documentType)
        try writer["includeAllVersions"].write(value.includeAllVersions)
        try writer["includeRenditions"].write(value.includeRenditions)
        try writer["includeSourceFiles"].write(value.includeSourceFiles)
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.VeevaSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.VeevaSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.documentType = try reader["documentType"].readIfPresent()
        value.includeSourceFiles = try reader["includeSourceFiles"].readIfPresent() ?? false
        value.includeRenditions = try reader["includeRenditions"].readIfPresent() ?? false
        value.includeAllVersions = try reader["includeAllVersions"].readIfPresent() ?? false
        return value
    }
}

extension AppflowClientTypes.TrendmicroSourceProperties {

    static func write(value: AppflowClientTypes.TrendmicroSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.TrendmicroSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.TrendmicroSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.SlackSourceProperties {

    static func write(value: AppflowClientTypes.SlackSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SlackSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SlackSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.SingularSourceProperties {

    static func write(value: AppflowClientTypes.SingularSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SingularSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SingularSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.ServiceNowSourceProperties {

    static func write(value: AppflowClientTypes.ServiceNowSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ServiceNowSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ServiceNowSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.SalesforceSourceProperties {

    static func write(value: AppflowClientTypes.SalesforceSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTransferApi"].write(value.dataTransferApi)
        try writer["enableDynamicFieldUpdate"].write(value.enableDynamicFieldUpdate)
        try writer["includeDeletedRecords"].write(value.includeDeletedRecords)
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SalesforceSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SalesforceSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.enableDynamicFieldUpdate = try reader["enableDynamicFieldUpdate"].readIfPresent() ?? false
        value.includeDeletedRecords = try reader["includeDeletedRecords"].readIfPresent() ?? false
        value.dataTransferApi = try reader["dataTransferApi"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.S3SourceProperties {

    static func write(value: AppflowClientTypes.S3SourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["s3InputFormatConfig"].write(value.s3InputFormatConfig, with: AppflowClientTypes.S3InputFormatConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.S3SourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.S3SourceProperties()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.s3InputFormatConfig = try reader["s3InputFormatConfig"].readIfPresent(with: AppflowClientTypes.S3InputFormatConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.S3InputFormatConfig {

    static func write(value: AppflowClientTypes.S3InputFormatConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3InputFileType"].write(value.s3InputFileType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.S3InputFormatConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.S3InputFormatConfig()
        value.s3InputFileType = try reader["s3InputFileType"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.MarketoSourceProperties {

    static func write(value: AppflowClientTypes.MarketoSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MarketoSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.MarketoSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.InforNexusSourceProperties {

    static func write(value: AppflowClientTypes.InforNexusSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.InforNexusSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.InforNexusSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.GoogleAnalyticsSourceProperties {

    static func write(value: AppflowClientTypes.GoogleAnalyticsSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.GoogleAnalyticsSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.GoogleAnalyticsSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.DynatraceSourceProperties {

    static func write(value: AppflowClientTypes.DynatraceSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DynatraceSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DynatraceSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.DatadogSourceProperties {

    static func write(value: AppflowClientTypes.DatadogSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DatadogSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DatadogSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.AmplitudeSourceProperties {

    static func write(value: AppflowClientTypes.AmplitudeSourceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AmplitudeSourceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.AmplitudeSourceProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.DestinationFlowConfig {

    static func write(value: AppflowClientTypes.DestinationFlowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["connectorProfileName"].write(value.connectorProfileName)
        try writer["connectorType"].write(value.connectorType)
        try writer["destinationConnectorProperties"].write(value.destinationConnectorProperties, with: AppflowClientTypes.DestinationConnectorProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DestinationFlowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DestinationFlowConfig()
        value.connectorType = try reader["connectorType"].readIfPresent() ?? .sdkUnknown("")
        value.apiVersion = try reader["apiVersion"].readIfPresent()
        value.connectorProfileName = try reader["connectorProfileName"].readIfPresent()
        value.destinationConnectorProperties = try reader["destinationConnectorProperties"].readIfPresent(with: AppflowClientTypes.DestinationConnectorProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.DestinationConnectorProperties {

    static func write(value: AppflowClientTypes.DestinationConnectorProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomConnector"].write(value.customConnector, with: AppflowClientTypes.CustomConnectorDestinationProperties.write(value:to:))
        try writer["CustomerProfiles"].write(value.customerProfiles, with: AppflowClientTypes.CustomerProfilesDestinationProperties.write(value:to:))
        try writer["EventBridge"].write(value.eventBridge, with: AppflowClientTypes.EventBridgeDestinationProperties.write(value:to:))
        try writer["Honeycode"].write(value.honeycode, with: AppflowClientTypes.HoneycodeDestinationProperties.write(value:to:))
        try writer["LookoutMetrics"].write(value.lookoutMetrics, with: AppflowClientTypes.LookoutMetricsDestinationProperties.write(value:to:))
        try writer["Marketo"].write(value.marketo, with: AppflowClientTypes.MarketoDestinationProperties.write(value:to:))
        try writer["Redshift"].write(value.redshift, with: AppflowClientTypes.RedshiftDestinationProperties.write(value:to:))
        try writer["S3"].write(value.s3, with: AppflowClientTypes.S3DestinationProperties.write(value:to:))
        try writer["SAPOData"].write(value.sapoData, with: AppflowClientTypes.SAPODataDestinationProperties.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: AppflowClientTypes.SalesforceDestinationProperties.write(value:to:))
        try writer["Snowflake"].write(value.snowflake, with: AppflowClientTypes.SnowflakeDestinationProperties.write(value:to:))
        try writer["Upsolver"].write(value.upsolver, with: AppflowClientTypes.UpsolverDestinationProperties.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: AppflowClientTypes.ZendeskDestinationProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.DestinationConnectorProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.DestinationConnectorProperties()
        value.redshift = try reader["Redshift"].readIfPresent(with: AppflowClientTypes.RedshiftDestinationProperties.read(from:))
        value.s3 = try reader["S3"].readIfPresent(with: AppflowClientTypes.S3DestinationProperties.read(from:))
        value.salesforce = try reader["Salesforce"].readIfPresent(with: AppflowClientTypes.SalesforceDestinationProperties.read(from:))
        value.snowflake = try reader["Snowflake"].readIfPresent(with: AppflowClientTypes.SnowflakeDestinationProperties.read(from:))
        value.eventBridge = try reader["EventBridge"].readIfPresent(with: AppflowClientTypes.EventBridgeDestinationProperties.read(from:))
        value.lookoutMetrics = try reader["LookoutMetrics"].readIfPresent(with: AppflowClientTypes.LookoutMetricsDestinationProperties.read(from:))
        value.upsolver = try reader["Upsolver"].readIfPresent(with: AppflowClientTypes.UpsolverDestinationProperties.read(from:))
        value.honeycode = try reader["Honeycode"].readIfPresent(with: AppflowClientTypes.HoneycodeDestinationProperties.read(from:))
        value.customerProfiles = try reader["CustomerProfiles"].readIfPresent(with: AppflowClientTypes.CustomerProfilesDestinationProperties.read(from:))
        value.zendesk = try reader["Zendesk"].readIfPresent(with: AppflowClientTypes.ZendeskDestinationProperties.read(from:))
        value.marketo = try reader["Marketo"].readIfPresent(with: AppflowClientTypes.MarketoDestinationProperties.read(from:))
        value.customConnector = try reader["CustomConnector"].readIfPresent(with: AppflowClientTypes.CustomConnectorDestinationProperties.read(from:))
        value.sapoData = try reader["SAPOData"].readIfPresent(with: AppflowClientTypes.SAPODataDestinationProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.SAPODataDestinationProperties {

    static func write(value: AppflowClientTypes.SAPODataDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["idFieldNames"].writeList(value.idFieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["objectPath"].write(value.objectPath)
        try writer["successResponseHandlingConfig"].write(value.successResponseHandlingConfig, with: AppflowClientTypes.SuccessResponseHandlingConfig.write(value:to:))
        try writer["writeOperationType"].write(value.writeOperationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SAPODataDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SAPODataDestinationProperties()
        value.objectPath = try reader["objectPath"].readIfPresent() ?? ""
        value.successResponseHandlingConfig = try reader["successResponseHandlingConfig"].readIfPresent(with: AppflowClientTypes.SuccessResponseHandlingConfig.read(from:))
        value.idFieldNames = try reader["idFieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        value.writeOperationType = try reader["writeOperationType"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ErrorHandlingConfig {

    static func write(value: AppflowClientTypes.ErrorHandlingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["failOnFirstDestinationError"].write(value.failOnFirstDestinationError)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ErrorHandlingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ErrorHandlingConfig()
        value.failOnFirstDestinationError = try reader["failOnFirstDestinationError"].readIfPresent() ?? false
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.bucketName = try reader["bucketName"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.SuccessResponseHandlingConfig {

    static func write(value: AppflowClientTypes.SuccessResponseHandlingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SuccessResponseHandlingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SuccessResponseHandlingConfig()
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.bucketName = try reader["bucketName"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.CustomConnectorDestinationProperties {

    static func write(value: AppflowClientTypes.CustomConnectorDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customProperties"].writeMap(value.customProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["entityName"].write(value.entityName)
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["idFieldNames"].writeList(value.idFieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["writeOperationType"].write(value.writeOperationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomConnectorDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.CustomConnectorDestinationProperties()
        value.entityName = try reader["entityName"].readIfPresent() ?? ""
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        value.writeOperationType = try reader["writeOperationType"].readIfPresent()
        value.idFieldNames = try reader["idFieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.customProperties = try reader["customProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.MarketoDestinationProperties {

    static func write(value: AppflowClientTypes.MarketoDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MarketoDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.MarketoDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.ZendeskDestinationProperties {

    static func write(value: AppflowClientTypes.ZendeskDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["idFieldNames"].writeList(value.idFieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["object"].write(value.object)
        try writer["writeOperationType"].write(value.writeOperationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ZendeskDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ZendeskDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.idFieldNames = try reader["idFieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        value.writeOperationType = try reader["writeOperationType"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.CustomerProfilesDestinationProperties {

    static func write(value: AppflowClientTypes.CustomerProfilesDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["objectTypeName"].write(value.objectTypeName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.CustomerProfilesDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.CustomerProfilesDestinationProperties()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.objectTypeName = try reader["objectTypeName"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.HoneycodeDestinationProperties {

    static func write(value: AppflowClientTypes.HoneycodeDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.HoneycodeDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.HoneycodeDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.UpsolverDestinationProperties {

    static func write(value: AppflowClientTypes.UpsolverDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["s3OutputFormatConfig"].write(value.s3OutputFormatConfig, with: AppflowClientTypes.UpsolverS3OutputFormatConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.UpsolverDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.UpsolverDestinationProperties()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.s3OutputFormatConfig = try reader["s3OutputFormatConfig"].readIfPresent(with: AppflowClientTypes.UpsolverS3OutputFormatConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.UpsolverS3OutputFormatConfig {

    static func write(value: AppflowClientTypes.UpsolverS3OutputFormatConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationConfig"].write(value.aggregationConfig, with: AppflowClientTypes.AggregationConfig.write(value:to:))
        try writer["fileType"].write(value.fileType)
        try writer["prefixConfig"].write(value.prefixConfig, with: AppflowClientTypes.PrefixConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.UpsolverS3OutputFormatConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.UpsolverS3OutputFormatConfig()
        value.fileType = try reader["fileType"].readIfPresent()
        value.prefixConfig = try reader["prefixConfig"].readIfPresent(with: AppflowClientTypes.PrefixConfig.read(from:))
        value.aggregationConfig = try reader["aggregationConfig"].readIfPresent(with: AppflowClientTypes.AggregationConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.AggregationConfig {

    static func write(value: AppflowClientTypes.AggregationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationType"].write(value.aggregationType)
        try writer["targetFileSize"].write(value.targetFileSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.AggregationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.AggregationConfig()
        value.aggregationType = try reader["aggregationType"].readIfPresent()
        value.targetFileSize = try reader["targetFileSize"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.PrefixConfig {

    static func write(value: AppflowClientTypes.PrefixConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["pathPrefixHierarchy"].writeList(value.pathPrefixHierarchy, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AppflowClientTypes.PathPrefix>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["prefixFormat"].write(value.prefixFormat)
        try writer["prefixType"].write(value.prefixType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.PrefixConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.PrefixConfig()
        value.prefixType = try reader["prefixType"].readIfPresent()
        value.prefixFormat = try reader["prefixFormat"].readIfPresent()
        value.pathPrefixHierarchy = try reader["pathPrefixHierarchy"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AppflowClientTypes.PathPrefix>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.LookoutMetricsDestinationProperties {

    static func write(value: AppflowClientTypes.LookoutMetricsDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.LookoutMetricsDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AppflowClientTypes.LookoutMetricsDestinationProperties()
    }
}

extension AppflowClientTypes.EventBridgeDestinationProperties {

    static func write(value: AppflowClientTypes.EventBridgeDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.EventBridgeDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.EventBridgeDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.SnowflakeDestinationProperties {

    static func write(value: AppflowClientTypes.SnowflakeDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["intermediateBucketName"].write(value.intermediateBucketName)
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SnowflakeDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SnowflakeDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.intermediateBucketName = try reader["intermediateBucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.SalesforceDestinationProperties {

    static func write(value: AppflowClientTypes.SalesforceDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataTransferApi"].write(value.dataTransferApi)
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["idFieldNames"].writeList(value.idFieldNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["object"].write(value.object)
        try writer["writeOperationType"].write(value.writeOperationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.SalesforceDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.SalesforceDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.idFieldNames = try reader["idFieldNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        value.writeOperationType = try reader["writeOperationType"].readIfPresent()
        value.dataTransferApi = try reader["dataTransferApi"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.S3DestinationProperties {

    static func write(value: AppflowClientTypes.S3DestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["s3OutputFormatConfig"].write(value.s3OutputFormatConfig, with: AppflowClientTypes.S3OutputFormatConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.S3DestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.S3DestinationProperties()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.s3OutputFormatConfig = try reader["s3OutputFormatConfig"].readIfPresent(with: AppflowClientTypes.S3OutputFormatConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.S3OutputFormatConfig {

    static func write(value: AppflowClientTypes.S3OutputFormatConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregationConfig"].write(value.aggregationConfig, with: AppflowClientTypes.AggregationConfig.write(value:to:))
        try writer["fileType"].write(value.fileType)
        try writer["prefixConfig"].write(value.prefixConfig, with: AppflowClientTypes.PrefixConfig.write(value:to:))
        try writer["preserveSourceDataTyping"].write(value.preserveSourceDataTyping)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.S3OutputFormatConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.S3OutputFormatConfig()
        value.fileType = try reader["fileType"].readIfPresent()
        value.prefixConfig = try reader["prefixConfig"].readIfPresent(with: AppflowClientTypes.PrefixConfig.read(from:))
        value.aggregationConfig = try reader["aggregationConfig"].readIfPresent(with: AppflowClientTypes.AggregationConfig.read(from:))
        value.preserveSourceDataTyping = try reader["preserveSourceDataTyping"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.RedshiftDestinationProperties {

    static func write(value: AppflowClientTypes.RedshiftDestinationProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketPrefix"].write(value.bucketPrefix)
        try writer["errorHandlingConfig"].write(value.errorHandlingConfig, with: AppflowClientTypes.ErrorHandlingConfig.write(value:to:))
        try writer["intermediateBucketName"].write(value.intermediateBucketName)
        try writer["object"].write(value.object)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.RedshiftDestinationProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.RedshiftDestinationProperties()
        value.object = try reader["object"].readIfPresent() ?? ""
        value.intermediateBucketName = try reader["intermediateBucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["bucketPrefix"].readIfPresent()
        value.errorHandlingConfig = try reader["errorHandlingConfig"].readIfPresent(with: AppflowClientTypes.ErrorHandlingConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.ExecutionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ExecutionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ExecutionDetails()
        value.mostRecentExecutionMessage = try reader["mostRecentExecutionMessage"].readIfPresent()
        value.mostRecentExecutionTime = try reader["mostRecentExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.mostRecentExecutionStatus = try reader["mostRecentExecutionStatus"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.TriggerConfig {

    static func write(value: AppflowClientTypes.TriggerConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["triggerProperties"].write(value.triggerProperties, with: AppflowClientTypes.TriggerProperties.write(value:to:))
        try writer["triggerType"].write(value.triggerType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.TriggerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.TriggerConfig()
        value.triggerType = try reader["triggerType"].readIfPresent() ?? .sdkUnknown("")
        value.triggerProperties = try reader["triggerProperties"].readIfPresent(with: AppflowClientTypes.TriggerProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.TriggerProperties {

    static func write(value: AppflowClientTypes.TriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Scheduled"].write(value.scheduled, with: AppflowClientTypes.ScheduledTriggerProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.TriggerProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.TriggerProperties()
        value.scheduled = try reader["Scheduled"].readIfPresent(with: AppflowClientTypes.ScheduledTriggerProperties.read(from:))
        return value
    }
}

extension AppflowClientTypes.ScheduledTriggerProperties {

    static func write(value: AppflowClientTypes.ScheduledTriggerProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataPullMode"].write(value.dataPullMode)
        try writer["firstExecutionFrom"].writeTimestamp(value.firstExecutionFrom, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["flowErrorDeactivationThreshold"].write(value.flowErrorDeactivationThreshold)
        try writer["scheduleEndTime"].writeTimestamp(value.scheduleEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["scheduleExpression"].write(value.scheduleExpression)
        try writer["scheduleOffset"].write(value.scheduleOffset)
        try writer["scheduleStartTime"].writeTimestamp(value.scheduleStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ScheduledTriggerProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ScheduledTriggerProperties()
        value.scheduleExpression = try reader["scheduleExpression"].readIfPresent() ?? ""
        value.dataPullMode = try reader["dataPullMode"].readIfPresent()
        value.scheduleStartTime = try reader["scheduleStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scheduleEndTime = try reader["scheduleEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timezone = try reader["timezone"].readIfPresent()
        value.scheduleOffset = try reader["scheduleOffset"].readIfPresent()
        value.firstExecutionFrom = try reader["firstExecutionFrom"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.flowErrorDeactivationThreshold = try reader["flowErrorDeactivationThreshold"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.Task {

    static func write(value: AppflowClientTypes.Task?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorOperator"].write(value.connectorOperator, with: AppflowClientTypes.ConnectorOperator.write(value:to:))
        try writer["destinationField"].write(value.destinationField)
        try writer["sourceFields"].writeList(value.sourceFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskProperties"].writeMap(value.taskProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["taskType"].write(value.taskType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.Task {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.Task()
        value.sourceFields = try reader["sourceFields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.connectorOperator = try reader["connectorOperator"].readIfPresent(with: AppflowClientTypes.ConnectorOperator.read(from:))
        value.destinationField = try reader["destinationField"].readIfPresent()
        value.taskType = try reader["taskType"].readIfPresent() ?? .sdkUnknown("")
        value.taskProperties = try reader["taskProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.ConnectorOperator {

    static func write(value: AppflowClientTypes.ConnectorOperator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amplitude"].write(value.amplitude)
        try writer["CustomConnector"].write(value.customConnector)
        try writer["Datadog"].write(value.datadog)
        try writer["Dynatrace"].write(value.dynatrace)
        try writer["GoogleAnalytics"].write(value.googleAnalytics)
        try writer["InforNexus"].write(value.inforNexus)
        try writer["Marketo"].write(value.marketo)
        try writer["Pardot"].write(value.pardot)
        try writer["S3"].write(value.s3)
        try writer["SAPOData"].write(value.sapoData)
        try writer["Salesforce"].write(value.salesforce)
        try writer["ServiceNow"].write(value.serviceNow)
        try writer["Singular"].write(value.singular)
        try writer["Slack"].write(value.slack)
        try writer["Trendmicro"].write(value.trendmicro)
        try writer["Veeva"].write(value.veeva)
        try writer["Zendesk"].write(value.zendesk)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorOperator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorOperator()
        value.amplitude = try reader["Amplitude"].readIfPresent()
        value.datadog = try reader["Datadog"].readIfPresent()
        value.dynatrace = try reader["Dynatrace"].readIfPresent()
        value.googleAnalytics = try reader["GoogleAnalytics"].readIfPresent()
        value.inforNexus = try reader["InforNexus"].readIfPresent()
        value.marketo = try reader["Marketo"].readIfPresent()
        value.s3 = try reader["S3"].readIfPresent()
        value.salesforce = try reader["Salesforce"].readIfPresent()
        value.serviceNow = try reader["ServiceNow"].readIfPresent()
        value.singular = try reader["Singular"].readIfPresent()
        value.slack = try reader["Slack"].readIfPresent()
        value.trendmicro = try reader["Trendmicro"].readIfPresent()
        value.veeva = try reader["Veeva"].readIfPresent()
        value.zendesk = try reader["Zendesk"].readIfPresent()
        value.sapoData = try reader["SAPOData"].readIfPresent()
        value.customConnector = try reader["CustomConnector"].readIfPresent()
        value.pardot = try reader["Pardot"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.MetadataCatalogConfig {

    static func write(value: AppflowClientTypes.MetadataCatalogConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["glueDataCatalog"].write(value.glueDataCatalog, with: AppflowClientTypes.GlueDataCatalogConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MetadataCatalogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.MetadataCatalogConfig()
        value.glueDataCatalog = try reader["glueDataCatalog"].readIfPresent(with: AppflowClientTypes.GlueDataCatalogConfig.read(from:))
        return value
    }
}

extension AppflowClientTypes.GlueDataCatalogConfig {

    static func write(value: AppflowClientTypes.GlueDataCatalogConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["roleArn"].write(value.roleArn)
        try writer["tablePrefix"].write(value.tablePrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.GlueDataCatalogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.GlueDataCatalogConfig()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.tablePrefix = try reader["tablePrefix"].readIfPresent() ?? ""
        return value
    }
}

extension AppflowClientTypes.MetadataCatalogDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.MetadataCatalogDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.MetadataCatalogDetail()
        value.catalogType = try reader["catalogType"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.tableRegistrationOutput = try reader["tableRegistrationOutput"].readIfPresent(with: AppflowClientTypes.RegistrationOutput.read(from:))
        value.partitionRegistrationOutput = try reader["partitionRegistrationOutput"].readIfPresent(with: AppflowClientTypes.RegistrationOutput.read(from:))
        return value
    }
}

extension AppflowClientTypes.RegistrationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.RegistrationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.RegistrationOutput()
        value.message = try reader["message"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ExecutionRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ExecutionRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ExecutionRecord()
        value.executionId = try reader["executionId"].readIfPresent()
        value.executionStatus = try reader["executionStatus"].readIfPresent()
        value.executionResult = try reader["executionResult"].readIfPresent(with: AppflowClientTypes.ExecutionResult.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataPullStartTime = try reader["dataPullStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataPullEndTime = try reader["dataPullEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.metadataCatalogDetails = try reader["metadataCatalogDetails"].readListIfPresent(memberReadingClosure: AppflowClientTypes.MetadataCatalogDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AppflowClientTypes.ExecutionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ExecutionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ExecutionResult()
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: AppflowClientTypes.ErrorInfo.read(from:))
        value.bytesProcessed = try reader["bytesProcessed"].readIfPresent()
        value.bytesWritten = try reader["bytesWritten"].readIfPresent()
        value.recordsProcessed = try reader["recordsProcessed"].readIfPresent()
        value.numParallelProcesses = try reader["numParallelProcesses"].readIfPresent()
        value.maxPageSize = try reader["maxPageSize"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ErrorInfo()
        value.putFailuresCount = try reader["putFailuresCount"].readIfPresent()
        value.executionMessage = try reader["executionMessage"].readIfPresent()
        return value
    }
}

extension AppflowClientTypes.ConnectorEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.ConnectorEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.ConnectorEntity()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.label = try reader["label"].readIfPresent()
        value.hasNestedEntities = try reader["hasNestedEntities"].readIfPresent() ?? false
        return value
    }
}

extension AppflowClientTypes.FlowDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> AppflowClientTypes.FlowDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppflowClientTypes.FlowDefinition()
        value.flowArn = try reader["flowArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.flowName = try reader["flowName"].readIfPresent()
        value.flowStatus = try reader["flowStatus"].readIfPresent()
        value.sourceConnectorType = try reader["sourceConnectorType"].readIfPresent()
        value.sourceConnectorLabel = try reader["sourceConnectorLabel"].readIfPresent()
        value.destinationConnectorType = try reader["destinationConnectorType"].readIfPresent()
        value.destinationConnectorLabel = try reader["destinationConnectorLabel"].readIfPresent()
        value.triggerType = try reader["triggerType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastRunExecutionDetails = try reader["lastRunExecutionDetails"].readIfPresent(with: AppflowClientTypes.ExecutionDetails.read(from:))
        return value
    }
}

extension AppflowClientTypes.ConnectorProfileConfig {

    static func write(value: AppflowClientTypes.ConnectorProfileConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorProfileCredentials"].write(value.connectorProfileCredentials, with: AppflowClientTypes.ConnectorProfileCredentials.write(value:to:))
        try writer["connectorProfileProperties"].write(value.connectorProfileProperties, with: AppflowClientTypes.ConnectorProfileProperties.write(value:to:))
    }
}

extension AppflowClientTypes.ConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.ConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amplitude"].write(value.amplitude, with: AppflowClientTypes.AmplitudeConnectorProfileCredentials.write(value:to:))
        try writer["CustomConnector"].write(value.customConnector, with: AppflowClientTypes.CustomConnectorProfileCredentials.write(value:to:))
        try writer["Datadog"].write(value.datadog, with: AppflowClientTypes.DatadogConnectorProfileCredentials.write(value:to:))
        try writer["Dynatrace"].write(value.dynatrace, with: AppflowClientTypes.DynatraceConnectorProfileCredentials.write(value:to:))
        try writer["GoogleAnalytics"].write(value.googleAnalytics, with: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials.write(value:to:))
        try writer["Honeycode"].write(value.honeycode, with: AppflowClientTypes.HoneycodeConnectorProfileCredentials.write(value:to:))
        try writer["InforNexus"].write(value.inforNexus, with: AppflowClientTypes.InforNexusConnectorProfileCredentials.write(value:to:))
        try writer["Marketo"].write(value.marketo, with: AppflowClientTypes.MarketoConnectorProfileCredentials.write(value:to:))
        try writer["Pardot"].write(value.pardot, with: AppflowClientTypes.PardotConnectorProfileCredentials.write(value:to:))
        try writer["Redshift"].write(value.redshift, with: AppflowClientTypes.RedshiftConnectorProfileCredentials.write(value:to:))
        try writer["SAPOData"].write(value.sapoData, with: AppflowClientTypes.SAPODataConnectorProfileCredentials.write(value:to:))
        try writer["Salesforce"].write(value.salesforce, with: AppflowClientTypes.SalesforceConnectorProfileCredentials.write(value:to:))
        try writer["ServiceNow"].write(value.serviceNow, with: AppflowClientTypes.ServiceNowConnectorProfileCredentials.write(value:to:))
        try writer["Singular"].write(value.singular, with: AppflowClientTypes.SingularConnectorProfileCredentials.write(value:to:))
        try writer["Slack"].write(value.slack, with: AppflowClientTypes.SlackConnectorProfileCredentials.write(value:to:))
        try writer["Snowflake"].write(value.snowflake, with: AppflowClientTypes.SnowflakeConnectorProfileCredentials.write(value:to:))
        try writer["Trendmicro"].write(value.trendmicro, with: AppflowClientTypes.TrendmicroConnectorProfileCredentials.write(value:to:))
        try writer["Veeva"].write(value.veeva, with: AppflowClientTypes.VeevaConnectorProfileCredentials.write(value:to:))
        try writer["Zendesk"].write(value.zendesk, with: AppflowClientTypes.ZendeskConnectorProfileCredentials.write(value:to:))
    }
}

extension AppflowClientTypes.PardotConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.PardotConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientCredentialsArn"].write(value.clientCredentialsArn)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.ConnectorOAuthRequest {

    static func write(value: AppflowClientTypes.ConnectorOAuthRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authCode"].write(value.authCode)
        try writer["redirectUri"].write(value.redirectUri)
    }
}

extension AppflowClientTypes.CustomConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.CustomConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey, with: AppflowClientTypes.ApiKeyCredentials.write(value:to:))
        try writer["authenticationType"].write(value.authenticationType)
        try writer["basic"].write(value.basic, with: AppflowClientTypes.BasicAuthCredentials.write(value:to:))
        try writer["custom"].write(value.custom, with: AppflowClientTypes.CustomAuthCredentials.write(value:to:))
        try writer["oauth2"].write(value.oauth2, with: AppflowClientTypes.OAuth2Credentials.write(value:to:))
    }
}

extension AppflowClientTypes.CustomAuthCredentials {

    static func write(value: AppflowClientTypes.CustomAuthCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialsMap"].writeMap(value.credentialsMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["customAuthenticationType"].write(value.customAuthenticationType)
    }
}

extension AppflowClientTypes.ApiKeyCredentials {

    static func write(value: AppflowClientTypes.ApiKeyCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
        try writer["apiSecretKey"].write(value.apiSecretKey)
    }
}

extension AppflowClientTypes.OAuth2Credentials {

    static func write(value: AppflowClientTypes.OAuth2Credentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.BasicAuthCredentials {

    static func write(value: AppflowClientTypes.BasicAuthCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension AppflowClientTypes.SAPODataConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.SAPODataConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["basicAuthCredentials"].write(value.basicAuthCredentials, with: AppflowClientTypes.BasicAuthCredentials.write(value:to:))
        try writer["oAuthCredentials"].write(value.oAuthCredentials, with: AppflowClientTypes.OAuthCredentials.write(value:to:))
    }
}

extension AppflowClientTypes.OAuthCredentials {

    static func write(value: AppflowClientTypes.OAuthCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.ZendeskConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.VeevaConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.TrendmicroConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiSecretKey"].write(value.apiSecretKey)
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.SnowflakeConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.SlackConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.SingularConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.ServiceNowConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuth2Credentials"].write(value.oAuth2Credentials, with: AppflowClientTypes.OAuth2Credentials.write(value:to:))
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.SalesforceConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientCredentialsArn"].write(value.clientCredentialsArn)
        try writer["jwtToken"].write(value.jwtToken)
        try writer["oAuth2GrantType"].write(value.oAuth2GrantType)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.RedshiftConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["password"].write(value.password)
        try writer["username"].write(value.username)
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.MarketoConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.InforNexusConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessKeyId"].write(value.accessKeyId)
        try writer["datakey"].write(value.datakey)
        try writer["secretAccessKey"].write(value.secretAccessKey)
        try writer["userId"].write(value.userId)
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.HoneycodeConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
        try writer["oAuthRequest"].write(value.oAuthRequest, with: AppflowClientTypes.ConnectorOAuthRequest.write(value:to:))
        try writer["refreshToken"].write(value.refreshToken)
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.DynatraceConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiToken"].write(value.apiToken)
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.DatadogConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
        try writer["applicationKey"].write(value.applicationKey)
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials {

    static func write(value: AppflowClientTypes.AmplitudeConnectorProfileCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
        try writer["secretKey"].write(value.secretKey)
    }
}

public enum AppflowClientTypes {}
